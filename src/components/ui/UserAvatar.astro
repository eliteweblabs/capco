---
// Enable this component to work as both regular component and partial
export const partial = true;
import { validateAvatarUrl, getSafeAvatarUrl } from "../../lib/avatar-utils";

// UserAvatar component for standardized avatar display throughout the project
export interface Props {
  user?: {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    avatarUrl?: string;
    companyName?: string;
  };
  // Support for currentUser object structure
  currentUser?: any;
  size?: "xs" | "sm" | "md" | "lg" | "xl";
  showBorder?: boolean;
  class?: string;
  id?: string;
  title?: string;
}

// Check if this is being used as a partial (X-headers present) or regular component
const isPartial =
  Astro.request.headers.has("x-user-avatar-user-id") ||
  Astro.request.headers.has("x-user-avatar-first-name");

// Extract props from either Astro.props or X-headers
const size = (Astro.props.size || Astro.request.headers.get("x-user-avatar-size") || "md") as
  | "xs"
  | "sm"
  | "md"
  | "lg"
  | "xl";

const showBorder =
  Astro.props.showBorder !== undefined
    ? Astro.props.showBorder
    : Astro.request.headers.get("x-user-avatar-show-border") !== "false";

const className = Astro.props.class || Astro.request.headers.get("x-user-avatar-class") || "";
const id = Astro.props.id || Astro.request.headers.get("x-user-avatar-id") || undefined;
const title = Astro.props.title || Astro.request.headers.get("x-user-avatar-title") || undefined;

// Extract user data from either props or headers
let user: {
  id?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  avatarUrl?: string;
  companyName?: string;
} | null = null;

if (isPartial) {
  // Extract from headers
  user = {
    id: Astro.request.headers.get("x-user-avatar-user-id") || undefined,
    firstName: Astro.request.headers.get("x-user-avatar-first-name") || undefined,
    lastName: Astro.request.headers.get("x-user-avatar-last-name") || undefined,
    email: Astro.request.headers.get("x-user-avatar-email") || undefined,
    avatarUrl:
      Astro.request.headers.get("x-user-avatar-avatar-url") ||
      Astro.request.headers.get("x-user-avatar-avatar") ||
      undefined,
    companyName: Astro.request.headers.get("x-user-avatar-company-name") || undefined,
  };
} else {
  // Extract from props
  if (Astro.props.currentUser) {
    // Handle currentUser object structure (from checkAuth)
    user = {
      id: Astro.props.currentUser.id,
      firstName: Astro.props.currentUser.profile?.firstName,
      lastName: Astro.props.currentUser.profile?.lastName,
      email: Astro.props.currentUser.email,
      avatarUrl:
        Astro.props.currentUser.profile?.avatarUrl ||
        Astro.props.currentUser.user_metadata?.avatarUrl ||
        Astro.props.currentUser.user_metadata?.picture,
      companyName: Astro.props.currentUser.profile?.companyName,
    };
  } else if (Astro.props.user) {
    user = Astro.props.user;
  }
}

// Generate user display name and initials
const fullName = user
  ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.companyName || "User"
  : "User";

const initials = fullName
  .split(" ")
  .map((name) => name.charAt(0))
  .join("")
  .toUpperCase()
  .slice(0, 2);

// Get avatar URL with fallback validation
const avatarUrl = user
  ? getSafeAvatarUrl(
      user.avatarUrl,
      undefined // No gravatar fallback for now
    )
  : null;

const shouldShowAvatar = avatarUrl && !validateAvatarUrl(avatarUrl).shouldUseFallback;

// Size classes
const sizeClasses = {
  xs: "w-6 h-6 text-xs",
  sm: "w-8 h-8 text-sm",
  md: "w-10 h-10 text-base",
  lg: "w-12 h-12 text-lg",
  xl: "w-16 h-16 text-xl",
};

const borderClass = showBorder ? "border-2 border-white dark:border-gray-700 shadow-sm" : "";

const containerClasses =
  `${sizeClasses[size]} rounded-full ${borderClass} bg-gradient-to-br from-primary-500 to-purple-600 flex items-center justify-center text-white font-medium ${className}`.trim();
---

<div
  class={containerClasses}
  {id}
  title={title || fullName}
  data-avatar-url={shouldShowAvatar ? avatarUrl : undefined}
  data-user-name={fullName}
  data-user-initials={initials}
>
  {
    shouldShowAvatar ? (
      <>
        {/* Avatar image (hidden initially, shown if load succeeds) */}
        {/* Don't set src initially - let JavaScript handle loading to avoid double requests */}
        <img
          alt={fullName}
          class="rounded-full w-full h-full object-cover user-avatar-img"
          style="display: none;"
          onerror="this.style.display='none'; this.parentElement?.querySelector('.user-avatar-fallback')?.classList.remove('hidden');"
        />
        {/* Fallback initials (visible initially, hidden if avatar loads) */}
        <span class="user-avatar-fallback">{initials}</span>
      </>
    ) : (
      <span>{initials}</span>
    )
  }
</div>

<script>
  // Handle avatar loading with proper fallback
  document.addEventListener("DOMContentLoaded", () => {
    const avatarContainers = document.querySelectorAll("[data-avatar-url]");

    avatarContainers.forEach((container) => {
      const avatarUrl = container.getAttribute("data-avatar-url");
      const avatarImg = container.querySelector(".user-avatar-img") as HTMLImageElement;
      const fallbackSpan = container.querySelector(".user-avatar-fallback") as HTMLElement;

      if (avatarUrl && avatarImg && fallbackSpan) {
        // For Supabase storage URLs, use a silent image load that won't show errors
        if (avatarUrl.includes("supabase.co/storage")) {
          // Create a silent image loader that suppresses network errors
          const img = new Image();

          // Suppress the error event from bubbling
          img.onerror = () => {
            // Silent fail - just show fallback, don't log
            avatarImg.style.display = "none";
            fallbackSpan.classList.remove("hidden");
          };

          img.onload = () => {
            // Success - show the image
            avatarImg.src = avatarUrl;
            avatarImg.style.display = "block";
            fallbackSpan.classList.add("hidden");
          };

          // Use a data URL as a test to see if the image element works
          // Then try loading the actual URL
          img.src = avatarUrl;
        } else {
          // Non-Supabase URL - load normally
          const img = new Image();

          img.onload = () => {
            avatarImg.style.display = "block";
            fallbackSpan.classList.add("hidden");
          };

          img.onerror = () => {
            avatarImg.style.display = "none";
            fallbackSpan.classList.remove("hidden");
          };

          img.src = avatarUrl;
        }
      }
    });
  });
</script>
