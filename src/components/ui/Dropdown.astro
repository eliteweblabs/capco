---
/**
 * Account dropdown panel for the header avatar (AuthIcon).
 * Flowbite: trigger uses data-dropdown-toggle="account-dropdown"; this panel has id="account-dropdown".
 * Navbar.astro attaches the logout handler to #logout-btn.
 */
interface Props {
  id: string;
  currentUser?: any;
  globalIconButtonClasses?: string;
  title?: string;
  // closeButton?: boolean;
  /** Name of global function to call when dropdown opens (e.g. for lazy load or refresh) */
  onOpenCallback?: string;
  /** Selector for input to focus when dropdown opens. Must run in same click handler for iOS keypad. */
  focusSelector?: string;
}

const { id, title = "", onOpenCallback, focusSelector } = Astro.props;
---

{/* Account dropdown: Flowbite data-dropdown-toggle / data-popover-target on AuthIcon trigger */}
<div
  id={`${id}-dropdown`}
  data-popover
  role="tooltip"
  {...onOpenCallback ? { "data-on-open": onOpenCallback } : {}}
  {...focusSelector ? { "data-focus-on-open": focusSelector } : {}}
  class="invisible absolute z-[150] inline-block w-full max-w-md overflow-visible rounded-b-lg border-t border-gray-200 bg-white text-body text-sm opacity-0 shadow-lg transition-opacity duration-300 dark:border-gray-700 dark:bg-gray-900 sm:border sm:border-t-0"
>
  <!-- <div class="flex max-h-[85vh] flex-col overflow-hidden">
    <div class="relative flex min-h-0 flex-1 flex-col"> -->
  <div class="relative z-1" data-popper-arrow></div>

  <div class="p-8">
    {
      title && (
        <div class="py-3">
          <h3 class="text-lg font-semibold text-gray-900 dark:text-white" set:html={title} />
        </div>
      )
    }

    <slot />
  </div>
</div>

<script is:inline>
  // Flowbite adds opacity/transition classes when closing; when reopening, only 'hidden' is
  // removed so the panel can stay invisible. Remove those classes on trigger click so dropdowns
  // (account, notifications) reopen correctly after being closed.
  // Supports both data-dropdown-toggle and data-popover-target (AuthIcon uses popover).
  // iOS keypad: focus() must run in same user gesture as click, so we focus synchronously first.
  document.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll("[id$='-dropdown']").forEach(function (panel) {
      var panelId = panel.id;
      if (!panelId) return;
      var onOpen = panel.getAttribute("data-on-open");
      var focusSel = panel.getAttribute("data-focus-on-open");
      var selectors =
        "[data-dropdown-toggle='" + panelId + "'], [data-popover-target='" + panelId + "']";
      document.querySelectorAll(selectors).forEach(function (trigger) {
        if (trigger.hasAttribute("data-onopen-bound")) return;
        trigger.setAttribute("data-onopen-bound", "true");
        trigger.addEventListener("click", function () {
          // Remove visibility-blocking classes FIRST (sync) so focus() works.
          // Browsers/emulators often ignore focus on hidden elements.
          if (panel) {
            panel.classList.remove(
              "opacity-0",
              "transition-opacity",
              "duration-300",
              "ease-out",
              "invisible",
              "hidden"
            );
          }
          // Sync focus in same click (required for iOS keypad)
          if (focusSel && panel) {
            var el = panel.querySelector(focusSel);
            if (el && typeof el.focus === "function") el.focus();
          }
          setTimeout(function () {
            if (panel && onOpen && typeof window[onOpen] === "function") {
              window[onOpen]();
            }
          }, 50);
        });
      });

      // Close button: use Flowbite Popover.hide() when available so state stays in sync.
      // Falls back to Dismiss-style hide (opacity-0, invisible, hidden) if no Popover instance.
      panel.querySelectorAll("[data-dropdown-close]").forEach(function (btn) {
        if (btn.hasAttribute("data-close-bound")) return;
        btn.setAttribute("data-close-bound", "true");
        btn.addEventListener("click", function (e) {
          e.preventDefault();
          var popoverId = panelId; // e.g. "account-dropdown"
          var inst =
            window.FlowbiteInstances && window.FlowbiteInstances.getInstance("Popover", popoverId);
          if (inst && typeof inst.hide === "function") {
            inst.hide();
          } else {
            panel.classList.add("opacity-0", "invisible");
            setTimeout(function () {
              panel.classList.add("hidden");
            }, 150);
          }
        });
      });
    });

    // When dropdown open: show X on trigger; when closed: show default icon. Wire X to close.
    document.querySelectorAll(".auth-icon-close").forEach(function (closeEl) {
      var trigger = closeEl.closest("[data-popover-target], [data-dropdown-toggle]");
      if (!trigger) return;
      var panelId = trigger.getAttribute("data-popover-target") || trigger.getAttribute("data-dropdown-toggle");
      var panel = panelId ? document.getElementById(panelId) : null;
      if (!panel) return;

      function closePopover() {
        var inst = window.FlowbiteInstances && window.FlowbiteInstances.getInstance("Popover", panelId);
        if (inst && typeof inst.hide === "function") {
          inst.hide();
        } else {
          panel.classList.add("opacity-0", "invisible");
          setTimeout(function () { panel.classList.add("hidden"); }, 150);
        }
      }

      closeEl.addEventListener("click", function (e) {
        e.preventDefault();
        e.stopPropagation();
        closePopover();
      });

      function updateTrigger(isOpen) {
        var defaultEl = trigger.querySelector(".auth-icon-default");
        if (defaultEl && closeEl) {
          if (isOpen) {
            defaultEl.style.opacity = "0";
            defaultEl.style.pointerEvents = "none";
            closeEl.style.opacity = "1";
            closeEl.style.pointerEvents = "auto";
          } else {
            defaultEl.style.opacity = "1";
            defaultEl.style.pointerEvents = "auto";
            closeEl.style.opacity = "0";
            closeEl.style.pointerEvents = "none";
          }
        }
      }

      var observer = new MutationObserver(function () {
        updateTrigger(!panel.classList.contains("hidden") && !panel.classList.contains("invisible"));
      });
      observer.observe(panel, { attributes: true, attributeFilter: ["class"] });
      updateTrigger(!panel.classList.contains("hidden") && !panel.classList.contains("invisible"));
    });
  });
</script>

<style>
  [role="tooltip"] > [data-popper-arrow]:before {
    border-color: var(--color-gray-200) !important;
  }

  [role="tooltip"] > [data-popper-arrow]:after {
    border-color: var(--color-gray-200) !important;
  }

  :global(.dark) [role="tooltip"] > [data-popper-arrow]:before {
    border-color: var(--color-gray-700) !important;
  }

  :global(.dark) [role="tooltip"] > [data-popper-arrow]:after {
    border-color: var(--color-gray-700) !important;
  }

  /* [role="tooltip"] > [data-popper-arrow]:after {
    border-color: var(--color-gray-200) !important;
    border-width: 1px !important;
    border-style: solid !important;
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  .dark [role="tooltip"] > [data-popper-arrow]:before {
    border-color: var(--color-gray-700) !important;
    border-width: 1px !important;
    border-style: solid !important;
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  .dark [role="tooltip"] > [data-popper-arrow]:after {
    border-color: var(--color-gray-700) !important;
    border-width: 1px !important;
    border-style: solid !important;
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  } */
</style>
