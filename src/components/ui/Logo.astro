---
import { globalCompanyData } from "../../pages/api/global/global-company-data";
import { readFileSync, existsSync } from "fs";
import { join } from "path";

const companyData = await globalCompanyData();

// Load SVG file
function loadSvgFile(): string {
  const svgPath = join(process.cwd(), "public", "img", "capco-logo.svg");
  if (!existsSync(svgPath)) return "";

  try {
    let svg = readFileSync(svgPath, "utf-8")
      .replace(/<\?xml[^>]*\?>/gi, "")
      .replace(/\s+/g, " ")
      .trim();

    // Fix dark mode: remove inline fill attributes and use class-based fills
    svg = svg
      .replace(/@media\s*\(prefers-color-scheme:\s*dark\)\s*\{[^}]*\}/gi, "")
      .replace(/\.fill\s*\{[^}]*fill:\s*#[^;]+[^}]*\}/gi, ".fill { fill: currentColor; }")
      .replace(/\}\s*\}/g, "}")
      // Remove all inline fill attributes from path elements (but keep class="fill" if present)
      .replace(/<path\s+([^>]*)\s+fill="[^"]*"([^>]*)>/gi, "<path $1$2>")
      .replace(/<path\s+fill="[^"]*"\s+([^>]*)>/gi, "<path $1>")
      // Ensure paths have class="fill" if they don't already
      .replace(/<path\s+([^>]*?)(?:\s+class="[^"]*")?([^>]*)>/gi, (match, p1, p2) => {
        if (!match.includes("class=")) {
          return `<path class="fill" ${p1}${p2}>`;
        }
        return match.replace(/class="([^"]*)"/gi, (m, classes) => {
          return classes.includes("fill") ? m : `class="${classes} fill"`;
        });
      });

    return svg;
  } catch {
    return "";
  }
}

// Process SVG from env var or string to remove inline fills
function processSvg(svg: string): string {
  if (!svg || !svg.includes("<svg")) return svg;

  return (
    svg
      // Remove inline fill attributes from path elements
      .replace(/<path\s+([^>]*)\s+fill="[^"]*"([^>]*)>/gi, "<path $1$2>")
      .replace(/<path\s+fill="[^"]*"\s+([^>]*)>/gi, "<path $1>")
      // Ensure paths have class="fill"
      .replace(/<path\s+([^>]*?)(?:\s+class="[^"]*")?([^>]*)>/gi, (match) => {
        if (!match.includes("class=")) {
          return match.replace(/<path\s+/, '<path class="fill" ');
        }
        if (!match.includes('class="fill"') && !match.includes("class='fill'")) {
          return match.replace(/class="([^"]*)"/gi, (m, classes) => {
            return `class="${classes} fill"`;
          });
        }
        return match;
      })
  );
}

// Get logo: prefer env var if set, otherwise use file
// This allows Railway variables to override the default file
const svgFromFile = loadSvgFile();
const logoSvgRaw = companyData.globalCompanyLogo || svgFromFile || "";
const logoSvg = processSvg(logoSvgRaw);

// Props
export interface Props {
  link?: string;
  className?: string;
}

const { link = "/" } = Astro.props;


// Validate link
let validLink = link;
if (typeof validLink === "string") {
  if (validLink.includes("<svg") || validLink.includes("<?xml") || validLink.includes("xmlns=")) {
    validLink = "/";
  } else if (validLink && !validLink.startsWith("/") && !validLink.startsWith("http")) {
    validLink = "/";
  }
}

// Get the logo classes from the CMS (defaults to empty string if not set)
const logoClassesFromDb = companyData.logoClasses || "";
// Merge prop className with database classes (prop classes come first for specificity)
const propClassName = Astro.props.className || "";
const className = propClassName ? `${propClassName} ${logoClassesFromDb}`.trim() : logoClassesFromDb;

// Debug logging (will only show in dev/server logs)
if (import.meta.env.DEV) {
  console.log("[Logo] logoClassesFromDb:", logoClassesFromDb);
  console.log("[Logo] propClassName:", propClassName);
  console.log("[Logo] Final className:", className);
}
---

{logoSvg && logoSvg.includes("<svg") && (
  <a
    href={validLink}
    title="Go to home page"
    class={`logo-svg-wrapper ${className}`.trim()}
    set:html={logoSvg}
  />
)}

<script>
  // Remove any remaining inline fill attributes on client side
  document.addEventListener("DOMContentLoaded", () => {
    const logoWrappers = document.querySelectorAll(".logo-svg-wrapper");
    logoWrappers.forEach((wrapper) => {
      const svg = wrapper.querySelector("svg");
      if (!svg) return;

      const paths = svg.querySelectorAll("path");
      paths.forEach((path) => {
        // Remove inline fill attribute if present
        if (path.hasAttribute("fill") && path.getAttribute("fill") !== "fill") {
          path.removeAttribute("fill");
        }
        // Ensure class="fill" is present
        if (!path.classList.contains("fill")) {
          path.classList.add("fill");
        }
      });
    });
  });
</script>
