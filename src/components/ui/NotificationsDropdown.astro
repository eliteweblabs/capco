---
/**
 * Account dropdown panel for the header avatar (AuthIcon).
 * Flowbite: trigger uses data-dropdown-toggle="account-dropdown"; this panel has id="account-dropdown".
 * Navbar.astro attaches the logout handler to #logout-btn.
 */
interface Props {
  currentUser: any;
  globalIconButtonClasses: string;
  closeButton: boolean;
  id: string;
  /** Name of global function to call when dropdown opens (e.g. for refresh). Expose as window.refreshUserProfile. */
  onOpen?: string;
}

// Redirect to API callback only when code is on a page that shouldn't handle it. Preserve full query.
// /auth/callback must render so client-side JS can exchange the code - do NOT redirect there
const authCode = Astro.url.searchParams.get("code");
if (authCode && !Astro.url.pathname.startsWith("/auth/callback")) {
  const query = Astro.url.search ? Astro.url.search : `?code=${encodeURIComponent(authCode)}`;
  return Astro.redirect(`/api/auth/callback${query}`);
}

const { currentUser, globalIconButtonClasses, closeButton = false, id, onOpen } = Astro.props;

const redirectUrl = Astro.url.searchParams.get("redirect") || "/project/dashboard";

const currentRole = currentUser?.profile?.role;
import Dropdown from "./Dropdown.astro";
import LoadingSpinner from "./LoadingSpinner.astro";
---

<!-- Account dropdown: Flowbite data-popover-target on UserIcon trigger -->
<Dropdown id={id} {currentUser} {globalIconButtonClasses} title="" onOpenCallback={onOpen}>
  <!-- Panel body: data-dropdown-id passed so script can find panel/triggers (Navbar uses id="notifications") -->
  <div class="min-h-0 flex-1 overflow-y-auto" data-dropdown-id={id}>
    <!-- Header with Mark all read and Archive all -->
    <div class="flex items-center justify-between gap-2 border-b border-gray-200 px-3 py-2 dark:border-gray-700">
      <button
        id="mark-all-read"
        class="text-sm text-primary-600 hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300"
      >
        Mark all read
      </button>
      <button
        id="archive-all"
        class="text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
      >
        Archive all
      </button>
    </div>

    <!-- Loading State -->
    <div id="notification-loading" class="p-4 text-center">
      <LoadingSpinner
        size="sm"
        loadingText="Loading notifications..."
        className="!flex-row !space-x-2 !space-y-0"
      />
    </div>

    <!-- Empty State -->
    <div id="notification-empty" class="hidden p-6 text-center">
      <svg
        class="mx-auto h-12 w-12 text-gray-400 dark:text-gray-600"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
        ></path>
      </svg>
      <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-white">
        No recent notifications
      </h3>
    </div>

    <!-- Notifications List -->
    <div id="notification-list" class="scrollbar-hide" data-dynamic-height="minHeight">
      <!-- Notifications will be populated here -->
    </div>

    <!-- Footer with auto-loading indicator -->
    <div class="shrink-0 border-t border-gray-200 px-4 py-2 dark:border-gray-700">
      <div
        id="loading-indicator"
        class="hidden text-center text-sm text-gray-500 dark:text-gray-400"
      >
        Loading more notifications...
      </div>
    </div>
  </div>
</Dropdown>

<script>
  class NotificationManager {
    isOpen: boolean = false;
    notifications: any[] = [];
    viewedNotifications: Set<number> = new Set();
    pollingInterval: NodeJS.Timeout | null = null;
    isLoadingMore: boolean = false;
    hasMore: boolean = true;
    panelId: string;

    constructor() {
      const dropdownContainer = document.querySelector("[data-dropdown-id]");
      if (!dropdownContainer) return;
      const dropdownId = dropdownContainer.getAttribute("data-dropdown-id");
      this.panelId = dropdownId ? `${dropdownId}-dropdown` : "notifications-dropdown";
      this.init();
    }

    async init() {
      this.bindEvents();
      await this.loadNotifications();
      this.startPolling();
    }

    bindEvents() {
      const panel = document.getElementById(this.panelId);
      const markAllRead = document.getElementById("mark-all-read");

      // When dropdown is opened (trigger), load notifications; when closed, mark as viewed
      // Also remove Dismiss-added classes (opacity-0, transition) so panel is visible again after closing once
      // Support both data-dropdown-toggle and data-popover-target (Navbar uses popover)
      const triggerSelectors = `[data-dropdown-toggle="${this.panelId}"], [data-popover-target="${this.panelId}"]`;
      document.querySelectorAll(triggerSelectors).forEach((el) => {
        el.addEventListener("click", () => {
          setTimeout(() => {
            if (panel && !panel.classList.contains("hidden")) {
              this.isOpen = true;
              panel.classList.remove("opacity-0", "transition-opacity", "duration-300", "ease-out");
              this.loadNotifications();
            } else {
              this.isOpen = false;
              this.markViewedNotificationsAsRead();
            }
          }, 10);
        });
      });

      // Close button: Flowbite Dismiss (data-dismiss-target) handles hide; sync state and mark viewed
      document.querySelectorAll(`[data-dismiss-target="#${this.panelId}"]`).forEach((el) => {
        el.addEventListener("click", () => {
          setTimeout(() => {
            this.isOpen = false;
            this.markViewedNotificationsAsRead();
          }, 50);
        });
      });

      // ESC key: close dropdown and sync state
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && panel && !panel.classList.contains("hidden")) {
          this.closeDropdown();
        }
      });

      // Mark all as read
      markAllRead?.addEventListener("click", () => {
        this.markAllAsRead();
      });

      document.getElementById("archive-all")?.addEventListener("click", () => {
        this.archiveAll();
      });

      // Mark notifications as viewed when scrolling and auto-load more
      const notificationList = document.getElementById("notification-list");
      notificationList?.addEventListener("scroll", () => {
        this.handleScroll();
      });

      // Swipe down to dismiss (only when list is at top to avoid conflicting with scroll)
      this.bindSwipeToDismiss();
    }

    bindSwipeToDismiss() {
      const panel = document.getElementById(this.panelId);
      const notificationList = document.getElementById("notification-list");
      if (!panel || !notificationList) return;
      if ((panel as any).__swipeBound) return;
      (panel as any).__swipeBound = true;

      let touchStartY = 0;
      panel.addEventListener(
        "touchstart",
        (e) => {
          touchStartY = e.touches[0].clientY;
        },
        { passive: true }
      );
      panel.addEventListener(
        "touchend",
        (e) => {
          if (!this.isOpen) return;
          const touchEndY = e.changedTouches[0].clientY;
          const deltaY = touchEndY - touchStartY;
          // Swipe down > 60px and list at top = dismiss
          if (deltaY > 60 && notificationList.scrollTop <= 0) {
            this.closeDropdown();
          }
        },
        { passive: true }
      );
    }

    closeDropdown() {
      const panel = document.getElementById(this.panelId);
      if (!panel) return;
      this.isOpen = false;
      this.markViewedNotificationsAsRead();
      const inst = (window as any).FlowbiteInstances?.getInstance("Popover", this.panelId);
      if (inst?.hide) {
        inst.hide();
      } else {
        panel.classList.add("opacity-0", "invisible");
        setTimeout(() => panel.classList.add("hidden"), 300);
      }
    }

    async loadNotifications() {
      try {
        this.showLoading();

        const response = await fetch("/api/notifications/get?limit=10", {
          credentials: "include",
        });

        if (response.status === 401) {
          this.showEmpty();
          return;
        }

        const data = await response.json();

        if (data.success) {
          const raw = data.notifications || [];
          // Unread first, then by createdAt desc
          this.notifications = [...raw].sort((a, b) => {
            const aUnread = !a.viewed ? 1 : 0;
            const bUnread = !b.viewed ? 1 : 0;
            if (bUnread !== aUnread) return bUnread - aUnread;
            return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
          });
          this.hasMore = raw.length >= (data.limit ?? 10);
          this.updateBadge(data.unreadCount || 0);
          this.renderNotifications();
        } else if (data.migrationRequired) {
          console.warn("‚ö†Ô∏è [NOTIFICATIONS] Database migration required:", data.error);
          this.showMigrationRequired(data.instructions);
        } else {
          console.error("‚ùå [NOTIFICATIONS] Failed to load notifications:", data.error);
          this.showEmpty();
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error loading notifications:", error);
        this.showEmpty();
      }
    }

    renderNotifications(saveScrollPosition = false) {
      const list = document.getElementById("notification-list");
      const empty = document.getElementById("notification-empty");
      const loading = document.getElementById("notification-loading");

      if (!list) {
        console.error("‚ùå [NOTIFICATIONS] notification-list element not found");
        return;
      }

      const scrollTop = saveScrollPosition ? list.scrollTop : undefined;
      const scrollHeight = saveScrollPosition ? list.scrollHeight : undefined;

      // Hide loading and empty states
      loading?.classList.add("hidden");
      empty?.classList.add("hidden");

      // Show the list
      list?.classList.remove("hidden");

      if (this.notifications.length === 0) {
        empty?.classList.remove("hidden");
        return;
      }

      list.innerHTML = "";

      this.notifications.forEach((notification: any) => {
        const notificationElement = this.createNotificationElement(notification);
        list.appendChild(notificationElement);
      });

      // Restore scroll position after append (e.g. load more) to avoid jump and re-trigger
      if (saveScrollPosition && scrollTop !== undefined && scrollHeight !== undefined) {
        list.scrollTop = scrollTop;
        const newHeight = list.scrollHeight;
        if (newHeight > scrollHeight) {
          list.scrollTop = scrollTop + (newHeight - scrollHeight);
        }
      }
    }

    createNotificationElement(notification: any) {
      const isRead = !!notification.viewed;
      const div = document.createElement("div");
      div.className = `relative notification-item overflow-hidden border-b border-gray-200 dark:border-gray-700 transition-colors ${isRead ? "notification-item-read opacity-90 bg-gray-50/80 dark:bg-gray-800/50" : "dark:bg-primary-900/20"}`;
      div.dataset.notificationId = String(notification.id);
      div.dataset.viewed = String(isRead);

      const timeAgo = this.formatTimeAgo(notification.createdAt);

      const iconColor = isRead
        ? "text-gray-400 dark:text-gray-500"
        : "text-primary-600 dark:text-primary-400";
      const iconPath = isRead
        ? "M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"
        : "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z";

      div.innerHTML = `
        <div class="notification-content p-2 m-2 flex items-start gap-2 sm:gap-3 relative">
            <div class="flex-shrink-0">
              <svg class="w-5 h-5 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${iconPath}"></path>
              </svg>
            </div>
            <div class="flex-1 min-w-0 overflow-hidden">
              <div class="flex items-center gap-2 min-w-0">
                <p class="text-sm font-medium text-gray-900 dark:text-white truncate min-w-0 flex-1">
                  ${notification.title}
                </p>
                <span class="text-xs text-gray-500 dark:text-gray-400 flex-shrink-0">${timeAgo}</span>
              </div>
              <p class="mt-1 text-sm text-gray-600 dark:text-gray-300 line-clamp-2 break-words">
                ${notification.message}
              </p>
              ${
                notification.actionUrl
                  ? `
                <div class="mt-2">
                  <a href="${notification.actionUrl}" class="text-sm text-primary-600 hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300">
                    ${notification.actionText || "View Details"}
                  </a>
                </div>
              `
                  : ""
              }
            </div>
            <div class="flex flex-shrink-0 items-center gap-0.5 self-center">
              ${!isRead ? `
              <button
                type="button"
                class="archive-notification-btn rounded-full p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 dark:text-gray-500 dark:hover:text-gray-300 dark:hover:bg-gray-700 transition-colors"
                title="Archive"
                data-notification-id="${notification.id}"
              >
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"></path>
                </svg>
              </button>
              ` : ""}
              <div class="delete-confirm-wrapper">
                <button
                  type="button"
                  id="delete-notification-${notification.id}"
                  class="delete-confirm-btn rounded-full inline-flex items-center justify-center p-2 text-sm font-medium text-gray-400 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-500 dark:hover:text-gray-200 dark:hover:bg-gray-700 transition-colors"
                  data-state="trash"
                  data-timeout="3000"
                  data-item-type="notification"
                  data-api-endpoint="/api/notifications/delete"
                  data-callback="handleNotificationDelete"
                  title="Delete notification"
                >
                  <svg class="inline-block delete-confirm-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18"></path>
                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                    <path d="M10 11v6"></path>
                    <path d="M14 11v6"></path>
                  </svg>
                  <svg width="44" height="44" viewBox="0 0 44 44" fill="none" xmlns="http://www.w3.org/2000/svg" class="absolute top-0 left-0 timer-ring-overlay">
                    <circle cx="22" cy="22" r="18" fill="none" stroke="#ef4444" stroke-width="3" stroke-dasharray="113.1" stroke-dashoffset="113.1" transform="rotate(-90 22 22)" class="timer-icon-test" />
                  </svg>
                </button>
              </div>
            </div>
          </div>
      `;

      const archiveBtn = div.querySelector(".archive-notification-btn");
      if (archiveBtn) {
        archiveBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.archiveNotification(notification.id);
        });
      }

      return div;
    }

    handleScroll() {
      // Mark visible notifications as viewed
      const list = document.getElementById("notification-list");
      if (!list) return;

      const rect = list.getBoundingClientRect();
      const notifications = list.querySelectorAll("[data-notification-id]");

      notifications.forEach((element) => {
        const elementRect = element.getBoundingClientRect();
        const isVisible = elementRect.top >= rect.top && elementRect.bottom <= rect.bottom;

        if (isVisible) {
          const notificationId = parseInt((element as HTMLElement).dataset.notificationId || "0");
          const notification = this.notifications.find((n) => n.id === notificationId);

          if (notification && !notification.viewed) {
            this.viewedNotifications.add(notificationId);
            this.markNotificationAsRead(notificationId);
          }
        }
      });

      // Check if we're near the bottom for auto-loading (only when there may be more)
      if (!this.hasMore || this.isLoadingMore) return;
      const scrollTop = list.scrollTop;
      const scrollHeight = list.scrollHeight;
      const clientHeight = list.clientHeight;
      const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;

      // Auto-load more when 80% scrolled
      if (scrollPercentage > 0.8 && this.notifications.length > 0) {
        this.loadMoreNotifications();
      }
    }

    async markNotificationAsRead(notificationId: number) {
      const notification = this.notifications.find((n) => n.id === notificationId);
      if (notification) {
        notification.viewed = true;
        this.updateNotificationDisplay(notificationId);
      }
    }

    updateNotificationDisplay(notificationId: number) {
      const notification = this.notifications.find((n: any) => n.id === notificationId);
      if (notification) notification.viewed = true;

      const element = document.querySelector(`[data-notification-id="${notificationId}"]`) as HTMLElement | null;
      if (element) {
        element.classList.add("notification-item-read", "opacity-90", "bg-gray-50/80", "dark:bg-gray-800/50");
        element.classList.remove("dark:bg-primary-900/20");
        element.setAttribute("data-viewed", "true");

        const archiveBtn = element.querySelector(".archive-notification-btn");
        if (archiveBtn) (archiveBtn as HTMLElement).remove();
      }
    }

    async markViewedNotificationsAsRead() {
      if (this.viewedNotifications.size === 0) return;

      try {
        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: Array.from(this.viewedNotifications),
            viewed: true,
          }),
        });

        if (response.ok) {
          const unreadCount = this.notifications.filter((n: any) => !n.viewed).length;
          this.updateBadge(unreadCount);
          this.viewedNotifications.clear();
          await this.loadNotifications();
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error(
            "‚ùå [NOTIFICATIONS] Error marking notifications as read:",
            response.status,
            errorData
          );
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error marking notifications as read:", error);
      }
    }

    async loadMoreNotifications() {
      if (this.isLoadingMore || !this.hasMore) return;
      this.isLoadingMore = true;

      const loadingIndicator = document.getElementById("loading-indicator");
      if (loadingIndicator) {
        loadingIndicator.classList.remove("hidden");
      }

      const limit = 10;
      const offset = this.notifications.length;

      try {
        const response = await fetch(`/api/notifications/get?limit=${limit}&offset=${offset}`, {
          credentials: "include",
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success && data.notifications) {
          const existingIds = new Set(this.notifications.map((n: any) => n.id));
          const newItems = data.notifications.filter((n: any) => !existingIds.has(n.id));
          this.notifications = [...this.notifications, ...newItems];
          this.hasMore = data.notifications.length >= limit;
          this.renderNotifications(true);
          this.updateBadge(
            data.unreadCount ?? this.notifications.filter((n: any) => !n.viewed).length
          );
        } else {
          this.hasMore = false;
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error auto-loading notifications:", error);
      } finally {
        this.isLoadingMore = false;
        if (loadingIndicator) {
          loadingIndicator.classList.add("hidden");
        }
      }
    }

    async markAllAsRead() {
      try {
        const unreadIds = this.notifications.filter((n: any) => !n.viewed).map((n: any) => n.id);
        if (unreadIds.length === 0) return;

        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: unreadIds,
            viewed: true,
          }),
        });

        if (response.ok) {
          this.updateBadge(0);
          await this.loadNotifications();
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error(
            "‚ùå [NOTIFICATIONS] Error marking all as read:",
            response.status,
            errorData
          );
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error marking all as read:", error);
      }
    }

    async archiveNotification(notificationId: number) {
      try {
        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: [notificationId],
            viewed: true,
          }),
        });
        if (response.ok) {
          this.viewedNotifications.add(notificationId);
          this.updateNotificationDisplay(notificationId);
          const unreadCount = this.notifications.filter((n: any) => !n.viewed).length;
          this.updateBadge(unreadCount);
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error archiving notification:", error);
      }
    }

    async archiveAll() {
      try {
        const ids = this.notifications.filter((n: any) => !n.viewed).map((n: any) => n.id);
        if (ids.length === 0) return;

        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: ids,
            viewed: true,
          }),
        });
        if (response.ok) {
          ids.forEach((id) => this.viewedNotifications.add(id));
          this.updateBadge(0);
          await this.loadNotifications();
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error("‚ùå [NOTIFICATIONS] Error archiving all:", response.status, errorData);
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error archiving all:", error);
      }
    }

    async deleteNotification(notificationId: number) {
      console.log("üîç [NOTIFICATIONS] Deleting notification ID:", notificationId);

      // The DeleteConfirmButton component handles the API call
      // This method just updates the UI after successful deletion
      await this.loadNotifications();
    }

    updateBadge(count: number) {
      console.log("üîç [NOTIFICATIONS] updateBadge called with count:", count);

      if ((window as any).updateNotificationBellCount) {
        (window as any).updateNotificationBellCount(count);
      } else {
        console.warn("üîç [NOTIFICATIONS] Global notification count updater not available");
      }
    }

    showLoading() {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.remove("hidden");
      empty?.classList.add("hidden");
      list?.classList.add("hidden");
    }

    showEmpty() {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.add("hidden");
      empty?.classList.remove("hidden");
      list?.classList.add("hidden");
    }

    showMigrationRequired(instructions: string[]) {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.add("hidden");
      empty?.classList.add("hidden");
      list?.classList.add("hidden");

      const emptyDiv = document.getElementById("notification-empty") as HTMLElement;
      if (emptyDiv) {
        emptyDiv.innerHTML = `
          <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-white">Database Migration Required</h3>
          <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">Notifications table not found.</p>
          <div class="mt-4 text-left">
            <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Setup instructions:</p>
            <ol class="text-xs text-gray-600 dark:text-gray-400 space-y-1">
              ${instructions.map((instruction: string) => `<li>${instruction}</li>`).join("")}
            </ol>
          </div>
        `;
        emptyDiv.classList.remove("hidden");
      }
    }

    startPolling() {
      // Poll for new notifications every 2 minutes
      this.pollingInterval = setInterval(() => {
        if (!this.isOpen) {
          this.loadNotifications();
        }
      }, 120000);
    }

    formatTimeAgo(dateString: string) {
      const date = new Date(dateString);
      const now = new Date();
      const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));

      if (diffInMinutes < 1) return "Just now";
      if (diffInMinutes < 60) return `${diffInMinutes}m ago`;

      const diffInHours = Math.floor(diffInMinutes / 60);
      if (diffInHours < 24) return `${diffInHours}h ago`;

      const diffInDays = Math.floor(diffInHours / 24);
      if (diffInDays < 7) return `${diffInDays}d ago`;

      return date.toLocaleDateString();
    }
  }

  // Initialize notification manager
  // console.log("üîç [NOTIFICATIONS] Initializing notification manager");
  const notificationManager = new NotificationManager();
  (window as any).notificationManager = notificationManager;

  // Global callback for delete confirmation (called by DeleteConfirmButton)
  (window as any).handleNotificationDelete = async (notificationId) => {
    console.log(
      "üîç [NOTIFICATIONS] Global handleNotificationDelete called for ID:",
      notificationId
    );
    if ((window as any).showNotice) {
      (window as any).showNotice("success", "Notification deleted", "Notification removed.", 3000);
    }
    await notificationManager.deleteNotification(notificationId);
  };

  // Flowbite: open via data-dropdown-toggle (bell), close via data-dismiss-target (close button); we load on open in bindEvents
</script>

<style>
  /* Custom scrollbar for notification list */
  #notification-list::-webkit-scrollbar {
    width: 4px;
  }

  #notification-list::-webkit-scrollbar-track {
    background: transparent;
  }

  #notification-list::-webkit-scrollbar-thumb {
    border-radius: 2px;
    background: #d1d5db;
  }

  #notification-list::-webkit-scrollbar-thumb:hover {
    background: #9ca3af;
  }

  /* Truncate notification message to 2 lines on mobile */
  #notification-list .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .notification-content {
    position: relative;
    z-index: 1;
  }
</style>
