---
import { getRetinaImageUrl } from "../../lib/image-retina";
/**
 * InsetBgFade - Fadeshow background: cycles through an array of image URLs with fade transitions.
 * Retina-aware: applies 2x resolution for Unsplash URLs when possible.
 * Use inside a positioned parent. No controls, loops indefinitely.
 *
 * @example
 * <InsetBgFade imageUrls={["https://images.unsplash.com/photo-1504307651254-35680f356dfd?w=1920&auto=format", ...]} />
 */

interface Props {
  imageUrls?: string[];
  /** Flat props for shortcode: image1, image2, ... image12 */
  image1?: string;
  image2?: string;
  image3?: string;
  image4?: string;
  image5?: string;
  image6?: string;
  image7?: string;
  image8?: string;
  image9?: string;
  image10?: string;
  image11?: string;
  image12?: string;
  /** Duration of each image in ms before fading to next. Default: 4000. Ignored when scrollMode. */
  interval?: number;
  /** Crossfade duration in ms. Default: 1200 */
  fadeDuration?: number;
  /** When true, images advance by scroll position instead of time. For md/single-col: each image visible when its scroll segment is in 15%-85% viewport zone. */
  scrollMode?: boolean | string;
}

const props = Astro.props;
function getImageUrls(): string[] {
  if (props.imageUrls) {
    if (typeof props.imageUrls === "string") {
      try {
        return JSON.parse(props.imageUrls) as string[];
      } catch {
        return [];
      }
    }
    return props.imageUrls;
  }
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    .map((i) => props[`image${i}` as keyof typeof props] as string | undefined)
    .filter((u): u is string => Boolean(u));
}
const resolvedUrls = getImageUrls();
const { interval = 4000, fadeDuration = 1200, scrollMode = false } = props;
const useScrollMode = scrollMode === true || scrollMode === "true";
---

{
  resolvedUrls.length > 0 && (
    <div
      class="pointer-events-none absolute inset-0 -z-10 overflow-hidden"
      aria-hidden="true"
      data-fadeshow
      data-fadeshow-scroll={useScrollMode ? "true" : undefined}
      data-interval={!useScrollMode ? interval : undefined}
      data-fade-duration={fadeDuration}
    >
      {resolvedUrls.map((url, i) => (
        <div
          class="fadeshow-layer absolute inset-0 bg-cover bg-center bg-no-repeat"
          data-fadeshow-layer
          data-index={i}
          style={`background-image: url(${getRetinaImageUrl(url)}); opacity: ${i === 0 ? 1 : 0};`}
        />
      ))}
    </div>
  )
}

<style>
  .fadeshow-layer {
    transition: opacity var(--fadeshow-duration, 1.2s) ease-in-out;
  }
</style>

<script>
  function initFadeshow(root?: Document | Element) {
    const scope = root ?? document;
    scope.querySelectorAll("[data-fadeshow]").forEach((container) => {
      if ((container as HTMLElement).dataset.fadeshowInit) return;
      (container as HTMLElement).dataset.fadeshowInit = "1";

      const layers = container.querySelectorAll<HTMLElement>("[data-fadeshow-layer]");
      if (layers.length <= 1) return;

      const fadeMs = parseInt(container.getAttribute("data-fade-duration") ?? "1200", 10);
      (container as HTMLElement).style.setProperty("--fadeshow-duration", `${fadeMs}ms`);

      const scrollMode = container.getAttribute("data-fadeshow-scroll") === "true";

      if (scrollMode) {
        const scrollEl = document.getElementById("reveal-scroll") ?? document.documentElement;
        const updateFromScroll = () => {
          const maxScroll =
            scrollEl === document.documentElement
              ? Math.max(0, document.documentElement.scrollHeight - window.innerHeight)
              : Math.max(0, scrollEl.scrollHeight - scrollEl.clientHeight);
          if (maxScroll <= 0) {
            layers[0]!.style.opacity = "1";
            for (let j = 1; j < layers.length; j++) layers[j]!.style.opacity = "0";
            return;
          }
          const scrollTop =
            scrollEl === document.documentElement ? window.scrollY : scrollEl.scrollTop;
          const progress = Math.max(0, Math.min(1, scrollTop / maxScroll));
          const idx = Math.min(
            layers.length - 1,
            Math.floor(progress * layers.length)
          );
          layers.forEach((l, i) => {
            l.style.opacity = i === idx ? "1" : "0";
          });
        };
        updateFromScroll();
        scrollEl.addEventListener("scroll", updateFromScroll, { passive: true });
        scrollEl.addEventListener("scrollend", updateFromScroll); /* catch momentum scroll end on mobile */
        scrollEl.addEventListener("touchend", updateFromScroll, { passive: true }); /* iOS: update after touch lift */
        window.addEventListener("resize", updateFromScroll);
      } else {
        const intervalMs = parseInt(container.getAttribute("data-interval") ?? "4000", 10);
        let idx = 0;
        const next = () => {
          const prev = idx;
          idx = (idx + 1) % layers.length;
          layers[prev]!.style.opacity = "0";
          layers[idx]!.style.opacity = "1";
        };
        setInterval(next, intervalMs);
      }
    });
  }
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => initFadeshow(document));
  } else {
    initFadeshow(document);
  }
  document.addEventListener("astro:after-swap", () => initFadeshow(document));
</script>
