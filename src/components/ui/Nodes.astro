---
// NodeEditor.astro - A complete node-based editor with demo page
---

<style>
  /* Demo page styles */

  .node-editor-canvas {
    position: absolute;
    inset: 0;
    cursor: grab;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    z-index: 0;
  }

  .node-editor-canvas:active {
    cursor: grabbing;
  }

  .connections-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  :global(.node-card) {
    position: absolute;
    min-width: 200px;
    max-width: 300px;
    border-radius: 8px;
    padding: 16px;
    cursor: move;
    z-index: 5;
    user-select: none;
    transition: all 0.2s;
    box-sizing: border-box;
  }

  :global(.node-card:hover) {
  }

  :global(.node-card.selected) {
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }

  :global(.node-card.dragging) {
    z-index: 10;
    transform: rotate(2deg);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  }

  :global(.node-header) {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
  }

  :global(.node-icon) {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
  }

  :global(.node-title) {
    font-weight: 600;
    font-size: 14px;
    margin: 0;
    padding: 0;
    line-height: 1.2;
  }

  :global(.node-subtitle) {
    font-size: 12px;
    margin-top: 2px;
    margin: 0;
    padding: 0;
    line-height: 1.2;
  }

  :global(.node-status) {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    margin-top: 8px;
    margin: 0;
    padding: 0;
  }

  :global(.status-indicator) {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #10b981;
  }

  :global(.connection-point) {
    /* position: absolute;
    width: 12px;
    height: 12px;
    background: #3b82f6;
    border: 2px solid #1a1a1a;
    border-radius: 50%; */
    /* cursor: pointer;
    z-index: 6;
    box-sizing: border-box; */
  }

  :global(.connection-point:hover) {
    background: #60a5fa;
    transform: scale(1.2);
  }

  :global(.connection-point.input.top) {
    left: 50%;
    top: -6px;
    transform: translateX(-50%);
  }

  :global(.connection-point.input.right) {
    right: -6px;
    top: 50%;
    transform: translateY(-50%);
  }

  :global(.connection-point.input.bottom) {
    left: 50%;
    bottom: -6px;
    transform: translateX(-50%);
  }

  :global(.connection-point.input.left) {
    left: -6px;
    top: 50%;
    transform: translateY(-50%);
  }

  :global(.connection-point.output.top) {
    left: 50%;
    top: -6px;
    transform: translateX(-50%);
  }

  :global(.connection-point.output.right) {
    right: -6px;
    top: 50%;
    transform: translateY(-50%);
  }

  :global(.connection-point.output.bottom) {
    left: 50%;
    bottom: -6px;
    transform: translateX(-50%);
  }

  :global(.connection-point.output.left) {
    left: -6px;
    top: 50%;
    transform: translateY(-50%);
  }

  :global(.connection-line) {
    stroke: #3b82f6;
    stroke-width: 3;
    fill: none;
    stroke-dasharray: 8, 4;
    animation:
      dash 2s linear infinite,
      drawLine 1.5s ease-in-out forwards;
    pointer-events: none;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: -12;
    }
  }

  @keyframes drawLine {
    from {
      stroke-dasharray: 0, 1000;
    }
    to {
      stroke-dasharray: 8, 4;
    }
  }

  :global(.connection-arrow) {
    fill: #3b82f6;
    pointer-events: none;
    animation:
      arrowPulse 1.5s ease-in-out infinite,
      drawArrow 1.5s ease-in-out forwards;
    opacity: 0;
  }

  @keyframes arrowPulse {
    0%,
    100% {
      opacity: 0.7;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
  }

  @keyframes drawArrow {
    0% {
      opacity: 0;
      transform: scale(0);
    }
    50% {
      opacity: 0.8;
      transform: scale(0.5);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  :global(.node-card[data-type="database"] .node-icon) {
    background: #3b82f6;
    color: white;
  }

  :global(.node-card[data-type="analytics"] .node-icon) {
    background: #8b5cf6;
    color: white;
  }

  :global(.node-card[data-type="storage"] .node-icon) {
    background: #f59e0b;
    color: white;
  }

  :global(.node-card[data-type="default"] .node-icon) {
    background: #6b7280;
    color: white;
  }
</style>

<div class="node-editor-wrapper absolute inset-0 z-0 mask-gradient-140">
  <div class="node-editor-canvas" id="node-canvas">
    <!-- Nodes will be dynamically added here -->
  </div>

  <!-- Connection overlay for drawing arrows -->
  <svg class="connections-overlay" id="connections-svg">
    <!-- Arrows will be drawn here -->
  </svg>
</div>

<script>
  class NodeEditor {
    canvas;
    svg;
    nodes;
    connections;
    draggedNode;
    dragOffset;
    connecting;
    connectionStart;
    nodeCounter;
    centerX;
    centerY;
    nodeSpacing;
    isScrolling;
    scrollSpeed;
    scrollInterval;

    constructor() {
      this.canvas = document.getElementById("node-canvas");
      this.svg = document.getElementById("connections-svg");
      this.nodes = new Map();
      this.connections = [];
      this.draggedNode = null;
      this.dragOffset = { x: 0, y: 0 };
      this.connecting = false;
      this.connectionStart = null;
      this.nodeCounter = 0;
      // Center maintenance properties
      this.centerX = 0;
      this.centerY = 0;
      this.nodeSpacing = 250; // Horizontal spacing between nodes
      // Continuous scroll properties
      this.isScrolling = false;
      this.scrollSpeed = 2;
      this.scrollInterval = null;

      this.init();
    }

    init() {
      this.setupEventListeners();
      this.addCustomNodes(1500);
    }

    setupEventListeners() {
      // Add node button

      // Canvas events
      this.canvas?.addEventListener("mousedown", this.handleCanvasMouseDown.bind(this));
      this.canvas?.addEventListener("mousemove", this.handleCanvasMouseMove.bind(this));
      this.canvas?.addEventListener("mouseup", this.handleCanvasMouseUp.bind(this));
    }

    addCustomNodes(delay = 1500) {
      // Start continuous scrolling immediately
      this.startContinuousScroll();
      // this.startContinuousNodeAddition(1000);

      const screenWidth = window.innerWidth || 0;
      const screenHeight = window.innerHeight || 0;

      // Add some sample nodes with their original specific positioning
      setTimeout(() => {
        this.addNodeWithCenterMaintenance({
          id: "create-account",
          type: "default",
          title: "Create Account",
          subtitle: "<a href='/auth/login?register=true'>Register</a>",
          status: "2 Minutes",
          x: screenWidth - 400,
          y: screenHeight * 0.2,
        });
      }, delay);

      setTimeout(() => {
        this.addNodeWithCenterMaintenance({
          id: "login",
          type: "login",
          title: "Login",
          subtitle: "<a href='/auth/login'>Login</a>",
          status: "2 Seconds",
          x: screenWidth - 200,
          y: screenHeight * 0.5,
        });
      }, delay + delay);

      setTimeout(
        () => {
          this.addConnection("create-account", "login", "right", "left");
        },
        delay + delay + 100
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addConnection("create-account", "login", "right", "left");
        },
        delay + delay + 100
      ); // After uplo

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "upload-files",
            type: "default",
            title: "Upload Files",
            status: "PDF, jpeg, png, autocad, revit, dwg",
            x: screenWidth,
            y: screenHeight * 0.25,
          });
        },
        delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("login", "upload-files", "right", "left");
        },
        delay + delay + delay + 10
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "submit-files",
            type: "default",
            title: "Request Review",
            status: "2-4 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.65,
          });
        },
        delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("upload-files", "submit-files", "right", "left");
        },
        delay + delay + delay + delay + 10
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "generate-proposal",
            type: "storage",
            title: "Generating Proposal",
            status: "24 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.5,
          });
        },
        delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("submit-files", "generate-proposal", "right", "left");
        },
        delay + delay + delay + delay + delay + 10
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "proposal-approved",
            type: "storage",
            title: "Approve Proposal",
            status: "24 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.25,
          });
        },
        delay + delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "proposal-request-revision",
            type: "storage",
            title: "Request Revision",
            status: "2-4 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.65,
          });
        },
        delay + delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("generate-proposal", "proposal-approved", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + 10
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addConnection("generate-proposal", "proposal-request-revision", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + 10
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "approve-revisions",
            type: "storage",
            title: "Approve Revisions",
            status: "24 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.45,
          });
        },
        delay + delay + delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "sign-off-proposal",
            type: "storage",
            title: "Sign Off Proposal",
            status: "2-4 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.75,
          });
        },
        delay + delay + delay + delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("approve-revisions", "sign-off-proposal", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + delay + delay + 100
      ); // After upload-files is created

      setTimeout(
        () => {
          this.addConnection("proposal-request-revision", "approve-revisions", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + delay + delay + 100
      ); // After upload-fil
      // es is created

      setTimeout(
        () => {
          this.addConnection("approve-revisions", "sign-off-proposal", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + delay + delay + 100
      ); // After upload-fil

      setTimeout(
        () => {
          this.addNodeWithCenterMaintenance({
            id: "final-documents",
            type: "storage",
            title: "Generating Final Documents",
            status: "24 hours to complete",
            x: screenWidth,
            y: screenHeight * 0.25,
          });
        },
        delay + delay + delay + delay + delay + delay + delay + delay + delay + delay
      );

      setTimeout(
        () => {
          this.addConnection("approve-revisions", "final-documents", "right", "left");
        },
        delay + delay + delay + delay + delay + delay + delay + delay + delay + delay + 100
      ); // After upload-files is created

      // setTimeout(() => {
      //   this.addNodeWithCenterMaintenance({
      //     id: "approve",
      //     type: "storage",
      //     title: "Approve Proposal",
      //     status: "24 hours to complete",
      //     x: screenWidth - 200,
      //     y: 700,
      //   });
      // }, delay + 2500);

      // setTimeout(() => {
      //   this.addNodeWithCenterMaintenance({
      //     id: "revision",
      //     type: "storage",
      //     title: "Request Revision",
      //     status: "24 hours to complete",
      //     x: screenWidth - 200,
      //     y: 200,
      //   });
      // }, delay + 3800);

      // setTimeout(() => {
      //   this.addNode({
      //     id: "final-1",
      //     type: "storage",
      //     title: "Final Review",
      //     status: "24 hours to complete",
      //     x: screenWidth - 200,
      //     y: 350,
      //   });
      // }, delay + 4500);

      // setTimeout(() => {
      //   this.addNode({
      //     id: "deliverable",
      //     type: "client",
      //     title: "Final Documents Ready",
      //     status: "24 hours to complete",
      //     x: screenWidth - 200,
      //     y: 5500,
      //   });

      //   // Keep scrolling - don't stop it
      //   // this.stopContinuousScroll(); // Removed to keep scrolling
      // }, delay + 3000);

      // Add connections with additional delay

      // setTimeout(() => {
      //   this.addConnection("upload-files", "proposal", "right", "left");
      // }, delay + 1600);

      // setTimeout(() => {
      //   this.addConnection("proposal", "approve", "right", "left");
      // }, delay + 2000);

      // setTimeout(() => {
      //   this.addConnection("proposal", "revision", "right", "left");
      // }, delay + 2600);

      // setTimeout(() => {
      //   this.addConnection("approval-1", "final-1", "right", "left");
      // }, delay + 3200);
    }

    addNode(options = {}) {
      const nodeId = options.id || `node-${++this.nodeCounter}`;

      // Calculate position using center maintenance
      const position = this.calculateNodePosition(options);

      const node = {
        id: nodeId,
        type: options.type || "default",
        title: options.title || `Node ${this.nodeCounter}`,
        subtitle: options.subtitle || "",
        status: options.status || "Active",
        x: position.x,
        y: position.y,
      };

      this.nodes.set(nodeId, node);
      this.renderNode(node);

      // Update center and shift existing nodes
      // this.updateCenterAndShiftNodes();

      return node;
    }

    calculateNodePosition(options = {}) {
      // If specific coordinates are provided, use them
      if (options.x !== undefined && options.y !== undefined) {
        return { x: options.x, y: options.y };
      }

      // Calculate canvas dimensions
      const canvasWidth = this.canvas.offsetWidth;
      const canvasHeight = this.canvas.offsetHeight;
      this.centerX = canvasWidth / 2;
      this.centerY = canvasHeight / 2;

      // Always place new nodes on the right side of the screen
      const x = canvasWidth - 200; // Right side of screen
      const y = this.centerY + (Math.random() - 0.5) * 300; // Add vertical variation

      return { x, y };
    }

    // Method to preserve individual node positioning while shifting
    preserveNodePositions() {
      // Store current positions of all nodes
      const nodePositions = new Map();
      this.nodes.forEach((node, nodeId) => {
        nodePositions.set(nodeId, { x: node.x, y: node.y });
      });
      return nodePositions;
    }

    // Method to restore individual node positions
    restoreNodePositions(nodePositions) {
      nodePositions.forEach((position, nodeId) => {
        const node = this.nodes.get(nodeId);
        if (node) {
          node.x = position.x;
          node.y = position.y;

          const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
          if (nodeElement) {
            nodeElement.style.left = `${node.x}px`;
            nodeElement.style.top = `${node.y}px`;
          }
        }
      });
    }

    // Method to remove nodes that have scrolled off the left side
    removeOffscreenNodes() {
      const nodesToRemove = [];

      this.nodes.forEach((node, nodeId) => {
        // Remove nodes that are well off the left side of the screen
        if (node.x < -1000) {
          // Much larger buffer to keep nodes and arrows visible longer
          nodesToRemove.push(nodeId);
        }
      });

      // Remove nodes and their DOM elements
      nodesToRemove.forEach((nodeId) => {
        const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeElement) {
          nodeElement.remove();
        }
        this.nodes.delete(nodeId);
      });

      // Don't remove connections - keep arrows visible even if nodes are off-screen
      // This ensures arrows stay visible during the timeline
      // this.connections = this.connections.filter((connection) => {
      //   return this.nodes.has(connection.from) && this.nodes.has(connection.to);
      // });
    }

    // Method to add a node with center maintenance and smooth animation
    addNodeWithCenterMaintenance(options = {}) {
      const node = this.addNode(options);

      // Add entrance animation
      const nodeElement = document.querySelector(`[data-node-id="${node.id}"]`);
      if (nodeElement) {
        nodeElement.style.opacity = "0";
        nodeElement.style.transform = "scale(0.01)";

        setTimeout(() => {
          nodeElement.style.transition = "opacity 0.3s ease-out, transform 0.85s ease-out";
          nodeElement.style.opacity = "1";
          nodeElement.style.transform = "scale(1)";
        }, 50);
      }

      return node;
    }

    renderNode(node) {
      const nodeElement = document.createElement("div");
      nodeElement.classList.add(
        "node-card",
        "bg-primary-100",
        "dark:bg-primary-900",
        "border",
        "border-primary-200",
        "dark:border-primary-700",
        "text-primary-900",
        "dark:text-primary-100"
      );
      nodeElement.dataset.nodeId = node.id;
      nodeElement.dataset.type = node.type;
      nodeElement.style.left = `${node.x}px`;
      nodeElement.style.top = `${node.y}px`;

      const iconMap = {
        database: "DB",
        analytics: "A",
        storage: "S",
        default: "N",
      };

      nodeElement.innerHTML = `
        <div class="node-header">
          <div class="node-icon">${iconMap[node.type] || "N"}</div>
          <div>
            <div class="node-title">${node.title}</div>
            ${node.subtitle ? `<div class="node-subtitle">${node.subtitle}</div>` : ""}
          </div>
        </div>
        <div class="node-status">
          <div class="status-indicator pulse"></div>
          <span>${node.status}</span>
        </div>
        <div class="connection-point input top"></div>
        <div class="connection-point input right"></div>
        <div class="connection-point input bottom"></div>
        <div class="connection-point input left"></div>
        <div class="connection-point output top"></div>
        <div class="connection-point output right"></div>
        <div class="connection-point output bottom"></div>
        <div class="connection-point output left"></div>
      `;

      // Add drag functionality
      nodeElement.addEventListener("mousedown", (e) => {
        e.stopPropagation();
        this.startDrag(node, e);
      });

      // Add connection point functionality
      nodeElement.querySelectorAll(".connection-point").forEach((point) => {
        point.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          const isOutput = point.classList.contains("output");
          const side = point.classList.contains("top")
            ? "top"
            : point.classList.contains("right")
              ? "right"
              : point.classList.contains("bottom")
                ? "bottom"
                : "left";
          this.startConnection(node, isOutput, side, e);
        });
      });

      this.canvas.appendChild(nodeElement);
    }

    startDrag(node, e) {
      this.draggedNode = node;
      const rect = e.target.closest(".node-card").getBoundingClientRect();
      const canvasRect = this.canvas.getBoundingClientRect();

      this.dragOffset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
      };

      e.target.closest(".node-card").classList.add("dragging");
    }

    startConnection(node, isOutput, side, e) {
      this.connecting = true;
      this.connectionStart = { node, isOutput, side };
      e.target.style.background = "#60a5fa";
    }

    findNearestAnchor(node, mouseX, mouseY) {
      const anchors = [
        { side: "top", pos: this.getConnectionPoint(node, "top") },
        { side: "right", pos: this.getConnectionPoint(node, "right") },
        { side: "bottom", pos: this.getConnectionPoint(node, "bottom") },
        { side: "left", pos: this.getConnectionPoint(node, "left") },
      ];

      let nearest = anchors[0];
      let minDistance = this.getDistance(mouseX, mouseY, anchors[0].pos.x, anchors[0].pos.y);

      for (let i = 1; i < anchors.length; i++) {
        const distance = this.getDistance(mouseX, mouseY, anchors[i].pos.x, anchors[i].pos.y);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = anchors[i];
        }
      }

      return nearest.side;
    }

    getDistance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    handleCanvasMouseMove(e) {
      if (this.draggedNode) {
        const canvasRect = this.canvas.getBoundingClientRect();
        const x = e.clientX - canvasRect.left - this.dragOffset.x;
        const y = e.clientY - canvasRect.top - this.dragOffset.y;

        this.draggedNode.x = Math.max(0, Math.min(x, this.canvas.offsetWidth - 200));
        this.draggedNode.y = Math.max(0, Math.min(y, this.canvas.offsetHeight - 100));

        const nodeElement = document.querySelector(`[data-node-id="${this.draggedNode.id}"]`);
        nodeElement.style.left = `${this.draggedNode.x}px`;
        nodeElement.style.top = `${this.draggedNode.y}px`;

        this.updateConnections();
      }

      // Handle connection preview when connecting
      if (this.connecting && this.connectionStart) {
        const canvasRect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - canvasRect.left;
        const mouseY = e.clientY - canvasRect.top;

        // Find the node under the mouse
        const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
        const nodeElement = elementUnderMouse?.closest(".node-card");

        if (
          nodeElement &&
          nodeElement !== document.querySelector(`[data-node-id="${this.connectionStart.node.id}"]`)
        ) {
          const nodeId = nodeElement.dataset.nodeId;
          const targetNode = this.nodes.get(nodeId);

          if (targetNode) {
            // Find nearest anchor on target node
            const nearestSide = this.findNearestAnchor(targetNode, mouseX, mouseY);

            // Update connection preview
            this.updateConnectionPreview(
              this.connectionStart.node,
              this.connectionStart.side,
              targetNode,
              nearestSide
            );
          }
        }
      }
    }

    handleCanvasMouseUp(e) {
      if (this.draggedNode) {
        this.draggedNode = null;
        document.querySelectorAll(".node-card").forEach((card) => {
          card.classList.remove("dragging");
        });
      }

      if (this.connecting && this.connectionStart) {
        const canvasRect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - canvasRect.left;
        const mouseY = e.clientY - canvasRect.top;

        // Find the node under the mouse
        const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
        const nodeElement = elementUnderMouse?.closest(".node-card");

        if (
          nodeElement &&
          nodeElement !== document.querySelector(`[data-node-id="${this.connectionStart.node.id}"]`)
        ) {
          const nodeId = nodeElement.dataset.nodeId;
          const targetNode = this.nodes.get(nodeId);

          if (targetNode) {
            // Find nearest anchor on target node
            const nearestSide = this.findNearestAnchor(targetNode, mouseX, mouseY);

            // Create the connection
            this.addConnection(
              this.connectionStart.node.id,
              targetNode.id,
              this.connectionStart.side,
              nearestSide
            );
          }
        }

        this.connecting = false;
        this.connectionStart = null;
        document.querySelectorAll(".connection-point").forEach((point) => {
          point.style.background = "#3b82f6";
        });

        // Clear preview
        this.clearConnectionPreview();
      }
    }

    updateConnectionPreview(fromNode, fromSide, toNode, toSide) {
      // Clear existing preview
      this.clearConnectionPreview();

      // Create preview connection
      const fromPos = this.getConnectionPoint(fromNode, fromSide);
      const toPos = this.getConnectionPoint(toNode, toSide);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const midX = (fromPos.x + toPos.x) / 2; // True middle point between anchors
      const pathData = `M ${fromPos.x} ${fromPos.y} L ${midX} ${fromPos.y} L ${midX} ${toPos.y} L ${toPos.x} ${toPos.y}`;

      path.setAttribute("d", pathData);
      path.setAttribute("class", "connection-line");
      path.setAttribute("style", "stroke: #60a5fa; stroke-dasharray: 3,3; opacity: 0.7;");

      this.svg.appendChild(path);
    }

    clearConnectionPreview() {
      // Remove preview connections (those with dashed style)
      const previewLines = this.svg.querySelectorAll('path[style*="stroke-dasharray"]');
      previewLines.forEach((line) => line.remove());
    }

    handleCanvasMouseDown(e) {
      // Deselect all nodes
      document.querySelectorAll(".node-card").forEach((card) => {
        card.classList.remove("selected");
      });
    }

    addConnection(fromNodeId, toNodeId, fromSide = "right", toSide = "left") {
      const connection = { from: fromNodeId, to: toNodeId, fromSide, toSide };
      this.connections.push(connection);
      this.renderConnection(connection);
    }

    renderConnection(connection) {
      const fromNode = this.nodes.get(connection.from);
      const toNode = this.nodes.get(connection.to);

      if (!fromNode || !toNode) return;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");

      // Calculate connection points based on sides
      const fromPos = this.getConnectionPoint(fromNode, connection.fromSide || "right");
      const toPos = this.getConnectionPoint(toNode, connection.toSide || "left");

      // Create 90-degree bent path with bend at the middle of the anchors
      const midX = (fromPos.x + toPos.x) / 2; // True middle point between anchors
      const pathData = `M ${fromPos.x} ${fromPos.y} L ${midX} ${fromPos.y} L ${midX} ${toPos.y} L ${toPos.x} ${toPos.y}`;

      path.setAttribute("d", pathData);
      path.setAttribute("class", "connection-line");

      // Add drawing animation delay based on connection order
      const delay = this.connections.indexOf(connection) * 200; // 200ms delay between each connection
      path.style.animationDelay = `${delay}ms`;

      // Add arrowhead at the end
      const arrowSize = 8;
      const arrowX = toPos.x - arrowSize;
      const arrowY = toPos.y;

      arrow.setAttribute(
        "points",
        `${toPos.x},${toPos.y} ${arrowX},${arrowY - arrowSize / 2} ${arrowX},${arrowY + arrowSize / 2}`
      );
      arrow.setAttribute("class", "connection-arrow");
      arrow.style.animationDelay = `${delay + 1000}ms`; // Arrow appears after line is drawn

      this.svg.appendChild(path);
      this.svg.appendChild(arrow);
    }

    getConnectionPoint(node, side) {
      // Get actual node dimensions from the DOM element
      const nodeElement = document.querySelector(`[data-node-id="${node.id}"]`);
      let nodeWidth = 200;
      let nodeHeight = 100;

      if (nodeElement) {
        const rect = nodeElement.getBoundingClientRect();
        const canvasRect = this.canvas.getBoundingClientRect();
        nodeWidth = rect.width;
        nodeHeight = rect.height;
      }

      switch (side) {
        case "top":
          return { x: node.x + nodeWidth / 2, y: node.y };
        case "right":
          return { x: node.x + nodeWidth, y: node.y + nodeHeight / 2 };
        case "bottom":
          return { x: node.x + nodeWidth / 2, y: node.y + nodeHeight };
        case "left":
          return { x: node.x, y: node.y + nodeHeight / 2 };
        default:
          return { x: node.x + nodeWidth, y: node.y + nodeHeight / 2 };
      }
    }

    updateConnections() {
      // Clear existing connections
      this.svg.innerHTML = "";

      // Re-render all connections with updated positions
      this.connections.forEach((connection) => {
        const fromNode = this.nodes.get(connection.from);
        const toNode = this.nodes.get(connection.to);

        // Only render if both nodes exist
        if (fromNode && toNode) {
          this.renderConnection(connection);
        }
      });
    }

    clearAll() {
      this.nodes.clear();
      this.connections = [];
      this.canvas.innerHTML = "";
      this.svg.innerHTML = "";
    }

    // Method to continuously add nodes to demonstrate center maintenance
    startContinuousNodeAddition(interval = 2000) {
      const nodeTypes = ["analytics", "database", "storage", "default"];
      const titles = [
        "Login",
        "Register",
        "Upload Files",
        "Generate Proposal",
        "Approve Proposal",
        "Request Revision",
        "Final Review",
        "Final Documents Ready",
      ];

      const addNextNode = () => {
        const randomType = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
        const randomTitle = titles[Math.floor(Math.random() * titles.length)];

        this.addNodeWithCenterMaintenance({
          type: randomType,
          title: randomTitle,
          status: `${Math.floor(Math.random() * 60)} minutes`,
        });

        // Schedule next node
        setTimeout(addNextNode, interval);
      };

      // Start the process
      setTimeout(addNextNode, interval);
    }

    // Method to stop continuous addition (if needed)
    stopContinuousAddition() {
      // This would require storing the timeout IDs, but for simplicity
      // we'll just clear all nodes
      this.clearAll();
    }

    // Start continuous smooth scrolling
    startContinuousScroll() {
      this.isScrolling = true;
      this.scrollSpeed = 3; // pixels per frame - adjust this value to change speed
      this.scrollInterval = null;

      const scroll = () => {
        if (this.isScrolling) {
          // Move all nodes left smoothly
          this.nodes.forEach((node, nodeId) => {
            node.x -= this.scrollSpeed;

            const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeElement) {
              nodeElement.style.left = `${node.x}px`;
            }
          });

          // Update connections every frame to maintain arrows
          this.updateConnections();

          // Remove offscreen nodes
          this.removeOffscreenNodes();

          // Continue scrolling
          this.scrollInterval = requestAnimationFrame(scroll);
        }
      };

      // Start the scroll loop
      this.scrollInterval = requestAnimationFrame(scroll);
    }

    // Stop continuous scrolling
    stopContinuousScroll() {
      this.isScrolling = false;
      if (this.scrollInterval) {
        cancelAnimationFrame(this.scrollInterval);
        this.scrollInterval = null;
      }
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    const nodeEditor = new NodeEditor();

    // Optional: Start continuous node addition to demonstrate center maintenance
    // Uncomment the line below to see the center maintenance in action
    // nodeEditor.startContinuousNodeAddition(3000);
  });
</script>
