---
/** Layout modes (used by layout components and CMS template): default | fullwidth | minimal | centered | fullscreen */
interface Props {
  title?: string;
  description?: string;
  currentUser?: any;
  session?: any;
  project?: any;
  supabase?: any;
  supabaseUrl?: string;
  projects?: any;
  isBackend?: boolean;
  id?: string;
  primaryTextClasses?: string;
  secondaryTextClasses?: string;
  globalInputClasses?: string;
  globalIconButtonClasses?: string;
  year?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  globalCompanyAddress?: string;
  globalCompanyPhone?: string;
  globalCompanyEmail?: string;
  globalCompanyWebsite?: string;
  globalCompanyLogo?: string;
  statusData?: any;
  statusOptions?: Array<{ value: string; label: string }>;
  mainClasses?: string;
  /** Layout: default | fullwidth | minimal | centered | fullscreen. Drives centering and fullscreen scroll. */
  layout?: "default" | "fullwidth" | "minimal" | "centered" | "fullscreen";
  mask?: string;
  horizontalScroll?: boolean;
}

const {
  title = undefined,
  description = undefined,
  project = undefined,
  supabaseUrl = undefined,
  projects = undefined,
  id = undefined,
  statusData = undefined,
  mainClasses = "",
  layout = undefined,
  mask = "center",
  horizontalScroll = false,
} = Astro.props;

// Derive layout behavior from layout prop only


// Effective template for data-template

import { globalCompanyData } from "../../pages/api/global/global-company-data";
const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  primaryColor,
  secondaryColor,
  fontFamily,
  secondaryFontFamily,
  globalCompanyIcon,
  plausibleTrackingScript,
  ogImage,
  customCss,
} = await globalCompanyData();

import { checkAuth } from "../../lib/auth";
const { currentUser, session, supabase, refreshToken, accessToken } = await checkAuth(
  Astro.cookies
);
import { globalClasses } from "../../pages/api/global/global-classes";
const { globalInputClasses, primaryTextClasses, secondaryTextClasses, globalIconButtonClasses } =
  globalClasses();

// Get theme from cookie (set by client-side script)
// Note: Cookie is set client-side, so on first load it may not exist yet
const themeCookie = Astro.cookies.get("theme");
const serverTheme = themeCookie?.value || "light"; // Default to light

// Debug logging

// Derived properties (8 props → 13 total)
const isAuth = currentUser ? true : false;
// const currentUserId = currentUser?.id || undefined; // Unused
const currentRole = currentUser?.profile?.role || undefined;
const projectId = project?.id || undefined;
const currentUrl = Astro.url.pathname;

// Icon sources - convert SVG to data URI; fallback to public favicon so we never use empty href
let iconSrc: string;
if (
  globalCompanyIcon &&
  (globalCompanyIcon.includes("<svg") || globalCompanyIcon.includes("<?xml"))
) {
  const encoded = Buffer.from(globalCompanyIcon).toString("base64");
  iconSrc = "data:image/svg+xml;base64," + encoded;
} else if (globalCompanyIcon && typeof globalCompanyIcon === "string") {
  iconSrc = globalCompanyIcon;
} else {
  iconSrc = "/favicon.svg";
}

// OG Image URL for social sharing - use setting from CMS, with fallback
const ogImageSrc = ogImage || "/videos/CACPCO-share-preview.gif";

// Get navigation data
import { navigation } from "@/pages/api/utils/navigation";
import { isBackendPage, isAuthPage, isContactPage } from "../../pages/api/utils/backend-page-check";

const isBackend = isBackendPage(Astro.url.pathname);
const isAuthPageResult = isAuthPage(Astro.url.pathname);
const isContactPageResult = isContactPage(Astro.url.pathname);
const navigationData = await navigation(
  currentUrl,
  isAuth,
  currentRole || "Client",
  isBackend || false
);
const { desktopNavigationHTML, mobileNavigationHTML, visibleNavItems } = navigationData;
import { ClientRouter } from "astro:transitions";
import { generateColorPalette } from "@/lib/color-utils";

// Server-rendered critical CMS colors so first paint uses DB colors before any script runs
const primaryPalette = generateColorPalette(primaryColor || "#825BDD");
const secondaryPalette = generateColorPalette(secondaryColor || "#0ea5e9");
const criticalColorVars = [
  ...Object.entries(primaryPalette)
    .filter(([k]) => k !== "DEFAULT" && !Number.isNaN(Number(k)))
    .map(([shade, color]) => "--color-primary-" + shade + ": " + color + ";"),
  ...Object.entries(secondaryPalette)
    .filter(([k]) => k !== "DEFAULT" && !Number.isNaN(Number(k)))
    .map(([shade, color]) => "--color-secondary-" + shade + ": " + color + ";"),
].join("\n");
const criticalColorsCss = ":root {\n  " + criticalColorVars + "\n}";
import "../../styles/global.css"; // Import Tailwind CSS
// import "../../styles/app.css"; // Import Tailwind CSS

import Modal from "../ui/Modal.astro";
import Footer from "./Footer.astro";
import UnifiedNotification from "./UnifiedNotification.astro";
import CookieBanner from "../common/CookieBanner.astro";
import Navbar from "./Navbar.astro";
import Aside from "./Aside.astro";
import TutorialOverlay from "../common/TutorialOverlay.astro";
import DebugPanel from "../common/DebugPanel.astro";
import FeedbackPanel from "../common/FeedbackPanel.astro";
import NotificationsModal from "../common/NotificationsModal.astro";
import UserProfileDropdown from "./UserProfileDropdown.astro";
import StickyActionButton from "../project/StickyActions.astro";
import PunchlistDrawer from "../project/PunchlistDrawer.astro";

// Notification count loader will be loaded via script tag

// Prepare debug data for admin users
const debugData = {
  // Original props
  title,
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  description,
  currentUser,
  session,
  project,
  supabase,
  supabaseUrl,
  projects,
  isBackend,
  id,
  statusData,
  // Derived properties
  isAuth,
  projectId,
  currentUrl,
  // Navigation data
  navigationData,
  desktopNavigationHTML,
  visibleNavItems,
  // Additional context
  astroUrl: Astro.url,
  astroRequest: {
    method: Astro.request.method,
    headers: Object.fromEntries(Astro.request.headers.entries()),
    url: Astro.request.url,
  },
};
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Console suppression MUST run first so it catches all subsequent script output -->
    <script is:inline>
      // Aggressively suppress harmless console errors in development
      (function () {
        const isDev =
          window.location.hostname === "localhost" ||
          window.location.hostname === "127.0.0.1" ||
          window.location.hostname.startsWith("192.168.");

        if (!isDev) return;

        // Suppress Cloudflare cookie warnings and errors
        const originalWarn = console.warn;
        const originalError = console.error;
        const originalLog = console.log;

        // Override console.warn
        console.warn = function (...args) {
          const message = String(args[0] || "");
          const fullMessage = args.join(" ");

          // Suppress Cloudflare cookie warnings
          if (
            message.includes("_cf_bm") ||
            message.includes("__cf_bm") ||
            (fullMessage.includes("Cookie") && fullMessage.includes("rejected")) ||
            fullMessage.includes("invalid domain") ||
            fullMessage.includes("NS_BINDING_ABORTED") ||
            fullMessage.includes("OpaqueResponseBlocking") ||
            fullMessage.includes("Ignoring Event: localhost") ||
            fullMessage.includes("Avatar failed to load") ||
            fullMessage.includes("rate limit")
          ) {
            return; // Silent fail
          }
          originalWarn.apply(console, args);
        };

        // Override console.error
        console.error = function (...args) {
          const message = String(args[0] || "");
          const fullMessage = args.join(" ");

          // Suppress Cloudflare cookie errors
          if (
            message.includes("_cf_bm") ||
            message.includes("__cf_bm") ||
            (fullMessage.includes("Cookie") && fullMessage.includes("rejected")) ||
            fullMessage.includes("invalid domain") ||
            fullMessage.includes("NS_BINDING_ABORTED")
          ) {
            return; // Silent fail
          }
          originalError.apply(console, args);
        };

        // Override console.log to suppress network errors
        console.log = function (...args) {
          // const message = String(args[0] || ""); // Unused
          const fullMessage = args.join(" ");

          if (
            fullMessage.includes("NS_BINDING_ABORTED") ||
            fullMessage.includes("net::ERR_") ||
            fullMessage.includes("_cf_bm") ||
            fullMessage.includes("__cf_bm")
          ) {
            return; // Silent fail
          }
          originalLog.apply(console, args);
        };

        // Suppress unhandled promise rejections for aborted requests
        window.addEventListener("unhandledrejection", function (event) {
          const reason = event.reason;
          const message = reason?.message || String(reason || "");

          if (
            message.includes("aborted") ||
            message.includes("NS_BINDING_ABORTED") ||
            message.includes("AbortError") ||
            reason?.name === "AbortError"
          ) {
            event.preventDefault(); // Prevent console error
            return;
          }
        });

        // Suppress global error events for network errors
        window.addEventListener(
          "error",
          function (event) {
            const message = event.message || "";
            const filename = event.filename || "";
            const target = event.target;

            // Suppress errors related to aborted requests, cookies, or failed image loads
            if (
              message.includes("NS_BINDING_ABORTED") ||
              message.includes("_cf_bm") ||
              message.includes("__cf_bm") ||
              (message.includes("Cookie") && message.includes("rejected")) ||
              (filename.includes("supabase.co") && message.includes("Failed")) ||
              (target &&
                target.tagName === "IMG" &&
                target.src &&
                target.src.includes("supabase.co/storage"))
            ) {
              event.preventDefault();
              event.stopPropagation();
              return false;
            }
          },
          true
        ); // Use capture phase to catch early

        // Intercept fetch to suppress aborted request errors and failed avatar requests
        const originalFetch = window.fetch;
        window.fetch = function (...args) {
          const url = typeof args[0] === "string" ? args[0] : args[0]?.url || "";
          const method = args[1]?.method || "GET";

          // Suppress HEAD requests to Supabase storage avatars (we know they'll fail)
          if (
            method === "HEAD" &&
            url.includes("supabase.co/storage") &&
            url.includes("/avatars/")
          ) {
            return Promise.resolve(new Response(null, { status: 404, statusText: "Not Found" }));
          }

          let fetchPromise = originalFetch.apply(this, args);

          // Wrap to catch and suppress abort errors
          fetchPromise = fetchPromise.catch(function (error) {
            if (
              error?.name === "AbortError" ||
              error?.message?.includes("aborted") ||
              error?.message?.includes("NS_BINDING_ABORTED")
            ) {
              // Return a silent rejection
              return Promise.reject(new Error("Request aborted (suppressed)"));
            }
            throw error;
          });

          // Also suppress 400 responses for avatar images
          fetchPromise = fetchPromise.then(function (response) {
            if (
              !response.ok &&
              response.status === 400 &&
              url.includes("supabase.co/storage") &&
              url.includes("/avatars/")
            ) {
              // Return a silent failure - don't throw, just return a 404-like response
              return new Response(null, { status: 404, statusText: "Not Found" });
            }
            return response;
          });

          return fetchPromise;
        };

        // Intercept XMLHttpRequest to suppress aborted errors and failed avatar requests
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function (...args) {
          this._suppressAbortError = false;
          this._url = args[1]; // Store URL for later check
          return originalXHROpen.apply(this, args);
        };

        XMLHttpRequest.prototype.send = function (...args) {
          const xhr = this;
          const url = xhr._url || "";

          // Suppress 400 errors for avatar images
          const originalOnLoad = xhr.onload;
          xhr.onload = function (event) {
            if (
              xhr.status === 400 &&
              url.includes("supabase.co/storage") &&
              url.includes("/avatars/")
            ) {
              // Silently fail - don't trigger error handlers
              return;
            }
            if (originalOnLoad) {
              originalOnLoad.call(xhr, event);
            }
          };

          const originalOnError = xhr.onerror;
          xhr.onerror = function (event) {
            // Suppress errors for avatar images
            if (url.includes("supabase.co/storage") && url.includes("/avatars/")) {
              return;
            }
            // Suppress aborted errors
            if (xhr.status === 0 && xhr.readyState === 0) {
              // Likely an aborted request
              return;
            }
            if (originalOnError) {
              originalOnError.call(xhr, event);
            }
          };

          return originalXHRSend.apply(this, args);
        };
      })();
    </script>

    <!-- Theme detection - MUST be first to be available for all components -->
    <script is:inline>
      (function() {
        // Initialize dark mode FIRST to prevent flash (IIFE avoids duplicate-declaration if script is inlined twice)
        var hasExplicitPreference = localStorage.getItem("color-theme") !== null;

        function setThemeCookie(theme) {
          document.cookie = "theme=" + theme + "; path=/; max-age=31536000; SameSite=Lax";
          console.log("[THEME-CLIENT] Cookie set to:", theme);
          console.log("[THEME-CLIENT] All cookies:", document.cookie);
          var cookies = document.cookie.split(";").reduce(function(acc, cookie) {
            var parts = cookie.trim().split("=");
            acc[parts[0]] = parts[1];
            return acc;
          }, {});
          console.log("[THEME-CLIENT] Parsed cookies:", cookies);
          console.log("[THEME-CLIENT] Theme cookie value:", cookies.theme);
        }

        if (hasExplicitPreference) {
          var theme = localStorage.getItem("color-theme");
          if (theme === "dark") {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
            setThemeCookie("dark");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
            setThemeCookie("light");
          }
        } else {
          if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "dark");
            setThemeCookie("dark");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "light");
            setThemeCookie("light");
          }
        }

        window.isDarkMode = function() {
          var hasDarkClass = document.documentElement.classList.contains("dark");
          var localStorageTheme = localStorage.getItem("color-theme");
          var systemPrefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
          if (hasDarkClass) return true;
          if (localStorageTheme !== null) return localStorageTheme === "dark";
          return systemPrefersDark;
        };

        window.currentTheme = window.isDarkMode() ? "dark" : "light";

        /* page-size-plugin: must run inline before CSS to avoid FOUC (see src/lib/page-size-plugin.ts) */
        var pageSize = localStorage.getItem("page-size") || "normal";
        document.documentElement.setAttribute("data-page-size", pageSize);

        var ua = navigator.userAgent;
        var isIOS = /iPad|iPhone|iPod/.test(ua);
        var versionMatch = ua.match(/Version\/(\d+)/);
        var major = versionMatch ? parseInt(versionMatch[1], 10) : 0;
        if (isIOS && major > 0 && major < 14) {
          window.__legacySafari = true;
        }
      })();
    </script>

    <!-- Expose for components that run in swapped SPA content (bundled so no 404 on /lib/...) -->
    <script>
      import "../../scripts/init-auth-globals";
    </script>

    <!-- Critical CMS colors (server-rendered) so first paint uses DB colors before any script -->
    <style is:global set:html={criticalColorsCss} />

    <!-- Dynamic Color & Font Injection - MUST run BEFORE CSS is parsed to prevent flash -->
    <script
      is:inline
      define:vars={{
        primaryColor,
        secondaryColor,
        fontFamily,
        secondaryFontFamily,
        globalCompanyName,
      }}
    >
      (function () {
        // Inject colors and font immediately, synchronously BEFORE any CSS is parsed
        const primary = primaryColor || "#825BDD";
        const secondary = secondaryColor || "#0ea5e9";
        const font = fontFamily || "Outfit Variable";
        const secondaryFont = secondaryFontFamily || "sans-serif";

        // Font loading configuration - maps font names to Google Fonts URLs
        const fontConfigs = {
          "Outfit Variable": null, // Loaded via npm package
          Roboto:
            "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap",
          "Open Sans":
            "https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700&display=swap",
          Lato: "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",
          Montserrat:
            "https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap",
          Poppins:
            "https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap",
          Inter: "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap",
          Raleway:
            "https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600;700&display=swap",
          "Source Sans Pro":
            "https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@300;400;600;700&display=swap",
          Nunito:
            "https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap",
          "Playfair Display":
            "https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap",
          Merriweather:
            "https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&display=swap",
          Oswald:
            "https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;600;700&display=swap",
          Lora: "https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap",
          "PT Sans": "https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap",
          Ubuntu: "https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;700&display=swap",
          "Noto Sans":
            "https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400;600;700&display=swap",
          "Work Sans":
            "https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;400;600;700&display=swap",
          "Crimson Text":
            "https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;700&display=swap",
          "Fira Sans":
            "https://fonts.googleapis.com/css2?family=Fira+Sans:wght@300;400;600;700&display=swap",
          "Dancing Script":
            "https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap",
          "Bebas Neue": "https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap",
          Comfortaa:
            "https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;600;700&display=swap",
          Quicksand:
            "https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;600;700&display=swap",
          Rubik: "https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;600;700&display=swap",
          "Josefin Sans":
            "https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600;700&display=swap",
          "Libre Baskerville":
            "https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap",
          Cabin: "https://fonts.googleapis.com/css2?family=Cabin:wght@400;600;700&display=swap",
          Dosis: "https://fonts.googleapis.com/css2?family=Dosis:wght@300;400;600;700&display=swap",
          Arvo: "https://fonts.googleapis.com/css2?family=Arvo:wght@400;700&display=swap",
          "Titillium Web":
            "https://fonts.googleapis.com/css2?family=Titillium+Web:wght@300;400;600;700&display=swap",
          Mukta: "https://fonts.googleapis.com/css2?family=Mukta:wght@300;400;600;700&display=swap",
          Karla: "https://fonts.googleapis.com/css2?family=Karla:wght@300;400;600;700&display=swap",
          Barlow:
            "https://fonts.googleapis.com/css2?family=Barlow:wght@300;400;600;700&display=swap",
          "DM Sans": "https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;700&display=swap",
          Manrope:
            "https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;700&display=swap",
          "Space Grotesk":
            "https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&display=swap",
          "Plus Jakarta Sans":
            "https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;600;700&display=swap",
        };

        // Load font dynamically if not already loaded
        function loadFont(fontName) {
          const url = fontConfigs[fontName];
          if (!url) return; // Skip if no URL (e.g., Outfit Variable loaded via npm)

          // Check if font link already exists
          const existingLink = document.querySelector(`link[href="${url}"]`);
          if (existingLink) {
            console.log("[Font] Already loaded:", fontName);
            return;
          }

          // Create and inject Google Font link
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url;
          link.crossOrigin = "anonymous";
          document.head.appendChild(link);
          console.log("[Font] Loading font:", fontName);
        }

        // Load primary and secondary fonts
        loadFont(font);
        loadFont(secondaryFont);

        // Generate color palettes inline (same algorithm as dynamic-colors.ts)
        function hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0,
            s = 0;
          const l = (max + min) / 2;
          if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                break;
              case g:
                h = ((b - r) / d + 2) / 6;
                break;
              case b:
                h = ((r - g) / d + 4) / 6;
                break;
            }
          }
          return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
        }

        function hslToHex(h, s, l) {
          l /= 100;
          const a = (s * Math.min(l, 1 - l)) / 100;
          const f = (n) => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color)
              .toString(16)
              .padStart(2, "0");
          };
          return `#${f(0)}${f(8)}${f(4)}`;
        }

        function generatePalette(baseColor) {
          if (!baseColor || !baseColor.match(/^#[0-9A-F]{6}$/i)) {
            baseColor = "#3b82f6";
          }
          const [h, s, l] = hexToHsl(baseColor);
          return {
            50: hslToHex(h, Math.max(s - 20, 10), Math.min(l + 45, 95)),
            100: hslToHex(h, Math.max(s - 15, 15), Math.min(l + 40, 90)),
            200: hslToHex(h, Math.max(s - 10, 20), Math.min(l + 30, 85)),
            300: hslToHex(h, Math.max(s - 5, 25), Math.min(l + 20, 75)),
            400: hslToHex(h, s, Math.min(l + 10, 65)),
            500: baseColor,
            600: hslToHex(h, Math.min(s + 5, 90), Math.max(l - 10, 25)),
            700: hslToHex(h, Math.min(s + 10, 95), Math.max(l - 20, 20)),
            800: hslToHex(h, Math.min(s + 15, 100), Math.max(l - 30, 15)),
            900: hslToHex(h, Math.min(s + 20, 100), Math.max(l - 40, 10)),
            950: hslToHex(h, Math.min(s + 25, 100), Math.max(l - 50, 5)),
          };
        }

        // Inject colors IMMEDIATELY - document.documentElement exists even before DOMContentLoaded
        const root = document.documentElement;
        const primaryPalette = generatePalette(primary);
        const secondaryPalette = generatePalette(secondary);

        Object.entries(primaryPalette).forEach(([shade, color]) => {
          root.style.setProperty(`--color-primary-${shade}`, color);
        });

        Object.entries(secondaryPalette).forEach(([shade, color]) => {
          root.style.setProperty(`--color-secondary-${shade}`, color);
        });

        // Inject font families
        root.style.setProperty("--font-family", font);
        root.style.setProperty("--font-family-secondary", secondaryFont);

        console.log("[App] ✅ Dynamic colors and fonts injected immediately:", {
          primary,
          secondary,
          font,
          secondaryFont,
        });
      })();
    </script>

    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="author" content="Tomsens+REKKO" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Preconnect to Google Fonts for better performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <title>
      {(title || Astro.url.pathname.replace(/\//g, " ").trim()) + " → " + globalCompanyName}
    </title>
    <meta name="description" content={description} />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content={primaryColor} />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-project-title" content={globalCompanyName} />
    <meta name="generator" content={Astro.generator} />
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups" />
    <!-- Open Graph / Facebook / iOS Preview -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content={globalCompanyName} />
    <meta property="og:url" content={Astro.url.href} />
    <meta property="og:title" content={(title || "Home") + " → " + globalCompanyName} />
    <meta property="og:description" content={description || globalCompanySlogan || ""} />
    {
      ogImageSrc && (
        <>
          <meta property="og:image" content={ogImageSrc} />
          <meta property="og:image:secure_url" content={ogImageSrc} />
          <meta
            property="og:image:type"
            content={
              ogImageSrc?.includes(".gif")
                ? "image/gif"
                : ogImageSrc?.includes(".svg")
                  ? "image/svg+xml"
                  : ogImageSrc?.includes(".png")
                    ? "image/png"
                    : ogImageSrc?.includes(".jpg") || ogImageSrc?.includes(".jpeg")
                      ? "image/jpeg"
                      : ogImageSrc?.includes(".webp")
                        ? "image/webp"
                        : "image/png"
            }
          />
          <meta property="og:image:width" content="1200" />
          <meta property="og:image:height" content="630" />
          <meta
            property="og:image:alt"
            content={globalCompanyName + " - " + (description || globalCompanySlogan || "")}
          />
        </>
      )
    }

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={(title || "Home") + " → " + globalCompanyName} />
    <meta name="twitter:description" content={description || globalCompanySlogan || ""} />
    {ogImageSrc && <meta name="twitter:image" content={ogImageSrc} />}
    {
      ogImageSrc && (
        <meta
          name="twitter:image:alt"
          content={globalCompanyName + " - " + (description || globalCompanySlogan || "")}
        />
      )
    }

    <!-- iOS / iMessage Preview -->
    <meta name="robots" content="max-image-preview:large" />

    <link rel="canonical" href={Astro.url.href} />
    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
      integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <!-- Favicons and App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href={iconSrc} />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      sizes="32x32"
      href={iconSrc}
    />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      sizes="16x16"
      href={iconSrc}
    />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      href={iconSrc}
    />
    <link rel="manifest" href="/manifest.json" />
    <link rel="mask-icon" href={iconSrc} color="#5bbad5" />
    <meta name="msapplication-TileColor" content={primaryColor} />
    <meta name="theme-color" content={primaryColor} />

    <!-- Custom CSS from CMS Global Settings -->
    {
      customCss && customCss.trim() && (
        <style is:inline set:html={customCss} data-source="cms-custom-css" />
      )
    }

    <script>
      import {
        initializeNotificationCount,
        loadNotificationCount,
        refreshNotificationCount,
        updateNotificationBellCount,
      } from "@/lib/notification-count-loader";

      // Make functions globally available
      (window as any).initializeNotificationCount = initializeNotificationCount;
      (window as any).updateNotificationBellCount = updateNotificationBellCount;
      (window as any).loadNotificationCount = loadNotificationCount;
      (window as any).refreshNotificationCount = refreshNotificationCount;
    </script>

    <!-- Global typewriter: simple (vanilla) + TypeIt-based -->
    <script>
      (function () {
        const DONE_ATTR = "data-typewriter-done";

        function runSimpleTypewriter(
          el: HTMLElement,
          options?: { speed?: number; doneClass?: string; dispatchEvent?: boolean }
        ): void {
          const text = el.getAttribute("data-text");
          if (!text || el.hasAttribute(DONE_ATTR)) return;
          el.setAttribute(DONE_ATTR, "true");
          el.textContent = "";
          const speed = options?.speed ?? 60;
          const doneClass = options?.doneClass ?? "typewriter-complete";
          const dispatchEvent = options?.dispatchEvent ?? false;

          function type(i: number) {
            if (i < text.length) {
              el.textContent += text[i];
              setTimeout(() => type(i + 1), speed);
            } else {
              el.classList.add(doneClass);
              if (dispatchEvent) {
                el.dispatchEvent(new CustomEvent("typewriter-complete", { bubbles: true }));
              }
            }
          }
          type(0);
        }

        function runSimpleTypewriterOnSelector(selector: string): void {
          document.querySelectorAll<HTMLElement>(selector).forEach((el) => runSimpleTypewriter(el));
        }

        (window as any).runSimpleTypewriter = runSimpleTypewriter;
        (window as any).runSimpleTypewriterOnSelector = runSimpleTypewriterOnSelector;

        function initLoadingTypewriters() {
          runSimpleTypewriterOnSelector("[data-loading-typewriter]");
        }
        document.addEventListener("DOMContentLoaded", initLoadingTypewriters);
        document.addEventListener("astro:page-load", initLoadingTypewriters);
        if (document.readyState === "complete" || document.readyState === "interactive") {
          initLoadingTypewriters();
        }
      })();
    </script>
    <script>
      import { initTypewriterTexts, triggerActiveStepTypewriter } from "../../scripts/typewriter-text";
      (window as any).initTypewriterTexts = initTypewriterTexts;
      (window as any).triggerActiveStepTypewriter = triggerActiveStepTypewriter;
    </script>

    <!-- Set global user data for client-side components -->

    <!-- SPA: persist CMS colors for re-apply after client navigation -->
    {isBackend && (
      <>
        <script id="cms-colors" type="application/json" set:html={JSON.stringify({
          primaryColor: primaryColor || "#825BDD",
          secondaryColor: secondaryColor || "#0ea5e9",
          fontFamily: fontFamily || "Outfit Variable",
          secondaryFontFamily: secondaryFontFamily || "sans-serif",
        })} />
        <script is:inline data-astro-rerun>
          document.addEventListener("astro:after-swap", function reapplyCmsColors() {
            const el = document.getElementById("cms-colors");
            if (!el || !el.textContent) return;
            try {
              const cms = JSON.parse(el.textContent);
              const primary = cms.primaryColor || "#825BDD";
              const secondary = cms.secondaryColor || "#0ea5e9";
              const root = document.documentElement;
              function hexToHsl(hex) {
                hex = hex.replace("#", "");
                var r = parseInt(hex.substr(0, 2), 16) / 255, g = parseInt(hex.substr(2, 2), 16) / 255, b = parseInt(hex.substr(4, 2), 16) / 255;
                var max = Math.max(r, g, b), min = Math.min(r, g, b), l = (max + min) / 2, s = 0, h = 0;
                if (max !== min) {
                  var d = max - min;
                  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                  switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
                  h /= 6;
                }
                return [h * 360, s * 100, l * 100];
              }
              function hslToHex(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                var a = s * Math.min(l, 1 - l) / 100;
                var f = function(n) { var k = (n + h / 30) % 12; return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); };
                return "#" + [0, 8, 4].map(function(n) { return Math.round(255 * f(n)).toString(16).padStart(2, "0"); }).join("");
              }
              function palette(base) {
                if (!base || !base.match(/^#[0-9A-F]{6}$/i)) base = "#825BDD";
                var _a = hexToHsl(base), h = _a[0], s = _a[1], l = _a[2];
                return { 50: hslToHex(h, Math.max(s - 20, 10), Math.min(l + 45, 95)), 100: hslToHex(h, Math.max(s - 15, 15), Math.min(l + 40, 90)), 200: hslToHex(h, Math.max(s - 10, 20), Math.min(l + 30, 85)), 300: hslToHex(h, Math.max(s - 5, 25), Math.min(l + 20, 75)), 400: hslToHex(h, s, Math.min(l + 10, 65)), 500: base, 600: hslToHex(h, Math.min(s + 5, 90), Math.max(l - 10, 25)), 700: hslToHex(h, Math.min(s + 10, 95), Math.max(l - 20, 20)), 800: hslToHex(h, Math.min(s + 15, 100), Math.max(l - 30, 15)), 900: hslToHex(h, Math.min(s + 20, 100), Math.max(l - 40, 10)), 950: hslToHex(h, Math.min(s + 25, 100), Math.max(l - 50, 5)) };
              }
              var p = palette(primary), s = palette(secondary);
              Object.keys(p).forEach(function(k) { root.style.setProperty("--color-primary-" + k, p[k]); });
              Object.keys(s).forEach(function(k) { root.style.setProperty("--color-secondary-" + k, s[k]); });
              root.style.setProperty("--font-family", cms.fontFamily || "Outfit Variable");
              root.style.setProperty("--font-family-secondary", cms.secondaryFontFamily || "sans-serif");
            } catch (e) { console.warn("[App] astro:after-swap reapplyCmsColors:", e); }
          });
        </script>
      </>
    )}

    <!-- SPA client-side routing for project/* and admin/* (no full page reload) -->
    {isBackend && <ClientRouter fallback="swap" />}
  </head>

  <body
    class:list={[
      "antialiased",
      // fullscreenScroll && "min-h-dvh flex flex-col",
      // centerContent && "layout-centered",
    ]}
    transition:animate={isBackend ? "none" : undefined}
    data-spa-enabled={isBackend ? "true" : undefined}
    data-spa-path={isBackend ? currentUrl : undefined}
  >

   
    <!-- SPA: re-apply theme and re-init after client-side navigation (backend only) -->
    {isBackend && (
      <script is:inline>
        (function () {
          function applyTheme() {
            if (!document.documentElement) return;
            var theme = localStorage.getItem("color-theme");
            var dark =
              theme === "dark" ||
              (!theme && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches);
            document.documentElement.classList.toggle("dark", dark);
            document.documentElement.classList.toggle("zD1iTsv7EQco3GO_szee", dark);
          }
          applyTheme();
          document.addEventListener("astro:page-load", applyTheme);

          // SPA: reset body scroll state after swap so new page can scroll (avoids stuck overflow:hidden from modals)
          document.addEventListener("astro:after-swap", function resetBodyScrollAfterSwap() {
            var body = document.body;
            var html = document.documentElement;
            body.style.overflow = "";
            body.style.position = "";
            body.style.top = "";
            body.style.width = "";
            html.style.overflow = "";
            body.classList.remove("modal-open");
            if (typeof window.forceUnlockBodyScroll === "function") {
              window.forceUnlockBodyScroll();
            }
          });
        })();
      </script>
    )}


    <!-- SPA debug: log transition lifecycle (localhost or ?debug=spa). Open browser console to trace. -->
    {isBackend && (
      <script is:inline data-astro-rerun>
        (function () {
          var isLocal = typeof window !== "undefined" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1");
          var qs = typeof window !== "undefined" && window.location.search;
          var debugSpa = isLocal || (qs && qs.indexOf("debug=spa") !== -1);
          if (!debugSpa) return;
          var path = typeof window !== "undefined" ? window.location.pathname : "";
          console.log("[SPA] Initial load pathname:", path);
          ["astro:before-preparation", "astro:after-preparation", "astro:page-load", "astro:after-swap"].forEach(function (ev) {
            document.addEventListener(ev, function (e) {
              var d = e.detail || {};
              console.log("[SPA] " + ev, {
                from: d.from,
                to: d.to || (ev === "astro:page-load" || ev === "astro:after-swap" ? window.location.pathname : undefined),
                response: d.response ? (d.response.redirected ? "redirect:" + d.response.url : "status:" + d.response.status) : undefined,
              });
            });
          });
        })();
      </script>
    )}

    <!-- SPA: run backend page inits on navigation (when swapped-in scripts may not run) -->
    {isBackend && (
      <script is:inline>
        (function () {
          function runPageInits() {
            var path = window.location.pathname;
            if (path === '/project/dashboard' && typeof window.__initProjectDashboard === 'function') {
              window.__initProjectDashboard();
            }
            if (path === '/dashboard' && typeof window.__initDashboard === 'function') {
              window.__initDashboard();
            }
            if (path === '/profile' && typeof window.__initProfile === 'function') {
              window.__initProfile();
            }
          }
          document.addEventListener('astro:page-load', runPageInits);
        })();
      </script>
    )}


    <!-- Global Modal Overlay - Single instance used by all modals -->
    <Modal id="global-backdrop" zIndex={1000} blurAmount="lg" opacity="50" />
    <!-- Global Modals - Must be siblings of overlay for z-index to work -->
    <NotificationsModal currentUser={currentUser} />

    <UserProfileDropdown {globalIconButtonClasses} {projects} {currentUser} />
       
    <PunchlistDrawer {globalIconButtonClasses} currentUser={currentUser} supabaseUrl={supabaseUrl} project={project} />
    
    <UnifiedNotification />
    <Navbar
      {globalIconButtonClasses}
      {desktopNavigationHTML}
      {currentUser}
      {session}
      {supabaseUrl}
      {id}
      {projects}
      {isBackend}
      {project}
      pathname={Astro.url.pathname}
      template={layout}
    />

    <div id="page" class="min-w-0 overflow-x-hidden h-full" data-template={layout}
    style={`transition: all 300ms ease-in-out;`}
    >
    <!-- ${centerContent ? 'overscroll-behavior-y: contain;' : ''} -->
    <!-- 'overscroll-behavior-y: contain; touch-action: pan-x;'  -->    
    <Aside
        {globalIconButtonClasses}
        {currentUser}
        {globalInputClasses}
        {primaryTextClasses}
        {projects}
        {mobileNavigationHTML}
      />

      <div
        id="main-content"
        class:list={[
          "flex-1 min-w-0",
          currentUser ? "sm:ml-16" : "",
          layout === "default" ? "min-h-[calc(100dvh-5rem)] px-4 sm:px-6 md:px-8 lg:px-10" : "",
          mainClasses,
          layout === "fullscreen" && "flex flex-col min-h-0",
          layout === "centered" ? "" : "",
          layout === "fullwidth" && "",

        ]}
        style={currentUser ? "" : undefined}
      >
        <main>
          <slot />
        </main>
      
        <TutorialOverlay {currentUser} tutorialId="demo-tour" autoStart={false} {isAuth} />
        <DebugPanel {debugData} {currentRole} />
        <FeedbackPanel {currentUser} />
        {
          layout === "fullscreen" ? (
            <div class="shrink-0">
              <Footer
                {globalIconButtonClasses}
                {globalCompanyName}
                {isBackend}
                {globalCompanyPhone}
                {primaryTextClasses}
                {secondaryTextClasses}
                {globalInputClasses}
              />
            </div>
          ) : (
            <Footer
              {globalIconButtonClasses}
              {globalCompanyName}
              {isBackend}
              {globalCompanyPhone}
              {primaryTextClasses}
              {secondaryTextClasses}
              {globalInputClasses}
            />
          )
        }
      </div>

    
    </div>

  
 





    <StickyActionButton 
    {isAuthPageResult}
    {isContactPageResult}
    {currentUser}
    {isBackend}
    {primaryTextClasses}
    {secondaryTextClasses}
    {globalInputClasses}
    {globalCompanyName}
    {globalCompanyPhone}
    />
    <CookieBanner />

    <!-- Prevent Flowbite from initializing modals that don't exist -->
    <!-- Flowbite JavaScript -->
    <script src="https://unpkg.com/flowbite@2.5.2/dist/flowbite.min.js"></script>

    <script>
      import { getIcon } from "../../lib/simple-icons";
      declare global {
        interface Window {
          // Global functions and utilities (alphabetized)
          acceptProposal?: () => void;
          initInputWithIcon?: (root?: Document | Element) => void;
          addNewLineItem?: () => void;
          camelToProper?: (str: string) => string;
          clipboardData?: any;
          createLineItemRow?: (data: any) => HTMLElement;
          createButtonPartial?: (config: any) => Promise<HTMLElement | null>;
          deleteProject?: (projectId: any) => void;
          getProject?: (projectId: string | number) => Promise<any>;
          handleNewStatusModalAndEmail?: any;
          handleUrlNotification?: (type: string, message: string) => void;
          hideOnFormFocus?: (elementSelector: string, mobileOnly?: boolean) => void;
          hideNotification?: any;
          // UX Utility Functions
          isDarkMode?: () => boolean;
          currentTheme?: "light" | "dark";
          updateThemeSync?: () => "light" | "dark";
          scrollToTopOnMobile?: () => void;
          scrollToTop?: (behavior?: ScrollBehavior) => void;
          isMobile?: () => boolean;
          isTablet?: () => boolean;
          isDesktop?: () => boolean;
          getViewportSize?: () => "mobile" | "tablet" | "desktop";
          debounce?: <T extends (...args: any[]) => any>(func: T, wait: number) => T;
          throttle?: <T extends (...args: any[]) => any>(func: T, limit: number) => T;
          truncateString?: (str: string, maxLength?: number, suffix?: string) => string;
          hideOnMobileInput?: (elementSelector: string) => void;
          isSafariIOS?: () => boolean;
          isSafari?: () => boolean;
          isSafariBeta?: () => boolean;
          isSafari18OrLater?: () => boolean;
          fixSafariViewport?: () => void;
          immediateSafariViewportFix?: () => void;
          setupViewportHandling?: () => void;
          ensureViewportBounds?: (minHeight?: number, maxHeight?: number) => void;
          lockBodyScroll?: () => void;
          unlockBodyScroll?: () => void;
          // Modal system
          showModal?: (options: {
            id?: string;
            title: string;
            body: string | HTMLElement;
            primaryButtonText?: string;
            secondaryButtonText?: string;
            onConfirm?: () => void | Promise<void>;
            onCancel?: () => void;
            showFooter?: boolean;
            size?: "small" | "medium" | "large" | "xlarge";
            closeOnBackdrop?: boolean;
            closeOnEscape?: boolean;
            zIndex?: number;
          }) => void;
          hideModal?: (modalId: string, resetZIndex?: boolean) => void;
          removeModal?: (modalId: string) => void;
          setModalOverlayZIndex?: (zIndex: number) => void;
          resetModalOverlayZIndex?: () => void;
          initializeSubjectEditing?: () => void;
          proposalHelper?: any;
          proposalManager?: any;
          refreshManager?: any;
          requestPushNotificationPermission?: () => void;
          resetForm?: any;
          resetNotifications?: () => void;
          sendEmail?: (emailData: any, currentUser: any) => Promise<any>;
          setPageLoadStatusActionsFromUrl?: any;
          showNotice?: any;
          switchTab?: any;
          toggleCommentForm?: () => void;
          trimText?: (text: string, maxLength?: number, suffix?: string) => string;
          trimWords?: (text: string, wordLimit?: number, suffix?: string) => string;
          // Typewriter (simple + TypeIt)
          runSimpleTypewriter?: (
            el: HTMLElement,
            options?: { speed?: number; doneClass?: string; dispatchEvent?: boolean }
          ) => void;
          runSimpleTypewriterOnSelector?: (selector: string) => void;
          initTypewriterTexts?: () => void;
          triggerActiveStepTypewriter?: () => void;
          // Sticky Actions Portal System
          initializeStickyActionsPortal?: () => void;
          showStickyActions?: (instanceIdOrElement: string | HTMLElement) => void;
          hideStickyActions?: (instanceIdOrElement?: string | HTMLElement) => void;
          updateCountBubble?: (
            parentElement: HTMLElement,
            count: number,
            options?: any
          ) => HTMLElement | null;
          updateProposalTotal?: () => void;
          updateStatus?: (project: any, newStatus: number, statuses?: any) => Promise<any>;
          validateEmail?: (email: string) => string | null;
          COUNT_BUBBLE_PRESETS?: {
            notification: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            punchlist: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            small: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
          };
        }
      }
      // Make data available globally for the proposal functions
      import { setupConsoleInterceptor } from "../../lib/console-interceptor.ts";

      // Setup console interceptor for client-side (filters out image fetch logs)
      setupConsoleInterceptor();

      // Set Stripe publishable key globally for PaymentForm
      (window as any).STRIPE_PUBLISHABLE_KEY = import.meta.env.STRIPE_PUBLISHABLE_KEY;
      console.log("🔧 [STRIPE] Publishable key loaded:", !!(window as any).STRIPE_PUBLISHABLE_KEY);

      // Helper function to create buttons using Button partial
      (window as any).createButtonPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-button-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/button", {
            headers: headers,
          });

          if (response.ok) {
            const buttonHTML = await response.text();
            return buttonHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch button partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating button partial:", error);
          return null;
        }
      };

      (window as any).createSimpleIconPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-icon-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/simple-icon", {
            headers: headers,
          });

          if (response.ok) {
            const iconHTML = await response.text();
            return iconHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch simple-icon partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating simple-icon partial:", error);
          return null;
        }
      };

      // Helper function to create user avatars using UserAvatar partial
      (window as any).createUserAvatarPartial = async function (config: any) {
        try {
          const headers = new Headers();

          // Handle nested user object
          if (config.user) {
            Object.entries(config.user).forEach(([key, value]) => {
              if (value !== undefined && value !== null) {
                headers.set(
                  `x-user-avatar-${key.replace(/([A-Z])/g, "-$1").toLowerCase()}`,
                  value.toString()
                );
              }
            });
          }

          // Handle other config options
          Object.entries(config).forEach(([key, value]) => {
            if (key !== "user" && value !== undefined && value !== null) {
              headers.set(
                `x-user-avatar-${key.replace(/([A-Z])/g, "-$1").toLowerCase()}`,
                value.toString()
              );
            }
          });

          const response = await fetch("/partials/user-avatar", {
            headers: headers,
          });

          if (response.ok) {
            const avatarHTML = await response.text();
            return avatarHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch user-avatar partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating user-avatar partial:", error);
          return null;
        }
      };

      if (!String.prototype.startsWith) {
        console.log("🔧 [POLYFILL] Adding startsWith polyfill...");
        String.prototype.startsWith = function (search: string, pos?: number) {
          return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
        console.log("🔧 [POLYFILL] startsWith polyfill added successfully");
      }

      // Global utility function to convert camelCase to Proper Case
      (window as any).camelToProper = (str: string): string => {
        if (!str) return "";

        // Handle special cases first
        const specialCases: { [key: string]: string } = {
          id: "ID",
          url: "URL",
          api: "API",
          sms: "SMS",
          email: "Email",
          phone: "Phone",
          status: "Status",
          project: "Project",
          user: "User",
          admin: "Admin",
          client: "Client",
          staff: "Staff",
          role: "Role",
          name: "Name",
          title: "Title",
          address: "Address",
          created: "Created",
          updated: "Updated",
          completed: "Completed",
          incomplete: "Incomplete",
          failed: "Failed",
          sent: "Sent",
          received: "Received",
          uploaded: "Uploaded",
          downloaded: "Downloaded",
          added: "Added",
          changed: "Changed",
          login: "Login",
          logout: "Logout",
          registration: "Registration",
          action: "Action",
          event: "Event",
          error: "Error",
          info: "Info",
          system: "System",
          notification: "Notification",
          discussion: "Discussion",
          punchlist: "Punchlist",
          proposal: "Proposal",
          assignment: "Assignment",
          comment: "Comment",
          file: "File",
        };

        // Split camelCase into words
        const words = str
          .replace(/([A-Z])/g, " $1")
          .trim()
          .split(" ");

        // Convert each word to proper case
        const properWords = words.map((word) => {
          const lowerWord = word.toLowerCase();

          // Check special cases first
          if (specialCases[lowerWord]) {
            return specialCases[lowerWord];
          }

          // Default: capitalize first letter
          return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        });

        return properWords.join(" ");
      };

      (window as any).hideNotification = function () {
        console.log("[FALLBACK-NOTIFICATION] Hiding notification");
      };

      // switchTab function is now defined in individual pages that need it
      // This prevents conflicts with page-specific tab switching logic

      (window as any).handleNewStatusModalAndEmail = function (response: any, context: string) {
        if (!response) {
          console.error(`ERROR [${context || "NOTIFICATION"}] API call failed:`, response.error);
          return;
        }

        if (!response.statusData || !(window as any).showNotice) {
          console.warn(
            `WARNING [${context || "NOTIFICATION"}] No notification data or showNotice function available`
          );
          return;
        }

        // Get the current status configuration
        const clientNotification = response.statusData?.client;
        const adminNotification = response.statusData?.admin;
        const currentNotification = response.statusData?.current;
        const currentUser = response.currentUser;

        clientNotification.email.currentUser = currentUser;
        adminNotification.email.currentUser = currentUser;
        // Send email if email configuration exists
        if (clientNotification?.email) {
          (window as any).sendEmail(clientNotification.email);
        }

        if (adminNotification?.email) {
          (window as any).sendEmail(adminNotification.email);
        }

        console.log("currentUser from notice", currentUser);
        if (currentNotification?.modal) {
          const modalData = {
            ...currentNotification.modal,
            redirect: currentNotification.modal.redirect
              ? {
                  url: currentNotification.modal.redirect.url,
                  showCountdown: currentNotification.modal.redirect.showCountdown || true,
                }
              : undefined,
          };
          console.log("🔔 [STATUS-MODAL] Showing modal with data:", modalData);
          (window as any).showNotice(modalData);
        } else {
          console.warn(`WARNING [${context || "NOTIFICATION"}] No notification found in response`);
        }
      };

      /** Focus first focusable input in a container. Call at end of panel animations so mobile keypad opens. */
      (window as any).focusFirstInputIn = function (container: HTMLElement): boolean {
        console.log("[AUTOFOCUS] focusFirstInputIn called", {
          hasContainer: !!container,
          containerTag: container?.tagName,
          containerStep: container?.getAttribute?.("data-step"),
        });
        if (!container || typeof container.querySelector !== "function") {
          console.log("[AUTOFOCUS] early return: no container or no querySelector");
          return false;
        }
        const first = container.querySelector(
          "input:not([type=hidden]):not([readonly]), textarea, select"
        ) as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null;
        console.log("[AUTOFOCUS] first focusable", {
          found: !!first,
          tag: first?.tagName,
          id: first?.id,
          name: (first as HTMLInputElement)?.name,
          type: (first as HTMLInputElement)?.type,
        });
        if (!first || typeof first.focus !== "function") {
          console.log("[AUTOFOCUS] early return: no first element or no focus method");
          return false;
        }
        const isTouch = "ontouchstart" in window;
        console.log("[AUTOFOCUS] focusing", { isTouch, preventScroll: false });
        if (isTouch) {
          first.scrollIntoView({ block: "center", behavior: "auto" });
          console.log("[AUTOFOCUS] touch: scrolled input into view before focus");
        }
        first.focus({ preventScroll: false });
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            const active = document.activeElement === first;
            console.log("[AUTOFOCUS] after rAF x2", { activeElementIsFirst: active });
            if (!active) first.focus({ preventScroll: false });
          });
        });
        if (isTouch) {
          console.log("[AUTOFOCUS] touch device: scheduling focus at 50ms, 300ms, 500ms (mobile keypad)");
          setTimeout(() => {
            first.focus({ preventScroll: false });
            console.log("[AUTOFOCUS] touch focus 50ms", { activeElementIsFirst: document.activeElement === first });
          }, 50);
          setTimeout(() => {
            first.focus({ preventScroll: false });
            console.log("[AUTOFOCUS] touch focus 300ms", { activeElementIsFirst: document.activeElement === first });
          }, 300);
          setTimeout(() => {
            first.focus({ preventScroll: false });
            console.log("[AUTOFOCUS] touch focus 500ms (iOS fallback)", { activeElementIsFirst: document.activeElement === first });
          }, 500);
        }
        console.log("[AUTOFOCUS] done", { activeElement: document.activeElement?.tagName, activeId: (document.activeElement as HTMLElement)?.id });
        return true;
      };

      /**
       * Injects SimpleIcons into elements with class .input-with-icon and data-icon="name".
       * Call with no args to run on the whole document, or pass a container to scope (e.g. after dynamic content).
       */
      (window as any).initInputWithIcon = function (root?: Document | Element) {
        const scope = root || document;
        const inputWrappers = scope.querySelectorAll(".input-with-icon[data-icon]");
        inputWrappers.forEach((wrapper) => {
          const iconName = wrapper.getAttribute("data-icon");
          if (!iconName) return;
          const iconSVG = getIcon(iconName, {
            size: 28,
            className: "text-black dark:text-white",
          });
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = iconSVG;
          const svgElement = tempDiv.firstElementChild as SVGElement;
          if (!svgElement) return;
          svgElement.style.position = "absolute";
          svgElement.style.left = "calc(1rem - 5px)";
          svgElement.style.right = "";
          svgElement.style.top = "50%";
          svgElement.style.transform = "translateY(-50%)";
          svgElement.style.pointerEvents = "none";
          svgElement.style.zIndex = "1";
          svgElement.style.opacity = "0.5";
          svgElement.style.transition = "opacity 0.3s ease";
          const input = wrapper.querySelector("input");
          if (input) {
            input.addEventListener("focus", () => {
              svgElement.style.opacity = "0.7";
            });
            input.addEventListener("blur", () => {
              svgElement.style.opacity = "0.5";
            });
          }
          wrapper.appendChild(svgElement);
        });
      };

      (window as any).hideOnFormFocus = function () {
        // Check if we should only hide on mobile
        // if (!(window as any).isMobile()) return;

        const element = document.querySelectorAll(".hide-on-form-focus");
        if (!element.length) return;

        // Set up CSS transitions for fade effect
        const transitionDuration = 300; // milliseconds
        const blurDelay = 100; // Delay before showing (prevents flash when tabbing between inputs)
        let blurTimeout: ReturnType<typeof setTimeout> | null = null;

        element.forEach((el) => {
          const htmlEl = el as HTMLElement;
          htmlEl.style.transition = `opacity ${transitionDuration}ms ease-in-out`;
          htmlEl.style.opacity = "1";
        });

        // Hide on input focus (fade out)
        const hideOnFocus = () => {
          // Cancel any pending show operation
          if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
          }

          element.forEach((el) => {
            const htmlEl = el as HTMLElement;
            htmlEl.style.opacity = "0";
            // Set visibility hidden after transition completes
            setTimeout(() => {
              htmlEl.style.visibility = "hidden";
            }, transitionDuration);
          });
        };

        // Show on input blur (fade in) - debounced to prevent flash
        const showOnBlur = () => {
          // Delay showing to see if focus moves to another input
          blurTimeout = setTimeout(() => {
            element.forEach((el) => {
              const htmlEl = el as HTMLElement;
              // Set visibility visible first, then fade in
              htmlEl.style.visibility = "visible";
              // Use requestAnimationFrame to ensure visibility is set before opacity change
              requestAnimationFrame(() => {
                htmlEl.style.opacity = "1";
                // Refresh AOS to allow animation when element becomes visible
                setTimeout(() => {
                  // @ts-ignore - AOS loaded from CDN
                  if (typeof AOS !== "undefined" && htmlEl.hasAttribute("data-aos")) {
                    // @ts-ignore
                    AOS.refresh();
                  }
                }, 50);
              });
            });
          }, blurDelay);
        };

        const selector =
          "input, textarea, select, form, .slot-machine-modal, #agent-chat, #agent-messages";
        // Add event listeners to all form inputs
        const inputs = document.querySelectorAll(selector);
        inputs.forEach((input) => {
          input.addEventListener("focus", hideOnFocus);
          input.addEventListener("focus-within", hideOnFocus);
          input.addEventListener("blur", showOnBlur);
        });

        // Also handle dynamically added inputs
        const inputObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newInputs = element.querySelectorAll
                  ? element.querySelectorAll(selector)
                  : [];
                newInputs.forEach((input) => {
                  input.addEventListener("focus", hideOnFocus);
                  input.addEventListener("blur", showOnBlur);
                });
              }
            });
          });
        });

        inputObserver.observe(document.body, { childList: true, subtree: true });

        // Watch for modal visibility changes
        const modalObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "class") {
              const target = mutation.target as HTMLElement;
              // Check if element has modal-related attributes or classes
              if (
                target.hasAttribute("data-modal") ||
                target.id.includes("Modal") ||
                target.id.includes("modal") ||
                target.classList.contains("modal")
              ) {
                const isVisible =
                  target.classList.contains("flex") && !target.classList.contains("hidden");
                if (isVisible) {
                  hideOnFocus();
                } else {
                  showOnBlur();
                }
              }
            }
          });
        });

        // Observe all existing modals and drawers for class changes
        const modals = document.querySelectorAll(
          '[data-modal], [id*="modal" i], [id*="Modal" i], [id*="drawer" i], .modal'
        );
        modals.forEach((modal) => {
          modalObserver.observe(modal, { attributes: true, attributeFilter: ["class"] });
        });

        // Also watch for new modals being added to the DOM
        const newModalObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                // Check if the added node itself is a modal
                if (
                  element.hasAttribute("data-modal") ||
                  element.id.includes("Modal") ||
                  element.id.includes("modal") ||
                  element.classList.contains("modal")
                ) {
                  modalObserver.observe(element, { attributes: true, attributeFilter: ["class"] });
                }
                // Also check for modals within the added node
                const innerModals = element.querySelectorAll
                  ? element.querySelectorAll(
                      '[data-modal], [id*="modal" i], [id*="Modal" i], .modal'
                    )
                  : [];
                innerModals.forEach((modal) => {
                  modalObserver.observe(modal, { attributes: true, attributeFilter: ["class"] });
                });
              }
            });
          });
        });

        newModalObserver.observe(document.body, { childList: true, subtree: true });
      };

      (window as any).sendEmail = async function (emailData: any, currentUser: any) {
        try {
          console.log("📧 [SEND-EMAIL] Received email data:", emailData);
          console.log("📧 [SEND-EMAIL] usersToNotify:", emailData.usersToNotify);
          console.log("📧 [SEND-EMAIL] method:", emailData.method);

          // Transform the email data to match the update-delivery API structure
          const transformedData = {
            usersToNotify: emailData.usersToNotify || [],
            method: emailData.method || "email",
            emailSubject: emailData.emailSubject || "Project Update",
            emailContent: emailData.emailContent || "Project status has been updated",
            buttonLink: emailData.buttonLink,
            buttonText: emailData.buttonText,
            project: emailData.project || {},
            currentUser: currentUser,
          };

          console.log("📧 [SEND-EMAIL] Sending email with transformed data:", transformedData);

          const response = await fetch("/api/delivery/update-delivery", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(transformedData),
          });

          const result = await response.json();
          console.log("📧 [SEND-EMAIL] Email response:", result);
          return result;
        } catch (error: any) {
          console.error("Global sendEmail error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).getProject = async function (projectId: string | number) {
        const projectResponse = await fetch(`/api/get-project?id=${projectId}`);
        if (projectResponse.ok) {
          return await projectResponse.json();
        } else {
          throw new Error("Failed to fetch project");
        }
      };

      let isDeleting = false; // Flag to prevent multiple delete operations
      (window as any).deleteProject = async function (projectId: any) {
        // Prevent multiple delete operations
        if (isDeleting) {
          console.log("Delete operation already in progress, ignoring request");
          return;
        }

        // Validate project ID - ensure it's a string
        console.log("🔧 [DELETE] projectId type:", typeof projectId, "value:", projectId);
        const projectIdStr = String(projectId);
        console.log("🔧 [DELETE] projectIdStr:", projectIdStr);
        if (!projectId || projectIdStr.startsWith("new-project-")) {
          if ((window as any).showNotice) {
            (window as any).showNotice(
              "error",
              "Delete Failed",
              "Cannot delete a new project that hasn't been saved yet.",
              5000
            );
          }
          return;
        }

        // Fetch project details for confirmation message
        let projectName = "this project";
        try {
          const project = await (window as any).getProject(projectId);
          if (project) {
            projectName = project.title || project.address || "this project";
          }
        } catch (error) {
          console.error("Failed to fetch project for delete confirmation:", error);
        }

        // Show confirmation modal with action buttons
        if ((window as any).showNotice) {
          (window as any).showNotice(
            "error",
            `Delete ${projectName}?`,
            `Are you sure you want to delete ${projectName}? This action cannot be undone.`,
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                variant: "link",
                fullWidth: true,
                action: () => {},
              },
              {
                label: "Yes",
                variant: "secondary",
                fullWidth: true,
                action: () => {
                  // Set deleting flag to prevent multiple operations
                  isDeleting = true;

                  // Show loading state
                  const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
                  deleteBtn?.setAttribute("data-loading", "true");
                  if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML =
                      '<SimpleIcon name="loader-2" class="animate-spin mr-1" />Deleting...';
                  }

                  // Make API call to delete project
                  console.log("Sending delete request for project:", projectId);
                  fetch(`/api/projects/delete`, {
                    method: "DELETE",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ projectId }),
                  })
                    .then(async (response) => {
                      const data = await response.json();

                      if (!response.ok) {
                        throw new Error(data.error || "Failed to delete project");
                      }

                      // Show success modal
                      if ((window as any).showNotice) {
                        (window as any).showNotice(
                          "success",
                          "Project Deleted!",
                          data.message || "Project has been deleted successfully.",
                          1500
                        );
                      }

                      // Reset deleting flag
                      isDeleting = false;

                      document
                        .querySelectorAll("[data-project-id='" + projectId + "']")
                        ?.forEach((element) => {
                          element.remove();
                        });
                    })
                    .catch((error) => {
                      console.error("Error deleting project:", error);

                      // Show error modal with specific error message
                      if ((window as any).showNotice) {
                        (window as any).showNotice(
                          "error",
                          "Delete Failed",
                          error.message || "Failed to delete project. Please try again.",
                          6000000
                        );
                      }

                      // Reset deleting flag and button state
                      isDeleting = false;
                      if (deleteBtn) {
                        deleteBtn.disabled = false;
                        deleteBtn.innerHTML =
                          '<SimpleIcon name="trash-2" class="mr-1" />Delete Project';
                      }
                    });
                },
              },
            ]
          );
        }
      };

      (window as any).updateStatus = async function (
        project: any,
        status: number,
        currentStatusData?: any
      ) {
        try {
          // If project exists, use it; otherwise fetch it
          let currentProject = project;
          if (!currentProject) {
            try {
              currentProject = await (window as any).getProject(project);
            } catch (error) {
              console.error(
                "📊 [UPDATE-STATUS] Could not fetch project, using minimal object:",
                error
              );
              currentProject = {
                id: project.id,
                status: 0,
              };
            }
          }

          const response = await fetch("/api/status/upsert", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              currentProject,
              newStatus: status,
              currentStatusData: currentStatusData || null, // Pass the current status data
            }),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global updateStatus error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).updateCountBubble = function (
        parentElement: HTMLElement,
        count: number,
        options: any = {}
      ) {
        if (!parentElement) {
          console.warn("🔍 [COUNT-BUBBLE] Parent element is null or undefined");
          return null;
        }

        const config = {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          parentClasses: "relative",
          maxCount: 99,
          showZero: false,
          ...options,
        };

        // Find existing bubble or create new one
        let countBubble = parentElement.querySelector(".count-bubble") as HTMLSpanElement;

        if (count > 0 || config.showZero) {
          // Create bubble if it doesn't exist
          if (!countBubble) {
            countBubble = document.createElement("span");
            countBubble.className = `count-bubble ${config.bubbleClasses}`;

            // Add parent classes if specified
            if (config.parentClasses) {
              parentElement.classList.add(...config.parentClasses.split(" "));
            }

            parentElement.appendChild(countBubble);
            console.log("🔍 [COUNT-BUBBLE] Created new bubble for element:", parentElement);
          }

          // Update bubble content and visibility
          const displayCount = count > config.maxCount ? `${config.maxCount}+` : count.toString();
          countBubble.textContent = displayCount;
          countBubble.style.display = "flex";

          // Update data attribute for accessibility
          parentElement.setAttribute("data-count", count.toString());
        } else {
          // Hide bubble when count is 0 (unless showZero is true)
          if (countBubble) {
            countBubble.style.display = "none";
            parentElement.removeAttribute("data-count");
            console.log("🔍 [COUNT-BUBBLE] Hidden bubble (count is 0)");
          }
        }

        return countBubble;
      };

      // Count bubble presets - single source of truth
      (window as any).COUNT_BUBBLE_PRESETS = {
        default: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        notification: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-600 animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        small: {
          bubbleClasses:
            "absolute -right-1 -top-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 9,
          showZero: false,
        },
      };

      // String utility functions
      (window as any).unslugify = function (slug: string): string {
        return (
          slug
            .split("/")
            .filter(Boolean)
            .pop() // Get last segment
            ?.split("-")
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ") || "Home"
        );
      };

      // ===== UX UTILITY FUNCTIONS =====

      // Scroll utilities
      (window as any).scrollToTopOnMobile = function () {
        if (window.innerWidth < 768) {
          console.log("📱 [UX-UTILS] Scrolling to top on mobile device");
          (window as any).scrollTo({ top: 0, behavior: "smooth" });
        }
      };

      (window as any).scrollToTop = function (behavior = "smooth") {
        console.log("📱 [UX-UTILS] Scrolling to top");
        (window as any).scrollTo({ top: 0, behavior });
      };

      // Device detection
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };

      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };

      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).getViewportSize = function () {
        if (window.innerWidth < 768) return "mobile";
        if (window.innerWidth < 1024) return "tablet";
        return "desktop";
      };

      // Utility functions
      (window as any).debounce = function (func: any, wait: any) {
        let timeout: any;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      (window as any).throttle = function (func: any, limit: any) {
        let inThrottle: any;
        return function executedFunction(this: any, ...args: any[]) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // String utilities
      (window as any).truncateString = function (
        str: string,
        maxLength: number = 30,
        suffix: string = "..."
      ) {
        if (!str) return "";
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).validateEmail = function (email: string): string | null {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) ? null : "Invalid email format";
      };

      (window as any).isSafariBeta = function () {
        const ua = navigator.userAgent;
        // Check if iOS device
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        // Extract Safari version
        const versionMatch = ua.match(/Version\/(\d+)\./);
        const safariVersion = versionMatch ? parseInt(versionMatch[1]) : null;
        // Check if Safari (not Chrome/Firefox/Edge)
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        // Updated to handle beta 26 and later
        const isBetaVersion = safariVersion && safariVersion >= 18 && safariVersion <= 30;
        const result = isIOS && isSafari && isBetaVersion;

        return result;
      };
      (window as any).isSafariIOS = function () {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        return isIOS && isSafari;
      };
      (window as any).isSafari = function () {
        const ua = navigator.userAgent;
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
      };
      (window as any).isSafari18OrLater = function () {
        const ua = navigator.userAgent;
        const safariMatch = ua.match(/Version\/(\d+)/);
        if (!safariMatch) return false;
        const version = parseInt(safariMatch[1]);
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua) && version >= 18;
      };
      (window as any).fixSafariViewport = function () {
        if ((window as any).isSafariIOS()) {
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", vh + "px");
        }
      };
      (window as any).immediateSafariViewportFix = function () {
        if ((window as any).isSafariIOS()) {
          const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
          };
          setViewportHeight();
          window.addEventListener("orientationchange", () => setTimeout(setViewportHeight, 100));
          window.addEventListener("resize", setViewportHeight);
        }
      };
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };
      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };
      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).setupViewportHandling = function () {
        (window as any).immediateSafariViewportFix();
      };

      (window as any).ensureViewportBounds = function (minHeight = 400, maxHeight = 1200) {
        const currentHeight = window.innerHeight;
        if (currentHeight < minHeight || currentHeight > maxHeight) {
          if ((window as any).showNotice) {
            (window as any).showNotice(
              "warning",
              "Viewport Issue",
              `Viewport height (${currentHeight}px) is outside recommended bounds (${minHeight}-${maxHeight}px)`,
              5000
            );
          }
        }
      };

      // Body scroll utilities
      (window as any).lockBodyScroll = function () {
        document.body.style.overflow = "hidden";
      };

      (window as any).unlockBodyScroll = function () {
        document.body.style.overflow = "";
      };

      /**
       * Handles URL parameter notifications (errors and success messages)
       * @param type - Notification type ('error' | 'success')
       * @param param - URL parameter value
       */
      (window as any).handleUrlNotification = function (
        type: "error" | "success",
        param: string
      ): void {
        const companyName = (window as any).globalCompanyName || "the company";
        const notifications = {
          // Error notifications
          error: {
            oauth_failed: {
              title: "Authentication Failed",
              message: "OAuth authentication failed. Please try again.",
            },
            verification_failed: {
              title: "Verification Failed",
              message: "Email verification failed. Please try again.",
            },
            verification_expired: {
              title: "Link Expired",
              message: "Verification link has expired. Please request a new one.",
            },
            verification_invalid: {
              title: "Invalid Link",
              message: "Invalid verification link.",
            },
            verification_error: {
              title: "Verification Error",
              message: "An error occurred during verification.",
            },
            no_token: {
              title: "Invalid Token",
              message: "Invalid or missing verification token.",
            },
            no_user: { title: "User Not Found", message: "User not found." },
            invalid_credentials: {
              title: "Invalid Credentials",
              message: "Invalid email or password.",
            },
            email_exists: {
              title: "Account Exists",
              message: "An account with this email already exists.",
            },
            weak_password: {
              title: "Weak Password",
              message: "Password must be at least 6 characters long.",
            },
            invalid_email: {
              title: "Invalid Email",
              message: "Please enter a valid email address.",
            },
            sms_missing_fields: {
              title: "SMS Error",
              message: "Please fill in all required fields for SMS.",
            },
            sms_invalid_phone: {
              title: "Invalid Phone",
              message: "Please enter a valid 10-digit phone number.",
            },
            sms_invalid_carrier: {
              title: "Invalid Carrier",
              message: "Please select a valid carrier.",
            },
            sms_send_failed: {
              title: "SMS Failed",
              message: "Failed to send SMS. Please try again.",
            },
            sms_email_error: {
              title: "Service Error",
              message: "Email service error. Please try again later.",
            },
            sms_unexpected_error: {
              title: "SMS Error",
              message: "An unexpected error occurred while sending SMS.",
            },
            bad_oauth_state: {
              title: "Sign-in link expired",
              message: "The sign-in link has expired. Please try again from the login page.",
            },
            invalid_request: {
              title: "Request expired",
              message: "The request has expired or is invalid. Please try again.",
            },
            default: { title: "Error", message: "An error occurred. Please try again." },
          },
          // Success notifications
          success: {
            registration_success: {
              title: "Account Created",
              message: "Registration successful! Please check your email to verify your account.",
            },
            verification_success: {
              title: "Email Verified",
              message: "Email verified successfully! You can now sign in.",
            },
            welcome: {
              title: "Welcome!",
              message: "Welcome! Your account has been verified and you're now signed in.",
            },
            logout_success: {
              title: "Signed Out",
              message: "You have been successfully signed out.",
              // redirect: { url: "/", delay: 3500, showCountdown: true },
            },
            sms_sent_success: {
              title: "Message Sent",
              message: `Your message has been sent to ${companyName} successfully.`,
            },
            // oauth_success: {
            //   title: "OAuth Success",
            //   message: `Your OAuth login has been successful.`,
            // },
            default: { title: "Success!", message: param },
          },
        };

        const notification = (notifications[type] as any)[param] || notifications[type].default;

        if ((window as any).showNotice) {
          // Use global UX utility function for mobile scroll
          (window as any).scrollToTopOnMobile();

          if (type === "error") {
            (window as any).showNotice("error", notification.title, notification.message);
          } else {
            (window as any).showNotice(
              "success",
              notification.title,
              notification.message,
              2500,
              notification.redirect
            );
          }
        } else {
          console.error(`🔔 [${notification.title}] ${notification.message}`);
          console.error("🔔 showNotice is not available - notification system not initialized");
        }
      };

      // ===== END GLOBAL FUNCTIONS =====

      // Setup console interceptor (disables console.log in production)
      // setupConsoleInterceptor();

      // // Handle URL parameter notifications (errors and success messages)
      (window as any).processUrlNotifications = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const errorParam = urlParams.get("error");
        const errorCode = urlParams.get("error_code");
        const successParam = urlParams.get("success");
        const messageParam = urlParams.get("message");

        if (errorParam) {
          // Map OAuth error=invalid_request&error_code=bad_oauth_state to toast
          const errorKey =
            errorParam === "invalid_request" && errorCode === "bad_oauth_state"
              ? "bad_oauth_state"
              : errorParam;
          console.log("🔔 [URL-NOTIFICATION] Processing error parameter:", errorKey);
          (window as any).handleUrlNotification("error", errorKey);

          // Clean up URL by removing error params - DELAYED to allow toast to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("error");
            newUrl.searchParams.delete("error_code");
            newUrl.searchParams.delete("error_description");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (successParam) {
          console.log("🔔 [URL-NOTIFICATION] Processing success parameter:", successParam);
          (window as any).handleUrlNotification("success", successParam);

          // Clean up URL by removing the success parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("success");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (messageParam) {
          console.log("🔔 [URL-NOTIFICATION] Processing message parameter:", messageParam);
          (window as any).handleUrlNotification("success", messageParam);

          // Clean up URL by removing the message parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("message");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }
      };

      // // Process URL notifications on page load with retry mechanism
      const processUrlNotificationsWithRetry = (attempts = 0) => {
        if ((window as any).showNotice) {
          // showNotice is available, process notifications
          (window as any).processUrlNotifications();
        } else if (attempts < 10) {
          // showNotice not ready yet, retry after 100ms
          console.log(
            "🔔 [URL-NOTIFICATION] showNotice not ready, retrying... attempt",
            attempts + 1
          );
          setTimeout(() => processUrlNotificationsWithRetry(attempts + 1), 100);
        } else {
          console.error(
            "🔔 [URL-NOTIFICATION] showNotice never became available after 10 attempts"
          );
        }
      };

      document.addEventListener("DOMContentLoaded", () => processUrlNotificationsWithRetry());

      // // Also run immediately in case DOM is already loaded
      if (document.readyState === "loading") {
        // DOM is still loading, event listener will handle it
      } else {
        // DOM is already loaded, run immediately with retry
        processUrlNotificationsWithRetry();
      }

      document.addEventListener("astro:after-swap", () => {
        if ((window as any).initInputWithIcon) (window as any).initInputWithIcon();
      });

      // Suppress ResizeObserver loop warnings (they're usually harmless)
      window.addEventListener("error", (e: any) => {
        if (e.message === "ResizeObserver loop completed with undelivered notifications.") {
          e.stopImmediatePropagation();
        }
      });

      // Register service worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration: any) => {
              console.log("✅ Service Worker registered successfully:", registration.scope);
            })
            .catch((error: any) => {
              console.log("❌ Service Worker registration failed:", error);
            });
        });
      } else {
        console.log("❌ Service Worker not supported in this browser");
      }

      // Global text trimming utilities
      (window as any).trimText = function (
        text: string,
        maxLength: number = 100,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).trimWords = function (
        text: string,
        wordLimit: number = 50,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        const words = text.trim().split(/\s+/);
        if (words.length <= wordLimit) return text;
        return words.slice(0, wordLimit).join(" ") + suffix;
      };

      /**
       * Initialize Sticky Actions Portal System
       * Teleports all StickyActions buttons to a global portal container in App.astro
       * This solves z-index stacking context issues while maintaining form functionality
       */
      (window as any).initializeStickyActionsPortal = function () {
        const portal = document.getElementById("sticky-actions-portal");
        const container = document.getElementById("sticky-actions-container");

        if (!portal || !container) {
          console.warn("🎯 [STICKY-ACTIONS] Portal container not found in App.astro");
          return;
        }

        console.log("🎯 [STICKY-ACTIONS] Initializing portal system...");

        // Find all StickyActions instances
        const stickyActionsInstances = document.querySelectorAll(
          '[class*="sticky-actions"], [data-sticky-actions]'
        );

        if (stickyActionsInstances.length === 0) {
          console.log("🎯 [STICKY-ACTIONS] No instances found on this page");
          return;
        }

        // Track active instance for showing/hiding
        let activeInstance: HTMLElement | null = null;

        stickyActionsInstances.forEach((instance, index) => {
          const instanceEl = instance as HTMLElement;
          const instanceId = instanceEl.id || `sticky-actions-${index}`;
          instanceEl.setAttribute("data-sticky-actions-id", instanceId);

          // Get the columns attribute for grid layout
          const columns = instanceEl.getAttribute("data-columns") || "4";

          // Store original parent for restoration if needed
          const originalParent = instanceEl.parentElement;
          instanceEl.setAttribute("data-original-parent", "true");

          // Get all buttons from this instance
          const buttons = instanceEl.querySelectorAll("button, a[role='button'], [type='submit']");

          if (buttons.length === 0) {
            console.log(`🎯 [STICKY-ACTIONS] Instance ${instanceId} has no buttons to teleport`);
            return;
          }

          console.log(
            `🎯 [STICKY-ACTIONS] Found instance ${instanceId} with ${buttons.length} button(s), columns: ${columns}`
          );

          // Function to show this instance in the portal
          const showInPortal = () => {
            // Hide portal first
            portal.style.display = "none";
            container.innerHTML = "";

            // Set grid columns based on button count
            container.style.gridTemplateColumns = `repeat(${columns}, minmax(0, 1fr))`;

            // Clone buttons and add them to portal
            buttons.forEach((button) => {
              const buttonEl = button as HTMLElement;
              const buttonClone = buttonEl.cloneNode(true) as HTMLElement;

              // If button is in a form, add form attribute to maintain submission
              const form = buttonEl.closest("form");
              if (form && form.id) {
                buttonClone.setAttribute("form", form.id);
                console.log(`🎯 [STICKY-ACTIONS] Linked button to form: ${form.id}`, buttonClone);
              } else if (form && !form.id) {
                // Generate form ID if it doesn't have one
                const formId = `form-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                form.id = formId;
                buttonClone.setAttribute("form", formId);
                console.log(`🎯 [STICKY-ACTIONS] Generated form ID and linked button: ${formId}`);
              }

              // Copy all event listeners by re-executing inline handlers
              const onclickAttr = buttonEl.getAttribute("onclick");
              if (onclickAttr) {
                buttonClone.setAttribute("onclick", onclickAttr);
              }

              // Copy data attributes
              Array.from(buttonEl.attributes).forEach((attr) => {
                if (attr.name.startsWith("data-")) {
                  buttonClone.setAttribute(attr.name, attr.value);
                }
              });

              container.appendChild(buttonClone);
            });

            // Show portal
            portal.style.display = "flex";
            activeInstance = instanceEl;

            console.log(`🎯 [STICKY-ACTIONS] Showing instance ${instanceId} in portal`);
          };

          // Function to hide this instance from portal
          const hideFromPortal = () => {
            if (activeInstance === instanceEl) {
              portal.style.display = "none";
              container.innerHTML = "";
              activeInstance = null;
              console.log(`🎯 [STICKY-ACTIONS] Hiding instance ${instanceId} from portal`);
            }
          };

          // Store functions on the element for external control
          (instanceEl as any).__showInPortal = showInPortal;
          (instanceEl as any).__hideFromPortal = hideFromPortal;

          // Auto-show if instance is visible on page load
          // Use Intersection Observer to detect visibility
          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  // Element is visible, show in portal
                  showInPortal();
                } else {
                  // Element is not visible, hide from portal
                  hideFromPortal();
                }
              });
            },
            {
              threshold: 0.1, // Trigger when 10% visible
              rootMargin: "0px 0px -100px 0px", // Don't trigger if too close to bottom
            }
          );

          observer.observe(instanceEl);

          // Hide the original instance (it's now in the portal)
          instanceEl.style.display = "none";
        });

        // Make portal controls globally available
        (window as any).showStickyActions = function (instanceIdOrElement: string | HTMLElement) {
          const instance =
            typeof instanceIdOrElement === "string"
              ? (document.querySelector(
                  `[data-sticky-actions-id="${instanceIdOrElement}"]`
                ) as HTMLElement)
              : instanceIdOrElement;

          if (instance && (instance as any).__showInPortal) {
            (instance as any).__showInPortal();
          } else {
            console.warn("🎯 [STICKY-ACTIONS] Instance not found:", instanceIdOrElement);
          }
        };

        (window as any).hideStickyActions = function (instanceIdOrElement?: string | HTMLElement) {
          if (!instanceIdOrElement) {
            // Hide all
            portal.style.display = "none";
            container.innerHTML = "";
            return;
          }

          const instance =
            typeof instanceIdOrElement === "string"
              ? (document.querySelector(
                  `[data-sticky-actions-id="${instanceIdOrElement}"]`
                ) as HTMLElement)
              : instanceIdOrElement;

          if (instance && (instance as any).__hideFromPortal) {
            (instance as any).__hideFromPortal();
          }
        };

        console.log(
          `🎯 [STICKY-ACTIONS] Portal initialized with ${stickyActionsInstances.length} instance(s)`
        );
      };

      document.addEventListener("DOMContentLoaded", () => {
        try {
          // Initialize autofill navigation - COMMENTED OUT
          // (window as any).setupAutofillNavigation();

          // Initialize Sticky Actions Portal System
          (window as any).initializeStickyActionsPortal();

          // Inject icons into .input-with-icon[data-icon] (e.g. MultiStepForm)
          if ((window as any).initInputWithIcon) (window as any).initInputWithIcon();

          // Global theme sync utility - updates theme attribute on elements with data-theme-sync
        (window as any).updateThemeSync = () => {
          const isDark = (window as any).isDarkMode();
          const themeValue = isDark ? "dark" : "light";
          (window as any).currentTheme = themeValue; // Keep currentTheme in sync

          // Find all elements with data-theme-sync attribute
          const elements = document.querySelectorAll("[data-theme-sync]");
          elements.forEach((el) => {
            el.setAttribute("theme", themeValue);
          });

          console.log(`[THEME-SYNC] Updated ${elements.length} element(s) to theme: ${themeValue}`);
          return themeValue;
        };

        // Update theme-synced elements initially
        (window as any).updateThemeSync();

        // Watch for theme changes and auto-sync
        const themeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.attributeName === "class") {
              (window as any).updateThemeSync();
            }
          });
        });

        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["class"],
        });

        // Call immediately (skip Safari 18 fixes on legacy iPad/Safari to avoid extra JS)
        const isLegacySafari = (window as any).__legacySafari === true;
        const isSafariBeta = !isLegacySafari && (window as any).isSafariBeta();
        console.log("🍎 [APP] isSafari18", isSafariBeta);
        if (isSafariBeta === true) {
          console.log(
            "🍎 [SAFARI-18-BETA] Applying Safari sticky positioning fixes (lightweight mode)"
          );
          // <!-- Mobile debugging console (Eruda) - only load in development or with ?debug=true -->

          const isDevelopment = import.meta.env.DEV;
          const hasDebugParam = new URLSearchParams(window.location.search).get("debug") === "true";

          if (isDevelopment || hasDebugParam) {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/eruda";
            script.onload = function () {
              if ((window as any).eruda) {
                (window as any).eruda.init();
                console.log("📱 [ERUDA] Mobile debugging console loaded");
              }
            };
            document.body.appendChild(script);
          }

          // Fix 1: Force GPU compositing on all sticky elements
          const stickyElements = document.querySelectorAll(
            '[class*="sticky"], .sticky, [style*="position: sticky"]'
          );
          stickyElements.forEach((el) => {
            const element = el as HTMLElement;
            element.style.transform = "translateZ(0)"; // Force GPU layer
            element.style.willChange = "transform, top, bottom";
            element.style.webkitBackfaceVisibility = "hidden";
            element.style.backfaceVisibility = "hidden";
          });

          // Fix 2: Force repaint on scroll without breaking fixed positioning (e.g. Flowbite dropdowns).
          // Applying transform to body would create a new containing block and make Popper/fixed
          // elements recalculate on scroll; use a reflow read instead.
          let scrollTimeout: number;
          const forceRepaint = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = window.setTimeout(() => {
              void document.body.offsetHeight; // Force reflow / repaint, no style change
            }, 100);
          };

          window.addEventListener("scroll", forceRepaint, { passive: true });

          // Fix 3: Add body class for CSS-based fixes
          // document.body.classList.add("safari-18-fix");

          // Fix 4: Handle header positioning - target the actual navbar
          const navbar = document.querySelector("nav.fixed");
          if (navbar) {
            const navbarElement = navbar as HTMLElement;
            console.log("🍎 [SAFARI-FIX] Found navbar, applying fixes");

            // Force the positioning
            // navbarElement.style.position = "fixed";
            // navbarElement.style.top = "0";
            // navbarElement.style.left = "0";
            // navbarElement.style.right = "0";
            // navbarElement.style.zIndex = "50";
            // navbarElement.style.transform = "translateZ(0)";
            // navbarElement.style.willChange = "transform";
            // navbarElement.style.webkitBackfaceVisibility = "hidden";
            // navbarElement.style.backfaceVisibility = "hidden";

            // Add a class for additional CSS targeting
            // navbarElement.classList.add("safari-sticky-fix");

            console.log("🍎 [SAFARI-FIX] Applied navbar fixes");
          } else {
            console.log('🍎 [SAFARI-FIX] No navbar found with class "fixed"');
          }

          // Fix 5: Handle SpeedDial positioning
          // const speedDial = document.querySelector("[data-speed-dial], .speed-dial");
          // if (speedDial) {
          //   const speedDialElement = speedDial as HTMLElement;
          //   speedDialElement.style.position = "fixed";
          //   speedDialElement.style.bottom = "20px";
          //   speedDialElement.style.right = "20px";
          //   speedDialElement.style.zIndex = "1000";
          //   speedDialElement.style.transform = "translateZ(0)";
          //   speedDialElement.style.willChange = "transform";
          // }

          const safariFixElement = document.querySelector(".safari-18-fix");
          if (safariFixElement) {
            // (safariFixElement as HTMLElement).style.height = "";
            (safariFixElement as HTMLElement).style.overflow = "scroll";
            (safariFixElement as HTMLElement).style.position = "fixed";
            (safariFixElement as HTMLElement).style.top = "0";
            (safariFixElement as HTMLElement).style.bottom = "0";
            (safariFixElement as HTMLElement).style.left = "0";
            (safariFixElement as HTMLElement).style.right = "0";
            (safariFixElement as HTMLElement).style.zIndex = "49";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
            (safariFixElement as HTMLElement).style.willChange = "transform";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
          }

          // Fix 6: Handle viewport height changes
          const handleViewportChange = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
            void document.body.offsetHeight; // Force reflow without breaking fixed positioning
          };

          window.addEventListener("resize", handleViewportChange);
          window.addEventListener("orientationchange", () => {
            setTimeout(handleViewportChange, 100);
          });

          console.log(
            `🍎 [SAFARI-18-BETA] Applied fixes to ${stickyElements.length} sticky elements (scroll triggers preserved)`
          );

          // Additional aggressive fix for navbar after a delay
          setTimeout(() => {
            const navbar = document.querySelector("nav.fixed");
            if (navbar) {
              const navbarElement = navbar as HTMLElement;
              console.log("🍎 [SAFARI-FIX] Re-applying navbar fixes after delay");

              // Force all the styles again
              // navbarElement.style.cssText = `
              //   position: fixed !important;
              //   top: 0 !important;
              //   left: 0 !important;
              //   right: 0 !important;
              //   z-index: 50 !important;
              //   transform: translateZ(0) !important;
              //   will-change: transform !important;
              //   -webkit-backface-visibility: hidden !important;
              //   backface-visibility: hidden !important;
              //       `;

              // Force a reflow
              navbarElement.offsetHeight;

              console.log("🍎 [SAFARI-FIX] Re-applied navbar fixes");
            }
          }, 1000);
        }
        } catch (e) {
          console.error("[APP] DOMContentLoaded error (older Safari/iPad?):", e);
        }
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", async () => {
        (window as any).hideOnFormFocus();

        // Initialize notification count only if user is authenticated
        try {
          const notificationBell = document.getElementById("notification-bell");
          if (
            notificationBell &&
            notificationBell.dataset.userId &&
            (window as any).initializeNotificationCount
          ) {
            console.log(
              "🔔 [APP] Initializing notifications for user:",
              notificationBell.dataset.userId
            );
            await (window as any).initializeNotificationCount();
          } else {
            console.log("🔔 [APP] Skipping notification initialization - no authenticated user");
          }
        } catch (error) {
          console.error("🔔 [APP] Error initializing notification count:", error);
        }
      });
    </script>

    <!-- Global Image Error Handler -->
    <script>
      // Global error handler for broken image URLs (especially Supabase storage)
      document.addEventListener("DOMContentLoaded", () => {
        // Suppress expected console errors in development
        const isDev =
          window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

        // Handle all img elements with error handling
        const images = document.querySelectorAll("img");

        images.forEach((img) => {
          img.addEventListener("error", (event) => {
            const target = event.target as HTMLImageElement;
            const src = target.src;

            // Check if it's a Supabase storage URL that's failing
            if (src && src.includes("supabase.co/storage")) {
              // Only log in production, silent in dev to reduce console noise
              if (!isDev) {
                console.warn("⚠️ [IMAGE-ERROR] Supabase storage image failed to load:", src);
              }

              // Hide the broken image and show a fallback
              target.style.display = "none";

              // Create a fallback element if it doesn't exist
              if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                const fallback = document.createElement("div");
                fallback.className =
                  "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                fallback.style.width = target.style.width || "100%";
                fallback.style.height = target.style.height || "100%";
                fallback.innerHTML = "📷";
                target.parentNode?.insertBefore(fallback, target.nextSibling);
              }
            }
          });
        });

        // Handle dynamically added images
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newImages = element.querySelectorAll("img");
                newImages.forEach((img) => {
                  img.addEventListener("error", (event) => {
                    const target = event.target as HTMLImageElement;
                    const src = target.src;

                    if (src && src.includes("supabase.co/storage")) {
                      console.warn("⚠️ [IMAGE-ERROR] Supabase storage image failed to load:", src);
                      target.style.display = "none";

                      if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                        const fallback = document.createElement("div");
                        fallback.className =
                          "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                        fallback.style.width = target.style.width || "100%";
                        fallback.style.height = target.style.height || "100%";
                        fallback.innerHTML = "📷";
                        target.parentNode?.insertBefore(fallback, target.nextSibling);
                      }
                    }
                  });
                });
              }
            });
          });
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
      });

      // Global error handler for unhandled promise rejections (network errors)
      window.addEventListener("unhandledrejection", (event) => {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("ERR_CONNECTION_CLOSED")
        ) {
          console.warn(
            "⚠️ [NETWORK-ERROR] Connection closed error suppressed:",
            event.reason.message
          );
          event.preventDefault(); // Prevent the error from showing in console
        }
      });

      // Global error handler for general errors
      window.addEventListener("error", (event) => {
        if (event.message && event.message.includes("ERR_CONNECTION_CLOSED")) {
          console.warn("⚠️ [NETWORK-ERROR] Connection closed error suppressed:", event.message);
          event.preventDefault(); // Prevent the error from showing in console
        }
      });
    </script>

    <!-- AOS (Animate On Scroll) - Global initialization -->
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet" />
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js" defer></script>
    <script is:inline>
      // Wait for AOS library to load before initializing
      window.addEventListener("DOMContentLoaded", function () {
        // @ts-ignore - AOS loaded from CDN
        if (typeof AOS !== "undefined") {
          // @ts-ignore
          AOS.init({
            duration: 800,
            easing: "ease-in-out",
            once: true,
            offset: 120,
            delay: 50,
          });
        }
      });
    </script>

    <!-- Custom Scroll Animations (Blur/Scale effects) -->
    <script>
      import "../../scripts/scroll-animations";
    </script>

    <!-- Lazy Loading Images (Global) -->
    <script>
      import "../../scripts/lazy-load-images";
    </script>

    <!-- Global Project Item Handlers (Extracted from ProjectItem.astro for performance) -->
    <script>
      import "../../scripts/project-item-handlers";
    </script>

    <!-- Button Ripple Effects (Focus and Click animations) -->
    <script>
      import "../../scripts/button-ripple";
    </script>

    <!-- Project Refresh Manager (DISABLED - use generic refresh-manager.ts instead) -->
    <!-- <script>
      import "../../lib/project-refresh-manager";
    </script> -->

    <!-- Global Modal System -->
    <script>
      import "../../lib/modal-global";
    </script>

    <!-- Plausible Analytics Script -->
    {plausibleTrackingScript && <Fragment set:html={plausibleTrackingScript} />}
  </body>
</html>
