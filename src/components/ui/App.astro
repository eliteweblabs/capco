---
interface Props {
  title?: string;
  description?: string;
  currentUser?: any;
  session?: any;
  project?: any;
  supabase?: any;
  supabaseUrl?: string;
  projects?: any;
  isBackend?: boolean;
  id?: string;
  primaryTextClasses?: string;
  secondaryTextClasses?: string;
  globalInputClasses?: string;
  year?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  noFooter?: boolean;
  globalCompanyAddress?: string;
  globalCompanyPhone?: string;
  globalCompanyEmail?: string;
  globalCompanyWebsite?: string;
  globalCompanyLogo?: string;
  statusData?: any;
  statusOptions?: Array<{ value: string; label: string }>;
  mainClasses?: string;
  centerContent?: boolean;
  mask?: string;
}

const {
  title = undefined,
  description = undefined,
  currentUser = undefined,
  session = undefined,
  project = undefined,
  supabase = undefined,
  supabaseUrl = undefined,
  projects = undefined,
  id = undefined,

  statusData = undefined,
  statusOptions = undefined,
  mainClasses = "",
  centerContent = false,
  mask = "center",
} = Astro.props;

import { globalCompanyData } from "../../pages/api/global/global-company-data";

const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  primaryColor,
  secondaryColor,
  fontFamily,
  secondaryFontFamily,
  globalCompanyIcon,
  plausibleTrackingScript,
  ogImage,
  socialNetworks,
} = await globalCompanyData();

import { globalClasses } from "../../pages/api/global/global-classes";
const { globalInputClasses, primaryTextClasses, secondaryTextClasses } = globalClasses();

// Get theme from cookie (set by client-side script)
// Note: Cookie is set client-side, so on first load it may not exist yet
const themeCookie = Astro.cookies.get("theme");
const serverTheme = themeCookie?.value || "light"; // Default to light

// Debug logging

// Derived properties (8 props ‚Üí 13 total)
const isAuth = currentUser ? true : false;
// const currentUserId = currentUser?.id || undefined; // Unused
const currentRole = currentUser?.profile?.role || undefined;
const projectId = project?.id || undefined;
const currentUrl = Astro.url.pathname;

// Icon sources - convert SVG to data URI
let iconSrc: string;
if (
  globalCompanyIcon &&
  (globalCompanyIcon.includes("<svg") || globalCompanyIcon.includes("<?xml"))
) {
  const encoded = Buffer.from(globalCompanyIcon).toString("base64");
  iconSrc = `data:image/svg+xml;base64,${encoded}`;
} else {
  iconSrc = globalCompanyIcon || "";
}

// OG Image URL for social sharing - use setting from CMS, with fallback
const ogImageSrc = ogImage || "/videos/CACPCO-share-preview.gif";

// Get navigation data
import { navigation } from "@/pages/api/utils/navigation";
import { isBackendPage } from "../../pages/api/utils/backend-page-check";

const isBackend = isBackendPage(Astro.url.pathname);
const navigationData = await navigation(
  currentUrl,
  isAuth,
  currentRole || "Client",
  isBackend || false
);
const { desktopNavigationHTML, mobileNavigationHTML, visibleNavItems } = navigationData;

import "../../styles/global.css"; // Import Tailwind CSS
// import "../../styles/app.css"; // Import Tailwind CSS

import Preloader from "../common/Preloader.astro";
import Footer from "./Footer.astro";
import UnifiedNotification from "./UnifiedNotification.astro";
import CookieBanner from "../common/CookieBanner.astro";
import SpeedDial from "./SpeedDial.astro";
import Navbar from "./Navbar.astro";
import Aside from "./Aside.astro";
import ScrollProgressIndicator from "./ScrollProgressIndicator.astro";
import TutorialOverlay from "../common/TutorialOverlay.astro";
import DebugPanel from "../common/DebugPanel.astro";
import NotificationDropdown from "../common/NotificationDropdown.astro";
import BannerAlertsLoader from "../../features/banner-alert/components/BannerAlertsLoader.astro";

// Notification count loader will be loaded via script tag

// Prepare debug data for admin users
const debugData = {
  // Original props
  title,
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  description,
  currentUser,
  session,
  project,
  supabase,
  supabaseUrl,
  projects,
  isBackend,
  id,
  statusData,
  // Derived properties
  isAuth,
  projectId,
  currentUrl,
  // Navigation data
  navigationData,
  desktopNavigationHTML,
  visibleNavItems,
  // Additional context
  astroUrl: Astro.url,
  astroRequest: {
    method: Astro.request.method,
    headers: Object.fromEntries(Astro.request.headers.entries()),
    url: Astro.request.url,
  },
};
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Theme detection - MUST be first to be available for all components -->
    <script is:inline>
      // Initialize dark mode FIRST to prevent flash
      const hasExplicitPreference = localStorage.getItem("color-theme") !== null;

      function setThemeCookie(theme) {
        document.cookie = `theme=${theme}; path=/; max-age=31536000; SameSite=Lax`;
        console.log("[THEME-CLIENT] Cookie set to:", theme);
        console.log("[THEME-CLIENT] All cookies:", document.cookie);

        // Verify cookie was set
        const cookies = document.cookie.split(";").reduce((acc, cookie) => {
          const [key, value] = cookie.trim().split("=");
          acc[key] = value;
          return acc;
        }, {});
        console.log("[THEME-CLIENT] Parsed cookies:", cookies);
        console.log("[THEME-CLIENT] Theme cookie value:", cookies.theme);
      }

      if (hasExplicitPreference) {
        // User has explicitly set a preference, apply it
        const theme = localStorage.getItem("color-theme");
        if (theme === "dark") {
          document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
          setThemeCookie("dark");
        } else {
          document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
          setThemeCookie("light");
        }
      } else {
        // No explicit preference, check system preference
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
          document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
          localStorage.setItem("color-theme", "dark");
          setThemeCookie("dark");
        } else {
          document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
          localStorage.setItem("color-theme", "light");
          setThemeCookie("light");
        }
      }

      // Global theme detection utility
      window.isDarkMode = () => {
        const hasDarkClass = document.documentElement.classList.contains("dark");
        const localStorageTheme = localStorage.getItem("color-theme");
        const systemPrefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

        console.log("[THEME-DEBUG] hasDarkClass:", hasDarkClass);
        console.log("[THEME-DEBUG] localStorageTheme:", localStorageTheme);
        console.log("[THEME-DEBUG] systemPrefersDark:", systemPrefersDark);

        // Priority 1: Check DOM class (most reliable)
        if (hasDarkClass) {
          console.log("[THEME-DEBUG] Returning true (dark class found)");
          return true;
        }

        // Priority 2: Check localStorage (user's explicit preference)
        if (localStorageTheme !== null) {
          const isDark = localStorageTheme === "dark";
          console.log("[THEME-DEBUG] Returning localStorage preference:", isDark);
          return isDark;
        }

        // Priority 3: Fall back to system preference (only if no explicit preference)
        const result = systemPrefersDark;
        console.log("[THEME-DEBUG] Returning system preference:", result);
        return result;
      };

      // Set current theme immediately (available ASAP for all components)
      window.currentTheme = window.isDarkMode() ? "dark" : "light";
      console.log("[THEME] window.currentTheme set to:", window.currentTheme);
    </script>

    <!-- Dynamic Color & Font Injection - MUST run BEFORE CSS is parsed to prevent flash -->
    <script
      is:inline
      define:vars={{
        primaryColor,
        secondaryColor,
        fontFamily,
        secondaryFontFamily,
        globalCompanyName,
      }}
    >
      (function () {
        // Inject colors and font immediately, synchronously BEFORE any CSS is parsed
        const primary = primaryColor || "#825BDD";
        const secondary = secondaryColor || "#0ea5e9";
        const font = fontFamily || "Outfit Variable";
        const secondaryFont = secondaryFontFamily || "sans-serif";

        // Font loading configuration - maps font names to Google Fonts URLs
        const fontConfigs = {
          "Outfit Variable": null, // Loaded via npm package
          Roboto:
            "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap",
          "Open Sans":
            "https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700&display=swap",
          Lato: "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",
          Montserrat:
            "https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap",
          Poppins:
            "https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap",
          Inter: "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap",
          Raleway:
            "https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600;700&display=swap",
          "Source Sans Pro":
            "https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@300;400;600;700&display=swap",
          Nunito:
            "https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap",
          "Playfair Display":
            "https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap",
          Merriweather:
            "https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&display=swap",
          Oswald:
            "https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;600;700&display=swap",
          Lora: "https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap",
          "PT Sans": "https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap",
          Ubuntu: "https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;700&display=swap",
          "Noto Sans":
            "https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400;600;700&display=swap",
          "Work Sans":
            "https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;400;600;700&display=swap",
          "Crimson Text":
            "https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;700&display=swap",
          "Fira Sans":
            "https://fonts.googleapis.com/css2?family=Fira+Sans:wght@300;400;600;700&display=swap",
          "Dancing Script":
            "https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap",
          "Bebas Neue": "https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap",
          Comfortaa:
            "https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;600;700&display=swap",
          Quicksand:
            "https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;600;700&display=swap",
          Rubik: "https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;600;700&display=swap",
          "Josefin Sans":
            "https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600;700&display=swap",
          "Libre Baskerville":
            "https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap",
          Cabin: "https://fonts.googleapis.com/css2?family=Cabin:wght@400;600;700&display=swap",
          Dosis: "https://fonts.googleapis.com/css2?family=Dosis:wght@300;400;600;700&display=swap",
          Arvo: "https://fonts.googleapis.com/css2?family=Arvo:wght@400;700&display=swap",
          "Titillium Web":
            "https://fonts.googleapis.com/css2?family=Titillium+Web:wght@300;400;600;700&display=swap",
          Mukta: "https://fonts.googleapis.com/css2?family=Mukta:wght@300;400;600;700&display=swap",
          Karla: "https://fonts.googleapis.com/css2?family=Karla:wght@300;400;600;700&display=swap",
          Barlow:
            "https://fonts.googleapis.com/css2?family=Barlow:wght@300;400;600;700&display=swap",
          "DM Sans": "https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;700&display=swap",
          Manrope:
            "https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;700&display=swap",
          "Space Grotesk":
            "https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&display=swap",
          "Plus Jakarta Sans":
            "https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;600;700&display=swap",
        };

        // Load font dynamically if not already loaded
        function loadFont(fontName) {
          const url = fontConfigs[fontName];
          if (!url) return; // Skip if no URL (e.g., Outfit Variable loaded via npm)

          // Check if font link already exists
          const existingLink = document.querySelector(`link[href="${url}"]`);
          if (existingLink) {
            console.log("[Font] Already loaded:", fontName);
            return;
          }

          // Create and inject Google Font link
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url;
          link.crossOrigin = "anonymous";
          document.head.appendChild(link);
          console.log("[Font] Loading font:", fontName);
        }

        // Load primary and secondary fonts
        loadFont(font);
        loadFont(secondaryFont);

        // Generate color palettes inline (same algorithm as dynamic-colors.ts)
        function hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0,
            s = 0;
          const l = (max + min) / 2;
          if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                break;
              case g:
                h = ((b - r) / d + 2) / 6;
                break;
              case b:
                h = ((r - g) / d + 4) / 6;
                break;
            }
          }
          return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
        }

        function hslToHex(h, s, l) {
          l /= 100;
          const a = (s * Math.min(l, 1 - l)) / 100;
          const f = (n) => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color)
              .toString(16)
              .padStart(2, "0");
          };
          return `#${f(0)}${f(8)}${f(4)}`;
        }

        function generatePalette(baseColor) {
          if (!baseColor || !baseColor.match(/^#[0-9A-F]{6}$/i)) {
            baseColor = "#3b82f6";
          }
          const [h, s, l] = hexToHsl(baseColor);
          return {
            50: hslToHex(h, Math.max(s - 20, 10), Math.min(l + 45, 95)),
            100: hslToHex(h, Math.max(s - 15, 15), Math.min(l + 40, 90)),
            200: hslToHex(h, Math.max(s - 10, 20), Math.min(l + 30, 85)),
            300: hslToHex(h, Math.max(s - 5, 25), Math.min(l + 20, 75)),
            400: hslToHex(h, s, Math.min(l + 10, 65)),
            500: baseColor,
            600: hslToHex(h, Math.min(s + 5, 90), Math.max(l - 10, 25)),
            700: hslToHex(h, Math.min(s + 10, 95), Math.max(l - 20, 20)),
            800: hslToHex(h, Math.min(s + 15, 100), Math.max(l - 30, 15)),
            900: hslToHex(h, Math.min(s + 20, 100), Math.max(l - 40, 10)),
            950: hslToHex(h, Math.min(s + 25, 100), Math.max(l - 50, 5)),
          };
        }

        // Inject colors IMMEDIATELY - document.documentElement exists even before DOMContentLoaded
        const root = document.documentElement;
        const primaryPalette = generatePalette(primary);
        const secondaryPalette = generatePalette(secondary);

        Object.entries(primaryPalette).forEach(([shade, color]) => {
          root.style.setProperty(`--color-primary-${shade}`, color);
        });

        Object.entries(secondaryPalette).forEach(([shade, color]) => {
          root.style.setProperty(`--color-secondary-${shade}`, color);
        });

        // Inject font families
        root.style.setProperty("--font-family", font);
        root.style.setProperty("--font-family-secondary", secondaryFont);

        console.log("[App] ‚úÖ Dynamic colors and fonts injected immediately:", {
          primary,
          secondary,
          font,
          secondaryFont,
        });
      })();
    </script>

    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="author" content="Tomsens+REKKO" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Preconnect to Google Fonts for better performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <title>
      {globalCompanyName + " ‚Üí " + (title || Astro.url.pathname.replace(/\//g, " ").trim())}
    </title>
    <meta name="description" content={description} />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content={primaryColor} />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-project-title" content={globalCompanyName} />
    <meta name="generator" content={Astro.generator} />
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups" />
    <!-- Open Graph / Facebook / iOS Preview -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content={globalCompanyName} />
    <meta property="og:url" content={Astro.url.href} />
    <meta property="og:title" content={(title || "Home") + " ‚Üí " + globalCompanyName} />
    <meta property="og:description" content={description || globalCompanySlogan || ""} />
    {
      ogImageSrc && (
        <>
          <meta property="og:image" content={ogImageSrc} />
          <meta property="og:image:secure_url" content={ogImageSrc} />
          <meta
            property="og:image:type"
            content={
              ogImageSrc?.includes(".gif")
                ? "image/gif"
                : ogImageSrc?.includes(".svg")
                  ? "image/svg+xml"
                  : ogImageSrc?.includes(".png")
                    ? "image/png"
                    : ogImageSrc?.includes(".jpg") || ogImageSrc?.includes(".jpeg")
                      ? "image/jpeg"
                      : ogImageSrc?.includes(".webp")
                        ? "image/webp"
                        : "image/png"
            }
          />
          <meta property="og:image:width" content="1200" />
          <meta property="og:image:height" content="630" />
          <meta
            property="og:image:alt"
            content={globalCompanyName + " - " + (description || globalCompanySlogan || "")}
          />
        </>
      )
    }

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={(title || "Home") + " ‚Üí " + globalCompanyName} />
    <meta name="twitter:description" content={description || globalCompanySlogan || ""} />
    {ogImageSrc && <meta name="twitter:image" content={ogImageSrc} />}
    {
      ogImageSrc && (
        <meta
          name="twitter:image:alt"
          content={globalCompanyName + " - " + (description || globalCompanySlogan || "")}
        />
      )
    }

    <!-- iOS / iMessage Preview -->
    <meta name="robots" content="max-image-preview:large" />

    <link rel="canonical" href={Astro.url.href} />
    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
      integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <!-- Favicons and App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href={iconSrc} />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      sizes="32x32"
      href={iconSrc}
    />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      sizes="16x16"
      href={iconSrc}
    />
    <link
      rel="icon"
      type={globalCompanyIcon?.includes("<svg") || globalCompanyIcon?.includes("<?xml")
        ? "image/svg+xml"
        : "image/png"}
      href={iconSrc}
    />
    <link rel="manifest" href="/manifest.json" />
    <link rel="mask-icon" href={iconSrc} color="#5bbad5" />
    <meta name="msapplication-TileColor" content={primaryColor} />
    <meta name="theme-color" content={primaryColor} />

    <script>
      import {
        initializeNotificationCount,
        loadNotificationCount,
        refreshNotificationCount,
        updateNotificationBellCount,
      } from "@/lib/notification-count-loader";

      // Make functions globally available
      (window as any).initializeNotificationCount = initializeNotificationCount;
      (window as any).updateNotificationBellCount = updateNotificationBellCount;
      (window as any).loadNotificationCount = loadNotificationCount;
      (window as any).refreshNotificationCount = refreshNotificationCount;
    </script>

    <!-- Set global user data for client-side components -->
  </head>

  <body class={`antialiased mask-${mask.trim()}`}>
    <!-- Preloader -->
    <Preloader />
    <ScrollProgressIndicator />

    <Navbar
      {desktopNavigationHTML}
      {currentUser}
      {session}
      {supabaseUrl}
      {id}
      {projects}
      {project}
      {isBackend}
    />

    <div class="flex">
      <Aside
        {currentUser}
        {globalInputClasses}
        {primaryTextClasses}
        {projects}
        {mobileNavigationHTML}
      />

      <div
        id="main-content"
        class=`w-full pt-16 ${mainClasses} ${centerContent ? "" : "overflow-x-hidden"}`
      >
        <main
          class={`flex-1 relative min-h-[calc(100dvh-8rem)] px-4 ${centerContent ? "flex items-center justify-center" : ""}`}
        >
          <slot />
        </main>
        <!-- Bottom Banner Alerts (above footer) -->
        <BannerAlertsLoader position="bottom" />
        <!-- Footer -->
        <Footer {globalCompanyName} {isBackend} {socialNetworks} />
      </div>
    </div>

    <!-- Unified Notification System -->
    <UnifiedNotification />
    <!-- Cookie Banner -->
    <CookieBanner />
    <!-- Speed Dial -->
    <SpeedDial
      currentUser={currentUser || undefined}
      {isBackend}
      {debugData}
      {primaryTextClasses}
      {secondaryTextClasses}
      {globalInputClasses}
    />

    {currentUser && <NotificationDropdown currentUser={currentUser} />}
    <TutorialOverlay {currentUser} tutorialId="demo-tour" autoStart={false} {isAuth} />
    <DebugPanel {currentUser} {debugData} />

    <!-- Prevent Flowbite from initializing modals that don't exist -->
    <script is:inline>
      // Check if notificationsModal exists before Flowbite initializes
      // This prevents errors when the modal is conditionally rendered (e.g., for Client users)
      // Run immediately (script is at end of body, so DOM should be ready)
      (function () {
        function checkAndRemoveModalAttributes() {
          const notificationsModal = document.getElementById("notificationsModal");
          if (!notificationsModal) {
            // Remove data-modal-target and data-modal-toggle attributes from buttons
            // that reference the non-existent modal to prevent Flowbite initialization errors
            const buttons = document.querySelectorAll(
              '[data-modal-target="notificationsModal"], [data-modal-toggle="notificationsModal"]'
            );
            buttons.forEach(function (button) {
              button.removeAttribute("data-modal-target");
              button.removeAttribute("data-modal-toggle");
            });
          }
        }

        // Check immediately (DOM should be ready since script is at end of body)
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", checkAndRemoveModalAttributes);
        } else {
          // DOM is already ready
          checkAndRemoveModalAttributes();
        }
      })();
    </script>

    <!-- Flowbite JavaScript -->
    <script src="https://unpkg.com/flowbite@2.5.2/dist/flowbite.min.js"></script>

    <script>
      declare global {
        interface Window {
          // Global functions and utilities (alphabetized)
          acceptProposal?: () => void;
          addNewLineItem?: () => void;
          camelToProper?: (str: string) => string;
          clipboardData?: any;
          createLineItemRow?: (data: any) => HTMLElement;
          createButtonPartial?: (config: any) => Promise<HTMLElement | null>;
          deleteProject?: (projectId: any) => void;
          getProject?: (projectId: string | number) => Promise<any>;
          handleNewStatusModalAndEmail?: any;
          handleUrlNotification?: (type: string, message: string) => void;
          hideOnFormFocus?: (elementSelector: string, mobileOnly?: boolean) => void;
          hideNotification?: any;
          // UX Utility Functions
          isDarkMode?: () => boolean;
          currentTheme?: "light" | "dark";
          updateThemeSync?: () => "light" | "dark";
          scrollToTopOnMobile?: () => void;
          scrollToTop?: (behavior?: ScrollBehavior) => void;
          isMobile?: () => boolean;
          isTablet?: () => boolean;
          isDesktop?: () => boolean;
          getViewportSize?: () => "mobile" | "tablet" | "desktop";
          debounce?: <T extends (...args: any[]) => any>(func: T, wait: number) => T;
          throttle?: <T extends (...args: any[]) => any>(func: T, limit: number) => T;
          truncateString?: (str: string, maxLength?: number, suffix?: string) => string;
          hideOnMobileInput?: (elementSelector: string) => void;
          isSafariIOS?: () => boolean;
          isSafari?: () => boolean;
          isSafariBeta?: () => boolean;
          isSafari18OrLater?: () => boolean;
          fixSafariViewport?: () => void;
          immediateSafariViewportFix?: () => void;
          setupViewportHandling?: () => void;
          ensureViewportBounds?: (minHeight?: number, maxHeight?: number) => void;
          lockBodyScroll?: () => void;
          unlockBodyScroll?: () => void;
          initializeSubjectEditing?: () => void;
          proposalHelper?: any;
          proposalManager?: any;
          refreshManager?: any;
          requestPushNotificationPermission?: () => void;
          resetForm?: any;
          resetNotifications?: () => void;
          sendEmail?: (emailData: any, currentUser: any) => Promise<any>;
          setPageLoadStatusActionsFromUrl?: any;
          showModal?: any;
          switchTab?: any;
          toggleCommentForm?: () => void;
          trimText?: (text: string, maxLength?: number, suffix?: string) => string;
          trimWords?: (text: string, wordLimit?: number, suffix?: string) => string;
          updateCountBubble?: (
            parentElement: HTMLElement,
            count: number,
            options?: any
          ) => HTMLElement | null;
          updateProposalTotal?: () => void;
          updateStatus?: (project: any, newStatus: number, statuses?: any) => Promise<any>;
          validateEmail?: (email: string) => string | null;
          COUNT_BUBBLE_PRESETS?: {
            notification: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            punchlist: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            small: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
          };
        }
      }
      // Make data available globally for the proposal functions
      import { setupConsoleInterceptor } from "../../lib/console-interceptor.ts";

      // Setup console interceptor for client-side (filters out image fetch logs)
      setupConsoleInterceptor();

      // Set Stripe publishable key globally for PaymentForm
      (window as any).STRIPE_PUBLISHABLE_KEY = import.meta.env.STRIPE_PUBLISHABLE_KEY;
      console.log("üîß [STRIPE] Publishable key loaded:", !!(window as any).STRIPE_PUBLISHABLE_KEY);

      // Helper function to create buttons using Button partial
      (window as any).createButtonPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-button-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/button", {
            headers: headers,
          });

          if (response.ok) {
            const buttonHTML = await response.text();
            return buttonHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch button partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating button partial:", error);
          return null;
        }
      };

      (window as any).createSimpleIconPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-icon-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/simple-icon", {
            headers: headers,
          });

          if (response.ok) {
            const iconHTML = await response.text();
            return iconHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch simple-icon partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating simple-icon partial:", error);
          return null;
        }
      };

      // Helper function to create user avatars using UserAvatar partial
      (window as any).createUserAvatarPartial = async function (config: any) {
        try {
          const headers = new Headers();

          // Handle nested user object
          if (config.user) {
            Object.entries(config.user).forEach(([key, value]) => {
              if (value !== undefined && value !== null) {
                headers.set(
                  `x-user-avatar-${key.replace(/([A-Z])/g, "-$1").toLowerCase()}`,
                  value.toString()
                );
              }
            });
          }

          // Handle other config options
          Object.entries(config).forEach(([key, value]) => {
            if (key !== "user" && value !== undefined && value !== null) {
              headers.set(
                `x-user-avatar-${key.replace(/([A-Z])/g, "-$1").toLowerCase()}`,
                value.toString()
              );
            }
          });

          const response = await fetch("/partials/user-avatar", {
            headers: headers,
          });

          if (response.ok) {
            const avatarHTML = await response.text();
            return avatarHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch user-avatar partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating user-avatar partial:", error);
          return null;
        }
      };

      if (!String.prototype.startsWith) {
        console.log("üîß [POLYFILL] Adding startsWith polyfill...");
        String.prototype.startsWith = function (search: string, pos?: number) {
          return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
        console.log("üîß [POLYFILL] startsWith polyfill added successfully");
      }

      // Global utility function to convert camelCase to Proper Case
      (window as any).camelToProper = (str: string): string => {
        if (!str) return "";

        // Handle special cases first
        const specialCases: { [key: string]: string } = {
          id: "ID",
          url: "URL",
          api: "API",
          sms: "SMS",
          email: "Email",
          phone: "Phone",
          status: "Status",
          project: "Project",
          user: "User",
          admin: "Admin",
          client: "Client",
          staff: "Staff",
          role: "Role",
          name: "Name",
          title: "Title",
          address: "Address",
          created: "Created",
          updated: "Updated",
          completed: "Completed",
          incomplete: "Incomplete",
          failed: "Failed",
          sent: "Sent",
          received: "Received",
          uploaded: "Uploaded",
          downloaded: "Downloaded",
          added: "Added",
          changed: "Changed",
          login: "Login",
          logout: "Logout",
          registration: "Registration",
          action: "Action",
          event: "Event",
          error: "Error",
          info: "Info",
          system: "System",
          notification: "Notification",
          discussion: "Discussion",
          punchlist: "Punchlist",
          proposal: "Proposal",
          assignment: "Assignment",
          comment: "Comment",
          file: "File",
        };

        // Split camelCase into words
        const words = str
          .replace(/([A-Z])/g, " $1")
          .trim()
          .split(" ");

        // Convert each word to proper case
        const properWords = words.map((word) => {
          const lowerWord = word.toLowerCase();

          // Check special cases first
          if (specialCases[lowerWord]) {
            return specialCases[lowerWord];
          }

          // Default: capitalize first letter
          return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        });

        return properWords.join(" ");
      };

      (window as any).hideNotification = function () {
        console.log("[FALLBACK-NOTIFICATION] Hiding notification");
      };

      // switchTab function is now defined in individual pages that need it
      // This prevents conflicts with page-specific tab switching logic

      (window as any).handleNewStatusModalAndEmail = function (response: any, context: string) {
        if (!response) {
          console.error(`ERROR [${context || "NOTIFICATION"}] API call failed:`, response.error);
          return;
        }

        if (!response.statusData || !(window as any).showModal) {
          console.warn(
            `WARNING [${context || "NOTIFICATION"}] No notification data or showModal function available`
          );
          return;
        }

        // Get the current status configuration
        const clientNotification = response.statusData?.client;
        const adminNotification = response.statusData?.admin;
        const currentNotification = response.statusData?.current;
        const currentUser = response.currentUser;

        clientNotification.email.currentUser = currentUser;
        adminNotification.email.currentUser = currentUser;
        // Send email if email configuration exists
        if (clientNotification?.email) {
          (window as any).sendEmail(clientNotification.email);
        }

        if (adminNotification?.email) {
          (window as any).sendEmail(adminNotification.email);
        }

        console.log("currentUser from notice", currentUser);
        if (currentNotification?.modal) {
          const modalData = {
            ...currentNotification.modal,
            redirect: currentNotification.modal.redirect
              ? {
                  url: currentNotification.modal.redirect.url,
                  showCountdown: currentNotification.modal.redirect.showCountdown || true,
                }
              : undefined,
          };
          console.log("üîî [STATUS-MODAL] Showing modal with data:", modalData);
          (window as any).showModal(modalData);
        } else {
          console.warn(`WARNING [${context || "NOTIFICATION"}] No notification found in response`);
        }
      };

      (window as any).hideOnFormFocus = function () {
        // Check if we should only hide on mobile
        // if (!(window as any).isMobile()) return;

        const element = document.querySelectorAll(".hide-on-form-focus");
        if (!element.length) return;

        // Set up CSS transitions for fade effect
        const transitionDuration = 300; // milliseconds
        const blurDelay = 100; // Delay before showing (prevents flash when tabbing between inputs)
        let blurTimeout: ReturnType<typeof setTimeout> | null = null;

        element.forEach((el) => {
          const htmlEl = el as HTMLElement;
          htmlEl.style.transition = `opacity ${transitionDuration}ms ease-in-out`;
          htmlEl.style.opacity = "1";
        });

        // Hide on input focus (fade out)
        const hideOnFocus = () => {
          // Cancel any pending show operation
          if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
          }

          element.forEach((el) => {
            const htmlEl = el as HTMLElement;
            htmlEl.style.opacity = "0";
            // Set visibility hidden after transition completes
            setTimeout(() => {
              htmlEl.style.visibility = "hidden";
            }, transitionDuration);
          });
        };

        // Show on input blur (fade in) - debounced to prevent flash
        const showOnBlur = () => {
          // Delay showing to see if focus moves to another input
          blurTimeout = setTimeout(() => {
            element.forEach((el) => {
              const htmlEl = el as HTMLElement;
              // Set visibility visible first, then fade in
              htmlEl.style.visibility = "visible";
              // Use requestAnimationFrame to ensure visibility is set before opacity change
              requestAnimationFrame(() => {
                htmlEl.style.opacity = "1";
                // Refresh AOS to allow animation when element becomes visible
                setTimeout(() => {
                  // @ts-ignore - AOS loaded from CDN
                  if (typeof AOS !== "undefined" && htmlEl.hasAttribute("data-aos")) {
                    // @ts-ignore
                    AOS.refresh();
                  }
                }, 50);
              });
            });
          }, blurDelay);
        };

        const selector = "input, textarea, select, form, button, label, .slot-machine-modal";
        // Add event listeners to all form inputs
        const inputs = document.querySelectorAll(selector);
        inputs.forEach((input) => {
          input.addEventListener("focus", hideOnFocus);
          input.addEventListener("focus-within", hideOnFocus);
          input.addEventListener("blur", showOnBlur);
        });

        // Also handle dynamically added inputs
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newInputs = element.querySelectorAll
                  ? element.querySelectorAll(selector)
                  : [];
                newInputs.forEach((input) => {
                  input.addEventListener("focus", hideOnFocus);
                  input.addEventListener("blur", showOnBlur);
                });
              }
            });
          });
        });

        observer.observe(document.body, { childList: true, subtree: true });
      };

      (window as any).sendEmail = async function (emailData: any, currentUser: any) {
        try {
          console.log("üìß [SEND-EMAIL] Received email data:", emailData);
          console.log("üìß [SEND-EMAIL] usersToNotify:", emailData.usersToNotify);
          console.log("üìß [SEND-EMAIL] method:", emailData.method);

          // Transform the email data to match the update-delivery API structure
          const transformedData = {
            usersToNotify: emailData.usersToNotify || [],
            method: emailData.method || "email",
            emailSubject: emailData.emailSubject || "Project Update",
            emailContent: emailData.emailContent || "Project status has been updated",
            buttonLink: emailData.buttonLink,
            buttonText: emailData.buttonText,
            project: emailData.project || {},
            currentUser: currentUser,
          };

          console.log("üìß [SEND-EMAIL] Sending email with transformed data:", transformedData);

          const response = await fetch("/api/delivery/update-delivery", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(transformedData),
          });

          const result = await response.json();
          console.log("üìß [SEND-EMAIL] Email response:", result);
          return result;
        } catch (error: any) {
          console.error("Global sendEmail error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).getProject = async function (projectId: string | number) {
        const projectResponse = await fetch(`/api/get-project?id=${projectId}`);
        if (projectResponse.ok) {
          return await projectResponse.json();
        } else {
          throw new Error("Failed to fetch project");
        }
      };

      let isDeleting = false; // Flag to prevent multiple delete operations
      (window as any).deleteProject = function (projectId: any) {
        // Prevent multiple delete operations
        if (isDeleting) {
          console.log("Delete operation already in progress, ignoring request");
          return;
        }

        // Validate project ID - ensure it's a string
        console.log("üîß [DELETE] projectId type:", typeof projectId, "value:", projectId);
        const projectIdStr = String(projectId);
        console.log("üîß [DELETE] projectIdStr:", projectIdStr);
        if (!projectId || projectIdStr.startsWith("new-project-")) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "error",
              "Delete Failed",
              "Cannot delete a new project that hasn't been saved yet.",
              5000
            );
          }
          return;
        }

        // Show confirmation modal with action buttons
        if ((window as any).showModal) {
          (window as any).showModal(
            "error",
            "Delete Project",
            "Are you sure you want to delete this project? This action cannot be undone.",
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                variant: "secondary",
                fullWidth: true,
                action: () => {},
              },
              {
                label: "Delete",
                variant: "danger",
                fullWidth: true,
                action: () => {
                  // Set deleting flag to prevent multiple operations
                  isDeleting = true;

                  // Show loading state
                  const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
                  deleteBtn?.setAttribute("data-loading", "true");
                  if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML =
                      '<SimpleIcon name="loader-2" class="animate-spin mr-1" />Deleting...';
                  }

                  // Make API call to delete project
                  console.log("Sending delete request for project:", projectId);
                  fetch(`/api/projects/delete`, {
                    method: "DELETE",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ projectId }),
                  })
                    .then(async (response) => {
                      const data = await response.json();

                      if (!response.ok) {
                        throw new Error(data.error || "Failed to delete project");
                      }

                      // Show success modal
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "success",
                          "Project Deleted!",
                          data.message || "Project has been deleted successfully.",
                          1500
                        );
                      }

                      // Reset deleting flag
                      isDeleting = false;

                      document
                        .querySelectorAll("[data-project-id='" + projectId + "']")
                        ?.forEach((element) => {
                          element.remove();
                        });
                    })
                    .catch((error) => {
                      console.error("Error deleting project:", error);

                      // Show error modal with specific error message
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "error",
                          "Delete Failed",
                          error.message || "Failed to delete project. Please try again.",
                          6000000
                        );
                      }

                      // Reset deleting flag and button state
                      isDeleting = false;
                      if (deleteBtn) {
                        deleteBtn.disabled = false;
                        deleteBtn.innerHTML =
                          '<SimpleIcon name="trash-2" class="mr-1" />Delete Project';
                      }
                    });
                },
              },
            ]
          );
        }
      };

      (window as any).updateStatus = async function (
        project: any,
        status: number,
        currentStatusData?: any
      ) {
        try {
          // If project exists, use it; otherwise fetch it
          let currentProject = project;
          if (!currentProject) {
            try {
              currentProject = await (window as any).getProject(project);
            } catch (error) {
              console.error(
                "üìä [UPDATE-STATUS] Could not fetch project, using minimal object:",
                error
              );
              currentProject = {
                id: project.id,
                status: 0,
              };
            }
          }

          const response = await fetch("/api/status/upsert", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              currentProject,
              newStatus: status,
              currentStatusData: currentStatusData || null, // Pass the current status data
            }),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global updateStatus error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).updateCountBubble = function (
        parentElement: HTMLElement,
        count: number,
        options: any = {}
      ) {
        if (!parentElement) {
          console.warn("üîç [COUNT-BUBBLE] Parent element is null or undefined");
          return null;
        }

        const config = {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          parentClasses: "relative",
          maxCount: 99,
          showZero: false,
          ...options,
        };

        // Find existing bubble or create new one
        let countBubble = parentElement.querySelector(".count-bubble") as HTMLSpanElement;

        if (count > 0 || config.showZero) {
          // Create bubble if it doesn't exist
          if (!countBubble) {
            countBubble = document.createElement("span");
            countBubble.className = `count-bubble ${config.bubbleClasses}`;

            // Add parent classes if specified
            if (config.parentClasses) {
              parentElement.classList.add(...config.parentClasses.split(" "));
            }

            parentElement.appendChild(countBubble);
            console.log("üîç [COUNT-BUBBLE] Created new bubble for element:", parentElement);
          }

          // Update bubble content and visibility
          const displayCount = count > config.maxCount ? `${config.maxCount}+` : count.toString();
          countBubble.textContent = displayCount;
          countBubble.style.display = "flex";

          // Update data attribute for accessibility
          parentElement.setAttribute("data-count", count.toString());
        } else {
          // Hide bubble when count is 0 (unless showZero is true)
          if (countBubble) {
            countBubble.style.display = "none";
            parentElement.removeAttribute("data-count");
            console.log("üîç [COUNT-BUBBLE] Hidden bubble (count is 0)");
          }
        }

        return countBubble;
      };

      // Count bubble presets - single source of truth
      (window as any).COUNT_BUBBLE_PRESETS = {
        default: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        notification: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-600 animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        small: {
          bubbleClasses:
            "absolute -right-1 -top-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 9,
          showZero: false,
        },
      };

      // String utility functions
      (window as any).unslugify = function (slug: string): string {
        return (
          slug
            .split("/")
            .filter(Boolean)
            .pop() // Get last segment
            ?.split("-")
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ") || "Home"
        );
      };

      // ===== UX UTILITY FUNCTIONS =====

      // Scroll utilities
      (window as any).scrollToTopOnMobile = function () {
        if (window.innerWidth < 768) {
          console.log("üì± [UX-UTILS] Scrolling to top on mobile device");
          (window as any).scrollTo({ top: 0, behavior: "smooth" });
        }
      };

      (window as any).scrollToTop = function (behavior = "smooth") {
        console.log("üì± [UX-UTILS] Scrolling to top");
        (window as any).scrollTo({ top: 0, behavior });
      };

      // Device detection
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };

      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };

      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).getViewportSize = function () {
        if (window.innerWidth < 768) return "mobile";
        if (window.innerWidth < 1024) return "tablet";
        return "desktop";
      };

      // Utility functions
      (window as any).debounce = function (func: any, wait: any) {
        let timeout: any;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      (window as any).throttle = function (func: any, limit: any) {
        let inThrottle: any;
        return function executedFunction(this: any, ...args: any[]) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // String utilities
      (window as any).truncateString = function (
        str: string,
        maxLength: number = 30,
        suffix: string = "..."
      ) {
        if (!str) return "";
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).validateEmail = function (email: string): string | null {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) ? null : "Invalid email format";
      };

      (window as any).isSafariBeta = function () {
        const ua = navigator.userAgent;
        // Check if iOS device
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        // Extract Safari version
        const versionMatch = ua.match(/Version\/(\d+)\./);
        const safariVersion = versionMatch ? parseInt(versionMatch[1]) : null;
        // Check if Safari (not Chrome/Firefox/Edge)
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        // Updated to handle beta 26 and later
        const isBetaVersion = safariVersion && safariVersion >= 18 && safariVersion <= 30;
        const result = isIOS && isSafari && isBetaVersion;

        return result;
      };
      (window as any).isSafariIOS = function () {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        return isIOS && isSafari;
      };
      (window as any).isSafari = function () {
        const ua = navigator.userAgent;
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
      };
      (window as any).isSafari18OrLater = function () {
        const ua = navigator.userAgent;
        const safariMatch = ua.match(/Version\/(\d+)/);
        if (!safariMatch) return false;
        const version = parseInt(safariMatch[1]);
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua) && version >= 18;
      };
      (window as any).fixSafariViewport = function () {
        if ((window as any).isSafariIOS()) {
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", vh + "px");
        }
      };
      (window as any).immediateSafariViewportFix = function () {
        if ((window as any).isSafariIOS()) {
          const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
          };
          setViewportHeight();
          window.addEventListener("orientationchange", () => setTimeout(setViewportHeight, 100));
          window.addEventListener("resize", setViewportHeight);
        }
      };
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };
      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };
      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).setupViewportHandling = function () {
        (window as any).immediateSafariViewportFix();
      };

      (window as any).ensureViewportBounds = function (minHeight = 400, maxHeight = 1200) {
        const currentHeight = window.innerHeight;
        if (currentHeight < minHeight || currentHeight > maxHeight) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "warning",
              "Viewport Issue",
              `Viewport height (${currentHeight}px) is outside recommended bounds (${minHeight}-${maxHeight}px)`,
              5000
            );
          }
        }
      };

      // Body scroll utilities
      (window as any).lockBodyScroll = function () {
        document.body.style.overflow = "hidden";
      };

      (window as any).unlockBodyScroll = function () {
        document.body.style.overflow = "";
      };

      /**
       * Handles URL parameter notifications (errors and success messages)
       * @param type - Notification type ('error' | 'success')
       * @param param - URL parameter value
       */
      (window as any).handleUrlNotification = function (
        type: "error" | "success",
        param: string
      ): void {
        const companyName = (window as any).globalCompanyName || "the company";
        const notifications = {
          // Error notifications
          error: {
            oauth_failed: {
              title: "Authentication Failed",
              message: "OAuth authentication failed. Please try again.",
            },
            verification_failed: {
              title: "Verification Failed",
              message: "Email verification failed. Please try again.",
            },
            verification_expired: {
              title: "Link Expired",
              message: "Verification link has expired. Please request a new one.",
            },
            verification_invalid: {
              title: "Invalid Link",
              message: "Invalid verification link.",
            },
            verification_error: {
              title: "Verification Error",
              message: "An error occurred during verification.",
            },
            no_token: {
              title: "Invalid Token",
              message: "Invalid or missing verification token.",
            },
            no_user: { title: "User Not Found", message: "User not found." },
            invalid_credentials: {
              title: "Invalid Credentials",
              message: "Invalid email or password.",
            },
            email_exists: {
              title: "Account Exists",
              message: "An account with this email already exists.",
            },
            weak_password: {
              title: "Weak Password",
              message: "Password must be at least 6 characters long.",
            },
            invalid_email: {
              title: "Invalid Email",
              message: "Please enter a valid email address.",
            },
            sms_missing_fields: {
              title: "SMS Error",
              message: "Please fill in all required fields for SMS.",
            },
            sms_invalid_phone: {
              title: "Invalid Phone",
              message: "Please enter a valid 10-digit phone number.",
            },
            sms_invalid_carrier: {
              title: "Invalid Carrier",
              message: "Please select a valid carrier.",
            },
            sms_send_failed: {
              title: "SMS Failed",
              message: "Failed to send SMS. Please try again.",
            },
            sms_email_error: {
              title: "Service Error",
              message: "Email service error. Please try again later.",
            },
            sms_unexpected_error: {
              title: "SMS Error",
              message: "An unexpected error occurred while sending SMS.",
            },
            default: { title: "Error", message: "An error occurred. Please try again." },
          },
          // Success notifications
          success: {
            registration_success: {
              title: "Account Created",
              message: "Registration successful! Please check your email to verify your account.",
            },
            verification_success: {
              title: "Email Verified",
              message: "Email verified successfully! You can now sign in.",
            },
            welcome: {
              title: "Welcome!",
              message: "Welcome! Your account has been verified and you're now signed in.",
            },
            logout_success: {
              title: "Signed Out",
              message: "You have been successfully signed out.",
              // redirect: { url: "/", delay: 3500, showCountdown: true },
            },
            sms_sent_success: {
              title: "Message Sent",
              message: `Your message has been sent to ${companyName} successfully.`,
            },
            // oauth_success: {
            //   title: "OAuth Success",
            //   message: `Your OAuth login has been successful.`,
            // },
            default: { title: "Success!", message: param },
          },
        };

        const notification = (notifications[type] as any)[param] || notifications[type].default;

        if ((window as any).showModal) {
          // Use global UX utility function for mobile scroll
          (window as any).scrollToTopOnMobile();

          if (type === "error") {
            (window as any).showModal("error", notification.title, notification.message);
          } else {
            (window as any).showModal(
              "success",
              notification.title,
              notification.message,
              2500,
              notification.redirect
            );
          }
        } else {
          console.error(`üîî [${notification.title}] ${notification.message}`);
          console.error("üîî showModal is not available - notification system not initialized");
        }
      };

      // ===== END GLOBAL FUNCTIONS =====

      // Setup console interceptor (disables console.log in production)
      // setupConsoleInterceptor();

      // // Handle URL parameter notifications (errors and success messages)
      (window as any).processUrlNotifications = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const errorParam = urlParams.get("error");
        const successParam = urlParams.get("success");
        const messageParam = urlParams.get("message");

        if (errorParam) {
          console.log("üîî [URL-NOTIFICATION] Processing error parameter:", errorParam);
          (window as any).handleUrlNotification("error", errorParam);

          // Clean up URL by removing the error parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("error");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (successParam) {
          console.log("üîî [URL-NOTIFICATION] Processing success parameter:", successParam);
          (window as any).handleUrlNotification("success", successParam);

          // Clean up URL by removing the success parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("success");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (messageParam) {
          console.log("üîî [URL-NOTIFICATION] Processing message parameter:", messageParam);
          (window as any).handleUrlNotification("success", messageParam);

          // Clean up URL by removing the message parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("message");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }
      };

      // // Process URL notifications on page load with retry mechanism
      const processUrlNotificationsWithRetry = (attempts = 0) => {
        if ((window as any).showModal) {
          // showModal is available, process notifications
          (window as any).processUrlNotifications();
        } else if (attempts < 10) {
          // showModal not ready yet, retry after 100ms
          console.log(
            "üîî [URL-NOTIFICATION] showModal not ready, retrying... attempt",
            attempts + 1
          );
          setTimeout(() => processUrlNotificationsWithRetry(attempts + 1), 100);
        } else {
          console.error("üîî [URL-NOTIFICATION] showModal never became available after 10 attempts");
        }
      };

      document.addEventListener("DOMContentLoaded", () => processUrlNotificationsWithRetry());

      // // Also run immediately in case DOM is already loaded
      if (document.readyState === "loading") {
        // DOM is still loading, event listener will handle it
      } else {
        // DOM is already loaded, run immediately with retry
        processUrlNotificationsWithRetry();
      }

      // Suppress ResizeObserver loop warnings (they're usually harmless)
      window.addEventListener("error", (e: any) => {
        if (e.message === "ResizeObserver loop completed with undelivered notifications.") {
          e.stopImmediatePropagation();
        }
      });

      // Register service worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration: any) => {
              console.log("‚úÖ Service Worker registered successfully:", registration.scope);
            })
            .catch((error: any) => {
              console.log("‚ùå Service Worker registration failed:", error);
            });
        });
      } else {
        console.log("‚ùå Service Worker not supported in this browser");
      }

      // Global text trimming utilities
      (window as any).trimText = function (
        text: string,
        maxLength: number = 100,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).trimWords = function (
        text: string,
        wordLimit: number = 50,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        const words = text.trim().split(/\s+/);
        if (words.length <= wordLimit) return text;
        return words.slice(0, wordLimit).join(" ") + suffix;
      };

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize autofill navigation - COMMENTED OUT
        // (window as any).setupAutofillNavigation();

        // Global theme sync utility - updates theme attribute on elements with data-theme-sync
        (window as any).updateThemeSync = () => {
          const isDark = (window as any).isDarkMode();
          const themeValue = isDark ? "dark" : "light";
          (window as any).currentTheme = themeValue; // Keep currentTheme in sync

          // Find all elements with data-theme-sync attribute
          const elements = document.querySelectorAll("[data-theme-sync]");
          elements.forEach((el) => {
            el.setAttribute("theme", themeValue);
          });

          console.log(`[THEME-SYNC] Updated ${elements.length} element(s) to theme: ${themeValue}`);
          return themeValue;
        };

        // Update theme-synced elements initially
        (window as any).updateThemeSync();

        // Watch for theme changes and auto-sync
        const themeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.attributeName === "class") {
              (window as any).updateThemeSync();
            }
          });
        });

        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["class"],
        });

        // Call immediately
        const isSafariBeta = (window as any).isSafariBeta();
        console.log("üçé [APP] isSafari18", isSafariBeta);
        if (isSafariBeta === true) {
          console.log(
            "üçé [SAFARI-18-BETA] Applying Safari sticky positioning fixes (lightweight mode)"
          );
          // <!-- Mobile debugging console (Eruda) - only load in development or with ?debug=true -->

          const isDevelopment = import.meta.env.DEV;
          const hasDebugParam = new URLSearchParams(window.location.search).get("debug") === "true";

          if (isDevelopment || hasDebugParam) {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/eruda";
            script.onload = function () {
              if ((window as any).eruda) {
                (window as any).eruda.init();
                console.log("üì± [ERUDA] Mobile debugging console loaded");
              }
            };
            document.body.appendChild(script);
          }

          // Fix 1: Force GPU compositing on all sticky elements
          const stickyElements = document.querySelectorAll(
            '[class*="sticky"], .sticky, [style*="position: sticky"]'
          );
          stickyElements.forEach((el) => {
            const element = el as HTMLElement;
            element.style.transform = "translateZ(0)"; // Force GPU layer
            element.style.willChange = "transform, top, bottom";
            element.style.webkitBackfaceVisibility = "hidden";
            element.style.backfaceVisibility = "hidden";
          });

          // Fix 2: Force repaint on scroll (lightweight - doesn't break scroll triggers)
          let scrollTimeout: number;
          const forceRepaint = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = window.setTimeout(() => {
              // Trigger a minimal repaint without changing layout
              document.body.style.transform = "translateZ(0)";
              requestAnimationFrame(() => {
                document.body.style.transform = "";
              });
            }, 100);
          };

          window.addEventListener("scroll", forceRepaint, { passive: true });

          // Fix 3: Add body class for CSS-based fixes
          // document.body.classList.add("safari-18-fix");

          // Fix 4: Handle header positioning - target the actual navbar
          const navbar = document.querySelector("nav.fixed");
          if (navbar) {
            const navbarElement = navbar as HTMLElement;
            console.log("üçé [SAFARI-FIX] Found navbar, applying fixes");

            // Force the positioning
            navbarElement.style.position = "fixed";
            navbarElement.style.top = "0";
            navbarElement.style.left = "0";
            navbarElement.style.right = "0";
            navbarElement.style.zIndex = "50";
            navbarElement.style.transform = "translateZ(0)";
            navbarElement.style.willChange = "transform";
            navbarElement.style.webkitBackfaceVisibility = "hidden";
            navbarElement.style.backfaceVisibility = "hidden";

            // Add a class for additional CSS targeting
            navbarElement.classList.add("safari-sticky-fix");

            console.log("üçé [SAFARI-FIX] Applied navbar fixes");
          } else {
            console.log('üçé [SAFARI-FIX] No navbar found with class "fixed"');
          }

          // Fix 5: Handle SpeedDial positioning
          const speedDial = document.querySelector("[data-speed-dial], .speed-dial");
          if (speedDial) {
            const speedDialElement = speedDial as HTMLElement;
            speedDialElement.style.position = "fixed";
            speedDialElement.style.bottom = "20px";
            speedDialElement.style.right = "20px";
            speedDialElement.style.zIndex = "1000";
            speedDialElement.style.transform = "translateZ(0)";
            speedDialElement.style.willChange = "transform";
          }
          const safariFixElement = document.querySelector(".safari-18-fix");
          if (safariFixElement) {
            // (safariFixElement as HTMLElement).style.height = "";
            (safariFixElement as HTMLElement).style.overflow = "scroll";
            (safariFixElement as HTMLElement).style.position = "fixed";
            (safariFixElement as HTMLElement).style.top = "0";
            (safariFixElement as HTMLElement).style.bottom = "0";
            (safariFixElement as HTMLElement).style.left = "0";
            (safariFixElement as HTMLElement).style.right = "0";
            (safariFixElement as HTMLElement).style.zIndex = "49";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
            (safariFixElement as HTMLElement).style.willChange = "transform";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
          }

          // Fix 6: Handle viewport height changes
          const handleViewportChange = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");

            // Force repaint on viewport change
            document.body.style.transform = "translateZ(0)";
            requestAnimationFrame(() => {
              document.body.style.transform = "";
            });
          };

          window.addEventListener("resize", handleViewportChange);
          window.addEventListener("orientationchange", () => {
            setTimeout(handleViewportChange, 100);
          });

          console.log(
            `üçé [SAFARI-18-BETA] Applied fixes to ${stickyElements.length} sticky elements (scroll triggers preserved)`
          );

          // Additional aggressive fix for navbar after a delay
          setTimeout(() => {
            const navbar = document.querySelector("nav.fixed");
            if (navbar) {
              const navbarElement = navbar as HTMLElement;
              console.log("üçé [SAFARI-FIX] Re-applying navbar fixes after delay");

              // Force all the styles again
              navbarElement.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 50 !important;
                transform: translateZ(0) !important;
                will-change: transform !important;
                -webkit-backface-visibility: hidden !important;
                backface-visibility: hidden !important;
              `;

              // Force a reflow
              navbarElement.offsetHeight;

              console.log("üçé [SAFARI-FIX] Re-applied navbar fixes");
            }
          }, 1000);
        }
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", async () => {
        (window as any).hideOnFormFocus();

        // Initialize notification count only if user is authenticated
        try {
          const notificationBell = document.getElementById("notification-bell");
          if (
            notificationBell &&
            notificationBell.dataset.userId &&
            (window as any).initializeNotificationCount
          ) {
            console.log(
              "üîî [APP] Initializing notifications for user:",
              notificationBell.dataset.userId
            );
            await (window as any).initializeNotificationCount();
          } else {
            console.log("üîî [APP] Skipping notification initialization - no authenticated user");
          }
        } catch (error) {
          console.error("üîî [APP] Error initializing notification count:", error);
        }
      });
    </script>

    <!-- Global Console Error Suppression for Development -->
    <!-- This MUST run early, before any other scripts -->
    <script is:inline>
      // Aggressively suppress harmless console errors in development
      (function () {
        const isDev =
          window.location.hostname === "localhost" ||
          window.location.hostname === "127.0.0.1" ||
          window.location.hostname.startsWith("192.168.");

        if (!isDev) return;

        // Suppress Cloudflare cookie warnings and errors
        const originalWarn = console.warn;
        const originalError = console.error;
        const originalLog = console.log;

        // Override console.warn
        console.warn = function (...args) {
          const message = String(args[0] || "");
          const fullMessage = args.join(" ");

          // Suppress Cloudflare cookie warnings
          if (
            message.includes("_cf_bm") ||
            message.includes("__cf_bm") ||
            (fullMessage.includes("Cookie") && fullMessage.includes("rejected")) ||
            fullMessage.includes("invalid domain") ||
            fullMessage.includes("NS_BINDING_ABORTED") ||
            fullMessage.includes("OpaqueResponseBlocking") ||
            fullMessage.includes("Ignoring Event: localhost") ||
            fullMessage.includes("Avatar failed to load") ||
            fullMessage.includes("rate limit")
          ) {
            return; // Silent fail
          }
          originalWarn.apply(console, args);
        };

        // Override console.error
        console.error = function (...args) {
          const message = String(args[0] || "");
          const fullMessage = args.join(" ");

          // Suppress Cloudflare cookie errors
          if (
            message.includes("_cf_bm") ||
            message.includes("__cf_bm") ||
            (fullMessage.includes("Cookie") && fullMessage.includes("rejected")) ||
            fullMessage.includes("invalid domain") ||
            fullMessage.includes("NS_BINDING_ABORTED")
          ) {
            return; // Silent fail
          }
          originalError.apply(console, args);
        };

        // Override console.log to suppress network errors
        console.log = function (...args) {
          // const message = String(args[0] || ""); // Unused
          const fullMessage = args.join(" ");

          if (
            fullMessage.includes("NS_BINDING_ABORTED") ||
            fullMessage.includes("net::ERR_") ||
            fullMessage.includes("_cf_bm") ||
            fullMessage.includes("__cf_bm")
          ) {
            return; // Silent fail
          }
          originalLog.apply(console, args);
        };

        // Suppress unhandled promise rejections for aborted requests
        window.addEventListener("unhandledrejection", function (event) {
          const reason = event.reason;
          const message = reason?.message || String(reason || "");

          if (
            message.includes("aborted") ||
            message.includes("NS_BINDING_ABORTED") ||
            message.includes("AbortError") ||
            reason?.name === "AbortError"
          ) {
            event.preventDefault(); // Prevent console error
            return;
          }
        });

        // Suppress global error events for network errors
        window.addEventListener(
          "error",
          function (event) {
            const message = event.message || "";
            const filename = event.filename || "";
            const target = event.target;

            // Suppress errors related to aborted requests, cookies, or failed image loads
            if (
              message.includes("NS_BINDING_ABORTED") ||
              message.includes("_cf_bm") ||
              message.includes("__cf_bm") ||
              (message.includes("Cookie") && message.includes("rejected")) ||
              (filename.includes("supabase.co") && message.includes("Failed")) ||
              (target &&
                target.tagName === "IMG" &&
                target.src &&
                target.src.includes("supabase.co/storage"))
            ) {
              event.preventDefault();
              event.stopPropagation();
              return false;
            }
          },
          true
        ); // Use capture phase to catch early

        // Intercept fetch to suppress aborted request errors and failed avatar requests
        const originalFetch = window.fetch;
        window.fetch = function (...args) {
          const url = typeof args[0] === "string" ? args[0] : args[0]?.url || "";
          const method = args[1]?.method || "GET";

          // Suppress HEAD requests to Supabase storage avatars (we know they'll fail)
          if (
            method === "HEAD" &&
            url.includes("supabase.co/storage") &&
            url.includes("/avatars/")
          ) {
            return Promise.resolve(new Response(null, { status: 404, statusText: "Not Found" }));
          }

          let fetchPromise = originalFetch.apply(this, args);

          // Wrap to catch and suppress abort errors
          fetchPromise = fetchPromise.catch(function (error) {
            if (
              error?.name === "AbortError" ||
              error?.message?.includes("aborted") ||
              error?.message?.includes("NS_BINDING_ABORTED")
            ) {
              // Return a silent rejection
              return Promise.reject(new Error("Request aborted (suppressed)"));
            }
            throw error;
          });

          // Also suppress 400 responses for avatar images
          fetchPromise = fetchPromise.then(function (response) {
            if (
              !response.ok &&
              response.status === 400 &&
              url.includes("supabase.co/storage") &&
              url.includes("/avatars/")
            ) {
              // Return a silent failure - don't throw, just return a 404-like response
              return new Response(null, { status: 404, statusText: "Not Found" });
            }
            return response;
          });

          return fetchPromise;
        };

        // Intercept XMLHttpRequest to suppress aborted errors and failed avatar requests
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function (...args) {
          this._suppressAbortError = false;
          this._url = args[1]; // Store URL for later check
          return originalXHROpen.apply(this, args);
        };

        XMLHttpRequest.prototype.send = function (...args) {
          const xhr = this;
          const url = xhr._url || "";

          // Suppress 400 errors for avatar images
          const originalOnLoad = xhr.onload;
          xhr.onload = function (event) {
            if (
              xhr.status === 400 &&
              url.includes("supabase.co/storage") &&
              url.includes("/avatars/")
            ) {
              // Silently fail - don't trigger error handlers
              return;
            }
            if (originalOnLoad) {
              originalOnLoad.call(xhr, event);
            }
          };

          const originalOnError = xhr.onerror;
          xhr.onerror = function (event) {
            // Suppress errors for avatar images
            if (url.includes("supabase.co/storage") && url.includes("/avatars/")) {
              return;
            }
            // Suppress aborted errors
            if (xhr.status === 0 && xhr.readyState === 0) {
              // Likely an aborted request
              return;
            }
            if (originalOnError) {
              originalOnError.call(xhr, event);
            }
          };

          return originalXHRSend.apply(this, args);
        };
      })();
    </script>

    <!-- Global Image Error Handler -->
    <script>
      // Global error handler for broken image URLs (especially Supabase storage)
      document.addEventListener("DOMContentLoaded", () => {
        // Suppress expected console errors in development
        const isDev =
          window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

        // Handle all img elements with error handling
        const images = document.querySelectorAll("img");

        images.forEach((img) => {
          img.addEventListener("error", (event) => {
            const target = event.target as HTMLImageElement;
            const src = target.src;

            // Check if it's a Supabase storage URL that's failing
            if (src && src.includes("supabase.co/storage")) {
              // Only log in production, silent in dev to reduce console noise
              if (!isDev) {
                console.warn("‚ö†Ô∏è [IMAGE-ERROR] Supabase storage image failed to load:", src);
              }

              // Hide the broken image and show a fallback
              target.style.display = "none";

              // Create a fallback element if it doesn't exist
              if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                const fallback = document.createElement("div");
                fallback.className =
                  "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                fallback.style.width = target.style.width || "100%";
                fallback.style.height = target.style.height || "100%";
                fallback.innerHTML = "üì∑";
                target.parentNode?.insertBefore(fallback, target.nextSibling);
              }
            }
          });
        });

        // Handle dynamically added images
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newImages = element.querySelectorAll("img");
                newImages.forEach((img) => {
                  img.addEventListener("error", (event) => {
                    const target = event.target as HTMLImageElement;
                    const src = target.src;

                    if (src && src.includes("supabase.co/storage")) {
                      console.warn("‚ö†Ô∏è [IMAGE-ERROR] Supabase storage image failed to load:", src);
                      target.style.display = "none";

                      if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                        const fallback = document.createElement("div");
                        fallback.className =
                          "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                        fallback.style.width = target.style.width || "100%";
                        fallback.style.height = target.style.height || "100%";
                        fallback.innerHTML = "üì∑";
                        target.parentNode?.insertBefore(fallback, target.nextSibling);
                      }
                    }
                  });
                });
              }
            });
          });
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
      });

      // Global error handler for unhandled promise rejections (network errors)
      window.addEventListener("unhandledrejection", (event) => {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("ERR_CONNECTION_CLOSED")
        ) {
          console.warn(
            "‚ö†Ô∏è [NETWORK-ERROR] Connection closed error suppressed:",
            event.reason.message
          );
          event.preventDefault(); // Prevent the error from showing in console
        }
      });

      // Global error handler for general errors
      window.addEventListener("error", (event) => {
        if (event.message && event.message.includes("ERR_CONNECTION_CLOSED")) {
          console.warn("‚ö†Ô∏è [NETWORK-ERROR] Connection closed error suppressed:", event.message);
          event.preventDefault(); // Prevent the error from showing in console
        }
      });
    </script>

    <!-- AOS (Animate On Scroll) - Global initialization -->
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet" />
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js" defer></script>
    <script is:inline>
      // Wait for AOS library to load before initializing
      window.addEventListener("DOMContentLoaded", function () {
        // @ts-ignore - AOS loaded from CDN
        if (typeof AOS !== "undefined") {
          // @ts-ignore
          AOS.init({
            duration: 800,
            easing: "ease-in-out",
            once: true,
            offset: 120,
            delay: 50,
          });
        }
      });
    </script>

    <!-- Custom Scroll Animations (Blur/Scale effects) -->
    <script>
      import "../../scripts/scroll-animations";
    </script>

    <!-- Lazy Loading Images (Global) -->
    <script>
      import "../../scripts/lazy-load-images";
    </script>

    <!-- Plausible Analytics Script -->
    {plausibleTrackingScript && <Fragment set:html={plausibleTrackingScript} />}
  </body>
</html>
