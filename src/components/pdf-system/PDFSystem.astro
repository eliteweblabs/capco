---
import Alert from "../partials/Alert.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import Dropzone from "../common/Dropzone.astro";

export interface Props {
  currentUser?: any;
  globalInputClasses?: string;
  secondaryTextClasses?: string;
  primaryTextClasses?: string;
}

const {
  currentUser,
  globalInputClasses = "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white",
  secondaryTextClasses = "text-gray-600 dark:text-gray-400",
  primaryTextClasses = "text-gray-900 dark:text-white",
} = Astro.props;

import SlotMachineModalFunction from "../form/SlotMachineModalFunction.astro";

console.log("üöÄ [PDF-SYSTEM] Current user:", currentUser);
---

<style>
  /* Custom scrollbar for fields list */
  #fields-list::-webkit-scrollbar {
    width: 8px;
  }

  #fields-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
  }

  #fields-list::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }

  #fields-list::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
  }

  /* Dark mode scrollbar */
  .dark #fields-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
  }

  .dark #fields-list::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
  }

  .dark #fields-list::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }
</style>

<div class="pdf-system-container p-6 color-background rounded-lg shadow-lg">
  <div class="mb-6">
    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">PDF System</h2>
    <p class="text-gray-600 dark:text-gray-400">Create templates and generate professional PDFs</p>
  </div>

  <!-- Tab Navigation -->
  <div class="mb-6">
    <div class="border-b border-gray-200 dark:border-gray-700">
      <nav class="-mb-px flex space-x-8">
        <button
          id="templates-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-blue-500 font-medium text-sm text-blue-600 dark:text-blue-400"
          data-tab="templates"
        >
          <SimpleIcon name="file-text" class="w-4 h-4 inline mr-2" />
          Templates
        </button>
        <button
          id="generate-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
          data-tab="generate"
        >
          <SimpleIcon name="file-plus" class="w-4 h-4 inline mr-2" />
          Generate PDF
        </button>
        <button
          id="contacts-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
          data-tab="contacts"
        >
          <SimpleIcon name="user" class="w-4 h-4 inline mr-2" />
          Google Contacts
        </button>
      </nav>
    </div>
  </div>

  <!-- Templates Tab Content -->
  <div id="templates-content" class="pdf-tab-content">
    <div class="mb-6">
      <div class="flex justify-between items-center mb-4">
        <!-- <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Template Management</h3> -->
        <div class="w-full">
          <Dropzone
            id="new-template-dropzone"
            accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif"
            maxSize={50}
            label="Drop a document here or click to browse"
            description="Supported formats: PDF, DOC, DOCX, JPG, PNG, GIF"
            required={false}
          />
        </div>
      </div>

      <!-- Template Editor Accordion (hidden by default) -->
      <div
        id="template-editor-accordion"
        class="hidden mb-6 border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden"
      >
        <div class="color-background p-6">
          <!-- Template Form -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Name
              </label>
              <input
                type="text"
                id="template-name"
                placeholder="Enter template name..."
                class={globalInputClasses}
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Type
              </label>
              <select id="template-type" class={globalInputClasses}>
                <option value="body">Body Template</option>
                <option value="header">Header Template</option>
                <option value="footer">Footer Template</option>
              </select>
            </div>
          </div>

          <!-- Template Content Editor -->
          <div class="grid grid-cols-12 gap-4">
            <div class="mb-6 col-span-8">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Content
              </label>
              <div
                id="template-editor"
                class="border border-gray-300 dark:border-gray-600 rounded-md min-h-[400px]"
              >
                <!-- Quill Editor will be loaded here -->
              </div>
            </div>
            <!-- Extracted Fields -->
            <div id="extracted-fields" class="mb-6 hidden col-span-4 flex flex-col max-h-[600px]">
              <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3 flex-shrink-0">
                Detected Fields
              </h4>
              <div id="fields-list" class="space-y-2 overflow-y-auto flex-1 pr-2">
                <!-- Extracted fields will be displayed here -->
              </div>
            </div>
          </div>

          <!-- Save Options -->
          <div class="mb-4 p-4 border border-gray-200 dark:border-gray-700 rounded-md hidden">
            <label class="flex items-center space-x-2 cursor-pointer">
              <input
                type="checkbox"
                checked="checked"
                id="save-html-template-checkbox"
                class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
              />
              <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
                Save HTML version to templates directory
              </span>
            </label>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1 ml-6">
              Saves the OCR'd/extracted content as an HTML file in the templates folder for preview
              purposes
            </p>
          </div>

          <!-- Save Template -->
          <div class="flex justify-end space-x-4 mt-6">
            <button
              id="cancel-template-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
            >
              Cancel
            </button>
            <button
              id="save-template-btn"
              class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
            >
              <SimpleIcon name="save" class="w-4 h-4 inline mr-2" />
              Save Template
            </button>
          </div>
        </div>
      </div>

      <!-- Template List -->
      <div id="templates-list" class="space-y-4">
        <!-- Templates will be loaded here -->
      </div>
    </div>
  </div>

  <!-- Generate PDF Tab Content -->
  <div id="generate-content" class="pdf-tab-content hidden">
    <div class="mb-6">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Generate PDF</h3>

      <!-- User Search -->
      <div class="mb-6">
        <label class="hidden block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Search User
        </label>
        <div class="flex space-x-2">
          <!-- <input
            type="text"
            id="user-search"
            placeholder="Search by user name, address, or client..."
            class={globalInputClasses}
          />
          <button
            id="search-users-btn"
            class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
          >
            <SimpleIcon name="search" class="w-4 h-4 inline mr-2" />
            Search
          </button> -->
          <!-- replace the above with slot machine for google contacts endpoint -->
          <!-- <button
            id="search-user-btn"
            class="hidden px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors"
            onclick="window.pdfSystem.checkGoogleAuthAndSearch()"
          >
            <SimpleIcon name="user" class="w-4 h-4 inline mr-2" />
            Search for a user...
          </button> -->

          <!-- Hidden SlotMachineModal for when auth is ready -->
          <SlotMachineModalFunction
            id="user-search"
            icon="user"
            title="Search User"
            options={[]}
            placeholder="Search for a user..."
            showCloseButton={true}
            showCancelButton={true}
            fetchApiEndpoint="/api/google/contacts"
            searchText="Search for a user..."
            searchPlaceholder="Search for a user..."
            valueField="id"
            labelField="name"
            {currentUser}
            {globalInputClasses}
          />
        </div>
        <div class="flex space-x-2">
          <!-- Selected user preview (rendered by SlotMachineModalFunction) -->
          <div id="user-search-preview" class="mt-4 rounded-md border p-4 text-sm color-background">
          </div>
        </div>
      </div>

      <!-- Template Selection -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Select Template
        </label>
        <select id="template-select" class={globalInputClasses}>
          <option value="">Choose a template...</option>
        </select>
      </div>

      <!-- Template Preview Section (for interactive placeholder mapping) -->
      <div id="template-preview-section" class="mb-6 hidden">
        <div class="p-4 color-background rounded-lg border border-gray-200 dark:border-gray-700">
          <div class="flex items-center justify-between mb-4">
            <div>
              <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-1">
                Map Placeholders
              </h4>
              <p class="text-sm text-gray-600 dark:text-gray-400">
                <span id="placeholder-progress">0 of 0</span> placeholders mapped
              </p>
            </div>
            <button
              id="skip-mapping-btn"
              class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200"
            >
              Skip for now
            </button>
          </div>
          <div
            id="template-preview-container"
            class="border border-gray-300 dark:border-gray-600 rounded-md p-6 bg-white dark:bg-gray-800"
          >
            <!-- Template content with highlighted placeholders will be rendered here -->
          </div>
        </div>
      </div>

      <!-- Placeholder Mapping Tooltip (positioned absolutely) -->
      <div
        id="placeholder-tooltip"
        class="hidden fixed z-50 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl p-4 max-w-md"
        style="display: none;"
      >
        <div class="flex items-center justify-between mb-3">
          <h5 class="text-sm font-semibold text-gray-900 dark:text-white">
            Select value for <span
              id="tooltip-placeholder-name"
              class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded"></span>
          </h5>
          <button
            id="close-tooltip-btn"
            class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            √ó
          </button>
        </div>
        <div id="tooltip-contact-fields" class="space-y-2 max-h-64 overflow-y-auto mb-3">
          <!-- Contact field options will be rendered here -->
        </div>
        <div class="border-t border-gray-200 dark:border-gray-700 pt-3">
          <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
            Or enter manually:
          </label>
          <input
            type="text"
            id="tooltip-manual-input"
            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm"
            placeholder="Enter value..."
          />
          <button
            id="tooltip-apply-btn"
            class="mt-3 w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
          >
            Apply
          </button>
        </div>
      </div>

      <!-- Placeholder Mapping Section -->
      <div id="placeholder-mapping-section" class="mb-6 hidden">
        <div class="p-4 color-background rounded-lg border border-gray-200 dark:border-gray-700">
          <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3">
            Map Template Placeholders to Contact Data
          </h4>
          <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
            Map each placeholder to a Google contact field or enter a value manually.
          </p>
          <div id="placeholder-mappings-list" class="space-y-3">
            <!-- Placeholder mappings will be rendered here -->
          </div>
        </div>
      </div>

      <!-- User Results -->
      <div id="user-results" class="mb-6">
        <!-- User search results will be displayed here -->
      </div>

      <!-- PDF Generation Options -->
      <div class="mb-6 p-4 color-background rounded-lg">
        <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3">PDF Options</h4>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Page Size
            </label>
            <select id="page-size" class={globalInputClasses}>
              <option value="8.5x11">8.5" x 11" (Letter)</option>
              <option value="A4">A4</option>
              <option value="A3">A3</option>
              <option value="11x17">11" x 17" (Tabloid)</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Orientation
            </label>
            <select id="orientation" class={globalInputClasses}>
              <option value="portrait">Portrait</option>
              <option value="landscape">Landscape</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Generate Button -->
      <div class="flex space-x-4">
        <button
          id="preview-pdf-btn"
          class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors"
        >
          <SimpleIcon name="eye" class="w-4 h-4 inline mr-2" />
          Preview
        </button>
        <button
          id="generate-pdf-btn"
          class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors"
        >
          <SimpleIcon name="download" class="w-4 h-4 inline mr-2" />
          Generate PDF
        </button>
      </div>
    </div>
  </div>

  <!-- Google Contacts Tab Content -->
  <div id="contacts-content" class="pdf-tab-content hidden">
    <div class="mb-6">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Google Contacts</h3>

      <!-- Information Card -->
      <div
        class="mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg"
      >
        <div class="flex items-start">
          <div
            class="w-5 h-5 text-blue-600 dark:text-blue-400 mr-3 mt-0.5 flex-shrink-0 text-lg font-bold"
          >
            i
          </div>
          <div class="flex-1">
            <p class="text-sm text-blue-800 dark:text-blue-300">
              <strong>Note:</strong> Google Contacts cannot be embedded in iframes due to security restrictions.
              Click the button below to open Google Contacts in a new tab where you can manage your contacts.
            </p>
          </div>
        </div>
      </div>

      <!-- Open Google Contacts Button -->
      <div
        class="flex flex-col items-center justify-center p-12 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-800/50"
      >
        <SimpleIcon name="user" class="w-16 h-16 text-gray-400 dark:text-gray-500 mb-4" />
        <h4 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">
          Manage Google Contacts
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-400 mb-6 text-center max-w-md">
          Add, edit, or search your Google Contacts in a new tab
        </p>
        <a
          href="https://contacts.google.com/"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium transition-colors shadow-lg hover:shadow-xl"
        >
          Open Google Contacts
          <span class="ml-2 text-sm">‚Üó</span>
        </a>
        <p class="text-xs text-gray-500 dark:text-gray-400 mt-4">Opens in a new tab</p>
      </div>
    </div>
  </div>
</div>

<script
  is:inline
  define:vars={{ currentUser, globalInputClasses, primaryTextClasses, secondaryTextClasses }}
>
  console.log("üöÄ [PDF-SYSTEM] Script starting...");

  class PDFSystem {
    constructor() {
      this.currentUser = null; // Will be set when needed
      this.selectedTemplate = null;
      this.selectedUser = null;
      this.selectedContactData = null; // Store Google contact data
      this.templates = [];
      this.users = [];
      this.editor = null;
      this.templateEditors = {}; // Store Quill editors for each template
      this.templateNameInput = null;
      this.templateTypeSelect = null;
      this.placeholderMappings = {}; // Store mappings: { placeholder: { source: 'contact'|'manual', value: string } }
      this.ocrResultsByPage = []; // Store OCR results with layout data for each page
      this.currentPlaceholderIndex = 0; // Track current placeholder being mapped
      this.placeholderElements = []; // Store DOM elements for placeholders in template preview
      this.placeholdersList = []; // Store list of placeholders to map
      this.tooltipListenersSetup = false; // Track if tooltip listeners are set up

      this.init();
    }

    async init() {
      console.log("üöÄ [PDF-SYSTEM] Initializing PDF system");
      this.setupEventListeners();
      await this.loadTemplates();
      this.setupTabNavigation();
    }

    setupEventListeners() {
      // Tab navigation

      document.querySelectorAll(".pdf-tab").forEach((tab) => {
        tab.addEventListener("click", (e) => {
          this.switchTab(e.target.dataset.tab);
        });
      });

      // Dropzone for new template file upload
      const dropzone = document.getElementById("new-template-dropzone");
      if (dropzone) {
        dropzone.addEventListener("dropzone-files-selected", (e) => {
          const { files } = e.detail;
          if (files && files.length > 0) {
            // Open the accordion and process the file
            this.openTemplateEditor();
            // Wait for editor to initialize before processing file
            setTimeout(() => {
              this.handleFileUpload(files[0]);
            }, 200);
          }
        });

        dropzone.addEventListener("dropzone-error", (e) => {
          const { error } = e.detail;
          this.showNotification(error || "Error uploading file", "error");
        });
      }

      document.getElementById("save-template-btn")?.addEventListener("click", () => {
        this.saveTemplate();
      });

      document.getElementById("cancel-template-btn")?.addEventListener("click", () => {
        this.closeTemplateEditor();
      });

      // Listen for user selection from SlotMachineModal (Google Contacts)
      // The preview rendering is now handled by SlotMachineModalFunction.astro
      window.addEventListener("slot-select", (event) => {
        const ce = /** @type {CustomEvent} */ (event);
        const detail = (ce && ce.detail) || {};
        if (detail.componentId !== "user-search") return;

        // Store the contact data for placeholder mapping
        this.selectedContactData = detail.data || null;
        console.log("üìÑ [PDF-SYSTEM] Contact selected:", detail.label, detail.data);

        // Update selectedUser from the value
        if (detail.value) {
          this.selectUser(detail.value);
        }

        // Check if template is also selected, if so show mapping UI
        if (this.selectedTemplate) {
          this.updatePlaceholderMappingUI();

          // Check if both template and user are selected, trigger mapping workflow
          // Use setTimeout to ensure DOM and data are ready
          if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
            setTimeout(() => {
              this.startPlaceholderMappingWorkflow();
            }, 100);
          }
        }
      });

      // Watch for changes to the hidden input value from SlotMachineModalFunction
      this.setupUserInputWatcher();

      // Listen for template selection changes (set up after templates are loaded)
      // The listener will be attached in loadTemplatesForGeneration()

      // Generate PDF
      document.getElementById("search-users-btn")?.addEventListener("click", () => {
        this.searchUsers();
      });

      document.getElementById("preview-pdf-btn")?.addEventListener("click", () => {
        this.previewPDF();
      });

      document.getElementById("generate-pdf-btn")?.addEventListener("click", () => {
        this.generatePDF();
      });
    }

    setupTabNavigation() {
      // Set initial tab
      this.switchTab("templates");
    }

    switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll(".pdf-tab").forEach((tab) => {
        tab.classList.remove("border-blue-500", "text-blue-600", "dark:text-blue-400");
        tab.classList.add(
          "border-transparent",
          "text-gray-500",
          "hover:text-gray-700",
          "hover:border-gray-300",
          "dark:text-gray-400",
          "dark:hover:text-gray-300"
        );
      });

      const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
      if (activeTab) {
        activeTab.classList.remove(
          "border-transparent",
          "text-gray-500",
          "hover:text-gray-700",
          "hover:border-gray-300",
          "dark:text-gray-400",
          "dark:hover:text-gray-300"
        );
        activeTab.classList.add("border-blue-500", "text-blue-600", "dark:text-blue-400");
      }

      // Show/hide content
      document.querySelectorAll(".pdf-tab-content").forEach((content) => {
        content.classList.add("hidden");
      });

      const activeContent = document.getElementById(`${tabName}-content`);
      if (activeContent) {
        activeContent.classList.remove("hidden");
      }

      // Load content based on tab
      if (tabName === "generate") {
        this.loadTemplatesForGeneration();
      }
    }

    async loadTemplates() {
      try {
        console.log("üìÑ [PDF-SYSTEM] Loading templates");
        const response = await fetch("/api/pdf/templates/get", {
          method: "GET",
          credentials: "include",
        });

        const data = await response.json();
        if (data.success) {
          const newTemplates = data.data.templates || [];

          // Only re-render if templates actually changed
          const templatesChanged =
            JSON.stringify(this.templates?.map((t) => t.id).sort()) !==
            JSON.stringify(newTemplates.map((t) => t.id).sort());

          this.templates = newTemplates;

          if (templatesChanged) {
            console.log("üìÑ [PDF-SYSTEM] Templates changed, re-rendering...");
            this.renderTemplates();
          } else {
            console.log("üìÑ [PDF-SYSTEM] Templates unchanged, skipping re-render");
          }
        } else {
          console.error("‚ùå [PDF-SYSTEM] Error loading templates:", data.error);
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error loading templates:", error);
      }
    }

    renderTemplates() {
      const container = document.getElementById("templates-list");
      if (!container) return;

      // Destroy existing Quill editors before replacing HTML
      if (this.templateEditors) {
        console.log("üóëÔ∏è [PDF-SYSTEM] Destroying existing template editors before re-rendering...");
        Object.keys(this.templateEditors).forEach((templateId) => {
          const editor = this.templateEditors[templateId];
          if (editor) {
            try {
              // Quill doesn't have a built-in destroy method, but we can clear the container
              const editorContainer = document.getElementById(`template-editor-${templateId}`);
              if (editorContainer) {
                editorContainer.innerHTML = "";
              }
            } catch (error) {
              console.warn(
                `‚ö†Ô∏è [PDF-SYSTEM] Error destroying editor for template ${templateId}:`,
                error
              );
            }
          }
        });
        // Clear the editors object so they can be recreated
        this.templateEditors = {};
      }

      if (this.templates.length === 0) {
        container.innerHTML = `
          <div class="text-center py-8 text-gray-500 dark:text-gray-400">
            <SimpleIcon name="file-text" class="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No templates found. Create your first template!</p>
          </div>
        `;
        return;
      }

      // Create accordion HTML for each template (following FileManager pattern)
      container.innerHTML = this.templates
        .map((template, index) => {
          return this.createTemplateAccordion(template, false); // First one open by default
        })
        .join("");

      // Initialize accordions
      this.initAccordions();

      // Initialize Quill editors for each template
      this.templates.forEach((template) => {
        setTimeout(() => {
          this.initializeTemplateEditor(template.id);
        }, 100);
      });
    }

    // Create accordion HTML for a template (following FileManager accordion pattern)
    createTemplateAccordion(template, open = false) {
      const defaultBadge = template.isDefault
        ? '<span class="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 px-2 py-1 rounded text-xs">Default</span>'
        : "";

      const createdDate = template.createdAt
        ? new Date(template.createdAt).toLocaleDateString()
        : "Unknown";

      const description =
        template.description || template.html_content?.substring(0, 100) || "No description";

      return `
        <div class="border border-gray-200 dark:border-gray-700 rounded-lg relative">
          <!-- Accordion Header -->
          <div class="flex items-center justify-between cursor-pointer rounded-lg transition-colors hover:bg-gray-50 dark:hover:bg-gray-700">
            <!-- Clickable header area -->
            <div 
              class="flex-1"
              data-accordion-target="#accordion-template-${template.id}"
              aria-expanded="${open}"
              aria-controls="accordion-template-${template.id}"
              role="button"
              tabindex="0"
              onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();this.click();}"
            >
              <div class="p-4">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium ${primaryTextClasses} truncate">
                    ${template.name}
                  </h3>
                  ${defaultBadge}
                </div>
                <p class="mt-1 ${secondaryTextClasses} text-sm truncate">${description}</p>
                <div class="flex items-center space-x-4 mt-2 text-xs ${secondaryTextClasses}">
                  <span>Type: ${template.templateType || "body"}</span>
                  <span>Size: ${template.pageSize || "8.5x11"}</span>
                  <span>Created: ${createdDate}</span>
                </div>
              </div>
            </div>

            <!-- Accordion Toggle Button -->
            <button
              class="text-gray-400 transition-colors hover:text-gray-600 dark:hover:text-gray-300 p-4"
              data-accordion-target="#accordion-template-${template.id}"
              aria-expanded="${open}"
              aria-controls="accordion-template-${template.id}"
              type="button"
            >
              <svg
                class="w-5 h-5 transition-transform duration-200 ${open ? "rotate-180" : ""}"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </button>
          </div>

          <!-- Accordion Content -->
          <div
            id="accordion-template-${template.id}"
            class="${open ? "" : "hidden"}"
            aria-labelledby="accordion-template-${template.id}"
          >
            <div class="border-t border-gray-200 px-4 pb-4 dark:border-gray-700">
              <div class="pt-4 space-y-4">
                <!-- Template Name Input -->
                <div>
                  <label for="template-name-${template.id}" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Template Name
                  </label>
                  <input
                    type="text"
                    id="template-name-${template.id}"
                    class="${globalInputClasses}"
                    value="${template.name || ""}"
                    placeholder="Enter template name..."
                  />
                </div>

                <!-- Template Description -->
                <div>
                  <label for="template-description-${template.id}" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Description
                  </label>
                  <textarea
                    id="template-description-${template.id}"
                    class="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                    rows="2"
                    placeholder="Enter template description..."
                  >${template.description || ""}</textarea>
                </div>

                <!-- Quill Editor Container -->
                <div>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Template Content
                  </label>
                  <div id="template-editor-${template.id}" class="min-h-[300px] bg-white dark:bg-gray-800 rounded-lg border border-gray-300 dark:border-gray-600">
                    <!-- Quill editor will be initialized here -->
                  </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex justify-end space-x-2 pt-2">
                  <button
                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors delete-template-btn"
                    data-template-id="${template.id}"
                    type="button"
                  >
                    <SimpleIcon name="trash-2" class="w-4 h-4 inline mr-2" />
                    Delete
                  </button>
                  <button
                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors save-template-btn"
                    data-template-id="${template.id}"
                    type="button"
                  >
                    <SimpleIcon name="save" class="w-4 h-4 inline mr-2" />
                    Save Template
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Initialize accordions (following FileManager pattern)
    initAccordions() {
      const accordionButtons = document.querySelectorAll("[data-accordion-target]");
      accordionButtons.forEach((button) => {
        button.addEventListener("click", function () {
          const targetId = this.getAttribute("data-accordion-target");
          const target = document.querySelector(targetId);
          const isExpanded = this.getAttribute("aria-expanded") === "true";

          if (target) {
            if (isExpanded) {
              target.classList.add("hidden");
              this.setAttribute("aria-expanded", "false");
              // Update both the main header and the toggle button
              const svg = this.querySelector("svg");
              if (svg) svg.style.transform = "rotate(0deg)";
              // Also update the toggle button if it exists
              const toggleButton = document.querySelector(
                `button[data-accordion-target="${targetId}"]`
              );
              if (toggleButton && toggleButton !== this) {
                const toggleSvg = toggleButton.querySelector("svg");
                if (toggleSvg) toggleSvg.style.transform = "rotate(0deg)";
                toggleButton.setAttribute("aria-expanded", "false");
              }
            } else {
              target.classList.remove("hidden");
              this.setAttribute("aria-expanded", "true");
              // Update both the main header and the toggle button
              const svg = this.querySelector("svg");
              if (svg) svg.style.transform = "rotate(180deg)";
              // Also update the toggle button if it exists
              const toggleButton = document.querySelector(
                `button[data-accordion-target="${targetId}"]`
              );
              if (toggleButton && toggleButton !== this) {
                const toggleSvg = toggleButton.querySelector("svg");
                if (toggleSvg) toggleSvg.style.transform = "rotate(180deg)";
                toggleButton.setAttribute("aria-expanded", "true");
              }
            }
          }
        });
      });

      // Add event listeners for save and delete buttons
      const container = document.getElementById("templates-list");
      if (!container) return;

      container.querySelectorAll(".save-template-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          console.log("üîò [PDF-SYSTEM] Save button clicked:", e.target);
          const templateId = e.target
            .closest(".save-template-btn")
            .getAttribute("data-template-id");
          console.log("üîò [PDF-SYSTEM] Template ID from button:", templateId);
          this.saveTemplate(templateId);
        });
      });

      container.querySelectorAll(".delete-template-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const templateId = e.target
            .closest(".delete-template-btn")
            .getAttribute("data-template-id");
          this.deleteTemplate(templateId);
        });
      });
    }

    // Initialize Quill editor for a specific template
    async initializeTemplateEditor(templateId) {
      const editorContainer = document.getElementById(`template-editor-${templateId}`);
      if (!editorContainer) {
        console.warn(`‚ö†Ô∏è [PDF-SYSTEM] Editor container not found for template ${templateId}`);
        return;
      }

      // Check if editor already exists
      if (this.templateEditors && this.templateEditors[templateId]) {
        console.log(`‚úÖ [PDF-SYSTEM] Editor already exists for template ${templateId}`);
        return;
      }

      // Load Quill if not already loaded
      if (!window.Quill) {
        await this.loadQuill();
      }

      // Find the template data
      const template = this.templates.find((t) => t.id === templateId);
      if (!template) {
        console.error(`‚ùå [PDF-SYSTEM] Template ${templateId} not found`);
        return;
      }

      // Create Quill editor
      try {
        if (!this.templateEditors) {
          this.templateEditors = {};
        }

        this.templateEditors[templateId] = new window.Quill(`#template-editor-${templateId}`, {
          theme: "snow",
          modules: {
            toolbar: [
              [{ header: [1, 2, 3, false] }],
              ["bold", "italic", "underline", "strike"],
              [{ list: "ordered" }, { list: "bullet" }],
              [{ script: "sub" }, { script: "super" }],
              [{ indent: "-1" }, { indent: "+1" }],
              [{ direction: "rtl" }],
              [{ size: ["small", false, "large", "huge"] }],
              [{ color: [] }, { background: [] }],
              [{ font: [] }],
              [{ align: [] }],
              ["clean"],
              ["link", "image"],
            ],
          },
        });

        // Set initial content
        const content = template.html_content || template.content || "";
        if (content) {
          this.templateEditors[templateId].clipboard.dangerouslyPasteHTML(content);
        }

        console.log(`‚úÖ [PDF-SYSTEM] Quill editor initialized for template ${templateId}`);
      } catch (error) {
        console.error(
          `‚ùå [PDF-SYSTEM] Error initializing editor for template ${templateId}:`,
          error
        );
      }
    }

    // Load Quill CSS and JS if not already loaded
    async loadQuill() {
      return new Promise((resolve) => {
        // Load Quill CSS
        if (!document.querySelector("#quill-css-templates")) {
          const quillCSS = document.createElement("link");
          quillCSS.id = "quill-css-templates";
          quillCSS.rel = "stylesheet";
          quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
          document.head.appendChild(quillCSS);
        }

        // Load Quill JS
        if (!window.Quill) {
          const quillJS = document.createElement("script");
          quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
          quillJS.onload = () => {
            console.log("‚úÖ [PDF-SYSTEM] Quill JS loaded for templates");
            resolve();
          };
          document.head.appendChild(quillJS);
        } else {
          resolve();
        }
      });
    }

    // Save template
    async saveTemplate(templateId) {
      console.log("üíæ [PDF-SYSTEM] ===== SAVE TEMPLATE FUNCTION CALLED =====");
      console.log("üíæ [PDF-SYSTEM] Input templateId:", templateId, "Type:", typeof templateId);
      console.log("üíæ [PDF-SYSTEM] All templates:", this.templates);
      console.log(
        "üíæ [PDF-SYSTEM] Template IDs in array:",
        this.templates.map((t) => ({ id: t.id, type: typeof t.id, name: t.name }))
      );

      // Convert templateId to number if it's a string (from getAttribute)
      const numericId = typeof templateId === "string" ? parseInt(templateId, 10) : templateId;
      console.log("üíæ [PDF-SYSTEM] Numeric ID:", numericId, "Type:", typeof numericId);

      // Try both string and number matches
      const template = this.templates.find(
        (t) => t.id === templateId || t.id === numericId || String(t.id) === String(templateId)
      );

      console.log("üíæ [PDF-SYSTEM] ===== TEMPLATE LOOKUP =====");
      console.log("üíæ [PDF-SYSTEM] Template found:", !!template);
      console.log("üíæ [PDF-SYSTEM] Template details:", template);
      console.log("üíæ [PDF-SYSTEM] Search comparisons:", {
        templateId,
        numericId,
        matches: this.templates.map((t) => ({
          id: t.id,
          matchesString: t.id === templateId,
          matchesNumber: t.id === numericId,
          matchesStringCoerce: String(t.id) === String(templateId),
        })),
      });

      if (!template) {
        window.showNotification({
          type: "error",
          title: "Template Not Found",
          message: `Template not found (ID: ${templateId})`,
        });
        return;
      }

      // Get form elements - ensure we're using the correct templateId format
      const actualTemplateId = template.id; // Use the actual template ID from the data
      const nameInput = document.getElementById(`template-name-${actualTemplateId}`);
      const descriptionInput = document.getElementById(`template-description-${actualTemplateId}`);
      const editor =
        this.templateEditors?.[actualTemplateId] ||
        this.templateEditors?.[templateId] ||
        this.templateEditors?.[numericId];

      console.log("üíæ [PDF-SYSTEM] Form elements:", {
        actualTemplateId,
        nameInputFound: !!nameInput,
        descriptionInputFound: !!descriptionInput,
        editorFound: !!editor,
        editorKeys: Object.keys(this.templateEditors || {}),
      });

      if (!nameInput) {
        window.showNotification({
          type: "error",
          title: "Form Element Not Found",
          message: `Template name input not found for ID: ${actualTemplateId}`,
        });
        return;
      }

      if (!editor) {
        window.showNotification({
          type: "error",
          title: "Editor Not Found",
          message: `Template editor not found for ID: ${actualTemplateId}. Available editors: ${Object.keys(this.templateEditors || {}).join(", ")}`,
        });
        return;
      }

      const name = nameInput.value.trim();
      console.log("üíæ [PDF-SYSTEM] Name validation:", {
        rawValue: nameInput.value,
        trimmed: name,
        isEmpty: !name,
        length: name.length,
      });

      if (!name) {
        window.showNotification({
          type: "error",
          title: "Validation Error",
          message: "Template name is required",
        });
        return;
      }

      const description = descriptionInput?.value.trim() || "";
      const content = editor.root.innerHTML;

      // Check if content is effectively empty (just whitespace/empty tags)
      const contentText = editor.getText().trim();
      const contentIsEmpty = !contentText || contentText.length === 0;
      const contentIsOnlyEmptyTags = content.replace(/<[^>]*>/g, "").trim().length === 0;

      console.log("üíæ [PDF-SYSTEM] Content validation:", {
        htmlLength: content.length,
        htmlPreview: content.substring(0, 100),
        textLength: contentText.length,
        textPreview: contentText.substring(0, 50),
        contentIsEmpty,
        contentIsOnlyEmptyTags,
        isEmptyOrWhitespace: contentIsEmpty || contentIsOnlyEmptyTags,
      });

      if (!content || contentIsEmpty || contentIsOnlyEmptyTags) {
        window.showNotification({
          type: "error",
          title: "Validation Error",
          message: "Template content is required. Please add some content to the template.",
        });
        return;
      }

      console.log("üíæ [PDF-SYSTEM] ===== SAVE TEMPLATE - DATA COLLECTION =====");
      console.log("üíæ [PDF-SYSTEM] Template ID (actual):", actualTemplateId);
      console.log("üíæ [PDF-SYSTEM] Name input value:", nameInput.value);
      console.log("üíæ [PDF-SYSTEM] Name (trimmed):", name);
      console.log("üíæ [PDF-SYSTEM] Description input value:", descriptionInput?.value);
      console.log("üíæ [PDF-SYSTEM] Description (trimmed):", description);
      console.log("üíæ [PDF-SYSTEM] Editor root HTML length:", editor.root.innerHTML.length);
      console.log(
        "üíæ [PDF-SYSTEM] Editor root HTML (first 200 chars):",
        editor.root.innerHTML.substring(0, 200)
      );
      console.log("üíæ [PDF-SYSTEM] Content:", content);
      console.log("üíæ [PDF-SYSTEM] Template data:", {
        templateType: template.templateType,
        pageSize: template.pageSize,
        margins: template.margins,
      });

      const payload = {
        id: actualTemplateId,
        name,
        description,
        content,
        templateType: template.templateType || "body",
        pageSize: template.pageSize || "8.5x11",
        margins: template.margins || { top: "1in", right: "1in", bottom: "1in", left: "1in" },
      };

      console.log("üíæ [PDF-SYSTEM] ===== PAYLOAD TO SEND =====");
      console.log("üíæ [PDF-SYSTEM] Full payload:", JSON.stringify(payload, null, 2));
      console.log("üíæ [PDF-SYSTEM] Payload sizes:", {
        id: String(payload.id).length,
        name: payload.name.length,
        description: payload.description.length,
        content: payload.content.length,
      });

      try {
        console.log("üíæ [PDF-SYSTEM] ===== FETCH REQUEST =====");
        console.log("üíæ [PDF-SYSTEM] URL:", "/api/pdf/templates/upsert");
        console.log("üíæ [PDF-SYSTEM] Method: POST");

        const response = await fetch("/api/pdf/templates/upsert", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload),
        });

        console.log("üíæ [PDF-SYSTEM] ===== RESPONSE RECEIVED =====");
        console.log("üíæ [PDF-SYSTEM] Response status:", response.status);
        console.log("üíæ [PDF-SYSTEM] Response ok:", response.ok);
        console.log(
          "üíæ [PDF-SYSTEM] Response headers:",
          Object.fromEntries(response.headers.entries())
        );

        const responseText = await response.text();
        console.log("üíæ [PDF-SYSTEM] Response text (raw):", responseText);

        let data;
        try {
          data = JSON.parse(responseText);
          console.log("üíæ [PDF-SYSTEM] Response data (parsed):", data);
        } catch (parseError) {
          console.error("‚ùå [PDF-SYSTEM] Failed to parse response as JSON:", parseError);
          console.error("‚ùå [PDF-SYSTEM] Response text was:", responseText);
          throw new Error("Invalid JSON response from server");
        }

        console.log("üíæ [PDF-SYSTEM] ===== PROCESSING RESPONSE =====");
        console.log("üíæ [PDF-SYSTEM] Data success:", data.success);
        console.log("üíæ [PDF-SYSTEM] Data message:", data.message);
        console.log("üíæ [PDF-SYSTEM] Data error:", data.error);
        console.log("üíæ [PDF-SYSTEM] Full data object:", data);

        if (data.success) {
          console.log("‚úÖ [PDF-SYSTEM] Save successful!");
          window.showNotification({
            type: "success",
            title: "Template Saved",
            message: "Template saved successfully",
          });
          // Reload templates to refresh the list
          console.log("üíæ [PDF-SYSTEM] Reloading templates...");
          await this.loadTemplates();
          console.log("üíæ [PDF-SYSTEM] Templates reloaded");
        } else {
          console.error("‚ùå [PDF-SYSTEM] Save failed:", data);
          window.showNotification({
            type: "error",
            title: "Save Failed",
            message: data.message || data.error || "Failed to save template",
          });
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] ===== EXCEPTION CAUGHT =====");
        console.error("‚ùå [PDF-SYSTEM] Error type:", error?.constructor?.name);
        console.error("‚ùå [PDF-SYSTEM] Error message:", error?.message);
        console.error("‚ùå [PDF-SYSTEM] Error stack:", error?.stack);
        console.error("‚ùå [PDF-SYSTEM] Full error object:", error);
        window.showNotification({
          type: "error",
          title: "Save Error",
          message: `Error saving template: ${error?.message || "Unknown error"}`,
        });
      }
    }

    // Delete template
    async deleteTemplate(templateId) {
      if (
        !confirm("Are you sure you want to delete this template? This action cannot be undone.")
      ) {
        return;
      }

      try {
        const response = await fetch(`/api/pdf/templates/${templateId}`, {
          method: "DELETE",
        });

        if (response.ok) {
          window.showNotification({
            type: "success",
            title: "Template Deleted",
            message: "Template deleted successfully",
          });
          // Remove editor instance
          if (this.templateEditors?.[templateId]) {
            delete this.templateEditors[templateId];
          }
          // Reload templates
          await this.loadTemplates();
        } else {
          const data = await response.json().catch(() => ({}));
          window.showNotification({
            type: "error",
            title: "Delete Failed",
            message: data.message || "Failed to delete template",
          });
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error deleting template:", error);
        window.showNotification({
          type: "error",
          title: "Delete Error",
          message: "Error deleting template. Please try again.",
        });
      }
    }

    openTemplateEditor(templateId = null) {
      const accordion = document.getElementById("template-editor-accordion");

      if (accordion) {
        const isHidden = accordion.classList.contains("hidden");

        if (isHidden) {
          // Open accordion
          accordion.classList.remove("hidden");

          this.selectedTemplate = templateId;

          if (templateId) {
            this.loadTemplateForEdit(templateId);
          } else {
            this.resetTemplateForm();
          }

          // Initialize editor after accordion is visible
          setTimeout(() => {
            this.initializeEditor();
          }, 100);

          // Scroll to accordion
          setTimeout(() => {
            accordion.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }, 150);
        } else {
          // Close accordion if clicking again
          this.closeTemplateEditor();
        }
      }
    }

    closeTemplateEditor() {
      const accordion = document.getElementById("template-editor-accordion");

      if (accordion) {
        accordion.classList.add("hidden");
        this.selectedTemplate = null;

        // Properly destroy the editor
        if (this.editor) {
          console.log("üóëÔ∏è [PDF-SYSTEM] Destroying editor on close...");
          try {
            // Properly dispose of the Quill instance
            this.editor = null;
          } catch (error) {
            console.warn("‚ö†Ô∏è [PDF-SYSTEM] Error disposing editor:", error);
          }

          // Clear the editor container completely
          const editorContainer = document.getElementById("template-editor");
          if (editorContainer) {
            editorContainer.innerHTML = "";
            // Remove any Quill-specific classes that might be left behind
            editorContainer.className = "";
          }

          // Remove any existing Quill toolbars from the DOM
          const existingToolbars = document.querySelectorAll(".ql-toolbar");
          existingToolbars.forEach((toolbar) => {
            if (toolbar.parentNode) {
              toolbar.parentNode.removeChild(toolbar);
            }
          });

          // Remove any existing Quill containers
          const existingContainers = document.querySelectorAll(".ql-container");
          existingContainers.forEach((container) => {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
            }
          });
        }
      }
    }

    async initializeEditor() {
      // Initialize Quill WYSIWYG Editor (using contract system pattern)
      this.templateNameInput = document.getElementById("template-name");
      this.templateTypeSelect = document.getElementById("template-type");

      console.log("üöÄ [PDF-SYSTEM] Initializing Quill editor...");

      // Destroy existing editor if it exists
      if (this.editor) {
        console.log("üóëÔ∏è [PDF-SYSTEM] Destroying existing editor...");
        try {
          // Properly dispose of the Quill instance
          this.editor = null;
        } catch (error) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Error disposing editor:", error);
        }

        // Clear the editor container completely
        const editorContainer = document.getElementById("template-editor");
        if (editorContainer) {
          editorContainer.innerHTML = "";
          // Remove any Quill-specific classes that might be left behind
          editorContainer.className = "";
        }

        // Remove any existing Quill toolbars from the DOM
        const existingToolbars = document.querySelectorAll(".ql-toolbar");
        existingToolbars.forEach((toolbar) => {
          if (toolbar.parentNode) {
            toolbar.parentNode.removeChild(toolbar);
          }
        });

        // Remove any existing Quill containers
        const existingContainers = document.querySelectorAll(".ql-container");
        existingContainers.forEach((container) => {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
        });
      }

      // Load Quill CSS and JS dynamically (like contract system)
      if (!document.querySelector("#quill-css-pdf")) {
        console.log("üì¶ [PDF-SYSTEM] Loading Quill CSS...");
        const quillCSS = document.createElement("link");
        quillCSS.id = "quill-css-pdf";
        quillCSS.rel = "stylesheet";
        quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
        document.head.appendChild(quillCSS);
      }

      if (!window.Quill) {
        console.log("üì¶ [PDF-SYSTEM] Loading Quill JS...");
        const quillJS = document.createElement("script");
        quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
        quillJS.onload = async () => {
          console.log("‚úÖ [PDF-SYSTEM] Quill JS loaded, creating editor...");
          await this.createEditor();
        };
        document.head.appendChild(quillJS);
      } else {
        console.log("‚úÖ [PDF-SYSTEM] Quill JS already loaded, creating editor...");
        await this.createEditor();
      }
    }

    async createEditor() {
      console.log("üîß [PDF-SYSTEM] Creating Quill editor...");

      try {
        this.editor = new window.Quill("#template-editor", {
          theme: "snow",
          modules: {
            toolbar: [
              [{ header: [1, 2, 3, 4, 5, 6, false] }],
              ["bold", "italic", "underline", "strike"],
              [{ color: [] }, { background: [] }],
              [{ list: "ordered" }, { list: "bullet" }],
              [{ indent: "-1" }, { indent: "+1" }],
              [{ align: [] }],
              ["link", "image"],
              ["clean"],
            ],
          },
          placeholder: "Enter your template content here...",
          readOnly: false,
        });

        // Set the editor container style
        const editorElement = document.getElementById("template-editor");
        editorElement.style.height = "400px";
        editorElement.style.border = "1px solid #374151";
        editorElement.style.borderRadius = "0.375rem";

        console.log("‚úÖ [PDF-SYSTEM] Quill editor created successfully");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error creating editor:", error);
        // Fallback to textarea if Quill is not available
        const editorDiv = document.getElementById("template-editor");
        editorDiv.innerHTML = `
          <textarea 
            id="template-content-textarea" 
            class="w-full h-96 p-4 border border-gray-300 dark:border-gray-600 rounded-md font-mono text-sm"
            placeholder="Enter your template content here..."
          ></textarea>
        `;
      }
    }

    async handleFileUpload(file) {
      if (!file) return;

      console.log("üìÑ [PDF-SYSTEM] Processing uploaded file:", file.name);

      try {
        // Process file directly with PDF.js
        await this.runClientSideOCR(file);

        this.showNotification("File processed successfully!", "success");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error processing file:", error);
        this.showNotification("Error processing file", "error");
      }
    }

    async processUploadedFile(file) {
      const formData = new FormData();
      formData.append("file", file);

      const response = await fetch("/api/pdf/process-file", {
        method: "POST",
        credentials: "include",
        body: formData,
      });

      return await response.json();
    }

    async displayExtractedContent(content, fields) {
      console.log("üìÑ [PDF-SYSTEM] Displaying extracted content:", {
        contentType: typeof content,
        contentLength: content?.length,
        contentPreview: content?.substring(0, 100),
        fieldsCount: fields?.length,
      });

      // Check if this needs client-side OCR
      console.log("üîç [PDF-SYSTEM] Checking for OCR placeholders...");
      console.log("üîç [PDF-SYSTEM] Content value:", JSON.stringify(content));
      console.log("üîç [PDF-SYSTEM] Is IMAGE_OCR_PLACEHOLDER?", content === "IMAGE_OCR_PLACEHOLDER");
      console.log("üîç [PDF-SYSTEM] Is PDF_OCR_PLACEHOLDER?", content === "PDF_OCR_PLACEHOLDER");

      if (content === "IMAGE_OCR_PLACEHOLDER") {
        console.log("üîç [PDF-SYSTEM] Image detected - running client-side OCR...");
        await this.runClientSideOCR(file);
        return;
      }

      if (content === "PDF_OCR_PLACEHOLDER") {
        console.log("üîç [PDF-SYSTEM] PDF detected - running client-side OCR...");
        await this.runClientSideOCR(file);
        return;
      }

      // Ensure content is a string
      const safeContent = content || "";

      // Set content in editor using Quill's proper method
      if (this.editor) {
        try {
          // Use Quill's clipboard to properly handle HTML content (like contract system)
          const delta = this.editor.clipboard.convert(safeContent);
          this.editor.setContents(delta);
          console.log("‚úÖ [PDF-SYSTEM] Content set in Quill editor using proper method");
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error setting content in editor:", error);
          // Fallback to textarea
          const textarea = document.getElementById("template-content-textarea");
          if (textarea) {
            textarea.value = safeContent;
          }
        }
      } else {
        // Try to find the textarea fallback
        const textarea = document.getElementById("template-content-textarea");
        if (textarea) {
          textarea.value = safeContent;
        } else {
          // If editor isn't ready yet, wait a bit and try again
          setTimeout(() => {
            if (this.editor) {
              try {
                const delta = this.editor.clipboard.convert(safeContent);
                this.editor.setContents(delta);
              } catch (error) {
                console.error("‚ùå [PDF-SYSTEM] Error setting content in delayed editor:", error);
              }
            } else {
              const textarea = document.getElementById("template-content-textarea");
              if (textarea) {
                textarea.value = safeContent;
              }
            }
          }, 200);
        }
      }

      // Display extracted fields
      if (fields && fields.length > 0) {
        this.displayExtractedFields(fields);
      }
    }

    async runClientSideOCR(file) {
      try {
        console.log("üîç [PDF-SYSTEM] Starting client-side PDF processing...");
        console.log("üîç [PDF-SYSTEM] Processing file:", file.name);

        // Use PDF.js like in New.astro
        if (file.type === "application/pdf") {
          await this.processPDFWithPDFJS(file);
        } else if (file.type.startsWith("image/")) {
          await this.processImageWithCanvas(file);
        } else {
          throw new Error("Unsupported file type. Please upload PDF or image files.");
        }

        this.showNotification("File processed successfully!", "success");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Processing Error:", error);
        this.showNotification("Processing failed: " + error.message, "error");
      }
    }

    async processPDFWithPDFJS(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this; // Capture the class context
        fileReader.onload = async function (e) {
          try {
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;

            let fullText = "";
            const numPages = pdf.numPages;

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();

              console.log(
                `üîç [PDF-SYSTEM] Page ${i}: ${textContent.items.length} text items found`
              );

              // Debug: Log first few items to see what we're getting
              if (textContent.items.length > 0) {
                console.log(
                  `üîç [PDF-SYSTEM] First 3 items:`,
                  textContent.items.slice(0, 3).map((item) => ({
                    str: item.str?.substring(0, 50),
                    hasText: !!item.str?.trim(),
                  }))
                );
              }

              // Enhanced text extraction with structure detection
              const structuredText = self.extractStructuredText(textContent.items);
              console.log(
                `üîç [PDF-SYSTEM] Page ${i} extracted text length:`,
                structuredText.length
              );
              fullText += structuredText + "\n";
            }

            console.log("üîç [PDF-SYSTEM] PDF text extracted:", fullText.length, "characters");
            console.log("üîç [PDF-SYSTEM] Extracted text preview:", fullText.substring(0, 200));

            // Check if we got meaningful text (more than just whitespace or very few characters)
            const meaningfulText = fullText.trim().length > 50;

            if (!meaningfulText) {
              console.log(
                "‚ö†Ô∏è [PDF-SYSTEM] Minimal text extracted from PDF. PDF may be scanned/image-based. Converting PDF pages to images for OCR..."
              );
              // Convert PDF pages to images and run OCR
              await self.processPDFWithOCR(file);
              resolve({ success: true, text: "", ocrUsed: true });
              return;
            }

            // Replace detected fields with placeholders
            const textWithPlaceholders = self.replaceFieldsWithPlaceholders(fullText);

            // Convert to HTML format with preserved structure and placeholders
            const htmlContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  ${textWithPlaceholders}
                </div>
              </div>
            `;

            // Set content in editor using Quill's proper method
            if (self.editor) {
              const delta = self.editor.clipboard.convert(htmlContent);
              self.editor.setContents(delta);
              console.log("‚úÖ [PDF-SYSTEM] Content set in Quill editor");
            } else {
              const textarea = document.getElementById("template-content-textarea");
              if (textarea) {
                textarea.value = htmlContent;
                console.log("‚úÖ [PDF-SYSTEM] Content set in textarea");
              }
            }

            // Extract fields
            const fields = self.extractFieldsFromText(fullText);
            if (fields && fields.length > 0) {
              self.displayExtractedFields(fields);
            }

            resolve({ success: true, text: fullText });
          } catch (error) {
            console.error("‚ùå [PDF-SYSTEM] PDF processing error:", error);
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    extractStructuredText(items) {
      let result = "";
      let currentList = [];
      let inList = false;
      let listType = null;

      if (!items || items.length === 0) {
        console.log("‚ö†Ô∏è [PDF-SYSTEM] No text items found in PDF page");
        return "";
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const text = item.str || "";
        const nextItem = items[i + 1];

        // Skip empty items
        if (!text || !text.trim()) continue;

        // Detect list items (bullet points, numbers, dashes)
        const isListItem = this.detectListItem(text, item, nextItem);

        if (isListItem) {
          if (!inList) {
            // Start new list
            inList = true;
            listType = this.detectListType(text);
            currentList = [];
          }
          currentList.push(text.trim());
        } else {
          // End current list if we were in one
          if (inList) {
            result += this.formatList(currentList, listType);
            currentList = [];
            inList = false;
            listType = null;
          }

          // Detect headers (all caps, short lines, or specific patterns)
          if (this.detectHeader(text, item)) {
            result += `<h3>${text.trim()}</h3>\n`;
          } else {
            // Regular paragraph
            result += `<p>${text.trim()}</p>\n`;
          }
        }
      }

      // Close any remaining list
      if (inList) {
        result += this.formatList(currentList, listType);
      }

      return result;
    }

    detectListItem(text, currentItem, nextItem) {
      const trimmed = text.trim();

      // Check for bullet points
      if (/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ]/.test(trimmed)) return true;

      // Check for numbered lists (1., 2., etc.)
      if (/^\d+\.\s/.test(trimmed)) return true;

      // Check for lettered lists (a., b., etc.)
      if (/^[a-zA-Z]\.\s/.test(trimmed)) return true;

      // Check for dashes
      if (/^[-‚Äì‚Äî]\s/.test(trimmed)) return true;

      // Check for indentation (if we have position data)
      if (currentItem.transform && nextItem && nextItem.transform) {
        const currentX = currentItem.transform[4];
        const nextX = nextItem.transform[4];
        if (currentX > nextX + 20) return true; // Indented more than next item
      }

      return false;
    }

    detectListType(text) {
      if (/^\d+\.\s/.test(text.trim())) return "ol";
      if (/^[a-zA-Z]\.\s/.test(text.trim())) return "ol";
      return "ul";
    }

    detectHeader(text, item) {
      const trimmed = text.trim();

      // All caps and short
      if (trimmed === trimmed.toUpperCase() && trimmed.length < 50 && trimmed.length > 3)
        return true;

      // Common header patterns
      if (/^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY)/i.test(trimmed))
        return true;

      // Short lines that might be headers
      if (trimmed.length < 30 && /^[A-Z]/.test(trimmed)) return true;

      return false;
    }

    formatList(items, type) {
      if (items.length === 0) return "";

      const listItems = items
        .map((item) => {
          // Clean up the item text
          const cleaned = item.replace(/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ\-\d+\.\s*[a-zA-Z]\.\s*]/, "").trim();
          return `<li>${cleaned}</li>`;
        })
        .join("\n");

      return `<${type}>\n${listItems}\n</${type}>\n\n`;
    }

    extractStructuredTextFromString(text) {
      // Split text into lines and process each line
      const lines = text.split("\n");
      let result = "";
      let currentList = [];
      let inList = false;
      let listType = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const nextLine = lines[i + 1]?.trim();

        // Skip empty lines
        if (!line) continue;

        // Detect list items (bullet points, numbers, dashes)
        const isListItem = this.detectListItemFromString(line);

        if (isListItem) {
          if (!inList) {
            // Start new list
            inList = true;
            listType = this.detectListTypeFromString(line);
            currentList = [];
          }
          currentList.push(line);
        } else {
          // End current list if we were in one
          if (inList) {
            result += this.formatList(currentList, listType);
            currentList = [];
            inList = false;
            listType = null;
          }

          // Detect headers (all caps, short lines, or specific patterns)
          if (this.detectHeaderFromString(line)) {
            result += `<h3>${line}</h3>\n`;
          } else {
            // Regular paragraph
            result += `<p>${line}</p>\n`;
          }
        }
      }

      // Close any remaining list
      if (inList) {
        result += this.formatList(currentList, listType);
      }

      return result;
    }

    detectListItemFromString(line) {
      // Check for bullet points
      if (/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ]/.test(line)) return true;

      // Check for numbered lists (1., 2., etc.)
      if (/^\d+\.\s/.test(line)) return true;

      // Check for lettered lists (a., b., etc.)
      if (/^[a-zA-Z]\.\s/.test(line)) return true;

      // Check for dashes
      if (/^[-‚Äì‚Äî]\s/.test(line)) return true;

      return false;
    }

    detectListTypeFromString(line) {
      if (/^\d+\.\s/.test(line)) return "ol";
      if (/^[a-zA-Z]\.\s/.test(line)) return "ol";
      return "ul";
    }

    detectHeaderFromString(line) {
      // All caps and short
      if (line === line.toUpperCase() && line.length < 50 && line.length > 3) return true;

      // Common header patterns
      if (/^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY)/i.test(line))
        return true;

      // Short lines that might be headers
      if (line.length < 30 && /^[A-Z]/.test(line)) return true;

      return false;
    }

    async processPDFWithOCR(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this;
        fileReader.onload = async function (e) {
          try {
            console.log("üîç [PDF-SYSTEM] Converting PDF to images for OCR...");
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
            const numPages = pdf.numPages;

            let allExtractedText = "";

            // Show loading state
            const loadingContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <h2>Processing PDF with OCR...</h2>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  <p>Converting ${numPages} page(s) to images and running OCR...</p>
                  <p>Please wait...</p>
                </div>
              </div>
            `;

            if (self.editor) {
              const delta = self.editor.clipboard.convert(loadingContent);
              self.editor.setContents(delta);
            }

            // Process each page
            for (let i = 1; i <= numPages; i++) {
              console.log(`üîç [PDF-SYSTEM] Processing page ${i}/${numPages} with OCR...`);

              const page = await pdf.getPage(i);
              const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR

              // Create canvas to render PDF page
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              // Render PDF page to canvas
              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;

              // Convert canvas to blob
              const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));

              // Create a File object from the blob
              const imageFile = new File([blob], `page-${i}.png`, { type: "image/png" });

              // Run OCR on this page
              try {
                const ocrResult = await self.runOCROnImage(imageFile, i);
                if (ocrResult && ocrResult.text) {
                  // Store both text and structured data
                  allExtractedText += `\n--- Page ${i} ---\n${ocrResult.text}\n`;
                  // Store structured OCR data for layout preservation
                  if (!self.ocrResultsByPage) {
                    self.ocrResultsByPage = [];
                  }
                  self.ocrResultsByPage.push({
                    page: i,
                    text: ocrResult.text,
                    words: ocrResult.words,
                    rawResult: ocrResult.rawResult,
                  });
                }
              } catch (ocrError) {
                console.error(`‚ùå [PDF-SYSTEM] OCR failed for page ${i}:`, ocrError);
              }
            }

            if (allExtractedText.trim().length > 0) {
              console.log(
                "üîç [PDF-SYSTEM] OCR completed. Total text length:",
                allExtractedText.length
              );

              // Try to preserve layout using OCR word positions
              let htmlContent = "";

              if (self.ocrResultsByPage && self.ocrResultsByPage.length > 0) {
                // Use structured OCR data with positions
                console.log("üîç [PDF-SYSTEM] Using structured OCR data to preserve layout...");

                let structuredHTML = "";
                self.ocrResultsByPage.forEach((pageData) => {
                  if (pageData.words && pageData.words.length > 0) {
                    const pageHTML = self.convertOCRToStructuredHTML(pageData.words);
                    structuredHTML += `<div class="ocr-page" style="margin-bottom: 2em; page-break-after: always;">
                      <h4 style="color: #666; font-size: 0.9em; margin-bottom: 1em;">Page ${pageData.page}</h4>
                      ${pageHTML}
                    </div>`;
                  } else {
                    // Fallback to plain text if no word positions
                    structuredHTML += `<div class="ocr-page" style="margin-bottom: 2em;">
                      <h4 style="color: #666; font-size: 0.9em; margin-bottom: 1em;">Page ${pageData.page}</h4>
                      <div style="white-space: pre-wrap; font-family: monospace;">${pageData.text.replace(/\n/g, "<br>")}</div>
                    </div>`;
                  }
                });

                // Replace detected fields with placeholders in the structured HTML
                const textWithPlaceholders = self.replaceFieldsWithPlaceholders(allExtractedText);

                // Merge structured layout with placeholders (simplified - could be improved)
                htmlContent = `
               
                      ${structuredHTML}
                  
                `;
              } else {
                // Fallback: Use plain text with structure detection
                const structuredText = self.extractStructuredTextFromString(allExtractedText);
                const textWithPlaceholders = self.replaceFieldsWithPlaceholders(allExtractedText);

                htmlContent = `
                  <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                    <h2>Extracted from PDF (OCR)</h2>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                      ${textWithPlaceholders}
                    </div>
                  </div>
                `;
              }

              // Set content in editor
              if (self.editor) {
                const delta = self.editor.clipboard.convert(htmlContent);
                self.editor.setContents(delta);
                console.log("‚úÖ [PDF-SYSTEM] OCR content set in Quill editor");
              }

              // Extract fields
              const fields = self.extractFieldsFromText(allExtractedText);
              if (fields && fields.length > 0) {
                self.displayExtractedFields(fields);
              }

              resolve({ success: true, text: allExtractedText });
            } else {
              throw new Error("OCR did not extract any text from the PDF");
            }
          } catch (error) {
            console.error("‚ùå [PDF-SYSTEM] PDF OCR processing error:", error);
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    async runOCROnImage(imageFile, pageNum = null) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append("file", imageFile);
        formData.append("language", "eng");
        formData.append("isOverlayRequired", "true"); // Get position data for layout preservation
        formData.append("OCREngine", "2");
        formData.append("detectOrientation", "true"); // Better for rotated/scanned documents
        formData.append("scale", "true"); // Scale for better quality

        fetch("https://api.ocr.space/parse/image", {
          method: "POST",
          headers: {
            apikey: "K81932338788957",
          },
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.IsErroredOnProcessing) {
              reject(new Error(data.ErrorMessage || "OCR processing failed"));
              return;
            }

            if (data.ParsedResults && data.ParsedResults[0]) {
              const result = data.ParsedResults[0];
              const extractedText = result.ParsedText ? result.ParsedText.trim() : "";

              // Get structured data with word positions for layout preservation
              // OCR.space returns WordsOverlay with Lines array, each containing Words array
              let wordOverlay = [];
              if (result.WordsOverlay && result.WordsOverlay.Lines) {
                wordOverlay = result.WordsOverlay.Lines;
              } else if (result.WordsOverlay && Array.isArray(result.WordsOverlay)) {
                // Alternative structure
                wordOverlay = result.WordsOverlay;
              }

              console.log("üîç [PDF-SYSTEM] OCR word overlay structure:", {
                hasWordsOverlay: !!result.WordsOverlay,
                hasLines: !!(result.WordsOverlay && result.WordsOverlay.Lines),
                linesCount: wordOverlay.length,
              });

              // Return both text and layout information
              resolve({
                text: extractedText,
                words: wordOverlay,
                rawResult: result,
              });
            } else {
              reject(new Error("No text extracted from OCR"));
            }
          })
          .catch((error) => {
            reject(error);
          });
      });
    }

    // Convert OCR words with positions to HTML with preserved layout
    convertOCRToStructuredHTML(ocrResults) {
      if (!ocrResults || !Array.isArray(ocrResults) || ocrResults.length === 0) {
        return "";
      }

      // Group words by Y position to detect lines
      const lines = [];
      const yTolerance = 5; // Pixels tolerance for same line

      ocrResults.forEach((word, index) => {
        if (!word.Words || word.Words.length === 0) return;

        word.Words.forEach((w) => {
          const wordText = w.WordText || "";
          if (!wordText.trim()) return;

          const y = Math.round(w.Top);
          const x = Math.round(w.Left);

          // Find existing line at similar Y position
          let foundLine = false;
          for (let i = 0; i < lines.length; i++) {
            if (Math.abs(lines[i].y - y) <= yTolerance) {
              lines[i].words.push({ text: wordText, x: x, width: w.Width || 0 });
              foundLine = true;
              break;
            }
          }

          if (!foundLine) {
            lines.push({ y: y, words: [{ text: wordText, x: x, width: w.Width || 0 }] });
          }
        });
      });

      // Sort lines by Y position
      lines.sort((a, b) => a.y - b.y);

      // Sort words within each line by X position
      lines.forEach((line) => {
        line.words.sort((a, b) => a.x - b.x);
      });

      // Convert to HTML with structure detection
      let html = "";
      let currentParagraph = [];
      let lastLineY = null;
      const paragraphSpacing = 15; // Pixels between lines to consider new paragraph

      lines.forEach((line, index) => {
        const lineText = line.words.map((w) => w.text).join(" ");
        const lineY = line.y;

        // Detect paragraph breaks based on Y spacing
        if (lastLineY !== null && lineY - lastLineY > paragraphSpacing) {
          // New paragraph
          if (currentParagraph.length > 0) {
            html += this.formatParagraph(currentParagraph.join(" "));
            currentParagraph = [];
          }
        }

        // Detect headers (all caps, short lines, centered-ish)
        const isHeader = this.detectHeaderFromOCR(line);
        if (isHeader) {
          // Close current paragraph if any
          if (currentParagraph.length > 0) {
            html += this.formatParagraph(currentParagraph.join(" "));
            currentParagraph = [];
          }
          html += `<h3 style="margin-top: 1em; margin-bottom: 0.5em;">${lineText}</h3>\n`;
        } else {
          currentParagraph.push(lineText);
        }

        lastLineY = lineY;
      });

      // Close last paragraph
      if (currentParagraph.length > 0) {
        html += this.formatParagraph(currentParagraph.join(" "));
      }

      return html;
    }

    formatParagraph(text) {
      if (!text || !text.trim()) return "";
      // Detect list items
      if (this.detectListItemFromString(text.trim())) {
        const listType = this.detectListTypeFromString(text.trim());
        return `<li>${text.trim()}</li>\n`;
      }
      return `<p style="margin: 0.5em 0; line-height: 1.6;">${text.trim()}</p>\n`;
    }

    detectHeaderFromOCR(line) {
      const lineText = line.words.map((w) => w.text).join(" ");
      const text = lineText.trim();

      // All caps and short
      if (text === text.toUpperCase() && text.length < 50 && text.length > 3) return true;

      // Common header patterns
      if (
        /^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY|AFFIDAVIT|CERTIFICATE|DECLARATION)/i.test(
          text
        )
      )
        return true;

      // Short lines that might be headers
      if (text.length < 30 && /^[A-Z]/.test(text)) return true;

      // Check if line is mostly centered (words spread out more)
      if (line.words.length > 0) {
        const firstWordX = line.words[0].x;
        const lastWordX =
          line.words[line.words.length - 1].x + (line.words[line.words.length - 1].width || 0);
        const lineWidth = lastWordX - firstWordX;
        // If words are spread out (centered-ish), might be a header
        // This is a heuristic - headers often have more spacing
      }

      return false;
    }

    async processImageWithCanvas(file) {
      return new Promise((resolve, reject) => {
        const self = this; // Capture the class context

        console.log("üîç [PDF-SYSTEM] Processing image with OCR...");

        // Show loading state
        const loadingContent = `
          <div style="font-family: Arial, sans-serif; line-height: 1.6;">
            <h2>Processing Image...</h2>
            <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
              <p>Running OCR on: ${file.name}</p>
              <p>Please wait while we extract text from the image...</p>
            </div>
          </div>
        `;

        // Set loading content
        if (self.editor) {
          const delta = self.editor.clipboard.convert(loadingContent);
          self.editor.setContents(delta);
        }

        // Send to OCR.space API (like in ocr.astro and New.astro)
        const formData = new FormData();
        formData.append("file", file);
        formData.append("language", "eng");
        formData.append("isOverlayRequired", "false");
        formData.append("OCREngine", "2");

        fetch("https://api.ocr.space/parse/image", {
          method: "POST",
          headers: {
            apikey: "K81932338788957", // Same API key as used in ocr.astro
          },
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("üîç [PDF-SYSTEM] OCR API response:", data);

            if (data.IsErroredOnProcessing) {
              throw new Error(data.ErrorMessage || "OCR processing failed");
            }

            if (data.ParsedResults && data.ParsedResults[0] && data.ParsedResults[0].ParsedText) {
              const extractedText = data.ParsedResults[0].ParsedText;
              console.log("üîç [PDF-SYSTEM] OCR completed. Text length:", extractedText.length);

              // Apply structure detection to the extracted text
              const structuredText = self.extractStructuredTextFromString(extractedText);

              // Replace detected fields with placeholders
              const textWithPlaceholders = self.replaceFieldsWithPlaceholders(extractedText);

              // Convert to HTML format with preserved structure and placeholders
              const htmlContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <h2>Extracted from Image (OCR)</h2>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  ${textWithPlaceholders}
                </div>
              </div>
            `;

              // Set content in editor using Quill's proper method
              if (self.editor) {
                const delta = self.editor.clipboard.convert(htmlContent);
                self.editor.setContents(delta);
              } else {
                const textarea = document.getElementById("template-content-textarea");
                if (textarea) {
                  textarea.value = htmlContent;
                }
              }

              // Extract fields from the OCR text
              const fields = self.extractFieldsFromText(extractedText);
              if (fields && fields.length > 0) {
                self.displayExtractedFields(fields);
              }

              resolve({ success: true, text: extractedText });
            } else {
              throw new Error("No text found in image");
            }
          })
          .catch((error) => {
            console.error("‚ùå [PDF-SYSTEM] OCR Error:", error);

            const errorContent = `
            <div style="font-family: Arial, sans-serif; line-height: 1.6;">
              <h2>OCR Processing Failed</h2>
              <div style="background: #ffebee; padding: 15px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #f44336;">
                <p><strong>Error:</strong> ${error.message}</p>
                <p>Image file: ${file.name}</p>
              </div>
            </div>
          `;

            if (self.editor) {
              const delta = self.editor.clipboard.convert(errorContent);
              self.editor.setContents(delta);
            }

            reject(error);
          });
      });
    }

    extractFieldsFromText(text) {
      const fields = [];

      // Email pattern
      const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
      const emails = text.match(emailRegex);
      if (emails) {
        emails.forEach((email) => {
          fields.push({ name: "Email", type: "email", value: email });
        });
      }

      // Enhanced phone patterns
      const phonePatterns = [
        /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g, // US format
        /(\+\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g, // International
        /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, // Simple format
        /\(\d{3}\)\s?\d{3}[-.\s]?\d{4}/g, // (123) 456-7890
      ];

      phonePatterns.forEach((pattern) => {
        const phones = text.match(pattern);
        if (phones) {
          phones.forEach((phone) => {
            if (!fields.some((f) => f.type === "phone" && f.value === phone)) {
              fields.push({ name: "Phone", type: "phone", value: phone });
            }
          });
        }
      });

      // Enhanced date patterns
      const datePatterns = [
        /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g, // MM/DD/YYYY or DD/MM/YYYY
        /\b\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b/gi, // DD Month YYYY
        /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi, // Month DD, YYYY
        /\b\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2}\b/g, // YYYY-MM-DD
        /\b\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi, // Full month names
      ];

      datePatterns.forEach((pattern) => {
        const dates = text.match(pattern);
        if (dates) {
          dates.forEach((date) => {
            if (!fields.some((f) => f.type === "date" && f.value === date)) {
              fields.push({ name: "Date", type: "date", value: date });
            }
          });
        }
      });

      // Address patterns
      const addressPatterns = [
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)\b/gi,
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)[\s,]*[A-Za-z\s]*,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/gi, // With city, state, zip
        /\b[A-Za-z\s]+,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/g, // City, State ZIP
      ];

      addressPatterns.forEach((pattern) => {
        const addresses = text.match(pattern);
        if (addresses) {
          addresses.forEach((address) => {
            if (!fields.some((f) => f.type === "address" && f.value === address)) {
              fields.push({ name: "Address", type: "address", value: address.trim() });
            }
          });
        }
      });

      // ZIP/Postal codes
      const zipRegex = /\b\d{5}(?:-\d{4})?\b/g;
      const zips = text.match(zipRegex);
      if (zips) {
        zips.forEach((zip) => {
          if (!fields.some((f) => f.type === "zip" && f.value === zip)) {
            fields.push({ name: "ZIP Code", type: "zip", value: zip });
          }
        });
      }

      // Names (simple pattern - capitalized words that might be names)
      // const nameRegex = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
      // const names = text.match(nameRegex);
      // if (names) {
      //   names.forEach((name) => {
      //     // Filter out common false positives
      //     const commonWords = [
      //       "The",
      //       "This",
      //       "That",
      //       "There",
      //       "Here",
      //       "Where",
      //       "When",
      //       "What",
      //       "How",
      //       "Why",
      //       "Who",
      //       "Which",
      //     ];
      //     if (!commonWords.some((word) => name.includes(word))) {
      //       if (!fields.some((f) => f.type === "name" && f.value === name)) {
      //         fields.push({ name: "Name", type: "name", value: name });
      //       }
      //     }
      //   });
      // }

      // URLs
      const urlRegex = /https?:\/\/[^\s]+/g;
      const urls = text.match(urlRegex);
      if (urls) {
        urls.forEach((url) => {
          fields.push({ name: "URL", type: "url", value: url });
        });
      }

      // Money amounts
      const moneyRegex = /\$[\d,]+(?:\.\d{2})?/g;
      const amounts = text.match(moneyRegex);
      if (amounts) {
        amounts.forEach((amount) => {
          fields.push({ name: "Amount", type: "money", value: amount });
        });
      }

      // Social Security Numbers
      const ssnRegex = /\b\d{3}-?\d{2}-?\d{4}\b/g;
      const ssns = text.match(ssnRegex);
      if (ssns) {
        ssns.forEach((ssn) => {
          fields.push({ name: "SSN", type: "ssn", value: ssn });
        });
      }

      // License plates
      const licenseRegex = /\b[A-Z]{1,3}\s?\d{1,4}[A-Z]?\b/g;
      const licenses = text.match(licenseRegex);
      if (licenses) {
        licenses.forEach((license) => {
          fields.push({ name: "License Plate", type: "license", value: license });
        });
      }

      return fields;
    }

    replaceFieldsWithPlaceholders(text) {
      let result = text;
      const detectedFields = [];
      const counters = {
        date: 0,
        phone: 0,
        address: 0,
        name: 0,
        email: 0,
        number: 0,
      };
      // Track unique values to reuse placeholders
      const valueToPlaceholder = {
        date: new Map(),
        phone: new Map(),
        address: new Map(),
        name: new Map(),
        email: new Map(),
        number: new Map(),
      };

      // Replace dates with {{DATE_1}}, {{DATE_2}}, etc.
      const datePatterns = [
        /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g, // MM/DD/YYYY or DD/MM/YYYY
        /\b\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b/gi, // DD Month YYYY
        /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi, // Month DD, YYYY
        /\b\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2}\b/g, // YYYY-MM-DD
        /\b\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi, // Full month names
      ];

      datePatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.date.has(match)) {
            return valueToPlaceholder.date.get(match);
          }

          // New unique value
          counters.date++;
          const placeholder = `{{DATE_${counters.date}}}`;
          valueToPlaceholder.date.set(match, placeholder);
          detectedFields.push({
            name: `DATE_${counters.date}`,
            type: "date",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace phone numbers with {{PHONE_1}}, {{PHONE_2}}, etc.
      const phonePatterns = [
        /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g, // US format
        /(\+\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g, // International
        /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, // Simple format
        /\(\d{3}\)\s?\d{3}[-.\s]?\d{4}/g, // (123) 456-7890
      ];

      phonePatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.phone.has(match)) {
            return valueToPlaceholder.phone.get(match);
          }

          // New unique value
          counters.phone++;
          const placeholder = `{{PHONE_${counters.phone}}}`;
          valueToPlaceholder.phone.set(match, placeholder);
          detectedFields.push({
            name: `PHONE_${counters.phone}`,
            type: "phone",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace addresses with {{ADDRESS_1}}, {{ADDRESS_2}}, etc.
      const addressPatterns = [
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)\b/gi,
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)[\s,]*[A-Za-z\s]*,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/gi, // With city, state, zip
        /\b[A-Za-z\s]+,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/g, // City, State ZIP
      ];

      addressPatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.address.has(match)) {
            return valueToPlaceholder.address.get(match);
          }

          // New unique value
          counters.address++;
          const placeholder = `{{ADDRESS_${counters.address}}}`;
          valueToPlaceholder.address.set(match, placeholder);
          detectedFields.push({
            name: `ADDRESS_${counters.address}`,
            type: "address",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace names with {{NAME_1}}, {{NAME_2}}, etc.
      const nameRegex = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
      const commonWords = [
        "The",
        "This",
        "That",
        "There",
        "Here",
        "Where",
        "When",
        "What",
        "How",
        "Why",
        "Who",
        "Which",
      ];

      result = result.replace(nameRegex, (match) => {
        // Filter out common false positives
        if (!commonWords.some((word) => match.includes(word))) {
          // Check if we've seen this value before
          if (valueToPlaceholder.name.has(match)) {
            return valueToPlaceholder.name.get(match);
          }

          // New unique value
          counters.name++;
          const placeholder = `{{NAME_${counters.name}}}`;
          valueToPlaceholder.name.set(match, placeholder);
          detectedFields.push({
            name: `NAME_${counters.name}`,
            type: "name",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        }
        return match;
      });

      // Replace emails with {{EMAIL_1}}, {{EMAIL_2}}, etc.
      const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
      result = result.replace(emailRegex, (match) => {
        // Check if we've seen this value before
        if (valueToPlaceholder.email.has(match)) {
          return valueToPlaceholder.email.get(match);
        }

        // New unique value
        counters.email++;
        const placeholder = `{{EMAIL_${counters.email}}}`;
        valueToPlaceholder.email.set(match, placeholder);
        detectedFields.push({
          name: `EMAIL_${counters.email}`,
          type: "email",
          value: match,
          placeholder: placeholder,
        });
        return placeholder;
      });

      // Replace money amounts with {{NUMBER_1}}, {{NUMBER_2}}, etc.
      const moneyRegex = /\$[\d,]+(?:\.\d{2})?/g;
      result = result.replace(moneyRegex, (match) => {
        // Check if we've seen this value before
        if (valueToPlaceholder.number.has(match)) {
          return valueToPlaceholder.number.get(match);
        }

        // New unique value
        counters.number++;
        const placeholder = `{{NUMBER_${counters.number}}}`;
        valueToPlaceholder.number.set(match, placeholder);
        detectedFields.push({
          name: `NUMBER_${counters.number}`,
          type: "number",
          value: match,
          placeholder: placeholder,
        });
        return placeholder;
      });

      // Store the detected fields for later use
      this.detectedFieldsMappings = detectedFields;

      return result;
    }

    displayExtractedFields(fields) {
      const container = document.getElementById("extracted-fields");
      const fieldsList = document.getElementById("fields-list");

      // Use the detected field mappings from replaceFieldsWithPlaceholders
      // This ensures the placeholders match what's actually in the document
      const fieldsToDisplay = this.detectedFieldsMappings || fields;

      // Add unique IDs and tracking info to fields
      this.trackedFields = fieldsToDisplay.map((field, index) => ({
        id: `field_${Date.now()}_${index}`,
        name: field.name,
        type: field.type,
        value: field.value,
        originalText: field.value,
        placeholder: field.placeholder || `{{${field.name}}}`,
        isReplaced: true, // Assuming fields are already replaced in the text
        isVisible: true, // User can toggle visibility
        position: null, // Will be updated when we find it in the document
      }));

      console.log("üîç [PDF-SYSTEM] Tracked fields:", this.trackedFields);

      if (container && fieldsList) {
        container.classList.remove("hidden");
        fieldsList.innerHTML = this.trackedFields
          .map(
            (field) => `
          <div class="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-600 rounded-md gap-3 hover:bg-gray-100 dark:hover:bg-gray-500 transition-colors" 
               data-field-id="${field.id}">
            <div class="flex-1">
              <div class="flex items-center gap-2">
                <span class="font-medium text-gray-900 dark:text-white">${field.name}</span>
                <span class="text-xs text-gray-500 dark:text-gray-400">(${field.type})</span>
              </div>
              <div class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-xs text-gray-500 dark:text-gray-400">Original:</span>
                  <span class="font-mono text-xs">${field.value}</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">${field.placeholder}</span>
                </div>
              </div>
            </div>
            </div>
            <div class="flex items-center gap-2">
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.revertField(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-yellow-500 hover:bg-yellow-600 text-white rounded transition-colors"
                title="Toggle between original text and placeholder, then locate in document"
              >
                Show Original
              </button>
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.toggleFieldVisibility(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors"
                title="Show/hide in document"
              >
                ${field.isVisible ? "Hide" : "Show"}
              </button>
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.removeField(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition-colors"
                title="Remove this field detection"
              >
                Remove
              </button>
            </div>
          
        `
          )
          .join("");
      }
    }

    // Helper function to find which editor contains the field
    findEditorForField(field) {
      // First check the main editor
      if (this.editor) {
        const mainEditorText = this.editor.getText();
        const searchText = field.isReplaced ? field.placeholder : field.originalText;
        if (mainEditorText.indexOf(searchText) !== -1) {
          return this.editor;
        }
      }

      // Check all template-specific editors
      if (this.templateEditors) {
        for (const [templateId, editor] of Object.entries(this.templateEditors)) {
          if (editor) {
            try {
              const editorText = editor.getText();
              const searchText = field.isReplaced ? field.placeholder : field.originalText;
              if (editorText.indexOf(searchText) !== -1) {
                console.log(`‚úÖ [PDF-SYSTEM] Found field in template editor ${templateId}`);
                return editor;
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è [PDF-SYSTEM] Error checking template editor ${templateId}:`, error);
            }
          }
        }
      }

      // Fallback to main editor if available
      return this.editor || null;
    }

    scrollToField(fieldId) {
      return new Promise((resolve, reject) => {
        const field = this.trackedFields.find((f) => f.id === fieldId);
        if (!field) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Field not found:", fieldId);
          reject(new Error("Field not found"));
          return;
        }

        console.log(
          "üìç [PDF-SYSTEM] Scrolling to field:",
          field.name,
          "isReplaced:",
          field.isReplaced
        );

        // Find the correct editor that contains this field
        const editor = this.findEditorForField(field);
        if (!editor) {
          console.error("‚ùå [PDF-SYSTEM] Editor not found for field");
          reject(new Error("Editor not initialized"));
          return;
        }

        // Get the Quill editor's text content to find the position
        const text = editor.getText();
        // Search for what's currently in the document: placeholder if replaced, original text if not
        const searchText = field.isReplaced ? field.placeholder : field.originalText;
        const textIndex = text.indexOf(searchText);

        console.log("üîç [PDF-SYSTEM] Searching for:", searchText.substring(0, 50));
        console.log("üîç [PDF-SYSTEM] Text index:", textIndex, "Text length:", text.length);

        if (textIndex === -1) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Search text not found in document:", searchText);
          console.log("üìÑ [PDF-SYSTEM] Editor text (first 500 chars):", text.substring(0, 500));
          reject(new Error(`Text not found: ${searchText.substring(0, 50)}...`));
          return;
        }

        try {
          // Focus the editor first
          editor.focus();

          // Get the bounds of the selection first (before setting selection)
          const searchTextLength = searchText.length;
          const bounds = editor.getBounds(textIndex, searchTextLength);

          if (!bounds) {
            reject(new Error("Could not get bounds"));
            return;
          }

          console.log("üìê [PDF-SYSTEM] Bounds:", bounds);

          // Get the Quill editor's scrolling element (.ql-editor)
          const editorScrollContainer = editor.root.parentElement.querySelector(".ql-editor");

          if (editorScrollContainer) {
            // Calculate the target scroll position - center the selection
            const containerHeight = editorScrollContainer.clientHeight;
            const targetScrollTop = Math.max(
              0,
              bounds.top - containerHeight / 2 + bounds.height / 2
            );

            console.log("üìú [PDF-SYSTEM] Scrolling container:", {
              currentScroll: editorScrollContainer.scrollTop,
              targetScroll: targetScrollTop,
              boundsTop: bounds.top,
              boundsHeight: bounds.height,
              containerHeight: containerHeight,
            });

            // Wait for scroll to complete before setting selection/highlight
            const scrollDistance = Math.abs(editorScrollContainer.scrollTop - targetScrollTop);
            const estimatedScrollTime = Math.min(2000, scrollDistance / 2); // Max 2 seconds, roughly 0.5px per ms

            // Scroll the editor to show the selection smoothly
            editorScrollContainer.scrollTo({
              top: targetScrollTop,
              behavior: "smooth",
            });

            // Wait for scroll animation to complete
            let lastScrollTop = editorScrollContainer.scrollTop;
            let scrollCheckInterval;
            let scrollTimeout;

            const checkScrollComplete = () => {
              const currentScrollTop = editorScrollContainer.scrollTop;
              const isScrolling = Math.abs(currentScrollTop - lastScrollTop) > 1;

              if (isScrolling) {
                lastScrollTop = currentScrollTop;
              } else {
                // Scroll has stopped
                clearInterval(scrollCheckInterval);
                clearTimeout(scrollTimeout);

                console.log("‚úÖ [PDF-SYSTEM] Scroll completed, setting selection");

                // Set selection after scroll completes
                const searchTextLength = searchText.length;
                editor.setSelection(textIndex, searchTextLength);
                console.log(
                  "‚úÖ [PDF-SYSTEM] Selection set at index:",
                  textIndex,
                  "length:",
                  searchTextLength
                );

                // Apply highlight
                this.applyFieldHighlight(textIndex, searchTextLength, editor);
                console.log("‚úÖ [PDF-SYSTEM] Applied highlight");

                resolve();
              }
            };

            // Start checking scroll progress after a short delay
            setTimeout(() => {
              scrollCheckInterval = setInterval(checkScrollComplete, 50);
              // Fallback timeout in case scroll never "completes" (stuck)
              scrollTimeout = setTimeout(() => {
                clearInterval(scrollCheckInterval);
                console.log("‚è±Ô∏è [PDF-SYSTEM] Scroll timeout, applying selection anyway");
                const searchTextLength = searchText.length;
                editor.setSelection(textIndex, searchTextLength);
                this.applyFieldHighlight(textIndex, searchTextLength, editor);
                resolve();
              }, estimatedScrollTime + 500);
            }, 100);
          } else {
            // Fallback: scroll the root element
            const scrollTop = Math.max(0, bounds.top - editor.root.clientHeight / 2);

            editor.root.scrollTo({
              top: scrollTop,
              behavior: "smooth",
            });

            // Wait for scroll to complete (fallback)
            setTimeout(() => {
              const searchTextLength = searchText.length;
              editor.setSelection(textIndex, searchTextLength);
              this.applyFieldHighlight(textIndex, searchTextLength, editor);
              resolve();
            }, 800); // Longer timeout for fallback
          }
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error scrolling to field:", error);
          reject(error);
        }
      });
    }

    applyFieldHighlight(textIndex, length, editor = null) {
      const targetEditor = editor || this.editor;
      if (!targetEditor) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] No editor available for highlight");
        return;
      }

      try {
        // Temporarily highlight the placeholder
        const originalFormat = targetEditor.getFormat(textIndex, length);
        targetEditor.formatText(textIndex, length, {
          background: "#ffeb3b",
          color: "#000",
        });

        console.log("üé® [PDF-SYSTEM] Applied highlight");

        // Remove highlight after 2 seconds
        setTimeout(() => {
          targetEditor.formatText(textIndex, length, originalFormat);
          console.log("üé® [PDF-SYSTEM] Removed highlight");
        }, 2000);
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error applying highlight:", error);
      }
    }

    revertField(fieldId) {
      const field = this.trackedFields.find((f) => f.id === fieldId);
      if (!field) return;

      console.log("üîÑ [PDF-SYSTEM] Toggling field:", field.name, "isReplaced:", field.isReplaced);

      // Find the correct editor that contains this field
      const editor = this.findEditorForField(field);
      if (!editor) {
        console.error("‚ùå [PDF-SYSTEM] Could not find editor for field");
        return;
      }

      // Get current editor content
      const content = editor.root.innerHTML;
      let updatedContent;

      if (field.isReplaced) {
        // Currently showing placeholder, switch to original text
        updatedContent = content.replace(new RegExp(`{{${field.name}}}`, "g"), field.originalText);
        field.isReplaced = false;
        console.log("‚úÖ [PDF-SYSTEM] Field switched to original text");
      } else {
        // Currently showing original text, switch to placeholder
        updatedContent = content.replace(
          new RegExp(field.originalText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
          `{{${field.name}}}`
        );
        field.isReplaced = true;
        console.log("‚úÖ [PDF-SYSTEM] Field switched to placeholder");
      }

      // Update editor
      const delta = editor.clipboard.convert(updatedContent);
      editor.setContents(delta);

      // Update button text to reflect current state
      this.updateRevertButton(fieldId, field.isReplaced);

      // After toggling, locate the field in the document - wait longer for editor to update
      // Quill needs time to update its internal text representation after setContents
      setTimeout(async () => {
        try {
          // Wait a bit more to ensure editor text is fully updated
          await new Promise((resolve) => setTimeout(resolve, 200));

          console.log("üîÑ [PDF-SYSTEM] Attempting to scroll after field revert");
          await this.scrollToField(fieldId);
          console.log("‚úÖ [PDF-SYSTEM] Field revert complete with scroll");
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error scrolling to field after revert:", error);
          // Try one more time with original text search if placeholder search failed
          const field = this.trackedFields.find((f) => f.id === fieldId);
          if (field) {
            // Find the correct editor again (in case it changed)
            const retryEditor = this.findEditorForField(field);
            if (!retryEditor) {
              console.error("‚ùå [PDF-SYSTEM] Could not find editor for retry");
              return;
            }

            console.log("üîÑ [PDF-SYSTEM] Retrying with alternative search...");
            // Try searching for the opposite (what we just switched to)
            const text = retryEditor.getText();
            const alternativeSearch = field.isReplaced ? field.originalText : field.placeholder;
            const altIndex = text.indexOf(alternativeSearch);
            if (altIndex !== -1) {
              console.log("‚úÖ [PDF-SYSTEM] Found text with alternative search, scrolling...");
              // Force a direct scroll to the found text
              try {
                const bounds = retryEditor.getBounds(altIndex, alternativeSearch.length);
                if (bounds) {
                  const editorScrollContainer =
                    retryEditor.root.parentElement.querySelector(".ql-editor");
                  if (editorScrollContainer) {
                    const containerHeight = editorScrollContainer.clientHeight;
                    const targetScrollTop = Math.max(
                      0,
                      bounds.top - containerHeight / 2 + bounds.height / 2
                    );
                    editorScrollContainer.scrollTo({ top: targetScrollTop, behavior: "smooth" });
                    setTimeout(() => {
                      retryEditor.setSelection(altIndex, alternativeSearch.length);
                      this.applyFieldHighlight(altIndex, alternativeSearch.length, retryEditor);
                    }, 800);
                  }
                }
              } catch (retryError) {
                console.error("‚ùå [PDF-SYSTEM] Retry also failed:", retryError);
              }
            }
          }
        }
      }, 300); // Increased delay to ensure editor is updated
    }

    updateRevertButton(fieldId, isReplaced) {
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        const revertButton = fieldElement.querySelector(
          "button[title*='Toggle between original text and placeholder']"
        );
        if (revertButton) {
          revertButton.textContent = isReplaced ? "Show Original" : "Show Placeholder";
          revertButton.title = isReplaced
            ? "Show original text and locate in document"
            : "Show placeholder text and locate in document";
        }
      }
    }

    toggleFieldVisibility(fieldId) {
      const field = this.trackedFields.find((f) => f.id === fieldId);
      if (!field) return;

      field.isVisible = !field.isVisible;

      // Update the UI button
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        const button = fieldElement.querySelector("button:nth-child(2)");
        if (button) {
          button.textContent = field.isVisible ? "Hide" : "Show";
        }
      }

      // Get current editor content
      const content = this.editor.root.innerHTML;

      if (field.isVisible) {
        // Show the field (replace with placeholder)
        const updatedContent = content.replace(
          new RegExp(field.originalText, "g"),
          `{{${field.name}}}`
        );
        const delta = this.editor.clipboard.convert(updatedContent);
        this.editor.setContents(delta);
      } else {
        // Hide the field (replace with empty or original)
        const updatedContent = content.replace(
          new RegExp(`{{${field.name}}}`, "g"),
          field.originalText
        );
        const delta = this.editor.clipboard.convert(updatedContent);
        this.editor.setContents(delta);
      }

      console.log(
        `${field.isVisible ? "üëÅÔ∏è" : "üôà"} [PDF-SYSTEM] Field visibility toggled:`,
        field.name
      );
    }

    removeField(fieldId) {
      const fieldIndex = this.trackedFields.findIndex((f) => f.id === fieldId);
      if (fieldIndex === -1) return;

      const field = this.trackedFields[fieldIndex];
      console.log("üóëÔ∏è [PDF-SYSTEM] Removing field:", field.name);

      // Revert the field before removing
      this.revertField(fieldId);

      // Remove from tracked fields
      this.trackedFields.splice(fieldIndex, 1);

      // Remove from UI
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        fieldElement.remove();
      }

      console.log("‚úÖ [PDF-SYSTEM] Field removed");
    }

    async saveTemplate() {
      // Get name directly from DOM (in case templateNameInput wasn't initialized)
      // Try multiple possible IDs: template-name, template-name-${id} for inline editing
      let nameInput = this.templateNameInput;

      if (!nameInput) {
        // Try the main editor input first
        nameInput = document.getElementById("template-name");

        // If not found and we have a selected template, try the dynamic ID
        if (!nameInput && this.selectedTemplate) {
          nameInput = document.getElementById(`template-name-${this.selectedTemplate}`);
        }

        // Also try to find any template-name-* input if we're in an accordion context
        if (!nameInput) {
          const allNameInputs = document.querySelectorAll('[id^="template-name-"]');
          if (allNameInputs.length > 0) {
            // Find the one that's visible (not in a hidden accordion)
            nameInput =
              Array.from(allNameInputs).find(
                (input) => input.offsetParent !== null // Check if element is visible
              ) || allNameInputs[0]; // Fallback to first one
          }
        }
      }

      const name = nameInput?.value?.trim() || "";

      // Get type select - also try dynamic ID
      let typeSelect = this.templateTypeSelect;
      if (!typeSelect) {
        typeSelect = document.getElementById("template-type");
        if (!typeSelect && this.selectedTemplate) {
          typeSelect = document.getElementById(`template-type-${this.selectedTemplate}`);
        }
      }
      const type = typeSelect?.value || "body";

      const content = this.editor
        ? this.editor.root.innerHTML
        : document.getElementById("template-content-textarea")?.value || "";

      // Helper function to check if HTML content is empty (only whitespace/empty tags)
      const isContentEmpty = (html) => {
        if (!html || !html.trim()) return true;
        // Remove HTML tags and check if only whitespace remains
        const textContent = html.replace(/<[^>]*>/g, "").trim();
        // Also check for common empty Quill patterns like <p><br></p> or <p></p>
        const emptyPatterns = /^(<p><br><\/p>|<p><\/p>|<br\s*\/?>|\s*)*$/i;
        return !textContent || emptyPatterns.test(html);
      };

      const saveHtmlCheckbox = document.getElementById("save-html-template-checkbox");
      const saveHtml =
        saveHtmlCheckbox && saveHtmlCheckbox instanceof HTMLInputElement
          ? saveHtmlCheckbox.checked
          : false;

      // Debug logging
      console.log(
        "üíæ [PDF-SYSTEM] Saving template - Name:",
        name,
        "Content length:",
        content?.length || 0
      );

      // Improved validation with specific error messages
      if (!name) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] Validation failed: Template name is empty");
        this.showNotification("Please enter a template name", "error");
        return;
      }

      if (isContentEmpty(content)) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] Validation failed: Template content is empty");
        this.showNotification("Please add content to the template", "error");
        return;
      }

      try {
        const response = await fetch("/api/pdf/templates/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            id: this.selectedTemplate,
            name,
            description: "",
            content,
            templateType: type,
            pageSize: "8.5x11",
            saveHtml: saveHtml, // Include the checkbox value
          }),
        });

        const data = await response.json();
        if (data.success) {
          this.showNotification("Template saved successfully!", "success");
          this.closeTemplateEditor();
          await this.loadTemplates();
        } else {
          this.showNotification("Error saving template: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error saving template:", error);
        this.showNotification("Error saving template", "error");
      }
    }

    async loadTemplatesForGeneration() {
      // Load templates for the generate tab
      await this.loadTemplates();

      const select = document.getElementById("template-select");
      if (select) {
        select.innerHTML =
          '<option value="">Choose a template...</option>' +
          this.templates
            .map(
              (template) =>
                `<option value="${template.id}">${template.name} (${template.templateType})</option>`
            )
            .join("");

        // Set up template selection listener if not already set
        if (!select.dataset.listenerAttached) {
          select.addEventListener("change", (e) => {
            const templateId = e.target.value;
            this.selectedTemplate = templateId || null;

            if (this.selectedTemplate && this.selectedContactData) {
              this.updatePlaceholderMappingUI();

              // Check if both template and user are selected, trigger mapping workflow
              // Use setTimeout to ensure DOM and data are ready
              if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
                setTimeout(() => {
                  this.startPlaceholderMappingWorkflow();
                }, 100);
              }
            } else {
              this.hidePlaceholderMappingUI();
            }
          });
          select.dataset.listenerAttached = "true";
        }
      }
    }

    async searchUsers() {
      const query = document.getElementById("user-search")?.value;
      if (!query) {
        this.showNotification("Please enter a search term", "error");
        return;
      }

      try {
        const response = await fetch("/api/users/search", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({ query }),
        });

        const data = await response.json();
        if (data.success) {
          this.users = data.data || [];
          this.renderUserResults();
        } else {
          this.showNotification("Error searching users: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error searching users:", error);
        this.showNotification("Error searching users", "error");
      }
    }

    setupUserInputWatcher() {
      // Watch for changes to the hidden input value from SlotMachineModalFunction
      // The hidden input has id="user-search-value" (component id + "-value")
      const hiddenInput = document.getElementById("user-search-value");

      if (!hiddenInput) {
        // Retry if input doesn't exist yet (component might not be initialized)
        setTimeout(() => this.setupUserInputWatcher(), 100);
        return;
      }

      // Store initial value to avoid triggering on page load
      const initialValue = hiddenInput.value || "";

      // Use MutationObserver to watch for value changes
      const observer = new MutationObserver(() => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's not the initial value on load
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Watch for changes to the value attribute
      observer.observe(hiddenInput, {
        attributes: true,
        attributeFilter: ["value"],
      });

      // Also watch for direct value property changes using input event
      hiddenInput.addEventListener("input", () => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's different from what we currently have
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Also watch for change events
      hiddenInput.addEventListener("change", () => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's different from what we currently have
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Don't do initial check - only trigger on actual changes
      // The slot-select event will handle the initial selection

      console.log("‚úÖ [PDF-SYSTEM] User input watcher set up for user-search-value");
    }

    selectUser(userId) {
      this.selectedUser = userId;
      this.showNotification("User selected", "success");

      // Check if both template and user are selected, trigger mapping workflow
      // Use setTimeout to ensure DOM and data are ready
      if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
        setTimeout(() => {
          this.startPlaceholderMappingWorkflow();
        }, 100);
      }
    }

    async previewPDF() {
      if (!this.selectedTemplate || !this.selectedUser) {
        this.showNotification("Please select a template and user", "error");
        return;
      }

      // Open preview in new window
      const previewUrl = `/api/pdf/preview?templateId=${this.selectedTemplate}&userId=${this.selectedUser}`;
      window.open(previewUrl, "_blank");
    }

    // Extract all placeholders from template content
    extractPlaceholdersFromTemplate(template) {
      if (!template) return [];

      // Get content from template (could be HTML or plain text)
      let content = template.html_content || template.content || "";

      // If content is HTML, extract text content to find placeholders
      // Placeholders might be in HTML attributes or text nodes
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = content;

      // Get all text content including from HTML
      const textContent = tempDiv.textContent || tempDiv.innerText || content;

      // Also check the raw HTML for placeholders in attributes
      const fullContent = textContent + " " + content;

      // Match placeholders: {{PLACEHOLDER_NAME}}
      const placeholderRegex = /\{\{([^}]+)\}\}/g;
      const placeholders = new Set();
      let match;

      // Search in both text content and raw HTML
      while ((match = placeholderRegex.exec(fullContent)) !== null) {
        const placeholder = match[1].trim();
        // Skip empty placeholders
        if (placeholder) {
          placeholders.add(placeholder);
        }
      }

      return Array.from(placeholders);
    }

    // Start the interactive placeholder mapping workflow
    async startPlaceholderMappingWorkflow() {
      console.log("üéØ [PDF-SYSTEM] Starting placeholder mapping workflow");

      // Ensure templates are loaded
      if (!this.templates || this.templates.length === 0) {
        console.log("üîÑ [PDF-SYSTEM] Templates not loaded, loading now...");
        await this.loadTemplatesForGeneration();
      }

      // Find the selected template - try both string and number comparison
      let template = this.templates.find((t) => t.id === this.selectedTemplate);

      // If not found, try converting IDs to strings for comparison
      if (!template) {
        template = this.templates.find((t) => String(t.id) === String(this.selectedTemplate));
      }

      // If still not found, try loading template directly from API
      if (!template && this.selectedTemplate) {
        console.log("üîÑ [PDF-SYSTEM] Template not in cache, fetching from API...");
        try {
          const response = await fetch(`/api/pdf/templates/get?id=${this.selectedTemplate}`, {
            credentials: "include",
          });
          const data = await response.json();
          if (data.success && data.data && data.data.templates && data.data.templates.length > 0) {
            template = data.data.templates[0];
            // Add to templates array if not already there
            if (!this.templates.find((t) => String(t.id) === String(template.id))) {
              this.templates.push(template);
            }
          }
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error fetching template:", error);
        }
      }

      if (!template) {
        console.error("‚ùå [PDF-SYSTEM] Template not found:", {
          selectedTemplate: this.selectedTemplate,
          templatesCount: this.templates?.length || 0,
          templateIds: this.templates?.map((t) => ({ id: t.id, type: typeof t.id })) || [],
        });
        this.showNotification(
          "Template not found. Please try selecting the template again.",
          "error"
        );
        return;
      }

      // Extract placeholders
      const placeholders = this.extractPlaceholdersFromTemplate(template);
      if (placeholders.length === 0) {
        this.showNotification("No placeholders found in template", "info");
        return;
      }

      // Store placeholders for workflow
      this.placeholdersList = placeholders;
      this.currentPlaceholderIndex = 0;

      // Show template preview section
      const previewSection = document.getElementById("template-preview-section");
      if (previewSection) {
        previewSection.classList.remove("hidden");
      }

      // Render template with highlighted placeholders
      await this.renderTemplatePreview(template);

      // Setup tooltip event listeners
      this.setupPlaceholderTooltipListeners();

      // Handle already-mapped placeholders (show them as green)
      Object.keys(this.placeholderMappings).forEach((placeholderName) => {
        const mapping = this.placeholderMappings[placeholderName];
        const elements = this.placeholderElements.filter(
          (el) => el.dataset.placeholder === placeholderName
        );
        elements.forEach((el) => {
          el.classList.remove(
            "bg-yellow-200",
            "dark:bg-yellow-900",
            "border-yellow-400",
            "dark:border-yellow-600"
          );
          el.classList.add(
            "bg-green-200",
            "dark:bg-green-900",
            "border-green-400",
            "dark:border-green-600"
          );
          el.textContent = mapping.value;
          el.title = `Mapped from ${mapping.source === "contact" ? "contact field" : "manual entry"}`;
        });
      });

      // Start with first placeholder
      this.highlightNextPlaceholder();
    }

    // Render template preview with placeholders highlighted
    async renderTemplatePreview(template) {
      const container = document.getElementById("template-preview-container");
      if (!container) return;

      let content = template.html_content || template.content || "";

      // Create a temporary div to parse HTML
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = content;

      // Find and replace placeholders with highlighted spans
      const placeholderRegex = /\{\{([^}]+)\}\}/g;
      const processedContent = content.replace(placeholderRegex, (match, placeholderName) => {
        const trimmedName = placeholderName.trim();
        return `<span 
          class="placeholder-highlight bg-yellow-200 dark:bg-yellow-900 border-2 border-yellow-400 dark:border-yellow-600 rounded px-1 cursor-pointer" 
          data-placeholder="${trimmedName}"
          data-placeholder-raw="${match}"
        >${match}</span>`;
      });

      container.innerHTML = processedContent;

      // Store placeholder elements
      this.placeholderElements = Array.from(container.querySelectorAll(".placeholder-highlight"));

      // Update progress
      this.updatePlaceholderProgress();
    }

    // Highlight next placeholder and scroll to it
    highlightNextPlaceholder() {
      if (!this.placeholdersList || this.currentPlaceholderIndex >= this.placeholdersList.length) {
        // All placeholders processed
        const unmappedCount = this.placeholdersList.filter(
          (p) => !this.placeholderMappings[p]
        ).length;

        if (unmappedCount === 0) {
          this.showNotification("All placeholders mapped!", "success");
        } else {
          this.showNotification(`${unmappedCount} placeholders skipped`, "info");
        }
        this.finishPlaceholderMapping();
        return;
      }

      const currentPlaceholder = this.placeholdersList[this.currentPlaceholderIndex];

      // Skip if already mapped
      if (this.placeholderMappings[currentPlaceholder]) {
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
        return;
      }

      const placeholderElement = this.placeholderElements.find(
        (el) => el.dataset.placeholder === currentPlaceholder
      );

      if (!placeholderElement) {
        // Move to next if element not found
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
        return;
      }

      // Remove previous highlights
      this.placeholderElements.forEach((el) => {
        el.classList.remove("ring-4", "ring-blue-500", "ring-offset-2");
      });

      // Highlight current placeholder
      placeholderElement.classList.add("ring-4", "ring-blue-500", "ring-offset-2");

      // Scroll to placeholder, then show tooltip after scroll completes
      this.scrollToPlaceholder(placeholderElement);

      // Wait for scroll to complete before showing tooltip
      setTimeout(() => {
        this.showPlaceholderTooltip(placeholderElement, currentPlaceholder);
      }, 500); // Wait for smooth scroll animation to complete
    }

    // Scroll to placeholder element
    scrollToPlaceholder(element) {
      if (!element) return;

      // Calculate position relative to viewport
      const elementRect = element.getBoundingClientRect();
      const viewportHeight = window.innerHeight;

      // Calculate scroll position to center the element in the viewport
      const scrollY =
        window.scrollY + elementRect.top - viewportHeight / 2 + elementRect.height / 2;

      // Scroll the page to center the element
      window.scrollTo({
        top: Math.max(0, scrollY),
        behavior: "smooth",
      });
    }

    // Show tooltip with contact field options
    async showPlaceholderTooltip(element, placeholderName) {
      console.log("üîç [PDF-SYSTEM] Showing tooltip for placeholder:", placeholderName);
      const tooltip = document.getElementById("placeholder-tooltip");
      if (!tooltip) {
        console.error("‚ùå [PDF-SYSTEM] Tooltip element not found!");
        return;
      }

      // Set placeholder name
      const nameSpan = document.getElementById("tooltip-placeholder-name");
      if (nameSpan) {
        nameSpan.textContent = `{{${placeholderName}}}`;
      }

      // Get contact fields and default values
      const contactFields = this.getAvailableContactFields(this.selectedContactData);
      const defaultFields = await this.getDefaultPlaceholderFields();
      const allFields = [...defaultFields, ...contactFields];
      console.log("üîç [PDF-SYSTEM] All fields:", allFields);

      // Render contact field options
      const fieldsContainer = document.getElementById("tooltip-contact-fields");
      if (fieldsContainer) {
        if (allFields.length === 0) {
          fieldsContainer.innerHTML =
            '<p class="text-sm text-gray-500 dark:text-gray-400">No fields available</p>';
        } else {
          fieldsContainer.innerHTML = allFields
            .map(
              (field) => `
            <button
              class="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors border border-gray-200 dark:border-gray-700 placeholder-field-btn ${field.isDefault ? "bg-blue-50 dark:bg-blue-900/20" : ""}"
              data-field-key="${field.key}"
              data-field-value="${field.value || ""}"
              data-is-default="${field.isDefault || false}"
            >
              <div class="font-medium text-sm text-gray-900 dark:text-white">
                ${field.label}
                ${field.isDefault ? '<span class="ml-2 text-xs text-blue-600 dark:text-blue-400">(default)</span>' : ""}
              </div>
              <div class="text-xs text-gray-500 dark:text-gray-400 mt-1 truncate">${field.value || "No value"}</div>
            </button>
          `
            )
            .join("");
        }
      }

      // Show tooltip first (but hidden) to get its dimensions
      tooltip.classList.remove("hidden");
      tooltip.style.display = "block";
      tooltip.style.visibility = "hidden"; // Hide but keep in layout

      // Position tooltip near the placeholder element
      this.positionTooltip(tooltip, element);

      // Make tooltip visible
      tooltip.style.visibility = "visible";

      // Store current placeholder being mapped
      this.currentMappingPlaceholder = placeholderName;
      console.log("‚úÖ [PDF-SYSTEM] Tooltip shown");
    }

    // Position tooltip relative to placeholder element
    positionTooltip(tooltip, element) {
      if (!element || !tooltip) return;

      const rect = element.getBoundingClientRect();

      // Force a layout recalculation to get accurate tooltip dimensions
      tooltip.offsetHeight; // Trigger reflow
      const tooltipRect = tooltip.getBoundingClientRect();

      // Try to position below, fallback to above if not enough space
      let top = rect.bottom + 10;
      let left = rect.left;

      // Check if tooltip would go off screen
      if (top + tooltipRect.height > window.innerHeight) {
        top = rect.top - tooltipRect.height - 10;
      }

      // Ensure tooltip doesn't go above viewport
      if (top < 10) {
        top = 10;
      }

      if (left + tooltipRect.width > window.innerWidth) {
        left = window.innerWidth - tooltipRect.width - 20;
      }

      // Ensure tooltip doesn't go off left edge
      if (left < 10) {
        left = 10;
      }

      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;

      console.log("üìç [PDF-SYSTEM] Tooltip positioned at:", {
        top,
        left,
        elementRect: rect,
        tooltipRect,
      });
    }

    // Setup tooltip event listeners (only once)
    setupPlaceholderTooltipListeners() {
      // Check if already set up
      if (this.tooltipListenersSetup) return;
      this.tooltipListenersSetup = true;

      // Close tooltip button
      document.getElementById("close-tooltip-btn")?.addEventListener("click", () => {
        this.closePlaceholderTooltip();
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
      });

      // Skip mapping button
      document.getElementById("skip-mapping-btn")?.addEventListener("click", () => {
        this.closePlaceholderTooltip();
        this.finishPlaceholderMapping();
      });

      // Contact field buttons (use event delegation)
      document.addEventListener("click", (e) => {
        if (e.target.closest(".placeholder-field-btn")) {
          const btn = e.target.closest(".placeholder-field-btn");
          const fieldKey = btn.dataset.fieldKey;
          const fieldValue = btn.dataset.fieldValue;
          this.applyPlaceholderMapping(fieldKey, fieldValue, "contact");
        }
      });

      // Manual input apply button
      document.getElementById("tooltip-apply-btn")?.addEventListener("click", () => {
        const manualInput = document.getElementById("tooltip-manual-input");
        if (manualInput && manualInput.value.trim()) {
          this.applyPlaceholderMapping(null, manualInput.value.trim(), "manual");
          manualInput.value = "";
        }
      });

      // Allow Enter key in manual input
      document.getElementById("tooltip-manual-input")?.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          document.getElementById("tooltip-apply-btn")?.click();
        }
      });
    }

    // Apply placeholder mapping
    applyPlaceholderMapping(fieldKey, value, source) {
      if (!this.currentMappingPlaceholder) return;

      // Store mapping
      this.placeholderMappings[this.currentMappingPlaceholder] = {
        source,
        fieldKey: fieldKey || null,
        value: value,
      };

      // Update template preview to show mapped value
      const placeholderElements = this.placeholderElements.filter(
        (el) => el.dataset.placeholder === this.currentMappingPlaceholder
      );

      placeholderElements.forEach((el) => {
        el.classList.remove(
          "bg-yellow-200",
          "dark:bg-yellow-900",
          "border-yellow-400",
          "dark:border-yellow-600"
        );
        el.classList.add(
          "bg-green-200",
          "dark:bg-green-900",
          "border-green-400",
          "dark:border-green-600"
        );
        el.textContent = value;
        el.title = `Mapped from ${source === "contact" ? "contact field" : "manual entry"}`;
      });

      // Close tooltip
      this.closePlaceholderTooltip();

      // Update progress
      this.updatePlaceholderProgress();

      // Move to next placeholder
      this.currentPlaceholderIndex++;
      setTimeout(() => {
        this.highlightNextPlaceholder();
      }, 300);
    }

    // Close placeholder tooltip
    closePlaceholderTooltip() {
      const tooltip = document.getElementById("placeholder-tooltip");
      if (tooltip) {
        tooltip.classList.add("hidden");
        tooltip.style.display = "none";
      }
      this.currentMappingPlaceholder = null;
    }

    // Update placeholder progress
    updatePlaceholderProgress() {
      const progressEl = document.getElementById("placeholder-progress");
      if (progressEl && this.placeholdersList) {
        const mappedCount = Object.keys(this.placeholderMappings).length;
        progressEl.textContent = `${mappedCount} of ${this.placeholdersList.length}`;
      }
    }

    // Finish placeholder mapping workflow
    finishPlaceholderMapping() {
      this.closePlaceholderTooltip();
      const previewSection = document.getElementById("template-preview-section");
      if (previewSection) {
        previewSection.classList.add("hidden");
      }

      // Update the old mapping UI as well
      if (this.selectedTemplate && this.selectedContactData) {
        this.updatePlaceholderMappingUI();
      }

      this.showNotification("Placeholder mapping complete", "success");
    }

    // Get default placeholder fields (currentDate, companyName, companyPhone)
    async getDefaultPlaceholderFields() {
      const defaultFields = [];

      // Current Date
      const currentDate = new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
      defaultFields.push({
        key: "currentDate",
        label: "Current Date",
        value: currentDate,
        isDefault: true,
      });

      // Fetch company data
      try {
        const response = await fetch("/api/global/company-data", {
          credentials: "include",
        });

        if (response.ok) {
          const data = await response.json();

          // Company Name
          if (data.company?.name) {
            defaultFields.push({
              key: "companyName",
              label: "Company Name",
              value: data.company.name,
              isDefault: true,
            });
          }

          // Company Phone
          if (data.company?.contact?.phone) {
            defaultFields.push({
              key: "companyPhone",
              label: "Company Phone",
              value: data.company.contact.phone,
              isDefault: true,
            });
          }
        } else {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Could not fetch company data for default fields");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error fetching company data:", error);
      }

      return defaultFields;
    }

    // Get available Google contact fields for mapping
    getAvailableContactFields(contactData) {
      if (!contactData) return [];

      const fields = [
        { key: "name", label: "Full Name", value: contactData.name || contactData.fullName },
        { key: "firstName", label: "First Name", value: contactData.firstName },
        { key: "lastName", label: "Last Name", value: contactData.lastName },
        { key: "email", label: "Email", value: contactData.email || contactData.emailAddress },
        { key: "phone", label: "Phone", value: contactData.phone || contactData.phoneNumber },
        {
          key: "organization",
          label: "Organization",
          value: contactData.organization || contactData.company,
        },
        {
          key: "address",
          label: "Address",
          value: contactData.address || contactData.streetAddress,
        },
        { key: "jobTitle", label: "Job Title", value: contactData.jobTitle },
        { key: "biography", label: "Biography", value: contactData.biography },
      ];

      // Filter out fields with no value
      return fields.filter((field) => field.value);
    }

    // Show placeholder mapping UI
    async updatePlaceholderMappingUI() {
      if (!this.selectedTemplate || !this.selectedContactData) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Find the selected template
      const template = this.templates.find((t) => t.id === this.selectedTemplate);
      if (!template) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Extract placeholders from template
      const placeholders = this.extractPlaceholdersFromTemplate(template);
      if (placeholders.length === 0) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Get available contact fields
      const contactFields = this.getAvailableContactFields(this.selectedContactData);

      // Show the mapping section
      const mappingSection = document.getElementById("placeholder-mapping-section");
      const mappingsList = document.getElementById("placeholder-mappings-list");
      if (!mappingSection || !mappingsList) return;

      mappingSection.classList.remove("hidden");

      // Render mapping UI for each placeholder
      mappingsList.innerHTML = placeholders
        .map((placeholder) => {
          const currentMapping = this.placeholderMappings[placeholder];
          const isManual = currentMapping?.source === "manual";
          const manualValue = isManual ? currentMapping.value : "";

          // Try to auto-match placeholder to contact field
          let autoMatch = null;
          const placeholderUpper = placeholder.toUpperCase();
          if (!currentMapping) {
            // Try to find a matching field
            if (
              placeholderUpper.includes("NAME") &&
              !placeholderUpper.includes("FIRST") &&
              !placeholderUpper.includes("LAST")
            ) {
              autoMatch = "name";
            } else if (
              placeholderUpper.includes("FIRST") ||
              placeholderUpper.includes("FIRSTNAME")
            ) {
              autoMatch = "firstName";
            } else if (placeholderUpper.includes("LAST") || placeholderUpper.includes("LASTNAME")) {
              autoMatch = "lastName";
            } else if (placeholderUpper.includes("EMAIL")) {
              autoMatch = "email";
            } else if (placeholderUpper.includes("PHONE") || placeholderUpper.includes("TEL")) {
              autoMatch = "phone";
            } else if (
              placeholderUpper.includes("ADDRESS") ||
              placeholderUpper.includes("STREET")
            ) {
              autoMatch = "address";
            } else if (
              placeholderUpper.includes("COMPANY") ||
              placeholderUpper.includes("ORGANIZATION") ||
              placeholderUpper.includes("ORG")
            ) {
              autoMatch = "organization";
            } else if (placeholderUpper.includes("TITLE") || placeholderUpper.includes("JOB")) {
              autoMatch = "jobTitle";
            }
          }

          const selectedField =
            currentMapping?.source === "contact" ? currentMapping.fieldKey : autoMatch || "";
          const selectedValue =
            currentMapping?.source === "contact"
              ? contactFields.find((f) => f.key === currentMapping.fieldKey)?.value || ""
              : autoMatch
                ? contactFields.find((f) => f.key === autoMatch)?.value || ""
                : "";

          return `
          <div class="border border-gray-200 dark:border-gray-700 rounded-md p-3" data-placeholder="${placeholder}">
            <div class="flex items-start justify-between mb-2">
              <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  <span class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">{{${placeholder}}}</span>
                </label>
                <div class="mt-2 space-y-2">
                  <!-- Source selection: Contact field or manual -->
                  <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                      <input 
                        type="radio" 
                        name="source-${placeholder}" 
                        value="contact" 
                        class="mr-2"
                        ${!isManual ? "checked" : ""}
                        onchange="window.pdfSystem?.setPlaceholderSource('${placeholder}', 'contact')"
                      >
                      <span class="text-sm text-gray-700 dark:text-gray-300">From Contact</span>
                    </label>
                    <label class="flex items-center">
                      <input 
                        type="radio" 
                        name="source-${placeholder}" 
                        value="manual" 
                        class="mr-2"
                        ${isManual ? "checked" : ""}
                        onchange="window.pdfSystem?.setPlaceholderSource('${placeholder}', 'manual')"
                      >
                      <span class="text-sm text-gray-700 dark:text-gray-300">Manual Entry</span>
                    </label>
                  </div>
                  
                  <!-- Contact field dropdown (shown when source is contact) -->
                  <div id="contact-field-${placeholder}" class="${isManual ? "hidden" : ""}">
                    <select 
                      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                      onchange="window.pdfSystem?.setPlaceholderField('${placeholder}', this.value)"
                    >
                      <option value="">Select a contact field...</option>
                      ${contactFields
                        .map(
                          (field) => `
                        <option value="${field.key}" ${selectedField === field.key ? "selected" : ""}>
                          ${field.label}${field.value ? ` (${field.value.substring(0, 30)}${field.value.length > 30 ? "..." : ""})` : ""}
                        </option>
                      `
                        )
                        .join("")}
                    </select>
                    ${
                      selectedValue
                        ? `
                      <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        Preview: ${selectedValue.substring(0, 50)}${selectedValue.length > 50 ? "..." : ""}
                      </p>
                    `
                        : ""
                    }
                  </div>
                  
                  <!-- Manual entry input (shown when source is manual) -->
                  <div id="manual-field-${placeholder}" class="${!isManual ? "hidden" : ""}">
                    <input 
                      type="text" 
                      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                      placeholder="Enter value manually..."
                      value="${manualValue}"
                      onchange="window.pdfSystem?.setPlaceholderManual('${placeholder}', this.value)"
                    >
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        })
        .join("");

      // Initialize mappings with auto-matched values
      placeholders.forEach((placeholder) => {
        if (!this.placeholderMappings[placeholder]) {
          const placeholderUpper = placeholder.toUpperCase();
          let autoMatch = null;

          if (
            placeholderUpper.includes("NAME") &&
            !placeholderUpper.includes("FIRST") &&
            !placeholderUpper.includes("LAST")
          ) {
            autoMatch = "name";
          } else if (placeholderUpper.includes("FIRST") || placeholderUpper.includes("FIRSTNAME")) {
            autoMatch = "firstName";
          } else if (placeholderUpper.includes("LAST") || placeholderUpper.includes("LASTNAME")) {
            autoMatch = "lastName";
          } else if (placeholderUpper.includes("EMAIL")) {
            autoMatch = "email";
          } else if (placeholderUpper.includes("PHONE") || placeholderUpper.includes("TEL")) {
            autoMatch = "phone";
          } else if (placeholderUpper.includes("ADDRESS") || placeholderUpper.includes("STREET")) {
            autoMatch = "address";
          } else if (
            placeholderUpper.includes("COMPANY") ||
            placeholderUpper.includes("ORGANIZATION") ||
            placeholderUpper.includes("ORG")
          ) {
            autoMatch = "organization";
          } else if (placeholderUpper.includes("TITLE") || placeholderUpper.includes("JOB")) {
            autoMatch = "jobTitle";
          }

          if (autoMatch) {
            const field = contactFields.find((f) => f.key === autoMatch);
            if (field && field.value) {
              this.placeholderMappings[placeholder] = {
                source: "contact",
                fieldKey: autoMatch,
                value: field.value,
              };
            }
          }
        }
      });

      // Update the UI to reflect initialized mappings
      this.refreshPlaceholderMappingUI();
    }

    // Set placeholder source (contact or manual)
    setPlaceholderSource(placeholder, source) {
      if (!this.placeholderMappings[placeholder]) {
        this.placeholderMappings[placeholder] = { source, value: "" };
      } else {
        this.placeholderMappings[placeholder].source = source;
      }

      // Show/hide appropriate inputs
      const contactDiv = document.getElementById(`contact-field-${placeholder}`);
      const manualDiv = document.getElementById(`manual-field-${placeholder}`);

      if (contactDiv) contactDiv.classList.toggle("hidden", source === "manual");
      if (manualDiv) manualDiv.classList.toggle("hidden", source === "contact");

      // Update radio buttons
      const radios = document.querySelectorAll(`input[name="source-${placeholder}"]`);
      radios.forEach((radio) => {
        radio.checked = radio.value === source;
      });
    }

    // Set placeholder field from contact
    setPlaceholderField(placeholder, fieldKey) {
      if (!fieldKey) {
        if (this.placeholderMappings[placeholder]) {
          this.placeholderMappings[placeholder].value = "";
        }
        this.refreshPlaceholderMappingUI();
        return;
      }

      const contactFields = this.getAvailableContactFields(this.selectedContactData);
      const field = contactFields.find((f) => f.key === fieldKey);

      if (field) {
        this.placeholderMappings[placeholder] = {
          source: "contact",
          fieldKey: fieldKey,
          value: field.value || "",
        };
        this.refreshPlaceholderMappingUI();
      }
    }

    // Set placeholder manual value
    setPlaceholderManual(placeholder, value) {
      if (!this.placeholderMappings[placeholder]) {
        this.placeholderMappings[placeholder] = { source: "manual", value: "" };
      }
      this.placeholderMappings[placeholder].source = "manual";
      this.placeholderMappings[placeholder].value = value;
    }

    // Refresh the mapping UI to show current values
    refreshPlaceholderMappingUI() {
      if (!this.selectedTemplate || !this.selectedContactData) return;

      const template = this.templates.find((t) => t.id === this.selectedTemplate);
      if (!template) return;

      const placeholders = this.extractPlaceholdersFromTemplate(template);
      const contactFields = this.getAvailableContactFields(this.selectedContactData);

      placeholders.forEach((placeholder) => {
        const mapping = this.placeholderMappings[placeholder];
        if (!mapping) return;

        // Update preview text if source is contact
        if (mapping.source === "contact" && mapping.fieldKey) {
          const field = contactFields.find((f) => f.key === mapping.fieldKey);
          if (field && field.value) {
            const preview = document.querySelector(`[data-placeholder="${placeholder}"] p.text-xs`);
            if (preview) {
              const previewText =
                field.value.substring(0, 50) + (field.value.length > 50 ? "..." : "");
              preview.textContent = `Preview: ${previewText}`;
            }
          }
        }
      });
    }

    // Hide placeholder mapping UI
    hidePlaceholderMappingUI() {
      const mappingSection = document.getElementById("placeholder-mapping-section");
      if (mappingSection) {
        mappingSection.classList.add("hidden");
      }
    }

    async generatePDF() {
      if (!this.selectedTemplate || !this.selectedUser) {
        this.showNotification("Please select a template and user", "error");
        return;
      }

      try {
        const pageSize = document.getElementById("page-size")?.value || "8.5x11";
        const orientation = document.getElementById("orientation")?.value || "portrait";

        const response = await fetch("/api/pdf/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            templateId: this.selectedTemplate,
            userId: this.selectedUser,
            pageSize,
            orientation,
          }),
        });

        const data = await response.json();
        if (data.success) {
          this.showNotification("PDF generated successfully!", "success");
          // Download the PDF
          if (data.downloadUrl) {
            window.open(data.downloadUrl, "_blank");
          }
        } else {
          this.showNotification("Error generating PDF: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error generating PDF:", error);
        this.showNotification("Error generating PDF", "error");
      }
    }

    showNotification(message, type = "info") {
      // Simple notification system
      const notification = document.createElement("div");
      notification.className = `fixed top-4 right-4 p-4 rounded-md text-white z-50 ${
        type === "success" ? "bg-green-600" : type === "error" ? "bg-red-600" : "bg-blue-600"
      }`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    resetTemplateForm() {
      if (this.templateNameInput) {
        this.templateNameInput.value = "";
      }
      if (this.templateTypeSelect) {
        this.templateTypeSelect.value = "body";
      }
      if (this.editor) {
        this.editor.setText("");
      } else {
        const textarea = document.getElementById("template-content-textarea");
        if (textarea) {
          textarea.value = "";
        }
      }
      document.getElementById("extracted-fields")?.classList.add("hidden");
    }

    editTemplate(templateId) {
      console.log("üìÑ [PDF-SYSTEM] Editing template:", templateId);
      this.openTemplateEditor(templateId);
    }

    // openUserSearchModal() {
    //   // Trigger the SlotMachineModal
    //   const searchButton = document.getElementById("user-search");
    //   if (searchButton) {
    //     searchButton.click();
    //   } else {
    //     console.error("‚ùå [PDF-SYSTEM] Could not find user search modal trigger");
    //     this.showNotification("Error opening search modal", "error");
    //   }
    // }
  }

  // Initialize PDF System
  document.addEventListener("DOMContentLoaded", () => {
    window.pdfSystem = new PDFSystem();
  });
</script>

<style>
  .pdf-tab {
    transition: all 0.2s ease-in-out;
  }

  .pdf-tab:hover {
    border-color: #d1d5db;
  }

  .pdf-tab-content {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<!-- PDF.js Scripts (like in New.astro) -->
<script src="/js/pdf.worker.min.js" defer></script>
<script src="/js/pdf.min.js" defer></script>

<!-- Quill WYSIWYG Editor - Loaded dynamically to avoid conflicts -->
