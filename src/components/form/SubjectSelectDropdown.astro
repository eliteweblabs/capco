---
interface Props {
  selectedSubject?: string;
  name?: string;
  required?: boolean;
  class?: string;
  label?: string;
  id?: string;
  placeholder?: string;
  category?: string; // Filter by category
}

const {
  selectedSubject = "",
  name = "subject",
  required = false,
  class: className = "",
  label = "Proposal Subject",
  id = "subject-select",
  placeholder = "Search and select or create subject...",
  category = undefined,
} = Astro.props;
---

<div class="grid grid-cols-1 gap-2">
  {
    label && (
      <label for={id} class="text-sm font-medium text-zinc-900 dark:text-zinc-300">
        {label}
        {required && <span class="ml-1 text-red-500">*</span>}
      </label>
    )
  }

  <div class="relative w-full">
    <!-- Always visible search input -->
    <div class="relative">
      <input
        type="text"
        id={`${id}-search`}
        {placeholder}
        class="w-full rounded-full border border-gray-300 px-3 py-2 pl-8 pr-10 text-left text-sm focus:border-transparent focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400"
        autocomplete="off"
        value={selectedSubject}
      />
      <svg
        class="absolute left-2.5 top-2.5 h-4 w-4 text-gray-400"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg>
      <!-- Clear button when text is present -->
      <button
        type="button"
        id={`${id}-clear`}
        class="absolute right-2.5 top-2.5 hidden h-4 w-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
      >
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

    <!-- Dropdown results (only shown on focus/search) -->
    <div
      class="absolute left-0 right-0 z-50 mt-1 hidden rounded-full bg-gray-100 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none color-background dark:ring-gray-700"
      id={`${id}-menu`}
      role="listbox"
    >
      <!-- Results header -->
      <div
        class="border-b border-gray-200 bg-gray-50 px-3 py-2 dark:border-gray-700 dark:bg-gray-700/50"
      >
        <div class="text-xs text-gray-500 dark:text-gray-400">
          <span id={`${id}-results-count`}>0</span> subjects available
        </div>
      </div>

      <!-- Scrollable options container -->
      <div class="max-h-64 overflow-y-auto">
        <div id={`${id}-options`}>
          <!-- Options will be loaded dynamically -->
        </div>

        <!-- Create new subject option -->
        <div id={`${id}-create-new`} class="hidden border-t border-gray-200 dark:border-gray-700">
          <button
            type="button"
            class="group flex w-full items-center px-3 py-3 text-sm text-blue-600 transition-colors hover:bg-blue-50 dark:text-blue-400 dark:hover:bg-blue-900/30"
            id={`${id}-create-btn`}
          >
            <svg
              class="mr-3 h-4 w-4 flex-shrink-0"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
            </svg>
            <div class="flex-1 text-left">
              <div class="font-medium">Create new subject:</div>
              <div class="text-xs opacity-75" id={`${id}-create-preview`}></div>
            </div>
          </button>
        </div>

        <!-- No results message -->
        <div
          id={`${id}-no-results`}
          class="hidden px-4 py-8 text-center text-sm text-gray-500 dark:text-gray-400"
        >
          <svg
            class="mx-auto h-12 w-12 text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
          <div class="mt-2">No subjects found</div>
          <div class="text-xs">Try a different search or create a new subject</div>
        </div>

        <!-- Loading state -->
        <div
          id={`${id}-loading`}
          class="hidden px-4 py-8 text-center text-sm text-gray-500 dark:text-gray-400"
        >
          <div
            class="mx-auto h-6 w-6 animate-spin rounded-full border-2 border-blue-500 border-t-transparent"
          >
          </div>
          <div class="mt-2">Loading subjects...</div>
        </div>
      </div>
    </div>

    <!-- Hidden input to store the selected value -->
    <input type="hidden" {id} {name} value={selectedSubject || ""} {required} />
  </div>
</div>

<script define:vars={{ id, selectedSubject, category }} is:inline>
  document.addEventListener("DOMContentLoaded", () => {
    const searchInput = document.getElementById(`${id}-search`);
    const menuElement = document.getElementById(`${id}-menu`);
    const hiddenInput = document.getElementById(id);
    const optionsContainer = document.getElementById(`${id}-options`);
    const resultsCountElement = document.getElementById(`${id}-results-count`);
    const noResultsElement = document.getElementById(`${id}-no-results`);
    const loadingElement = document.getElementById(`${id}-loading`);
    const createNewElement = document.getElementById(`${id}-create-new`);
    const createBtn = document.getElementById(`${id}-create-btn`);
    const createPreview = document.getElementById(`${id}-create-preview`);
    const clearButton = document.getElementById(`${id}-clear`);

    if (!searchInput || !menuElement || !hiddenInput || !optionsContainer) return;

    let subjects = [];
    let isDropdownVisible = false;
    let searchTimeout = null;

    // Load subjects from API
    async function loadSubjects(searchTerm = "") {
      if (loadingElement) loadingElement.classList.remove("hidden");
      if (noResultsElement) noResultsElement.classList.add("hidden");
      if (createNewElement) createNewElement.classList.add("hidden");

      try {
        const params = new URLSearchParams();
        if (searchTerm) params.append("search", searchTerm);
        if (category) params.append("category", category);
        params.append("limit", "20");

        const response = await fetch(`/api/subject-catalog?${params}`, {
          credentials: "include",
        });

        if (response.ok) {
          const data = await response.json();
          subjects = data.subjects || [];
          renderSubjects(searchTerm);
        } else {
          console.error("Failed to load subjects");
          subjects = [];
          renderSubjects(searchTerm);
        }
      } catch (error) {
        console.error("Error loading subjects:", error);
        subjects = [];
        renderSubjects(searchTerm);
      } finally {
        if (loadingElement) loadingElement.classList.add("hidden");
      }
    }

    // Render subjects in dropdown
    function renderSubjects(searchTerm = "") {
      if (!optionsContainer) return;

      const term = searchTerm.toLowerCase().trim();
      let visibleCount = 0;

      // Clear existing options
      optionsContainer.innerHTML = "";

      // Filter and render subjects
      subjects.forEach((subject) => {
        const matches =
          !term ||
          subject.subject.toLowerCase().includes(term) ||
          (subject.description && subject.description.toLowerCase().includes(term)) ||
          (subject.category && subject.category.toLowerCase().includes(term));

        if (matches) {
          const option = createSubjectOption(subject);
          optionsContainer.appendChild(option);
          visibleCount++;
        }
      });

      // Update results count
      if (resultsCountElement) {
        resultsCountElement.textContent = visibleCount;
      }

      // Show/hide create new option
      if (createNewElement && createPreview) {
        if (term && !subjects.some((s) => s.subject.toLowerCase() === term)) {
          createPreview.textContent = `"${searchTerm}"`;
          createNewElement.classList.remove("hidden");
        } else {
          createNewElement.classList.add("hidden");
        }
      }

      // Show/hide no results message
      if (noResultsElement) {
        if (visibleCount === 0 && term && !createNewElement?.classList.contains("hidden")) {
          // Don't show no results if we can create new
          noResultsElement.classList.add("hidden");
        } else if (visibleCount === 0 && term) {
          noResultsElement.classList.remove("hidden");
        } else {
          noResultsElement.classList.add("hidden");
        }
      }
    }

    // Create subject option element
    function createSubjectOption(subject) {
      const button = document.createElement("button");
      button.type = "button";
      button.className =
        "group flex w-full items-left px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors text-gray-700 dark:text-gray-300 subject-option";
      button.setAttribute("data-subject-id", subject.id);
      button.setAttribute("data-subject-text", subject.subject);
      button.setAttribute(
        "data-search-text",
        `${subject.subject} ${subject.description || ""} ${subject.category || ""}`.toLowerCase()
      );

      button.innerHTML = `
        <span class="flex items-center flex-1 min-w-0">
          <svg class="w-4 h-4 mr-3 text-gray-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
          </svg>
          <div class="flex-1 min-w-0">
            <div class="truncate font-medium">${subject.subject}</div>
            ${subject.description ? `<div class="text-xs text-gray-500 dark:text-gray-400 truncate">${subject.description}</div>` : ""}
            <div class="flex items-center mt-1 text-xs text-gray-400">
              ${subject.category ? `<span class="mr-2">${subject.category}</span>` : ""}
              <span class="flex items-center">
                <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                </svg>
                ${subject.usageCount} uses
              </span>
            </div>
          </div>
        </span>
      `;

      return button;
    }

    // Create new subject
    async function createNewSubject(subjectText) {
      try {
        const response = await fetch("/api/subject-catalog", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          credentials: "include",
          body: JSON.stringify({
            subject: subjectText.trim(),
            category: category || "General",
          }),
        });

        const data = await response.json();

        if (data.success) {
          // Use the new subject
          selectSubject(subjectText);
          hideDropdown();

          // Show success message
          if (window.showModal) {
            window.showModal(
              "Success",
              data.isNew ? "New subject created and selected!" : "Subject selected!",
              "success"
            );
          }

          // Refresh the list
          loadSubjects("");
        } else {
          console.error("Failed to create subject:", data.error);
          if (window.showModal) {
            window.showModal("error", "Error", "Failed to create subject");
          }
        }
      } catch (error) {
        console.error("Error creating subject:", error);
        if (window.showModal) {
          window.showModal("error", "Error", "Failed to create subject");
        }
      }
    }

    // Select a subject
    function selectSubject(subjectText) {
      hiddenInput.value = subjectText;
      searchInput.value = subjectText;
      toggleClearButton();

      // Trigger change event
      const event = new CustomEvent("subjectSelected", {
        detail: { subject: subjectText },
      });
      document.dispatchEvent(event);
    }

    // Show/hide clear button
    function toggleClearButton() {
      if (clearButton) {
        if (searchInput.value.trim()) {
          clearButton.classList.remove("hidden");
        } else {
          clearButton.classList.add("hidden");
        }
      }
    }

    // Show dropdown
    function showDropdown() {
      if (!isDropdownVisible) {
        menuElement.classList.remove("hidden");
        isDropdownVisible = true;
      }
    }

    // Hide dropdown
    function hideDropdown() {
      if (isDropdownVisible) {
        menuElement.classList.add("hidden");
        isDropdownVisible = false;
      }
    }

    // Clear selection
    function clearSelection() {
      searchInput.value = "";
      hiddenInput.value = "";
      toggleClearButton();
      searchInput.focus();
      loadSubjects("");
    }

    // Event listeners
    searchInput.addEventListener("input", (e) => {
      const value = e.target.value;
      toggleClearButton();

      // Debounce search
      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        loadSubjects(value);
        if (value.trim() && !isDropdownVisible) {
          showDropdown();
        }
      }, 300);
    });

    searchInput.addEventListener("focus", () => {
      showDropdown();
      if (subjects.length === 0) {
        loadSubjects(searchInput.value);
      }
    });

    searchInput.addEventListener("blur", () => {
      setTimeout(() => {
        hideDropdown();
      }, 150);
    });

    if (clearButton) {
      clearButton.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        clearSelection();
      });
    }

    // Handle option selection
    optionsContainer.addEventListener("click", (e) => {
      const option = e.target.closest("button[data-subject-text]");
      if (!option) return;

      const subjectText = option.getAttribute("data-subject-text");
      selectSubject(subjectText);
      hideDropdown();
    });

    // Handle create new subject
    if (createBtn) {
      createBtn.addEventListener("click", () => {
        const newSubject = searchInput.value.trim();
        if (newSubject) {
          createNewSubject(newSubject);
        }
      });
    }

    // Prevent dropdown from closing when clicking inside
    menuElement.addEventListener("mousedown", (e) => {
      e.preventDefault();
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      if (!searchInput.contains(e.target) && !menuElement.contains(e.target)) {
        hideDropdown();
      }
    });

    // Keyboard navigation
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        hideDropdown();
        searchInput.blur();
      } else if (e.key === "Enter") {
        e.preventDefault();
        const newSubject = searchInput.value.trim();
        if (
          newSubject &&
          !subjects.some((s) => s.subject.toLowerCase() === newSubject.toLowerCase())
        ) {
          createNewSubject(newSubject);
        }
      }
    });

    // Initialize
    toggleClearButton();
    if (selectedSubject) {
      loadSubjects("");
    }
  });
</script>
