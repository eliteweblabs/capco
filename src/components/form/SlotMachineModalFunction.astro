---
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";

// Generic Slot Machine Modal Component - Reusable for any picker scenario

interface Props {
  id: string; // Required: Unique identifier for this picker instance
  title: string; // Required: Modal title (e.g., "Select Status", "Choose Staff")
  options: Array<{ value: string; label: string; disabled?: boolean }>; // Required: Array of options
  selectedValue?: string; // Optional: Currently selected value
  placeholder?: string; // Optional: Placeholder text for button
  buttonText?: string; // Optional: Custom button text (defaults to selected label or placeholder)
  showCloseButton?: boolean; // Optional: Show X close button (default: true)
  showCancelButton?: boolean; // Optional: Show Cancel button (default: true)
  addNewOption?: boolean; // Optional: Show add new option button (default: false)
  // skipSaveToAPI?: boolean; // Optional: Skip saving to API when used inside forms (default: false)
  name?: string; // Optional: Form field name (defaults to id)
  buttonClass?: string; // Optional: Custom button class (defaults to "")
  noResultsText?: string; // Optional: No results text (defaults to "No results found")
  // NEW FLEXIBLE PROPS:
  fetchApiEndpoint?: string; // Optional: API endpoint for fetching/searching data
  saveApiEndpoint?: string; // Optional: API endpoint for saving data (defaults to id if not provided)
  searchText?: string; // Optional: Search input label (if provided, enables search)
  searchPlaceholder?: string; // Optional: Search input placeholder
  apiParams?: Record<string, any>; // Optional: Additional API parameters
  dataTransform?: string; // Optional: Function name to transform API response
  valueField?: string; // Optional: Field name to use for the value (default: "value")
  labelField?: string; // Optional: Field name to use for the label (default: "label")
  // fetchOnLoad?: boolean; // Optional: Whether to fetch data immediately on modal open (default: false)
  showNotification?: boolean; // Optional: Whether to show notification (default: true)
  project?: any; // Optional: Project for API calls
  icon?: string; // Optional: Icon name for the button (default: "")
  currentUser?: any; // Optional: Current user for API calls
  globalInputClasses?: string; // Optional: Global input classes
  buttonVariant?:
    | "primary"
    | "secondary"
    | "outline"
    | "ghost"
    | "link"
    | "success"
    | "warning"
    | "danger"
    | "loading"
    | "disabled"
    | "selected"
    | "anchor"; // Optional: Button variant (default: "primary")
}

const {
  id,
  title,
  options = [],
  selectedValue = "",
  placeholder = "Select an option...",
  buttonClass = "",
  buttonText,
  showCloseButton = true,
  showCancelButton = true,
  addNewOption = false,
  // skipSaveToAPI = false,
  name,
  noResultsText = "",
  icon = "chevron-down",
  currentUser,
  globalInputClasses = "",
  // NEW FLEXIBLE PROPS:
  fetchApiEndpoint,
  saveApiEndpoint,
  searchText,
  searchPlaceholder = "Type to search options...",
  apiParams = {},
  dataTransform,
  valueField = "value",
  labelField = "label",
  // fetchOnLoad = false,
  showNotification = false,
  buttonVariant = "primary",
  project,
  // project = {},
} = Astro.props;

// Debug logging for saveApiEndpoint
// console.log("üîß [SLOT-MACHINE] Props received:", { saveApiEndpoint, fetchApiEndpoint, id });
// console.log("üîß [SLOT-MACHINE] saveApiEndpoint type:", typeof saveApiEndpoint);
// console.log("üîß [SLOT-MACHINE] saveApiEndpoint value:", JSON.stringify(saveApiEndpoint));

const projectId = project?.id || "";
// Ensure options is always an array
const optionsArray = Array.isArray(options) ? options : [];

// Determine if search should be enabled (if searchText is provided)
const enableSearch = !!searchText;

// Find the selected option to get the button text
const selectedOption = optionsArray.find((option) => option.value === selectedValue);
const displayText = buttonText || selectedOption?.label || placeholder;
---

<!-- Slot Machine Picker Button -->
<Button
  {id}
  variant={buttonVariant || "outline"}
  class={buttonClass || ""}
  data-refresh={name}
  data-project-id={projectId}
  size="sm"
  icon={icon || "chevron-down"}
  iconPosition="right"
>
  {displayText}
</Button>

<!-- Hidden input to store the selected value -->
<input
  type="hidden"
  id={`${id}-value`}
  name={name || id}
  value={selectedValue}
  data-refresh={name}
  data-project-id={projectId}
/>

<script
  define:vars={{
    id,
    title,
    options: optionsArray,
    selectedValue,
    showCloseButton,
    showCancelButton,
    // skipSaveToAPI,
    enableSearch,
    fetchApiEndpoint,
    saveApiEndpoint,
    searchText,
    searchPlaceholder,
    showNotification,
    apiParams,
    dataTransform,
    valueField,
    labelField,
    // fetchOnLoad,
    projectId,
    noResultsText,
    globalInputClasses,
    // project,
  }}
  is:inline
>
  // Debug logging in script

  // Initialize the slot machine picker
  // Wait for DOM to be ready and element to exist
  let hiddenInput = null;
  let googleAuthModal = null; // Track Google auth modal instance

  function setupSlotMachine() {
    const trigger = document.getElementById(id);
    hiddenInput = document.getElementById(`${id}-value`);

    if (!trigger) {
      console.warn(`üé∞ [SLOT-MACHINE] Trigger button with ID '${id}' not found yet, retrying...`);
      // Retry after a short delay
      setTimeout(setupSlotMachine, 100);
      return;
    }

    console.log(`‚úÖ [SLOT-MACHINE] Trigger button found for ID: ${id}`);
    attachClickHandler(trigger);
  }

  function attachClickHandler(trigger) {
    console.log(`üîó [SLOT-MACHINE] Attaching click handler to trigger for ID: ${id}`);
    console.log(`üîó [SLOT-MACHINE] Trigger element:`, trigger);
    console.log(`üîó [SLOT-MACHINE] Trigger tag:`, trigger.tagName);
    console.log(`üîó [SLOT-MACHINE] fetchApiEndpoint: ${fetchApiEndpoint}`);

    // Set up click handler
    trigger.addEventListener("click", async function (e) {
      console.log(`üéØ [SLOT-MACHINE] Click event fired for ID: ${id}`);
      console.log(`üéØ [SLOT-MACHINE] Event target:`, e.target);
      console.log(`üéØ [SLOT-MACHINE] Event currentTarget:`, e.currentTarget);

      e.stopPropagation();

      // Only preventDefault if it's a link (anchor tag)
      if (trigger.tagName === "A") {
        e.preventDefault();
        console.log(`üõë [SLOT-MACHINE] Prevented default navigation`);
      }

      console.log(`üé∞ [SLOT-MACHINE] Click handler processing for ID: ${id}`);
      console.log(`üé∞ [SLOT-MACHINE] fetchApiEndpoint: ${fetchApiEndpoint}`);

      // If this is a Google Contacts picker, check auth first
      if (fetchApiEndpoint && fetchApiEndpoint.includes("/api/google/contacts")) {
        console.log("üîç [SLOT-MACHINE] Google Contacts detected, checking auth...");
        try {
          const isAuthenticated = await checkGoogleAuthAndSearch();
          console.log(`üîç [SLOT-MACHINE] Auth check result: ${isAuthenticated}`);

          // If auth check passed, modal will already be opened by checkGoogleAuthAndSearch
          // If not authenticated, auth modal is shown and we don't proceed
          if (!isAuthenticated) {
            console.log("‚ùå [SLOT-MACHINE] Auth failed, not proceeding");
            return; // Don't proceed if auth failed
          }
        } catch (authError) {
          console.error("‚ùå [SLOT-MACHINE] Error during auth check:", authError);
          showSlotNotification("Error checking authentication", "error");
          return;
        }
      } else {
        // For non-Google endpoints, open directly
        console.log("‚úÖ [SLOT-MACHINE] Non-Google endpoint, opening modal directly");
        initializeSlotMachine();
      }
    });

    console.log(`‚úÖ [SLOT-MACHINE] Click handler attached successfully for ID: ${id}`);
  }

  function initializeSlotMachine() {
    const currentValue = hiddenInput ? hiddenInput.value : selectedValue;
    showSlotMachineModal({
      id: id,
      title: title,
      options: options,
      selectedValue: currentValue,
      showCloseButton: showCloseButton,
      showCancelButton: showCancelButton,
      valueField: valueField,
      labelField: labelField,
      searchText: searchText,
      searchPlaceholder: searchPlaceholder,
      globalInputClasses: globalInputClasses,
      enableSearch: enableSearch,
      fetchApiEndpoint: fetchApiEndpoint,
      searchText: searchText,
      searchPlaceholder: searchPlaceholder,
      apiParams: apiParams,
      dataTransform: dataTransform,
      valueField: valueField,
      labelField: labelField,
      noResultsText: noResultsText,
      globalInputClasses: globalInputClasses,
      // project: project,
    });
  }
  // Check for successful Google auth redirect on page load
  function checkGoogleAuthRedirect() {
    const urlParams = new URLSearchParams(window.location.search);
    const googleAuthSuccess = urlParams.get("google_auth");

    // Also check sessionStorage for auth component tracking
    const authComponentId = sessionStorage.getItem("google_auth_component_id");
    const authTimestamp = sessionStorage.getItem("google_auth_timestamp");

    // Check if this component should auto-open after auth (within last 30 seconds)
    const shouldAutoOpen =
      authComponentId === id &&
      authTimestamp &&
      Date.now() - parseInt(authTimestamp) < 30000 &&
      fetchApiEndpoint &&
      fetchApiEndpoint.includes("/api/google/contacts");

    if (
      (googleAuthSuccess === "success" || shouldAutoOpen) &&
      fetchApiEndpoint &&
      fetchApiEndpoint.includes("/api/google/contacts")
    ) {
      // Clean up URL parameter and sessionStorage
      const newUrl = new URL(window.location);
      newUrl.searchParams.delete("google_auth");
      window.history.replaceState({}, "", newUrl);
      sessionStorage.removeItem("google_auth_component_id");
      sessionStorage.removeItem("google_auth_timestamp");

      // Close any existing auth modal
      closeGoogleAuthModal();

      // Wait longer for cookies to be set (httpOnly cookies need time)
      setTimeout(async () => {
        console.log("üîÑ [SLOT-MACHINE] Google auth redirect detected, retrying auth check...");

        // Try multiple times with exponential backoff
        let attempts = 0;
        const maxAttempts = 3;

        const retryAuth = async () => {
          attempts++;
          const isAuthenticated = await checkGoogleAuthAndSearch();

          if (!isAuthenticated && attempts < maxAttempts) {
            console.log(
              `üîÑ [SLOT-MACHINE] Auth check failed, retrying in ${attempts * 500}ms... (attempt ${attempts}/${maxAttempts})`
            );
            setTimeout(retryAuth, attempts * 500);
          } else if (isAuthenticated) {
            console.log("‚úÖ [SLOT-MACHINE] Auth successful after redirect, modal should be open");
          } else {
            console.error("‚ùå [SLOT-MACHINE] Auth check failed after multiple attempts");
            showSlotNotification("Authentication failed. Please try again.", "error");
          }
        };

        retryAuth();
      }, 1000);
    }
  }

  // Check on page load if we just returned from Google auth
  if (typeof window !== "undefined") {
    // Run immediately and also on DOMContentLoaded as fallback
    checkGoogleAuthRedirect();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", checkGoogleAuthRedirect);
    } else {
      // DOM already loaded, run immediately
      checkGoogleAuthRedirect();
    }
  }

  // Initialize the component when DOM is ready
  if (typeof document !== "undefined") {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", setupSlotMachine);
    } else {
      // DOM already loaded
      setupSlotMachine();
    }
  }

  // Check for URL parameters to auto-open this specific picker
  // function checkUrlParameters() {
  //   const urlParams = new URLSearchParams(window.location.search);
  //   const modalParam = urlParams.get("modal");

  //   console.log(`üé∞ [SLOT-MACHINE] Checking URL parameters for ID '${id}':`, {
  //     modalParam,
  //     componentId: id,
  //     match: modalParam === id,
  //   });

  //   if (modalParam === id) {
  //     // console.log(`üé∞ [SLOT-MACHINE] URL parameter detected: modal=${id}`);

  //     // Wait for DOM to be ready, then trigger the picker
  //     setTimeout(() => {
  //       if (trigger) {
  //         // console.log(`üé∞ [SLOT-MACHINE] Auto-opening picker for ID: ${id}`);
  //         trigger.click();

  //         // Clean up the URL parameter
  //         const newUrl = new URL(window.location);
  //         newUrl.searchParams.delete("modal");
  //         window.history.replaceState({}, "", newUrl);
  //         // console.log(`üé∞ [SLOT-MACHINE] URL cleaned up: ${newUrl.href}`);
  //       } else {
  //         console.error(`üé∞ [SLOT-MACHINE] Trigger button not found for auto-open`);
  //       }
  //     }, 100);
  //   }
  // }

  // // Check URL parameters on load
  // checkUrlParameters();

  // });

  // Auto-save function that uses saveApiEndpoint or falls back to component ID
  // async function saveToAPI(apiEndpoint, value, label) {
  //   try {
  //     console.log(`üé∞ [SLOT-MACHINE] ===== SAVE TO API START =====`);
  //     console.log(`üé∞ [SLOT-MACHINE] API Endpoint received: ${apiEndpoint}`);
  //     console.log(`üé∞ [SLOT-MACHINE] Value: ${value} (type: ${typeof value})`);
  //     console.log(`üé∞ [SLOT-MACHINE] Label: ${label} (type: ${typeof label})`);
  //     // console.log(`üé∞ [SLOT-MACHINE] Value: ${value} (type: ${typeof value})`);
  //     // console.log(`üé∞ [SLOT-MACHINE] Label: ${label} (type: ${typeof label})`);
  //     // console.log(`üé∞ [SLOT-MACHINE] ProjectId prop: ${projectId} (type: ${typeof projectId})`);
  //     // console.log(`üé∞ [SLOT-MACHINE] Current URL: ${window.location.href}`);
  //     // console.log(`üé∞ [SLOT-MACHINE] URL pathname: ${window.location.pathname}`);

  //     // Format data based on the component type
  //     let requestBody;

  //     console.log(`üé∞ [XXXSLOT-MACHINE] API Endpoint: ${apiEndpoint}`);
  //     if (apiEndpoint === "update-status") {
  //       // console.log(`üé∞ [SLOT-MACHINE] Processing UPDATE-STATUS request`);
  //       // console.log(`üé∞ [SLOT-MACHINE] Raw projectId prop:`, projectId);
  //       // console.log(`üé∞ [SLOT-MACHINE] Raw value:`, value);
  //       // console.log(`üé∞ [SLOT-MACHINE] URL pathname:`, window.location.pathname);

  //       const parsedProjectId =
  //         parseInt(projectId) || parseInt(window.location.pathname.split("/").pop()) || null;
  //       const parsedStatus = parseInt(value);

  //       console.log(
  //         `üé∞ [SLOT-MACHINE] Parsed projectId: ${parsedProjectId} (type: ${typeof parsedProjectId})`
  //       );
  //       console.log(
  //         `üé∞ [SLOT-MACHINE] Parsed status: ${parsedStatus} (type: ${typeof parsedStatus})`
  //       );

  //       // Additional validation checks
  //       if (!parsedProjectId) {
  //         console.error(`üé∞ [SLOT-MACHINE] ERROR: Could not parse projectId!`);
  //         console.error(`üé∞ [SLOT-MACHINE] projectId prop:`, projectId);
  //         console.error(`üé∞ [SLOT-MACHINE] URL pathname:`, window.location.pathname);
  //         console.error(
  //           `üé∞ [SLOT-MACHINE] URL pathname split:`,
  //           window.location.pathname.split("/")
  //         );
  //       }

  //       if (isNaN(parsedStatus)) {
  //         console.error(`üé∞ [SLOT-MACHINE] ERROR: Could not parse status!`);
  //         console.error(`üé∞ [SLOT-MACHINE] Raw value:`, value);
  //         console.error(`üé∞ [SLOT-MACHINE] Parsed status:`, parsedStatus);
  //       }

  //       // For status updates, send the format expected by update-status API
  //       requestBody = {
  //         projectId: parsedProjectId,
  //         status: parsedStatus, // Convert value to integer
  //       };
  //       console.log(`üé∞ [SLOT-MACHINE] UPDATE-STATUS requestBody:`, requestBody);
  //       const parsedProjectId =
  //         parseInt(projectId) || parseInt(window.location.pathname.split("/").pop()) || null;
  //       console.log(
  //         `üé∞ [SLOT-MACHINE] Parsed projectId: ${parsedProjectId} (type: ${typeof parsedProjectId})`
  //       );
  //       console.log(`üé∞ [SLOT-MACHINE] Staff ID: ${value} (type: ${typeof value})`);
  //       console.log(`üé∞ [SLOT-MACHINE] Staff Name: ${label} (type: ${typeof label})`);

  //       // For staff assignment, send the format expected by update-project API
  //       requestBody = {
  //         projectId: parsedProjectId,
  //         assignedToId: value, // Staff member ID
  //         assignedToName: label, // Staff member name
  //       };
  //     } else if (apiEndpoint === "update-project") {
  //       console.log(`üé∞ [SLOT-MACHINE] ===== UPDATE-PROJECT REQUEST START =====`);
  //       console.log(`üé∞ [SLOT-MACHINE] Processing UPDATE-PROJECT request`);
  //       console.log(`üé∞ [SLOT-MACHINE] Component ID: ${id}`);
  //       console.log(`üé∞ [SLOT-MACHINE] API Endpoint: ${apiEndpoint}`);
  //       console.log(`üé∞ [SLOT-MACHINE] Project ID prop: ${projectId}`);
  //       console.log(`üé∞ [SLOT-MACHINE] Current URL: ${window.location.href}`);

  //       const parsedProjectId =
  //         parseInt(projectId) || parseInt(window.location.pathname.split("/").pop()) || null;
  //       console.log(
  //         `üé∞ [SLOT-MACHINE] Parsed projectId: ${parsedProjectId} (type: ${typeof parsedProjectId})`
  //       );
  //       console.log(`üé∞ [SLOT-MACHINE] Field value: ${value} (type: ${typeof value})`);
  //       console.log(`üé∞ [SLOT-MACHINE] Field label: ${label} (type: ${typeof label})`);

  //       // For generic project updates, determine the field name from the component ID or context
  //       let fieldName = "value"; // Default field name

  //       // Try to determine field name from component ID or context
  //       if (id.includes("due-date") || id.includes("dueDate")) {
  //         fieldName = "dueDate";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (due-date component)`);
  //       } else if (id.includes("title")) {
  //         fieldName = "title";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (title component)`);
  //       } else if (id.includes("address")) {
  //         fieldName = "address";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (address component)`);
  //       } else if (id.includes("description")) {
  //         fieldName = "description";
  //         console.log(
  //           `üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (description component)`
  //         );
  //       } else if (id.includes("sqFt") || id.includes("sqft")) {
  //         fieldName = "sqFt";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (sqFt component)`);
  //       } else if (id.includes("units")) {
  //         fieldName = "units";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (units component)`);
  //       } else if (id.includes("building")) {
  //         fieldName = "building";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (building component)`);
  //       } else if (id.includes("tier")) {
  //         fieldName = "tier";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (tier component)`);
  //       } else if (id.includes("project")) {
  //         fieldName = "project";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (project component)`);
  //       } else if (id.includes("service")) {
  //         fieldName = "service";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (service component)`);
  //       } else if (id.includes("architect")) {
  //         fieldName = "architect";
  //         console.log(`üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (architect component)`);
  //       } else if (id.includes("requestedDocs")) {
  //         fieldName = "requestedDocs";
  //         console.log(
  //           `üé∞ [SLOT-MACHINE] Detected field name: ${fieldName} (requestedDocs component)`
  //         );
  //       } else {
  //         console.log(
  //           `üé∞ [SLOT-MACHINE] Using default field name: ${fieldName} (no specific component detected)`
  //         );
  //       }

  //       // For dueDate, convert to proper date format if needed
  //       let fieldValue = value;
  //       if (fieldName === "dueDate" && value) {
  //         console.log(`üé∞ [SLOT-MACHINE] Processing dueDate field with value: ${value}`);
  //         // Ensure the date is in ISO format
  //         const date = new Date(value);
  //         if (!isNaN(date.getTime())) {
  //           fieldValue = date.toISOString().split("T")[0]; // YYYY-MM-DD format
  //           console.log(`üé∞ [SLOT-MACHINE] Converted dueDate to: ${fieldValue}`);
  //         } else {
  //           console.log(`üé∞ [SLOT-MACHINE] Invalid date value: ${value}`);
  //         }
  //       }

  //       requestBody = {
  //         projectId: parsedProjectId,
  //         [fieldName]: fieldValue,
  //       };
  //       console.log(`üé∞ [SLOT-MACHINE] UPDATE-PROJECT requestBody:`, requestBody);
  //       console.log(`üé∞ [SLOT-MACHINE] ===== UPDATE-PROJECT REQUEST END =====`);
  //     } else {
  //       console.log(`üé∞ [SLOT-MACHINE] Processing GENERIC request for component: ${apiEndpoint}`);
  //       // For other components, use generic format
  //       requestBody = {
  //         value: value,
  //         label: label,
  //         componentId: apiEndpoint,
  //       };
  //       console.log(`üé∞ [SLOT-MACHINE] GENERIC requestBody:`, requestBody);
  //     }

  //     console.log(`üé∞ [SLOT-MACHINE] Final request body:`, requestBody);

  //     // Use the passed apiEndpoint directly
  //     console.log(`üé∞ [SLOT-MACHINE] Using API endpoint: ${apiEndpoint}`);
  //     const finalApiEndpoint = `/api/${apiEndpoint}`;
  //     console.log(`üé∞ [SLOT-MACHINE] Final API endpoint: ${finalApiEndpoint}`);
  //     console.log(`üé∞ [SLOT-MACHINE] Making fetch request to: ${finalApiEndpoint}`);

  //     const response = await fetch(finalApiEndpoint, {
  //       method: "POST",
  //       headers: {
  //         "Content-Type": "application/json",
  //       },
  //       credentials: "include",
  //       body: JSON.stringify(requestBody),
  //     });

  //     console.log(`üé∞ [SLOT-MACHINE] Fetch response status: ${response.status}`);
  //     console.log(`üé∞ [SLOT-MACHINE] Fetch response ok: ${response.ok}`);
  //     console.log(
  //       `üé∞ [SLOT-MACHINE] Fetch response headers:`,
  //       Object.fromEntries(response.headers.entries())
  //     );

  //     if (response.ok) {
  //       const result = await response.clone().json();
  //       console.log(`üé∞ [SLOT-MACHINE] ===== API SUCCESS RESPONSE =====`);
  //       console.log(`üé∞ [SLOT-MACHINE] API response:`, result);

  //       // Show success notification

  //       // Also try the original notification handler if it exists
  //       if (window.handleNewStatusModalAndEmail) {
  //         window.handleNewStatusModalAndEmail(result, "SLOT-MACHINE");
  //       }

  //       // if (result.notificationData && window.showModal && showNotification) {
  //       //   const { type, title, message, duration } = result.notificationData;

  //       //   window.showModal(type, title, message, duration);
  //       // } else if (result.success && window.showModal && showNotification) {
  //       //   // Fallback success notification
  //       //   window.showModal(
  //       //     "success",
  //       //     "Success",
  //       //     result.message || "Operation completed successfully",
  //       //     3000
  //       //   );
  //       // }

  //       // Close the modal after success
  //       setTimeout(() => {
  //         const modal = document.querySelector(`[data-modal-backdrop="${apiEndpoint}-modal"]`);
  //         if (modal) {
  //           modal.click(); // Click the backdrop to close
  //         }
  //       }, 1000);
  //     } else {
  //       console.log(`üé∞ [SLOT-MACHINE] ===== API ERROR RESPONSE =====`);
  //       console.log(`üé∞ [SLOT-MACHINE] Response status: ${response.status}`);
  //       console.log(`üé∞ [SLOT-MACHINE] Response statusText: ${response.statusText}`);

  //       let errorData;
  //       try {
  //         errorData = await response.clone().json();
  //         console.log(`üé∞ [SLOT-MACHINE] Error response body:`, errorData);
  //       } catch (parseError) {
  //         console.log(`üé∞ [SLOT-MACHINE] Could not parse error response as JSON:`, parseError);
  //         const textResponse = await response.clone().text();
  //         console.log(`üé∞ [SLOT-MACHINE] Error response as text:`, textResponse);
  //         errorData = { error: textResponse };
  //       }

  //       console.error(`üé∞ [SLOT-MACHINE] API error:`, errorData);
  //       throw new Error(errorData.error || `Failed to save ${apiEndpoint}`);
  //     }
  //   } catch (error) {
  //     console.log(`üé∞ [SLOT-MACHINE] ===== CATCH BLOCK =====`);
  //     console.error(`üé∞ [SLOT-MACHINE] Error saving to API:`, error);
  //     console.error(`üé∞ [SLOT-MACHINE] Error name:`, error.name);
  //     console.error(`üé∞ [SLOT-MACHINE] Error message:`, error.message);
  //     console.error(`üé∞ [SLOT-MACHINE] Error stack:`, error.stack);

  //     // Show error notification if available
  //     if (window.showModal) {
  //       window.showModal("error", "Error", `Failed to save selection. Please try again.`, 5000);
  //     }
  //   }
  // }

  function showGoogleAuthModal() {
    // Create a simple modal for Google authentication
    const modal = document.createElement("div");
    modal.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
    modal.innerHTML = `
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
          <div class="flex items-center mb-4">
            <div class="w-10 h-10 bg-primary-100 dark:bg-primary-900 rounded-full flex items-center justify-center mr-3">
              <svg class="w-6 h-6 text-primary-600 dark:text-primary-400" fill="currentColor" viewBox="0 0 24 24">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
              </svg>
            </div>
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Google Authentication Required</h3>
          </div>
          <p class="text-gray-600 dark:text-gray-400 mb-6">
            To search your Google contacts, you need to authenticate with Google first. This will allow us to access your contacts safely and securely.
          </p>
          <div class="flex space-x-3">
            <button
              onclick="window.authenticateWithGoogle()"
              class="flex-1 bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-md font-medium transition-colors"
            >
              Sign in with Google
            </button>
            <button
              onclick="window.closeGoogleAuthModal()"
              class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
            >
              Cancel
            </button>
          </div>
        </div>
      `;

    document.body.appendChild(modal);
    googleAuthModal = modal;
  }

  function authenticateWithGoogle() {
    // Store the component ID in sessionStorage so we can auto-open after redirect
    sessionStorage.setItem("google_auth_component_id", id);
    sessionStorage.setItem("google_auth_timestamp", Date.now().toString());

    // Redirect to Google OAuth with current page as redirect target + success param
    const currentUrl = window.location.pathname + window.location.search;
    const redirectUrl = `${currentUrl}${currentUrl.includes("?") ? "&" : "?"}google_auth=success`;
    window.location.href = `/api/google/signin?redirect=${encodeURIComponent(redirectUrl)}`;
  }
  window.authenticateWithGoogle = authenticateWithGoogle;

  function closeGoogleAuthModal() {
    try {
      if (googleAuthModal) {
        googleAuthModal.remove();
        googleAuthModal = null;
        console.log("‚úÖ [SLOT-MACHINE] Google auth modal closed");
      }
    } catch (error) {
      console.error("‚ùå [SLOT-MACHINE] Error closing Google auth modal:", error);
      // Try to find and remove any existing modals as fallback
      const existingModal = document.querySelector(".fixed.inset-0.bg-black.bg-opacity-50");
      if (existingModal && existingModal.innerHTML.includes("Google Authentication Required")) {
        existingModal.remove();
      }
    }
  }
  window.closeGoogleAuthModal = closeGoogleAuthModal;

  // Generic notification function (can be overridden by parent component)
  function showSlotNotification(message, type = "info") {
    if (typeof window.showNotification === "function") {
      window.showNotification(message, type);
    } else {
      // Fallback notification
      const notification = document.createElement("div");
      notification.className = `fixed top-4 right-4 p-4 rounded-md text-white z-50 ${
        type === "success" ? "bg-green-600" : type === "error" ? "bg-red-600" : "bg-primary-600"
      }`;
      notification.textContent = message;
      document.body.appendChild(notification);
      setTimeout(() => notification.remove(), 3000);
    }
  }

  async function checkGoogleAuthAndSearch() {
    console.log("üîç [SLOT-MACHINE] Checking Google authentication...");
    console.log("üîç [SLOT-MACHINE] Current URL:", window.location.href);
    console.log(
      "üîç [SLOT-MACHINE] Cookies check:",
      document.cookie
        ? "Cookies present"
        : "No cookies in document.cookie (httpOnly cookies won't show here)"
    );

    try {
      // First, check cookies via debug endpoint to see if they're actually set
      try {
        const debugResponse = await fetch("/api/debug-cookies", {
          credentials: "include",
        });

        if (debugResponse.ok) {
          const debugData = await debugResponse.json();
          console.log("üç™ [SLOT-MACHINE] Cookie debug info:", {
            availableCookies: debugData.availableCookies,
            hasGoogleToken: debugData.availableCookies.includes("google_access_token"),
            totalCookies: debugData.totalCookiesFound,
          });
        }
      } catch (debugError) {
        console.warn("‚ö†Ô∏è [SLOT-MACHINE] Could not check debug cookies:", debugError);
      }

      // Check if Google auth is available by making a test call
      const response = await fetch("/api/google/contacts?input=test", {
        credentials: "include",
      });

      console.log("üîç [SLOT-MACHINE] Auth check response:", {
        status: response.status,
        ok: response.ok,
        statusText: response.statusText,
      });

      if (response.ok) {
        // Auth is working, open the search modal
        console.log("‚úÖ [SLOT-MACHINE] Google auth is working, opening search modal");
        initializeSlotMachine();
        return true;
      } else if (response.status === 401) {
        // Need to authenticate
        let errorData = {};
        try {
          const text = await response.text();
          errorData = JSON.parse(text);
        } catch (e) {
          // Ignore parse errors
        }
        console.log("üîê [SLOT-MACHINE] Google auth required (401):", errorData);
        console.log("üîê [SLOT-MACHINE] Showing auth modal - cookies may not be set correctly");
        console.log("üîê [SLOT-MACHINE] Try visiting /api/debug-cookies to verify cookie status");
        showGoogleAuthModal();
        return false;
      } else {
        // Other error
        console.error("‚ùå [SLOT-MACHINE] Google auth check failed:", response.status);
        const errorText = await response.text().catch(() => "Unknown error");
        console.error("‚ùå [SLOT-MACHINE] Error response:", errorText);
        showSlotNotification(`Error checking Google authentication: ${response.status}`, "error");
        return false;
      }
    } catch (error) {
      console.error("‚ùå [SLOT-MACHINE] Error checking Google auth:", error);
      showSlotNotification("Error checking Google authentication", "error");
      return false;
    }
  }
  // Store last search queries per slot machine instance
  const searchQueryCache = {};

  // Generic slot machine modal function
  async function showSlotMachineModal(config) {
    const {
      id,
      title,
      options,
      selectedValue,
      showCloseButton = true,
      showCancelButton = true,
      onSelect,
      enableSearch = false,
      fetchApiEndpoint,
      searchText,
      searchPlaceholder,
      apiParams = {},
      dataTransform,
      valueField = "value",
      labelField = "label",
      noResultsText = "No results found",
    } = config;

    // Check for dynamically updated options
    const dynamicOptions = window.slotMachineOptions && window.slotMachineOptions[id];
    const finalOptions = dynamicOptions || options;

    // Initialize selectedIndex early to avoid reference errors
    let selectedIndex = finalOptions.findIndex((option) => {
      const optionValue = option[valueField] || option.value || option.place_id || option.id;

      // Special handling for date fields (due-date components)
      if (id.includes("due-date") || id.includes("dueDate")) {
        if (optionValue && selectedValue) {
          // Normalize both dates to ISO strings for comparison
          const optionDate = new Date(optionValue);
          const selectedDate = new Date(selectedValue);

          // Check if both are valid dates and compare their time values
          if (!isNaN(optionDate.getTime()) && !isNaN(selectedDate.getTime())) {
            return optionDate.getTime() === selectedDate.getTime();
          }
        }
      }

      return optionValue && selectedValue && optionValue.toString() === selectedValue.toString();
    });

    // Initialize originalOptions immediately for static options (before search setup)
    let originalOptions = [];
    // if (!fetchOnLoad && finalOptions.length > 0) {
    //   originalOptions = [...finalOptions];
    //   console.log(
    //     `üîç [SLOT-MACHINE] Initialized originalOptions with ${originalOptions.length} static options`
    //   );
    //   console.log(`üîç [SLOT-MACHINE] Sample option structure:`, originalOptions[0]);
    // }

    // Helper function to create LI elements consistently
    function createOptionElement(option, index, isSelected = false) {
      const li = document.createElement("li");
      li.className = liClassName;

      // Base styles
      let baseStyles = `
        display: flex;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        padding: 12px 16px;
        user-select: none;
        position: relative;
      `;

      // Add selected styling if needed
      if (isSelected) {
        baseStyles += `
          background: bg-primary-500 !important;
          color: text-white !important; 
          border-radius: 8px !important;
          margin: 0 8px !important;
          color: white !important;
        `;
        li.classList.add("selected");
      }

      li.style.cssText = baseStyles;

      const span = document.createElement("span");
      span.className = spanClassName;
      span.style.cssText = `
        text-align: center;
        font-weight: 500;
        transition: all 0.2s;
      `;

      // Set content and data attributes
      span.textContent =
        option[labelField] || option.label || option.name || option.description || option;
      span.dataset.value =
        option[valueField] || option.value || option.place_id || option.id || option;
      span.dataset.label =
        option[labelField] || option.label || option.name || option.description || option;
      span.dataset.index = index;
      try {
        span.dataset.json = JSON.stringify(option);
      } catch (e) {
        // ignore non-serializable option
      }

      li.appendChild(span);
      return li;
    }

    // Helper function to create message LI elements
    function createMessageElement(message, isError = false) {
      const li = document.createElement("li");
      li.className = `${liClassName} ${isError ? "error-message" : "info-message"}`;
      li.style.cssText = `
        display: flex;
      `;
      li.textContent = message;
      return li;
    }

    // Helper function to populate options list
    function populateOptionsList(optionsArray, clearExisting = true) {
      if (clearExisting) {
        optionsList.innerHTML = "";
      }

      console.log("üîç [SLOT-MACHINE] populateOptionsList", optionsArray);
      let newSelectedIndex = -1;

      const modal = document.getElementById(`${id}-slot-machine-modal`);
      const emptyState = modal?.querySelector(".slot-empty-state");

      if (optionsArray.length > 0) {
        if (emptyState) {
          emptyState.classList.add("hidden");
        }
        optionsArray.forEach((option, index) => {
          const optionValue = option[valueField] || option.value || option.place_id || option.id;
          const isSelected =
            optionValue && selectedValue && optionValue.toString() === selectedValue.toString();

          // Track the new selected index in the filtered results
          if (isSelected) {
            newSelectedIndex = index;
          }

          const li = createOptionElement(option, index, isSelected);
          optionsList.appendChild(li);
        });
      } else {
        if (emptyState) {
          emptyState.classList.remove("hidden");
        }
      }

      // Handle single item case - if there's only one option and no selection, select it by default
      if (newSelectedIndex === -1 && optionsArray.length === 1) {
        newSelectedIndex = 0;
      }

      return newSelectedIndex;
    }

    // Lock body scroll to prevent background scrolling (Safari iOS compatible)
    if (window.lockBodyScroll) {
      window.lockBodyScroll();
    } else {
      // Fallback for older implementations
      document.body.style.overflow = "hidden";
    }

    // Create modal using partial route
    const headers = new Headers();
    headers.set("x-component-id", id);
    headers.set("x-modal-title", title);
    headers.set("x-show-search", enableSearch.toString());
    headers.set("x-cancel-button", "Cancel");
    headers.set("x-select-button", "Select");
    headers.set("x-no-results-text", noResultsText);
    headers.set("x-global-input-classes", globalInputClasses || "");

    // Add search-specific headers if search is enabled
    if (enableSearch) {
      headers.set("x-search-text", searchText || "");
      headers.set("x-search-placeholder", searchPlaceholder || "Type to search...");
    }

    const response = await fetch("/partials/slot-machine-modal", {
      headers: headers,
    });

    if (!response.ok) {
      console.error("Failed to fetch slot machine modal partial:", response.status);
      return;
    }

    const modalHTML = await response.text();
    const modalWrapper = document.createElement("div");
    modalWrapper.innerHTML = modalHTML;
    const modal = modalWrapper.firstElementChild;

    // Get the modal content from the partial
    const modalContent = modal.querySelector(".mx-4.max-h-\\[90vh\\].w-full.max-w-2xl");

    // Get references to elements from the partial
    const optionsList = modal.querySelector(`#${id}-slot-options-list`);
    const selectButton = modal.querySelector(`#${id}-slot-select-btn`);
    const cancelButton = modal.querySelector(`#${id}-slot-cancel-btn`);
    const closeButton = modal.querySelector(`#${id}-close-slot-modal`);
    const searchInput = modal.querySelector(`#${id}-slot-search-input`);
    const liClassName = "text-black dark:text-white";
    const spanClassName = "slot-machine-item-text";

    // Add event listeners to buttons from the partial
    if (closeButton) {
      closeButton.addEventListener("click", async () => {
        await cleanupModal();
        modal.remove();
      });
    }

    if (cancelButton) {
      cancelButton.addEventListener("click", async () => {
        await cleanupModal();
        modal.remove();
      });
    }

    // Focus search input after modal is fully rendered (only for non-fetchOnLoad modals)
    if (searchInput) {
      // Restore previous search query if it exists
      const cachedQuery = searchQueryCache[id];
      if (cachedQuery) {
        searchInput.value = cachedQuery;
      }

      // Use setTimeout to ensure the modal is fully rendered
      setTimeout(() => {
        searchInput.focus();

        // If there's a cached query, trigger the search
        if (cachedQuery && fetchApiEndpoint && cachedQuery.length >= 2) {
          // Trigger input event to perform search
          const inputEvent = new Event("input", { bubbles: true });
          searchInput.dispatchEvent(inputEvent);
        }
      }, 100);
    }

    // Add search functionality if enabled
    if (enableSearch && searchInput) {
      let searchTimeout;
      // originalOptions is now initialized earlier in the function

      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();

        // Cache the search query for this slot machine instance
        searchQueryCache[id] = query;

        console.log(
          `üîç [SLOT-MACHINE] Search input changed: "${query}", originalOptions: ${originalOptions.length}`
        );

        // Clear previous timeout
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }

        // If fetchOnLoad is true OR we have pre-populated options without an API endpoint, filter existing options
        //   if (
        //     fetchOnLoad ||
        //     (!fetchApiEndpoint && (originalOptions.length > 0 || finalOptions.length > 0))
        //   ) {
        //     // Store original options on first search
        //     if (originalOptions.length === 0) {
        //       // If we have finalOptions (pre-populated from props), use those
        //       console.log("üîç [SLOT-MACHINE] finalOptions", finalOptions);
        //       if (finalOptions.length > 0) {
        //         originalOptions = finalOptions.map((option, index) => ({
        //           value: option[valueField] || option.value || "",
        //           label: option[labelField] || option.label || "",
        //           index: index,
        //         }));
        //         if (emptyState) {
        //           emptyState.classList.add("hidden");
        //         }
        //       } else {
        //         // Otherwise, get from DOM
        //         originalOptions = Array.from(optionsList.querySelectorAll("li")).map((li, index) => {
        //           const span = li.querySelector("span");
        //           return {
        //             value: span?.dataset.value || "",
        //             label: span?.dataset.label || "",
        //             index: index,
        //           };
        //         });
        //         if (emptyState) {
        //           emptyState.classList.add("hidden");
        //         }
        //       }
        //     }

        //     // If search is cleared, restore all original options
        //     if (query.length === 0) {
        //       if (optionsList) {
        //         optionsList.innerHTML = "";
        //         originalOptions.forEach((option, index) => {
        //           const li = document.createElement("li");
        //           li.className = spanClassName;
        //           li.style.cssText = `
        //   display: flex;
        //   align-items: center;
        //   justify-content: center;
        //   height: 3rem;
        //   text-align: center;
        //   font-weight: 500;
        //   cursor: pointer;
        //   transition: all 0.2s;
        //   min-height: 48px;
        //   padding: 12px 16px;
        //   user-select: none;
        //   position: relative;
        // `;

        //           const span = document.createElement("span");
        //           span.className = spanClassName;
        //           span.style.cssText = `
        //   text-align: center;
        //   font-weight: 500;
        //   transition: all 0.2s;
        //   width: 100%;
        // `;

        //           span.textContent = option.label;
        //           span.dataset.value = option.value;
        //           span.dataset.label = option.label;
        //           span.dataset.index = index;

        //           li.appendChild(span);
        //           optionsList.appendChild(li);
        //         });
        //       }
        //       return;
        //     }

        //     // Filter options based on search query
        //     console.log(`üîç [SLOT-MACHINE] Filtering options with query: "${query}"`);
        //     console.log(
        //       `üîç [SLOT-MACHINE] Original options:`,
        //       originalOptions.map((o) => ({ label: o.label, value: o.value }))
        //     );

        //     const filteredOptions = originalOptions.filter((option) => {
        //       const matches = option.label.toLowerCase().includes(query.toLowerCase());
        //       console.log(
        //         `üîç [SLOT-MACHINE] Option "${option.label}" matches "${query}": ${matches}`
        //       );
        //       return matches;
        //     });
        //     console.log(
        //       `üîç [SLOT-MACHINE] Filtered ${originalOptions.length} options to ${filteredOptions.length} results`
        //     );

        //     // Update the options list
        //     if (optionsList) {
        //       optionsList.innerHTML = "";
        //       if (emptyState) {
        //         emptyState.classList.add("hidden");
        //       }
        //       if (filteredOptions.length > 0) {
        //         console.log(`üîç [SLOT-MACHINE] Showing ${filteredOptions.length} filtered results`);
        //         const newSelectedIndex = populateOptionsList(filteredOptions);
        //         selectedIndex = newSelectedIndex;

        //         // Update selection styling and center the selected item
        //         updateSelection();
        //         centerSelectedItem();
        //       } else {
        //         console.log(
        //           `üîç [SLOT-MACHINE] No matching results found, showing no-results message`
        //         );
        //         // Show "no results" message
        //         const messageLi = createMessageElement("No matching clients found");
        //         optionsList.innerHTML = "";
        //         optionsList.appendChild(messageLi);
        //         selectedIndex = -1;
        //         if (emptyState) {
        //           emptyState.classList.remove("hidden");
        //         }
        //       }
        //     }
        //     return;
        //   }

        // Original API-based search for non-fetchOnLoad cases
        if (fetchApiEndpoint && query.length >= 2) {
          searchTimeout = setTimeout(async () => {
            try {
              // console.log(`üîç [SLOT-MACHINE] Searching for: ${query}`);

              // Build search URL with API params
              const searchParams = new URLSearchParams({
                input: query,
                ...apiParams,
              });

              const response = await fetch(`${fetchApiEndpoint}?${searchParams}`, {
                credentials: "include",
              });
              if (!response.ok) {
                throw new Error(`Search failed: ${response.status}`);
              }

              const data = await response.json();
              console.log(`üîç [SLOT-MACHINE] Search results:`, data);

              // Transform data if transform function exists
              let transformedData = data;
              if (dataTransform && typeof window[dataTransform] === "function") {
                transformedData = window[dataTransform](data);
                console.log(`üîç [SLOT-MACHINE] Transformed data:`, transformedData);
              }

              // Handle different data formats
              let optionsArray = [];
              if (Array.isArray(transformedData)) {
                optionsArray = transformedData;
              } else if (transformedData && Array.isArray(transformedData.predictions)) {
                // Google Places format
                optionsArray = transformedData.predictions;
              } else if (transformedData && Array.isArray(transformedData.results)) {
                // Alternative format
                optionsArray = transformedData.results;
              } else if (transformedData && Array.isArray(transformedData.contacts)) {
                // Google Contacts format
                optionsArray = transformedData.contacts;
              } else if (
                transformedData &&
                transformedData.data &&
                Array.isArray(transformedData.data)
              ) {
                // Wrapped format
                optionsArray = transformedData.data;
              }

              console.log(`üîç [SLOT-MACHINE] Options array:`, optionsArray);
              console.log(`üîç [SLOT-MACHINE] First option:`, optionsArray[0]);
              console.log(`üîç [SLOT-MACHINE] Value field:`, valueField);
              console.log(`üîç [SLOT-MACHINE] Label field:`, labelField);

              // Update options list with search results
              if (optionsList) {
                const newSelectedIndex = populateOptionsList(optionsArray);
                selectedIndex = newSelectedIndex;
                updateSelection();
                centerSelectedItem();
              }
            } catch (error) {
              console.error(`üîç [SLOT-MACHINE] Search error:`, error);

              // Show error message
              if (optionsList) {
                const errorLi = createMessageElement("Error loading results", true);
                optionsList.innerHTML = "";
                optionsList.appendChild(errorLi);
              }
            }
          }, 300); // 300ms debounce
        } else if (query.length === 0) {
          // Restore original options when search is empty
          if (optionsList) {
            // Use originalOptions if available (for static options), otherwise use finalOptions
            const optionsToRestore = originalOptions.length > 0 ? originalOptions : finalOptions;
            const newSelectedIndex = populateOptionsList(optionsToRestore);
            selectedIndex = newSelectedIndex;
            updateSelection();
            centerSelectedItem();
          }
        }
      });
    }

    // // Fetch data on load if fetchOnLoad is true
    // if (fetchOnLoad && fetchApiEndpoint && optionsList) {
    //   try {
    //     console.log(`üîÑ [SLOT-MACHINE] Fetching data on load for: ${fetchApiEndpoint}`);

    //     // Build URL with API params
    //     const searchParams = new URLSearchParams(apiParams);
    //     const response = await fetch(`${fetchApiEndpoint}?${searchParams}`);

    //     if (!response.ok) {
    //       throw new Error(`Fetch failed: ${response.status}`);
    //     }

    //     const data = await response.json();
    //     console.log(`üîÑ [SLOT-MACHINE] Load data response:`, data);

    //     // Transform data if transform function exists
    //     let transformedData = data;
    //     if (dataTransform && typeof window[dataTransform] === "function") {
    //       transformedData = window[dataTransform](data);
    //       console.log(`üîÑ [SLOT-MACHINE] Transformed load data:`, transformedData);
    //     }

    //     // Handle different data formats
    //     let optionsArray = [];
    //     if (Array.isArray(transformedData)) {
    //       optionsArray = transformedData;
    //     } else if (transformedData && Array.isArray(transformedData.predictions)) {
    //       // Google Places format
    //       optionsArray = transformedData.predictions;
    //     } else if (transformedData && Array.isArray(transformedData.results)) {
    //       // Alternative format
    //       optionsArray = transformedData.results;
    //     } else if (transformedData && Array.isArray(transformedData.clients)) {
    //       // Clients API format
    //       optionsArray = transformedData.clients;
    //     } else if (transformedData && transformedData.data && Array.isArray(transformedData.data)) {
    //       // Wrapped format
    //       optionsArray = transformedData.data;
    //     }

    //     console.log(`üîÑ [SLOT-MACHINE] Load options array:`, optionsArray);

    //     // Update finalOptions with fetched data
    //     if (optionsArray.length > 0) {
    //       const newSelectedIndex = populateOptionsList(optionsArray);
    //       selectedIndex = newSelectedIndex;
    //       updateSelection();
    //       centerSelectedItem();
    //     }
    //   } catch (error) {
    //     console.error(`üîÑ [SLOT-MACHINE] Error fetching data on load:`, error);
    //   }

    //   // Focus search input after fetchOnLoad data is populated
    //   if (searchInput) {
    //     setTimeout(() => {
    //       searchInput.focus();
    //     }, 100);
    //   }
    // }

    // Populate options in the list from the partial (only if not fetched on load)
    if (optionsList) {
      optionsList.style.transform = "translateY(0px)";
      populateOptionsList(finalOptions);
    }

    // Fetch all options when modal opens if using API endpoint
    if (fetchApiEndpoint && optionsList) {
      (async () => {
        try {
          console.log(
            `üîÑ [SLOT-MACHINE] Fetching all options on modal open for: ${fetchApiEndpoint}`
          );

          // Build URL with API params (empty or minimal query to get all results)
          const searchParams = new URLSearchParams({
            input: "", // Empty query to fetch all
            ...apiParams,
          });

          const response = await fetch(`${fetchApiEndpoint}?${searchParams}`, {
            credentials: "include",
          });

          if (!response.ok) {
            throw new Error(`Fetch failed: ${response.status}`);
          }

          const data = await response.json();
          console.log(`üîÑ [SLOT-MACHINE] Initial load data response:`, data);

          // Transform data if transform function exists
          let transformedData = data;
          if (dataTransform && typeof window[dataTransform] === "function") {
            transformedData = window[dataTransform](data);
            console.log(`üîÑ [SLOT-MACHINE] Transformed initial load data:`, transformedData);
          }

          // Handle different data formats
          let optionsArray = [];
          if (Array.isArray(transformedData)) {
            optionsArray = transformedData;
          } else if (transformedData && Array.isArray(transformedData.predictions)) {
            // Google Places format
            optionsArray = transformedData.predictions;
          } else if (transformedData && Array.isArray(transformedData.results)) {
            // Alternative format
            optionsArray = transformedData.results;
          } else if (transformedData && Array.isArray(transformedData.contacts)) {
            // Google Contacts format
            optionsArray = transformedData.contacts;
          } else if (
            transformedData &&
            transformedData.data &&
            Array.isArray(transformedData.data)
          ) {
            // Wrapped format
            optionsArray = transformedData.data;
          }

          console.log(`üîÑ [SLOT-MACHINE] Initial load options array:`, optionsArray);

          // Update options list with fetched data
          if (optionsArray.length > 0) {
            // Store as originalOptions for search restoration
            originalOptions = [...optionsArray];
            const newSelectedIndex = populateOptionsList(optionsArray);
            selectedIndex = newSelectedIndex;
            updateSelection();
            centerSelectedItem();
          } else {
            console.log(`üîÑ [SLOT-MACHINE] No options returned from initial fetch`);
          }
        } catch (error) {
          console.error(`üîÑ [SLOT-MACHINE] Error fetching data on modal open:`, error);
          // Don't show error message - let the user search instead
        }
      })();
    }

    // Slot machine functionality

    // Add event listener to select button from the partial
    if (selectButton) {
      selectButton.addEventListener("click", async () => {
        // Get the currently selected option from the DOM
        const currentOptions = optionsList.querySelectorAll("li");
        const selectedItem = currentOptions[selectedIndex];

        if (selectedItem && selectedIndex >= 0) {
          const span = selectedItem.querySelector("span");
          if (span) {
            const value = span.dataset.value;
            const label = span.dataset.label;

            await cleanupModal();
            modal.remove();

            // Call the generic handleSelect function
            // Try to include full option data if available
            let rawData = undefined;
            try {
              rawData = span.dataset.json ? JSON.parse(span.dataset.json) : undefined;
            } catch {}

            // Notify global listeners first
            window.dispatchEvent(
              new CustomEvent("slot-select", {
                detail: { componentId: id, value, label, data: rawData },
              })
            );

            // If this is a Google Contacts picker and we have data, try to render preview
            if (fetchApiEndpoint && fetchApiEndpoint.includes("/api/google/contacts") && rawData) {
              const previewId = `${id}-preview`;
              renderContactPreview(rawData, previewId);
            }

            if (typeof window.handleSelect === "function") {
              window.handleSelect(value, label, id);
            }
          }
        }
      });
    }

    // Add modal to DOM
    document.body.appendChild(modal);

    // Handle single item case - if there's only one option, select it by default
    if (selectedIndex === -1 && finalOptions.length === 1) {
      selectedIndex = 0;
    }

    // Debug logging for selection
    // // console.log("üé∞ [SLOT-MACHINE] Selection debug:", {
    //   selectedValue,
    //   selectedValueType: typeof selectedValue,
    //   options: finalOptions.map((opt) => ({
    //     value: opt.value,
    //     valueType: typeof opt.value,
    //     label: opt.label,
    //   })),
    //   selectedIndex,
    //   foundOption: finalOptions[selectedIndex],
    // });

    // Center selected item
    function centerSelectedItem() {
      // Only apply translateY if there's a valid selection
      if (selectedIndex >= 0) {
        // Use responsive item height based on screen size
        const itemHeight = window.innerWidth <= 768 ? 56 : 48;
        const containerHeight = 192;
        const centerOffset = (containerHeight - itemHeight) / 2;
        const targetY = -(selectedIndex * itemHeight) + centerOffset;

        // Use smooth transition
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = `translateY(${targetY}px)`;
      } else {
        // No selection - keep at default position
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = "translateY(0px)";
      }

      // Update centering (visual feedback only, no selection styling)
      updateCentering();
    }

    // Add checkmark to selected item
    function addCheckmark(item) {
      // Remove existing checkmark if any
      const existingCheckmark = item.querySelector(".checkmark");
      if (existingCheckmark) {
        existingCheckmark.remove();
      }

      const checkmark = document.createElement("div");
      checkmark.className = "checkmark";
      checkmark.innerHTML = "‚úì";
      checkmark.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        transition: all 0.2s ease-out;
        color: #ffffff;
        font-weight: bold;
        font-size: 16px;
        animation: checkmarkPulse 1.5s ease-in-out infinite;
        z-index: 10;
      `;

      item.appendChild(checkmark);
    }

    // Remove checkmark from item
    function removeCheckmark(item) {
      const checkmark = item.querySelector(".checkmark");
      if (checkmark) {
        checkmark.remove();
      }
    }

    // Update selection styling (only for clicked items)
    function updateSelection() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        if (index === selectedIndex && selectedIndex >= 0) {
          item.classList.add("selected", "bg-primary-500", "text-white");
          // Reset and apply selected styles
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
            border-radius: 8px;
            margin: 0 8px;
          `;
          addCheckmark(item);
          if (selectButton) selectButton.disabled = false;
        } else {
          item.classList.remove("selected", "bg-primary-500", "text-white");
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
          `;
          removeCheckmark(item);
        }
      });

      // Disable select button if no item is selected
      if (selectedIndex < 0) {
        if (selectButton) selectButton.disabled = true;
      }
    }

    // Update visual centering (without selection styling)
    function updateCentering() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        // Only update the centering, not the selection styling
        if (index === selectedIndex && selectedIndex >= 0) {
          // Just center the item visually, don't apply selected styling
          item.style.transform = "scale(1.05)";
          item.style.transition = "transform 0.2s ease-out";
        } else {
          item.style.transform = "scale(1)";
          item.style.transition = "transform 0.2s ease-out";
        }
      });
    }

    // Handle wheel events (desktop) with natural scroll sensitivity
    let wheelAccumulator = 0;
    const wheelThreshold = 50; // Require more scroll distance before moving items

    optionsList.addEventListener("wheel", (e) => {
      e.preventDefault();

      // Accumulate wheel delta to make scrolling feel more natural
      wheelAccumulator += e.deltaY;

      // Only move when we've accumulated enough scroll distance
      if (Math.abs(wheelAccumulator) >= wheelThreshold) {
        const deltaY = wheelAccumulator;
        wheelAccumulator = 0; // Reset accumulator

        // Get current options count from DOM
        const currentOptions = optionsList.querySelectorAll("li");
        const maxIndex = currentOptions.length - 1;

        // Calculate new index based on scroll direction
        if (deltaY > 0) {
          // Scrolling down - move to next item
          selectedIndex = Math.min(selectedIndex + 1, maxIndex);
        } else {
          // Scrolling up - move to previous item
          selectedIndex = Math.max(selectedIndex - 1, 0);
        }

        // Smoothly center the selected item and update selection
        centerSelectedItem();
        updateSelection();
      }
    });

    // Handle touch events (mobile)
    let touchStartY = 0;
    let touchStartTime = 0;
    let isScrolling = false;

    optionsList.addEventListener(
      "touchstart",
      (e) => {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isScrolling = false;
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (!isScrolling) {
          isScrolling = true;
        }
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchend",
      (e) => {
        e.preventDefault();
        if (!isScrolling) return;

        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        const deltaY = touchStartY - touchEndY;
        const deltaTime = touchEndTime - touchStartTime;

        // Only process if there was significant movement and it was quick enough
        if (Math.abs(deltaY) > 20 && deltaTime < 500) {
          // Get current options count from DOM
          const currentOptions = optionsList.querySelectorAll("li");
          const maxIndex = currentOptions.length - 1;

          if (deltaY > 0) {
            // Swiping up - move to next item
            selectedIndex = Math.min(selectedIndex + 1, maxIndex);
          } else {
            // Swiping down - move to previous item
            selectedIndex = Math.max(selectedIndex - 1, 0);
          }

          // Smoothly center the selected item and update selection
          centerSelectedItem();
          updateSelection();
        }
      },
      { passive: false }
    );

    // Handle click on items
    optionsList.addEventListener("click", (e) => {
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on click
        updateSelection();
      }
    });

    // Handle touch on items for mobile
    optionsList.addEventListener("touchend", (e) => {
      e.preventDefault();
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on touch
        updateSelection();
      }
    });

    // Handle keyboard navigation
    document.addEventListener("keydown", (e) => {
      // Only handle keyboard events when modal is open
      if (!modal || !document.body.contains(modal)) return;

      const currentOptions = optionsList.querySelectorAll("li");
      const maxIndex = currentOptions.length - 1;

      switch (e.key) {
        case "ArrowUp":
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, 0);
          centerSelectedItem();
          updateSelection();
          break;

        case "ArrowDown":
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, maxIndex);
          centerSelectedItem();
          updateSelection();
          break;

        case "Enter":
          e.preventDefault();
          if (selectedIndex >= 0 && selectedIndex <= maxIndex) {
            // Trigger the same logic as clicking the select button
            const selectedItem = currentOptions[selectedIndex];
            if (selectedItem) {
              const span = selectedItem.querySelector("span");
              if (span) {
                const value = span.dataset.value;
                const label = span.dataset.label;

                // Close modal and call handleSelect
                cleanupModal();
                modal.remove();

                if (typeof window.handleSelect === "function") {
                  window.handleSelect(value, label, id);
                }
              }
            }
          }
          break;

        case "Escape":
          e.preventDefault();
          // Close modal without selecting
          cleanupModal();
          modal.remove();
          break;
      }
    });

    // Initial setup
    centerSelectedItem();
    updateSelection();

    // Cleanup function to restore body scroll
    function cleanupModal() {
      // Unlock body scroll (Safari iOS compatible)
      if (window.unlockBodyScroll) {
        window.unlockBodyScroll();
      } else {
        // Fallback for older implementations
        document.body.style.overflow = "";
      }
    }

    // Close modal when clicking outside
    modal.addEventListener("click", async (e) => {
      if (e.target === modal) {
        await cleanupModal();
        modal.remove();
      }
    });
  }

  // Generic contact preview rendering function (for Google Contacts and similar data)
  function renderContactPreview(data, previewElementId) {
    const preview = document.getElementById(previewElementId);
    if (!preview || !data) return;

    const c = typeof data === "string" ? JSON.parse(data) : data;
    const name = c.name || c.label || "Selected Contact";

    // Helper to format keys (camelCase to Title Case)
    const formatKey = (key) => {
      return key
        .replace(/([A-Z])/g, " $1")
        .replace(/^./, (str) => str.toUpperCase())
        .trim();
    };

    // Helper to format values
    const formatValue = (value) => {
      if (Array.isArray(value)) {
        return value.join(", ");
      }
      if (typeof value === "object" && value !== null) {
        return JSON.stringify(value, null, 2);
      }
      return String(value);
    };

    // Get emoji for common fields
    const getEmoji = (key) => {
      const emojiMap = {
        email: "üìß",
        phone: "üìû",
        organization: "üè¢",
        company: "üè¢",
        jobTitle: "üíº",
        title: "üíº",
        address: "üìç",
        birthday: "üéÇ",
        websites: "üåê",
        biography: "üìù",
        allEmails: "üìß",
        allPhones: "üìû",
      };
      return emojiMap[key.toLowerCase()] || "‚Ä¢";
    };

    // Build the fields HTML by looping through all properties
    const fieldsHtml = Object.keys(c)
      .filter((key) => {
        const value = c[key];
        const keyLower = key.toLowerCase();
        const formattedLabel = formatKey(key).toLowerCase();

        // Skip keys that contain "Value:" or "Raw Contact"
        const skipPatterns = [
          "value:",
          /^value$/i,
          /^raw\s*contact$/i,
          "rawcontact",
          "raw_contact",
        ];

        const shouldSkip = skipPatterns.some((pattern) => {
          if (typeof pattern === "string") {
            return keyLower.includes(pattern) || formattedLabel.includes(pattern);
          } else if (pattern instanceof RegExp) {
            return pattern.test(key) || pattern.test(formattedLabel);
          }
          return false;
        });

        if (shouldSkip) return false;

        const displayLabel = formatKey(key);
        if (
          displayLabel.toLowerCase().includes("value:") ||
          displayLabel.toLowerCase().includes("raw contact")
        ) {
          return false;
        }

        return (
          key !== "name" &&
          key !== "id" &&
          value !== null &&
          value !== undefined &&
          value !== "" &&
          !(Array.isArray(value) && value.length === 0) &&
          !(typeof value === "object" && Object.keys(value).length === 0)
        );
      })
      .map((key) => {
        const value = formatValue(c[key]);
        const label = formatKey(key);
        const emoji = getEmoji(key);
        return `<div>${emoji} <span class="font-medium">${label}:</span> ${value}</div>`;
      })
      .join("");

    preview.innerHTML = `
      <div class="text-sm">
        <div class="text-base font-semibold mb-1">${name}</div>
        <div class="space-y-1 text-gray-700 dark:text-gray-300">
          ${fieldsHtml || '<div class="text-gray-500 italic">No additional information available</div>'}
        </div>
      </div>
    `;
    preview.classList.remove("hidden");
  }

  // Generic handleSelect function that works for any slot machine
  window.handleSelect = function (value, label, componentId, passedSaveApiEndpoint) {
    console.log(`üé∞ [SLOT-MACHINE] ===== WINDOW.HANDLESELECT CALLED =====`);
    console.log(`üé∞ [SLOT-MACHINE] Value: ${value} (type: ${typeof value})`);
    console.log(`üé∞ [SLOT-MACHINE] Label: ${label} (type: ${typeof label})`);
    console.log(`üé∞ [SLOT-MACHINE] Component ID: ${componentId}`);
    console.log(`üé∞ [SLOT-MACHINE] Passed Save API Endpoint: ${passedSaveApiEndpoint}`);
    console.log(`üé∞ [SLOT-MACHINE] Global saveApiEndpoint: ${saveApiEndpoint}`);

    // Find the hidden input for this component
    const hiddenInput = document.getElementById(`${componentId}-value`);
    if (hiddenInput) {
      hiddenInput.value = value;
      console.log(
        `üé∞ [SLOT-MACHINE] Updated hidden input ${componentId}-value with value: ${value}`
      );
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Hidden input ${componentId}-value not found`);
    }

    // Find the button and update its text
    const button = document.getElementById(componentId);
    if (button) {
      // Try to find the button-text span first
      const buttonTextSpan = button.querySelector(".button-text");
      if (buttonTextSpan) {
        console.log(`üé∞ [SLOT-MACHINE] Found button-text span, updating to: ${label}`);
        buttonTextSpan.textContent = label;
        console.log(`üé∞ [SLOT-MACHINE] Button text span updated successfully`);
        console.log(`üé∞ [SLOT-MACHINE] Button text span computed styles:`, {
          color: getComputedStyle(buttonTextSpan).color,
          display: getComputedStyle(buttonTextSpan).display,
          visibility: getComputedStyle(buttonTextSpan).visibility,
        });
      } else {
        // Fallback to updating the entire button content
        console.log(`üé∞ [SLOT-MACHINE] Button-text span not found, updating entire button content`);
        button.textContent = label;
        console.log(`üé∞ [SLOT-MACHINE] Updated button text to: ${label}`);
      }
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Button ${componentId} not found`);
    }

    console.log(`‚úÖ [SLOT-MACHINE] Selected: ${label} (${value}) for component: ${componentId}`);

    // Auto-save to API if saveApiEndpoint is provided or legacy component IDs

    if (passedSaveApiEndpoint || componentId === "update-status") {
      console.log(
        `üé∞ [SLOT-MACHINE] Auto-saving to API for passedSaveApiEndpoint: ${passedSaveApiEndpoint}`
      );

      // Determine the correct API endpoint - passedSaveApiEndpoint takes priority
      let correctSaveApiEndpoint;
      if (passedSaveApiEndpoint) {
        // Use the passed saveApiEndpoint if provided (highest priority)
        correctSaveApiEndpoint = passedSaveApiEndpoint;
      } else {
        // For other components without saveApiEndpoint, use the component ID
        correctSaveApiEndpoint = componentId;
      }

      console.log(
        `üé∞ [SLOT-MACHINE] Calling saveToAPI with correct endpoint: ${correctSaveApiEndpoint}`
      );
      saveToAPI(correctSaveApiEndpoint, value, label);
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Not auto-saving to API for component: ${componentId}`);
    }
  };

  // Expose function to update slot machine options dynamically
  window.updateSlotMachineOptions = function (componentId, newOptions) {
    // Store the new options for this component
    if (!window.slotMachineOptions) {
      window.slotMachineOptions = {};
    }
    window.slotMachineOptions[componentId] = newOptions;
  };
</script>

<style>
  /* Prevent text selection in modal */
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    touch-action: pan-y !important;
    -webkit-touch-callout: none !important;
  }

  /* Improve touch targets for mobile */
  @media (max-width: 768px) {
    .slot-machine-item {
      min-height: 56px !important;
      height: 56px !important;
      padding: 16px !important;
      font-size: 16px !important;
    }

    .slot-machine-item-text {
      font-size: 16px !important;
    }
  }

  .slot-machine-item > span {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
  }

  /* Smooth transitions */
  .transition-transform {
    transition-property: transform;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 300ms;
  }

  /* Slot machine container styling */
  .slot-machine-container {
    min-height: 12rem !important;
    max-height: 12rem !important;
    height: 12rem !important;
    display: block !important;
  }

  /* Ensure the slot machine list takes full height */
  .slot-machine-container ul {
    height: 100% !important;
    min-height: 12rem !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
  }

  /* Ensure slot machine items are visible */
  .slot-machine-item {
    min-height: 3rem !important;
    height: 3rem !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: all 0.2s ease-in-out;
  }

  /* Ensure selected items have white text */
  .slot-machine-item.selected {
    color: white !important;
  }

  .slot-machine-item.selected span {
    color: white !important;
  }

  /* Default option text color */
  .slot-machine-item {
    color: #111827;
  }

  /* Checkmark pulse animation */
  @keyframes checkmarkPulse {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes checkmarkPulseDark {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    50% {
      opacity: 0.9;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 16px rgba(16, 185, 129, 1);
    }
  }

  /* Empty state styling */
  .slot-empty-state {
    transition: opacity 0.3s ease-in-out;
  }

  /* Message element styling */
  .error-message {
    color: #ef4444 !important;
  }

  .info-message {
    color: #6b7280 !important;
  }
</style>
