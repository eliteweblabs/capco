---
import SlotMachineMap from "./SlotMachineMap.astro";

interface Props {
  id: string;
  name: string;
  label: string;
  value?: string;
  placeholder?: string;
  required?: boolean;
  class?: string;
  projectStatus?: number;
}

const {
  id,
  name,
  label,
  value = "",
  placeholder = "Start typing an address...",
  required = false,
  class: className = "",
  projectStatus = 0,
} = Astro.props;

// Always render the address input (removed projectStatus restriction)
// if (projectStatus !== 0) {
//   return;
// }
---

<div class="relative custom-places-input">
  <!-- Add Address Button -->
  <button
    type="button"
    class={`places-add-btn w-full rounded-md border border-gray-300 bg-white px-3 py-2.5 text-left text-sm text-gray-500 transition-colors hover:border-gray-400 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-400 dark:hover:border-gray-500 dark:hover:bg-gray-600 ${className}`}
  >
    <div class="flex items-center justify-between">
      <span class="places-button-text">Add Address</span>
      <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
      </svg>
    </div>
  </button>

  <!-- Loading Indicator -->
  <div class="places-loading mb-3 hidden">
    <div class="flex items-center justify-center py-2">
      <svg class="h-4 w-4 animate-spin text-gray-400 mr-2" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"
        ></circle>
        <path
          class="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>
      <span class="text-sm text-gray-500 dark:text-gray-400">Searching for addresses...</span>
    </div>
  </div>

  <!-- Error Message -->
  <div class="places-error mb-3 text-sm text-red-600 dark:text-red-400 hidden"></div>

  <!-- Selected Address Display -->
  <!-- <div class="places-selected-container mb-3 hidden">
    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
      >Selected Address:</label
    >
    <div class="flex items-center justify-between bg-gray-50 dark:bg-gray-700 rounded-md p-3">
      <span class="places-selected-text text-sm text-gray-900 dark:text-white"></span>
      <button
        type="button"
        class="places-clear-btn text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 ml-2"
        title="Clear selection"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
  </div> -->

  <!-- Hidden input for form submission -->
  <input
    type="text"
    id={id}
    name={name}
    value={value}
    required={required}
    class="places-hidden-input sr-only"
    tabindex="-1"
    aria-hidden="true"
  />

  <!-- Slot Machine Map Component -->
  <div class="places-slot-machine-container hidden">
    <SlotMachineMap
      id={`${id}-slot-machine`}
      title="Select Address"
      options={[]}
      selectedValue=""
      placeholder="Choose an address..."
      theme="blue"
      showCloseButton={true}
      showCancelButton={true}
      skipSaveToAPI={true}
    />
  </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // Simple approach: find the container and initialize
    const container = document.querySelector(".custom-places-input") as HTMLElement;
    if (!container) return;

    // Generate a unique ID for this component instance
    const componentId = `places-${Math.random().toString(36).substr(2, 9)}`;

    const addBtn = container.querySelector(".places-add-btn") as HTMLButtonElement;
    const buttonText = container.querySelector(".places-button-text") as HTMLSpanElement;
    const hiddenInput = container.querySelector(".places-hidden-input") as HTMLInputElement;
    const loadingIndicator = container.querySelector(".places-loading") as HTMLDivElement;
    const errorDiv = container.querySelector(".places-error") as HTMLDivElement;
    const selectedContainer = container.querySelector(
      ".places-selected-container"
    ) as HTMLDivElement;
    const selectedText = container.querySelector(".places-selected-text") as HTMLSpanElement;
    const clearBtn = container.querySelector(".places-clear-btn") as HTMLButtonElement;

    if (!addBtn || !hiddenInput) {
      console.error("üö® [CUSTOM-PLACES] Required elements not found");
      return;
    }

    // Show loading state
    function showLoading() {
      loadingIndicator?.classList.remove("hidden");
    }

    // Hide loading state
    function hideLoading() {
      loadingIndicator?.classList.add("hidden");
    }

    // Show error message
    function showError(message: string) {
      if (errorDiv) {
        errorDiv.textContent = message;
        errorDiv.classList.remove("hidden");
      }
    }

    // Hide error message
    function hideError() {
      errorDiv?.classList.add("hidden");
    }

    // Show selected address
    function showSelectedAddress(address: string) {
      if (selectedText) {
        selectedText.textContent = address;
      }
      selectedContainer?.classList.remove("hidden");

      // Update button text to show selected address
      if (buttonText) {
        buttonText.textContent = address;
      }
    }

    // Hide selected address
    function hideSelectedAddress() {
      selectedContainer?.classList.add("hidden");
    }

    // Clear selection
    function clearSelection() {
      hiddenInput.value = "";
      hideSelectedAddress();
      hideError();

      // Reset button text
      if (buttonText) {
        buttonText.textContent = "Add Address";
      }
    }

    // Helper functions to manage body scroll lock
    function lockBodyScroll() {
      const body = document.body;
      const scrollY = window.scrollY;

      // Store current scroll position
      body.style.top = `-${scrollY}px`;
      body.classList.add("modal-open");

      console.log("üîí [CUSTOM-PLACES] Body scroll locked at position:", scrollY);
    }

    function unlockBodyScroll() {
      const body = document.body;
      const scrollY = body.style.top;

      // Remove the lock class
      body.classList.remove("modal-open");

      // Restore scroll position
      if (scrollY) {
        const scrollPosition = parseInt(scrollY || "0") * -1;
        body.style.top = "";
        window.scrollTo(0, scrollPosition);
      }

      console.log("üîì [CUSTOM-PLACES] Body scroll unlocked, restored to position:", scrollY);
    }

    // Show address search modal with input inside
    function showAddressSearchModal() {
      // Create modal HTML with search input inside
      const modalHTML = `
        <div id="${componentId}-address-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md mx-4">
            <!-- Modal Header -->
            <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
              <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Add Address</h3>
              <button type="button" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" onclick="this.closest('.fixed').remove()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>
            
            <!-- Modal Body -->
            <div class="p-4">
              <!-- Search Input -->
              <div class="relative mb-4">
                <input
                  type="text"
                  id="${componentId}-modal-search"
                  class="w-full rounded-md border border-gray-300 px-3 py-2.5 pr-10 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                  placeholder="Search for an address..."
                  autocomplete="off"
                />
                <button
                  type="button"
                  id="${componentId}-modal-search-btn"
                  class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors duration-200"
                  title="Search for address"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                  </svg>
                </button>
              </div>
              
              <!-- Loading Indicator -->
              <div id="${componentId}-modal-loading" class="hidden mb-4">
                <div class="flex items-center justify-center py-2">
                  <svg class="h-4 w-4 animate-spin text-gray-400 mr-2" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  <span class="text-sm text-gray-500 dark:text-gray-400">Searching for addresses...</span>
                </div>
              </div>
              
              <!-- Error Message -->
              <div class="h-4">
              <div id="${componentId}-modal-error" class="hidden mb-4 text-sm text-red-600 dark:text-red-400"></div>
              </div>
            </div>
            
            <!-- Modal Footer -->
            <div class="flex items-center justify-end gap-2 p-4 border-t border-gray-200 dark:border-gray-700">
              <button
                type="button"
                id="${componentId}-modal-cancel"
                class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-600 dark:hover:bg-gray-600"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      `;

      // Lock body scroll and add modal to page
      lockBodyScroll();
      document.body.insertAdjacentHTML("beforeend", modalHTML);

      // Get modal elements
      const modal = document.getElementById(`${componentId}-address-modal`);
      const modalSearchInput = document.getElementById(
        `${componentId}-modal-search`
      ) as HTMLInputElement;
      const modalSearchBtn = document.getElementById(
        `${componentId}-modal-search-btn`
      ) as HTMLButtonElement;
      const modalLoading = document.getElementById(`${componentId}-modal-loading`);
      const modalError = document.getElementById(`${componentId}-modal-error`);
      const modalCancel = document.getElementById(`${componentId}-modal-cancel`);

      // Debug: Check if all elements were found
      console.log("üîç [CUSTOM-PLACES] Modal elements found:", {
        modal: !!modal,
        modalSearchInput: !!modalSearchInput,
        modalSearchBtn: !!modalSearchBtn,
        modalLoading: !!modalLoading,
        modalError: !!modalError,
        modalCancel: !!modalCancel,
        componentId: componentId,
      });

      // Focus on search input
      modalSearchInput?.focus();

      // Event listeners - add a small delay to ensure elements are fully rendered
      setTimeout(() => {
        console.log("üîç [CUSTOM-PLACES] Setting up event listeners...");
        console.log("üîç [CUSTOM-PLACES] modalSearchBtn:", !!modalSearchBtn);
        console.log("üîç [CUSTOM-PLACES] modalSearchInput:", !!modalSearchInput);

        if (modalSearchBtn) {
          modalSearchBtn.addEventListener("click", () => {
            console.log(
              "üîç [CUSTOM-PLACES] Search button clicked, query:",
              modalSearchInput?.value
            );
            if (modalSearchInput) {
              searchPlacesInModal(modalSearchInput.value);
            }
          });
          console.log("üîç [CUSTOM-PLACES] Search button event listener added");
        } else {
          console.error("üö® [CUSTOM-PLACES] modalSearchBtn not found for event listener");
        }

        if (modalSearchInput) {
          // Add input event listener with debouncing and 2-character minimum
          let searchTimeout: NodeJS.Timeout;
          modalSearchInput.addEventListener("input", (e) => {
            const query = (e.target as HTMLInputElement).value.trim();
            console.log("üîç [CUSTOM-PLACES] Input changed, query:", query);

            // Clear previous timeout
            if (searchTimeout) {
              clearTimeout(searchTimeout);
            }

            // Only search if query is at least 2 characters
            if (query.length >= 2) {
              console.log("üîç [CUSTOM-PLACES] Query is 2+ characters, scheduling search...");
              searchTimeout = setTimeout(() => {
                console.log("üîç [CUSTOM-PLACES] Executing delayed search for:", query);
                searchPlacesInModal(query);
              }, 300); // 300ms debounce
            } else if (query.length === 0) {
              // Clear results if input is empty
              hideModalError();
            }
          });

          // Keep Enter key functionality
          modalSearchInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              const query = modalSearchInput.value.trim();
              if (query.length >= 2) {
                console.log("üîç [CUSTOM-PLACES] Enter key pressed, query:", query);
                if (searchTimeout) {
                  clearTimeout(searchTimeout);
                }
                searchPlacesInModal(query);
              }
            }
          });
          console.log("üîç [CUSTOM-PLACES] Search input event listeners added");
        } else {
          console.error("üö® [CUSTOM-PLACES] modalSearchInput not found for event listener");
        }
      }, 100);

      modalCancel?.addEventListener("click", () => {
        modal?.remove();
        unlockBodyScroll();
      });

      modal?.addEventListener("click", (e) => {
        if (e.target === modal) {
          modal.remove();
          unlockBodyScroll();
        }
      });

      // Search function for modal
      async function searchPlacesInModal(query: string) {
        console.log("üîç [CUSTOM-PLACES] searchPlacesInModal function called with query:", query);

        if (!query.trim()) {
          console.log("üîç [CUSTOM-PLACES] Empty query, showing error");
          showModalError("Please enter an address to search");
          return;
        }

        console.log("üîç [CUSTOM-PLACES] Starting address search...");
        showModalLoading();
        hideModalError();

        try {
          // Use our server-side proxy endpoint to avoid CORS issues
          const requestUrl = `/api/places-autocomplete?input=${encodeURIComponent(query)}&types=address&components=country:us&locationBias=circle:100@42.3601,-71.0589`;

          console.log("üîç [CUSTOM-PLACES] Making HTTP request to proxy endpoint:", requestUrl);

          const response = await fetch(requestUrl);
          const data = await response.json();

          console.log("üîç [CUSTOM-PLACES] API response received:", {
            status: data.status,
            predictions: data.predictions?.length,
          });

          if (data.status === "OK" && data.predictions && data.predictions.length > 0) {
            console.log(
              "üîç [CUSTOM-PLACES] Showing results:",
              data.predictions.length,
              "predictions"
            );
            // Show results in modal
            showModalResults(data.predictions, query);
          } else {
            console.log("üîç [CUSTOM-PLACES] No results or error status:", data.status);
            showModalError("No addresses found. Please try a different search term.");
          }
        } catch (error) {
          console.error("üö® [CUSTOM-PLACES] Search error:", error);
          showModalError("Failed to search for addresses. Please try again.");
        } finally {
          hideModalLoading();
        }
      }

      // Modal helper functions
      function showModalLoading() {
        modalLoading?.classList.remove("hidden");
        modalSearchBtn.disabled = true;
      }

      function hideModalLoading() {
        modalLoading?.classList.add("hidden");
        modalSearchBtn.disabled = false;
      }

      function showModalError(message: string) {
        if (modalError) {
          modalError.textContent = message;
          modalError.classList.remove("hidden");
        }
      }

      function hideModalError() {
        modalError?.classList.add("hidden");
      }

      function showModalResults(predictions: any[], query: string) {
        console.log(
          "üîç [CUSTOM-PLACES] showModalResults called with:",
          predictions.length,
          "predictions"
        );

        // Convert predictions to slot machine options format
        const options = predictions.map((prediction) => ({
          value: prediction.place_id,
          label: prediction.description,
          disabled: false,
        }));

        console.log(
          "üîç [CUSTOM-PLACES] Converting to slot machine format:",
          options.length,
          "options"
        );

        // Show slot machine modal instead of simple list
        console.log(
          "üîç [CUSTOM-PLACES] About to call showCustomSlotMachine with",
          options.length,
          "options"
        );
        showCustomSlotMachine(options, query);
      }
    }

    // Custom slot machine implementation for addresses
    function showCustomSlotMachine(
      options: Array<{ value: string; label: string; disabled: boolean }>,
      originalQuery: string
    ) {
      console.log("üé∞ [SLOT-MACHINE] showCustomSlotMachine called with", options.length, "options");

      // Close the search modal first
      const searchModal = document.getElementById(`${componentId}-address-modal`);
      if (searchModal) {
        console.log("üé∞ [SLOT-MACHINE] Removing search modal");
        searchModal.remove();
      } else {
        console.log("üé∞ [SLOT-MACHINE] No search modal found to remove");
      }

      // Create slot machine modal HTML with search input at top
      const modalHTML = `
        <div id="${componentId}-slot-machine-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <!-- Modal Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
              <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Select Address</h2>
              <button id="${componentId}-close-slot-modal" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors duration-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>

            <!-- Modal Content -->
            <div class="p-6">
              <!-- Search Input Section -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  Search for an address:
                </label>
                <div class="relative">
                  <input
                    type="text"
                    id="${componentId}-slot-search-input"
                    class="w-full rounded-md border border-gray-300 px-3 py-2.5 pr-10 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                    placeholder="Type to search for addresses..."
                    autocomplete="off"
                    value="${originalQuery}"
                  />
                  <button
                    type="button"
                    id="${componentId}-slot-search-btn"
                    class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors duration-200"
                    title="Search for address"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                    </svg>
                  </button>
                </div>
              </div>

              <!-- Slot Machine Container with Fixed Height -->
              <div class="h-48 slot-machine-container relative overflow-hidden border-2 border-gray-200 dark:border-gray-600 rounded-lg mb-4 bg-gray-50 dark:bg-gray-700">
                <!-- Loading State -->
                <div id="${componentId}-slot-loading" class="absolute inset-0 flex items-center justify-center text-gray-500 dark:text-gray-400 hidden">
                  <div class="text-center">
                    <svg class="h-6 w-6 animate-spin text-gray-400 mx-auto mb-2" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p class="text-sm">Searching for addresses...</p>
                  </div>
                </div>

                <!-- Error State -->
                <div id="${componentId}-slot-error" class="absolute inset-0 flex items-center justify-center text-red-600 dark:text-red-400 hidden">
                  <div class="text-center">
                    <svg class="w-6 h-6 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <p class="text-sm">Error loading addresses</p>
                  </div>
                </div>
                <ul id="${componentId}-slot-address-list" class="absolute inset-0 transition-transform duration-300 ease-out">
                  ${options
                    .map(
                      (option, index) => `
                    <li class="slot-machine-item flex items-center justify-center h-12 text-center cursor-pointer transition-all duration-200 hover:bg-blue-50 dark:hover:bg-blue-900/20" data-index="${index}" data-value="${option.value}">
                      <span class="text-sm font-medium text-gray-900 dark:text-white px-4">${option.label}</span>
                    </li>
                  `
                    )
                    .join("")}
                </ul>
                <!-- Empty state when no results -->
                <div id="${componentId}-slot-empty-state" class="slot-empty-state absolute inset-0 flex items-center justify-center text-gray-500 dark:text-gray-400 hidden">
                  <div class="text-center">
                    <svg class="w-8 h-8 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                    <p class="text-sm">No addresses found</p>
                  </div>
                </div>
              </div>

              <!-- Action Buttons -->
              <div class="flex justify-center gap-2">
                <button id="${componentId}-slot-cancel-btn" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200">
                  Cancel
                </button>
                <button id="${componentId}-slot-select-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md disabled:opacity-50" disabled>
                  Select
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      // Add modal to DOM (scroll is already locked from search modal)
      console.log("üé∞ [SLOT-MACHINE] Adding modal HTML to DOM");
      document.body.insertAdjacentHTML("beforeend", modalHTML);

      // Verify modal was added
      const addedModal = document.getElementById(`${componentId}-slot-machine-modal`);
      if (addedModal) {
        console.log("üé∞ [SLOT-MACHINE] Modal successfully added to DOM");
      } else {
        console.error("üé∞ [SLOT-MACHINE] Failed to add modal to DOM");
      }

      setupSlotMachine(options);
    }

    // Set up slot machine functionality
    function setupSlotMachine(options: Array<{ value: string; label: string; disabled: boolean }>) {
      console.log("üé∞ [SLOT-MACHINE] setupSlotMachine called with", options.length, "options");

      const addressList = document.getElementById(
        `${componentId}-slot-address-list`
      ) as HTMLUListElement;
      const selectBtn = document.getElementById(
        `${componentId}-slot-select-btn`
      ) as HTMLButtonElement;
      const cancelBtn = document.getElementById(
        `${componentId}-slot-cancel-btn`
      ) as HTMLButtonElement;
      const closeBtn = document.getElementById(
        `${componentId}-close-slot-modal`
      ) as HTMLButtonElement;
      const modal = document.getElementById(`${componentId}-slot-machine-modal`) as HTMLDivElement;
      const searchInput = document.getElementById(
        `${componentId}-slot-search-input`
      ) as HTMLInputElement;
      const searchBtn = document.getElementById(
        `${componentId}-slot-search-btn`
      ) as HTMLButtonElement;
      const loadingDiv = document.getElementById(`${componentId}-slot-loading`);
      const errorDiv = document.getElementById(`${componentId}-slot-error`);

      console.log("üé∞ [SLOT-MACHINE] Element check:", {
        addressList: !!addressList,
        selectBtn: !!selectBtn,
        cancelBtn: !!cancelBtn,
        closeBtn: !!closeBtn,
        modal: !!modal,
        searchInput: !!searchInput,
        searchBtn: !!searchBtn,
        loadingDiv: !!loadingDiv,
        errorDiv: !!errorDiv,
      });

      let selectedIndex = -1; // Start with no selection
      const itemHeight = 48;
      let currentOptions = options;

      // Center selected item
      function centerSelectedItem() {
        if (currentOptions.length === 0) {
          return; // Don't center if no options
        }

        console.log(
          "üé∞ [SLOT-MACHINE] Centering item, selectedIndex:",
          selectedIndex,
          "total options:",
          currentOptions.length
        );

        const containerHeight = 192;
        let targetY;

        if (selectedIndex === -1) {
          // No selection - show items from the top (no dead space)
          targetY = 0;
        } else {
          // Item selected - center it
          const centerOffset = (containerHeight - itemHeight) / 2;
          targetY = -(selectedIndex * itemHeight) + centerOffset;
        }

        console.log("üé∞ [SLOT-MACHINE] Transform values:", {
          containerHeight,
          targetY,
          selectedIndex,
        });

        addressList.style.transform = `translateY(${targetY}px)`;
        updateSelection();
      }

      // Update selection styling
      function updateSelection() {
        const items = addressList.querySelectorAll("li");
        items.forEach((item, index) => {
          if (index === selectedIndex && selectedIndex !== -1) {
            item.classList.add("selected");
            item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-radius: 8px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            position: relative;
          `;
            addCheckmark(item);
            selectBtn.disabled = false;
          } else {
            item.classList.remove("selected");
            item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: #111827;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
          `;
            removeCheckmark(item);
          }
        });

        // Disable select button if no item is selected
        if (selectedIndex === -1) {
          selectBtn.disabled = true;
        }
      }

      // Add checkmark to selected item
      function addCheckmark(item: HTMLElement) {
        // Remove existing checkmark if any
        const existingCheckmark = item.querySelector(".checkmark");
        if (existingCheckmark) {
          existingCheckmark.remove();
        }

        const checkmark = document.createElement("div");
        checkmark.className = "checkmark";
        checkmark.innerHTML = "‚úì";
        checkmark.style.cssText = `
          position: absolute;
          right: 8px;
          top: 50%;
          transform: translateY(-50%);
          color: #10b981;
          font-weight: bold;
          font-size: 16px;
          animation: checkmarkPulse 1.5s ease-in-out infinite;
          z-index: 10;
        `;

        item.appendChild(checkmark);
      }

      // Remove checkmark from item
      function removeCheckmark(item: HTMLElement) {
        const checkmark = item.querySelector(".checkmark");
        if (checkmark) {
          checkmark.remove();
        }
      }

      // Handle wheel events
      addressList.addEventListener("wheel", (e) => {
        e.preventDefault();

        if (currentOptions.length === 0) {
          return; // Don't handle wheel events if no options
        }

        const deltaY = e.deltaY;

        // If no item is selected, start from the first item
        if (selectedIndex === -1) {
          selectedIndex = 0;
        } else {
          if (deltaY > 0) {
            selectedIndex = Math.min(selectedIndex + 1, currentOptions.length - 1);
          } else {
            selectedIndex = Math.max(selectedIndex - 1, 0);
          }
        }

        centerSelectedItem();
      });

      // Handle click on items
      addressList.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        if (target) {
          const item = target.closest("li");
          if (item) {
            selectedIndex = parseInt(item.dataset.index || "0");
            centerSelectedItem();
          }
        }
      });

      // Handle select button
      selectBtn.addEventListener("click", () => {
        const selectedOption = currentOptions[selectedIndex];
        if (selectedOption) {
          console.log("üó∫Ô∏è [CUSTOM-PLACES] Address selected from slot machine:", {
            value: selectedOption.value,
            label: selectedOption.label,
            componentId,
          });

          // Update the main input field with the selected address
          const mainInput = document.getElementById(
            `${componentId}-address-input`
          ) as HTMLInputElement;
          if (mainInput) {
            mainInput.value = selectedOption.label;
            console.log("üó∫Ô∏è [CUSTOM-PLACES] Updated main input value:", mainInput.value);
          }

          console.log("üó∫Ô∏è [CUSTOM-PLACES] Calling getPlaceDetails...");
          getPlaceDetails(selectedOption.value, selectedOption.label);
        }
      });

      // Handle cancel/close buttons
      function closeModal() {
        modal?.remove();
        unlockBodyScroll();
      }

      cancelBtn?.addEventListener("click", closeModal);
      closeBtn?.addEventListener("click", closeModal);
      modal?.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });

      // Search functionality for slot machine
      function showSlotLoading() {
        // Hide all other states
        hideSlotError();
        hideSlotResults();
        hideSlotEmpty();

        // Show loading state
        loadingDiv?.classList.remove("hidden");
        searchBtn.disabled = true;
      }

      function hideSlotLoading() {
        loadingDiv?.classList.add("hidden");
        searchBtn.disabled = false;
      }

      function showSlotError(message: string) {
        // Hide all other states
        hideSlotLoading();
        hideSlotResults();
        hideSlotEmpty();

        // Show error state
        if (errorDiv) {
          errorDiv.classList.remove("hidden");
        }
      }

      function hideSlotError() {
        errorDiv?.classList.add("hidden");
      }

      function showSlotResults() {
        // Hide all other states
        hideSlotLoading();
        hideSlotError();
        hideSlotEmpty();

        // Show results
        addressList.style.display = "block";
      }

      function hideSlotResults() {
        addressList.style.display = "none";
      }

      function showSlotEmpty() {
        // Hide all other states
        hideSlotLoading();
        hideSlotError();
        hideSlotResults();

        // Show empty state
        const emptyState = document.getElementById(`${componentId}-slot-empty-state`);
        emptyState?.classList.remove("hidden");
      }

      function hideSlotEmpty() {
        const emptyState = document.getElementById(`${componentId}-slot-empty-state`);
        emptyState?.classList.add("hidden");
      }

      async function searchInSlotMachine(query: string) {
        if (!query.trim() || query.length < 2) {
          showSlotError("Please enter at least 2 characters to search");
          return;
        }

        showSlotLoading();
        hideSlotError();

        try {
          const requestUrl = `/api/places-autocomplete?input=${encodeURIComponent(query)}&types=address&components=country:us&locationBias=circle:100@42.3601,-71.0589`;
          const response = await fetch(requestUrl);
          const data = await response.json();

          if (data.status === "OK" && data.predictions && data.predictions.length > 0) {
            // Convert predictions to options format
            const newOptions = data.predictions.map((prediction: any) => ({
              value: prediction.place_id,
              label: prediction.description,
              disabled: false,
            }));

            // Update the slot machine with new options
            updateSlotMachineOptions(newOptions);
          } else {
            showSlotError("No addresses found. Please try a different search term.");
          }
        } catch (error) {
          console.error("üö® [CUSTOM-PLACES] Slot machine search error:", error);
          showSlotError("Failed to search for addresses. Please try again.");
        } finally {
          hideSlotLoading();
        }
      }

      function updateSlotMachineOptions(
        newOptions: Array<{ value: string; label: string; disabled: boolean }>
      ) {
        console.log("üé∞ [SLOT-MACHINE] Updating options with:", newOptions.length, "items");

        currentOptions = newOptions;
        selectedIndex = -1; // Don't auto-select any item

        if (newOptions.length === 0) {
          console.log("üé∞ [SLOT-MACHINE] No options, showing empty state");
          // Show empty state
          addressList.innerHTML = "";
          showSlotEmpty();
          selectBtn.disabled = true;
        } else {
          console.log("üé∞ [SLOT-MACHINE] Updating with", newOptions.length, "options");

          // Update the HTML with fixed height items
          addressList.innerHTML = newOptions
            .map(
              (option, index) => `
                <li class="slot-machine-item flex items-center justify-center h-12 text-center cursor-pointer transition-all duration-200 hover:bg-blue-50 dark:hover:bg-blue-900/20" data-index="${index}" data-value="${option.value}">
                  <span class="text-sm font-medium text-gray-900 dark:text-white px-4">${option.label}</span>
                </li>
              `
            )
            .join("");

          console.log("üé∞ [SLOT-MACHINE] HTML updated, showing results");

          // Show results without auto-selecting
          showSlotResults();
          // Position list at top (no dead space) since no item is selected
          setTimeout(() => {
            centerSelectedItem();
          }, 10);
        }
      }

      // Add search input event listeners
      if (searchInput) {
        let searchTimeout: NodeJS.Timeout;

        searchInput.addEventListener("input", (e) => {
          const query = (e.target as HTMLInputElement).value.trim();

          if (searchTimeout) {
            clearTimeout(searchTimeout);
          }

          if (query.length >= 2) {
            searchTimeout = setTimeout(() => {
              searchInSlotMachine(query);
            }, 300);
          } else if (query.length === 0) {
            // Reset to original options if search is cleared
            updateSlotMachineOptions(options);
          } else {
            // Show empty state for 1 character
            showSlotEmpty();
          }
        });

        searchInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const query = searchInput.value.trim();
            if (query.length >= 2) {
              if (searchTimeout) {
                clearTimeout(searchTimeout);
              }
              searchInSlotMachine(query);
            }
          }
        });
      }

      if (searchBtn) {
        searchBtn.addEventListener("click", () => {
          const query = searchInput?.value.trim();
          if (query && query.length >= 2) {
            searchInSlotMachine(query);
          }
        });
      }

      // Initialize with a small delay to ensure DOM is ready
      setTimeout(() => {
        if (currentOptions.length > 0) {
          showSlotResults();
          // Position list at top (no dead space) since no item is selected
          centerSelectedItem();
        } else {
          showSlotEmpty();
        }
      }, 50);
    }

    // Get detailed place information using our server-side proxy endpoint
    async function getPlaceDetails(placeId: string, description: string) {
      console.log("üîç [CUSTOM-PLACES] getPlaceDetails called with:", { placeId, description });
      showLoading();

      try {
        // Use our server-side proxy endpoint to avoid CORS issues
        const requestUrl = `/api/places-details?place_id=${placeId}&fields=formatted_address,name,address_components`;

        console.log("üîç [CUSTOM-PLACES] Getting place details for:", placeId);
        console.log("üîç [CUSTOM-PLACES] Request URL:", requestUrl);

        const response = await fetch(requestUrl);
        const data = await response.json();

        console.log("üîç [CUSTOM-PLACES] Place details response:", {
          status: data.status,
          result: !!data.result,
          formattedAddress: data.result?.formatted_address,
          fullResponse: data,
        });

        if (data.status === "OK" && data.result) {
          // Update the hidden input with the selected address
          const formattedAddress = data.result.formatted_address || description;
          console.log("üîç [CUSTOM-PLACES] Setting hidden input value:", formattedAddress);
          console.log("üîç [CUSTOM-PLACES] Hidden input element:", hiddenInput);

          hiddenInput.value = formattedAddress;
          console.log("üîç [CUSTOM-PLACES] Hidden input value after setting:", hiddenInput.value);

          // Show selected address
          showSelectedAddress(formattedAddress);

          // Close the slot machine modal
          const slotModal = document.getElementById(`${componentId}-slot-machine-modal`);
          slotModal?.remove();
          unlockBodyScroll();

          // Trigger change event
          hiddenInput.dispatchEvent(new Event("change", { bubbles: true }));

          console.log(
            "üó∫Ô∏è [CUSTOM-PLACES] Address selected and hidden input updated:",
            formattedAddress
          );
        } else {
          console.error("üîç [CUSTOM-PLACES] Failed to get place details:", data);
          showError("Failed to get address details. Please try again.");
        }
      } catch (error) {
        console.error("üö® [CUSTOM-PLACES] Get place details error:", error);
        showError("Failed to get address details. Please try again.");
      } finally {
        hideLoading();
      }
    }

    // Event listeners
    addBtn.addEventListener("click", () => {
      console.log("üîç [CUSTOM-PLACES] Add Address button clicked");
      showAddressSearchModal();
    });

    clearBtn?.addEventListener("click", clearSelection);

    // Initialize component
    function initializeComponent() {
      console.log("üó∫Ô∏è [CUSTOM-PLACES] Component initialized successfully");
    }

    // Start initialization
    initializeComponent();

    // Cleanup function to unlock scroll if component is destroyed
    const cleanup = () => {
      unlockBodyScroll();
    };

    // Add cleanup on page unload
    window.addEventListener("beforeunload", cleanup);

    // Also cleanup if the component container is removed
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container) {
            cleanup();
            observer.disconnect();
          }
        });
      });
    });

    if (container.parentNode) {
      observer.observe(container.parentNode, { childList: true });
    }
  });
</script>

<style>
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
  }

  /* Smooth transitions */
  .transition-transform {
    transition-property: transform;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 300ms;
  }

  /* Prevent body scrolling when modal is open */
  body.modal-open {
    overflow: hidden !important;
    position: fixed !important;
    width: 100% !important;
    height: 100% !important;
  }

  /* Alternative approach for better browser compatibility */
  body.modal-open-alt {
    overflow: hidden !important;
    height: 100vh !important;
  }

  /* Slot machine container styling */
  .slot-machine-container {
    min-height: 12rem !important;
    max-height: 12rem !important;
    height: 12rem !important;
    display: block !important;
  }

  /* Ensure the slot machine list takes full height */
  .slot-machine-container ul {
    height: 100% !important;
    min-height: 12rem !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
  }

  /* Ensure slot machine items are visible */
  .slot-machine-item {
    min-height: 3rem !important;
    height: 3rem !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: all 0.2s ease-in-out;
  }

  /* Checkmark pulse animation */
  @keyframes checkmarkPulse {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes checkmarkPulseDark {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    50% {
      opacity: 0.9;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 16px rgba(16, 185, 129, 1);
    }
  }

  /* Empty state styling */
  .slot-empty-state {
    transition: opacity 0.3s ease-in-out;
  }
</style>
