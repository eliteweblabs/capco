---
import BoxIcon from "../common/BoxIcon.astro";

interface Props {
  id: string;
  name: string;
  title: string;
  label: string;
  value?: string;
  placeholder?: string;
  required?: boolean;
  class?: string;
  projectStatus?: number;
  noResultsText?: string;
}

const {
  title = "google-places-slotmachine",
  name,
  label,
  value = "",
  placeholder = "Start typing an address...",
  required = false,
  class: className = "",
  projectStatus = 0,
  id,
  noResultsText = "No results found",
} = Astro.props;

// Always render the address input (removed projectStatus restriction)
// if (projectStatus !== 0) {
//   return;
// }
---

<div class="relative" data-component-id={id}>
  <!-- Add Address Button -->
  <button
    type="button"
    id={`${id}-open-btn`}
    class={`rounded-full border border-gray-300 bg-white px-3 py-2.5 text-left text-sm text-gray-500 transition-colors hover:border-gray-400 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-400 dark:hover:border-gray-500 dark:hover:bg-gray-600 ${className}`}
  >
    <div class="flex items-center justify-between">
      <span id={`${id}-button-text`}>Add Address</span>

      <BoxIcon name="plus" size="sm" />
    </div>
  </button>

  <!-- Hidden input for form submission -->
  <input
    type="text"
    id={`${id}-hidden-input`}
    name={name}
    value={value}
    required={required}
    class="sr-only"
    tabindex="-1"
    aria-hidden="true"
    autocomplete="off"
  />
</div>

<script define:vars={{ noResultsText }}>
  document.addEventListener("DOMContentLoaded", function () {
    // Simple approach: find the container and initialize
    const container = document.querySelector("[data-component-id]");
    if (!container) return;

    // Generate a unique ID for this component instance
    const componentId = container.getAttribute("data-component-id") || "google-places-slotmachine";

    const addBtn = container.querySelector(`#${componentId}-open-btn`);
    const buttonText = container.querySelector(`#${componentId}-button-text`);
    const hiddenInput = container.querySelector(`#${componentId}-hidden-input`);

    if (!addBtn || !hiddenInput) {
      console.error("üö® [CUSTOM-PLACES] Required elements not found");
      return;
    }

    // Update button text with selected

    function updateButtonText(address: string) {
      if (buttonText) {
        buttonText.textContent = address;
      }
    }

    // Clear selection
    function clearSelection() {
      hiddenInput.value = "";
      if (buttonText) {
        buttonText.textContent = "Add Address";
      }
    }

    // Helper functions to manage body scroll lock
    function lockBodyScroll() {
      // Lock body scroll to prevent background scrolling
      document.body.style.overflow = "hidden";
    }

    function unlockBodyScroll() {
      // Unlock body scroll
      document.body.style.overflow = "";
    }

    // Show slot machine modal directly
    let selectedIndex = -1; // Track selected item index

    async function showSlotMachineModal() {
      const response = await fetch("/partials/slot-machine-modal", {
        headers: {
          "x-component-id": componentId,
          "x-modal-title": "Select Address",
          "x-show-search": "true",
          "x-cancel-button": "Cancel",
          "x-select-button": "Select",
          "x-no-results-text": { noResultsText },
        },
      });
      const modalHTML = await response.text();

      // Insert the modal into the DOM
      document.body.insertAdjacentHTML("beforeend", modalHTML);

      // Lock body scroll
      lockBodyScroll();

      // Get modal elements for the new slot machine modal
      const modal = document.getElementById(`${componentId}-slot-machine-modal`);
      const modalSearchInput = document.getElementById(`${componentId}-slot-search-input`);
      const modalSearchBtn = document.getElementById(`${componentId}-slot-search-btn`);
      const modalLoading = document.getElementById(`${componentId}-slot-loading`);
      const modalError = document.getElementById(`${componentId}-slot-error`);
      const modalCancel = document.getElementById(`${componentId}-slot-cancel-btn`);
      const modalSelect = document.getElementById(`${componentId}-slot-select-btn`);
      const modalPlacesLoading = document.getElementById(
        `${componentId}-slot-loading`
      ) as HTMLDivElement;
      const modalPlacesError = document.getElementById(
        `${componentId}-slot-error`
      ) as HTMLDivElement;

      // Debug: Check if all elements were found
      console.log("üîç [CUSTOM-PLACES] Modal elements found:", {
        modal: !!modal,
        modalSearchInput: !!modalSearchInput,
        modalSearchBtn: !!modalSearchBtn,
        modalLoading: !!modalLoading,
        modalError: !!modalError,
        modalCancel: !!modalCancel,
        modalSelect: !!modalSelect,
        modalPlacesLoading: !!modalPlacesLoading,
        modalPlacesError: !!modalPlacesError,
        componentId: componentId,
      });

      // Focus on search input
      modalSearchInput?.focus();

      // Event listeners - add a small delay to ensure elements are fully rendered
      setTimeout(() => {
        console.log("üîç [CUSTOM-PLACES] Setting up event listeners...");
        console.log("üîç [CUSTOM-PLACES] modalSearchBtn:", !!modalSearchBtn);
        console.log("üîç [CUSTOM-PLACES] modalSearchInput:", !!modalSearchInput);

        if (modalSearchBtn) {
          modalSearchBtn.addEventListener("click", () => {
            console.log(
              "üîç [CUSTOM-PLACES] Search button clicked, query:",
              modalSearchInput?.value
            );
            if (modalSearchInput) {
              searchAddresses(modalSearchInput.value);
            }
          });
          console.log("üîç [CUSTOM-PLACES] Search button event listener added");
        } else {
          console.error("üö® [CUSTOM-PLACES] modalSearchBtn not found for event listener");
        }

        if (modalSearchInput) {
          // Add input event listener with debouncing and 2-character minimum
          let searchTimeout: NodeJS.Timeout;
          modalSearchInput.addEventListener("input", (e) => {
            const query = e.target.value.trim();
            console.log("üîç [CUSTOM-PLACES] Input changed, query:", query);

            // Clear previous timeout
            if (searchTimeout) {
              clearTimeout(searchTimeout);
            }

            // Only search if query is at least 2 characters
            if (query.length >= 2) {
              console.log("üîç [CUSTOM-PLACES] Query is 2+ characters, scheduling search...");
              searchTimeout = setTimeout(() => {
                console.log("üîç [CUSTOM-PLACES] Executing delayed search for:", query);
                searchAddresses(query);
              }, 300); // 300ms debounce
            } else if (query.length === 0) {
              // Clear results if input is empty
              hideModalError();
            }
          });

          // Keep Enter key functionality
          modalSearchInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              const query = modalSearchInput.value.trim();
              if (query.length >= 2) {
                console.log("üîç [CUSTOM-PLACES] Enter key pressed, query:", query);
                if (searchTimeout) {
                  clearTimeout(searchTimeout);
                }
                searchAddresses(query);
              }
            }
          });
          console.log("üîç [CUSTOM-PLACES] Search input event listeners added");
        } else {
          console.error("üö® [CUSTOM-PLACES] modalSearchInput not found for event listener");
        }
      }, 100);

      modalCancel?.addEventListener("click", () => {
        modal?.remove();
        unlockBodyScroll();
      });

      modalSelect?.addEventListener("click", () => {
        // Get the selected option from the slot machine using the selectedIndex
        const addressList = document.getElementById(
          `${componentId}-slot-options-list`
        ) as HTMLUListElement;
        if (addressList) {
          const selectedItem = addressList.querySelector(`li[data-index="${selectedIndex}"]`);
          if (selectedItem && selectedIndex >= 0) {
            const value = selectedItem.getAttribute("data-value");
            const label = selectedItem.querySelector("span")?.textContent;
            if (value && label) {
              console.log("üé∞ [SLOT-MACHINE] Selected option:", { value, label, selectedIndex });

              // Update the hidden input with the selected address
              console.log("üîç [DEBUG] Before setting - hiddenInput:", hiddenInput);
              console.log("üîç [DEBUG] Before setting - hiddenInput.value:", hiddenInput.value);
              console.log("üîç [DEBUG] Setting value to:", label);

              hiddenInput.value = label;
              hiddenInput.setAttribute("value", label);

              console.log("üîç [DEBUG] After setting - hiddenInput.value:", hiddenInput.value);
              console.log(
                "üîç [DEBUG] After setting - hiddenInput.getAttribute('value'):",
                hiddenInput.getAttribute("value")
              );

              // Update the button text to show the selected address
              updateButtonText(label);

              // Close the modal
              modal?.remove();
              unlockBodyScroll();

              // Trigger change event for form validation
              hiddenInput.dispatchEvent(new Event("change", { bubbles: true }));

              // Test form submission - log the hidden input value
              console.log("‚úÖ [FORM-TEST] Hidden input ready for submission:", {
                name: hiddenInput.name,
                value: hiddenInput.value,
                id: hiddenInput.id,
              });
            }
          } else {
            console.log(
              "üé∞ [SLOT-MACHINE] No item selected or invalid selectedIndex:",
              selectedIndex
            );
          }
        }
      });

      modal?.addEventListener("click", (e) => {
        if (e.target === modal) {
          modal.remove();
          unlockBodyScroll();
        }
      });

      // Search function for modal
      async function searchAddresses(query: string) {
        console.log("üîç [CUSTOM-PLACES] searchAddresses function called with query:", query);

        if (!query.trim()) {
          console.log("üîç [CUSTOM-PLACES] Empty query, showing error");
          showModalError("Please enter an address to search");
          return;
        }

        console.log("üîç [CUSTOM-PLACES] Starting address search...");
        showModalLoading();
        hideModalError();

        try {
          // Use our server-side proxy endpoint to avoid CORS issues
          const requestUrl = `/api/places-autocomplete?input=${encodeURIComponent(query)}&types=address&components=country:us&locationBias=circle:100@42.3601,-71.0589`;

          console.log("üîç [CUSTOM-PLACES] Making HTTP request to proxy endpoint:", requestUrl);

          const response = await fetch(requestUrl);
          const data = await response.json();

          console.log("üîç [CUSTOM-PLACES] API response received:", {
            status: data.status,
            predictions: data.predictions?.length,
          });

          if (data.status === "OK" && data.predictions && data.predictions.length > 0) {
            console.log(
              "üîç [CUSTOM-PLACES] Showing results:",
              data.predictions.length,
              "predictions"
            );
            // Show results in modal
            showModalResults(data.predictions, query);
          } else {
            console.log("üîç [CUSTOM-PLACES] No results or error status:", data.status);
            showModalError("No addresses found. Please try a different search term.");
          }
        } catch (error) {
          console.error("üö® [CUSTOM-PLACES] Search error:", error);
          showModalError("Failed to search for addresses. Please try again.");
        } finally {
          hideModalLoading();
        }
      }

      function showModalResults(predictions: any[], query: string) {
        console.log(
          "üîç [CUSTOM-PLACES] showModalResults called with:",
          predictions.length,
          "predictions"
        );

        // Convert predictions to slot machine options format
        const options = predictions.map((prediction) => ({
          value: prediction.place_id,
          label: prediction.description,
          disabled: false,
        }));

        console.log(
          "üîç [CUSTOM-PLACES] Converting to slot machine format:",
          options.length,
          "options"
        );

        // Update the slot machine with the new options
        console.log("üîç [CUSTOM-PLACES] Updating slot machine with", options.length, "options");
        updateSlotMachineOptions(options);
      }

      // Helper functions for modal states
      function showModalLoading() {
        modalPlacesLoading?.classList.remove("hidden");
        modalPlacesError?.classList.add("hidden");
      }

      function hideModalLoading() {
        modalPlacesLoading?.classList.add("hidden");
      }

      function showModalError(message: string) {
        if (modalPlacesError) {
          modalPlacesError.textContent = message;
          modalPlacesError.classList.remove("hidden");
        }
      }

      function hideModalError() {
        modalPlacesError?.classList.add("hidden");
      }

      // Declare currentOptions at the modal scope
      let currentOptions: Array<{ value: string; label: string; disabled: boolean }> = [];

      // Update slot machine with new options
      function updateSlotMachineOptions(
        options: Array<{ value: string; label: string; disabled: boolean }>
      ) {
        const addressList = document.getElementById(
          `${componentId}-slot-options-list`
        ) as HTMLUListElement;
        const selectBtn = document.getElementById(`${componentId}-slot-select-btn`);
        const emptyState = document.getElementById(
          `${componentId}-slot-empty-state`
        ) as HTMLDivElement;

        if (!addressList) return;

        if (options.length === 0) {
          emptyState?.classList.remove("hidden");
          return;
        }

        emptyState?.classList.add("hidden");
        selectBtn.disabled = true;

        // Update currentOptions for wheel/touch events
        currentOptions = options;

        addressList.innerHTML = options
          .map(
            (option, index) => `
            <li class="slot-machine-item flex items-center justify-center h-12 text-center cursor-pointer transition-all duration-200 hover:bg-primary-50 dark:hover:bg-primary-900/20" data-index="${index}" data-value="${option.value}">
              <span class="text-sm font-medium text-gray-900 dark:text-white px-4">${option.label}</span>
            </li>
          `
          )
          .join("");

        setupSlotMachineInteractions();
      }

      // Setup slot machine interactions
      function setupSlotMachineInteractions() {
        const addressList = document.getElementById(
          `${componentId}-slot-options-list`
        ) as HTMLUListElement;
        const selectBtn = document.getElementById(`${componentId}-slot-select-btn`);

        if (!addressList) return;

        // Handle wheel events and touch events on the entire slot machine container
        const slotContainer = document.querySelector(
          `#${componentId}-slot-machine-modal .slot-machine-container`
        ) as HTMLDivElement;
        if (slotContainer) {
          // Wheel events for desktop
          slotContainer.addEventListener("wheel", (e) => {
            e.preventDefault();
            if (currentOptions.length === 0) return;

            const deltaY = e.deltaY;
            if (selectedIndex === -1) {
              selectedIndex = 0;
            } else {
              if (deltaY > 0) {
                selectedIndex = Math.min(selectedIndex + 1, currentOptions.length - 1);
              } else {
                selectedIndex = Math.max(selectedIndex - 1, 0);
              }
            }
            centerSelectedItem();
            updateSelection();
          });

          // Touch events for mobile
          let touchStartY = 0;
          let touchStartTime = 0;

          slotContainer.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (currentOptions.length === 0) return;

            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
          });

          slotContainer.addEventListener("touchmove", (e) => {
            e.preventDefault();
          });

          slotContainer.addEventListener("touchend", (e) => {
            e.preventDefault();
            if (currentOptions.length === 0) return;

            const touchEndY = e.changedTouches[0].clientY;
            const touchEndTime = Date.now();
            const deltaY = touchStartY - touchEndY;
            const deltaTime = touchEndTime - touchStartTime;

            // Only process if it's a quick swipe (less than 300ms) with enough movement (more than 20px)
            if (deltaTime < 300 && Math.abs(deltaY) > 20) {
              if (selectedIndex === -1) {
                selectedIndex = 0;
              } else {
                if (deltaY > 0) {
                  // Swipe up - move to next item
                  selectedIndex = Math.min(selectedIndex + 1, currentOptions.length - 1);
                } else {
                  // Swipe down - move to previous item
                  selectedIndex = Math.max(selectedIndex - 1, 0);
                }
              }
              centerSelectedItem();
              updateSelection();
            }
          });
        }

        // Handle click and touch on items
        addressList.addEventListener("click", (e) => {
          const target = e.target;
          const li = target.closest("li[data-index]");
          if (li) {
            selectedIndex = parseInt(li.getAttribute("data-index") || "0");
            centerSelectedItem();
            updateSelection();
          }
        });

        // Add touch support for list items
        addressList.addEventListener("touchend", (e) => {
          e.preventDefault();
          const target = e.target;
          const li = target.closest("li[data-index]");
          if (li) {
            selectedIndex = parseInt(li.getAttribute("data-index") || "0");
            centerSelectedItem();
            updateSelection();
          }
        });

        // Handle select button - this will be handled by the modal setup

        // Center selected item
        function centerSelectedItem() {
          if (selectedIndex >= 0) {
            const itemHeight = 48;
            const containerHeight = 192;
            const centerOffset = (containerHeight - itemHeight) / 2;
            const targetY = -(selectedIndex * itemHeight) + centerOffset;
            addressList.style.transform = `translateY(${targetY}px)`;
          }
        }

        // Update selection styling
        function updateSelection() {
          const items = addressList.querySelectorAll("li");
          items.forEach((item, index) => {
            if (index === selectedIndex && selectedIndex >= 0) {
              item.classList.add("selected", "bg-primary-500");
              item.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: center;
                height: 3rem;
                text-align: center;
                color: white !important;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                border-radius: 8px;
                margin: 0 8px;
                position: relative;
              `;
              const span = item.querySelector("span");
              if (span) {
                span.style.color = "white !important";
              }
              selectBtn.disabled = false;
            } else {
              item.classList.remove("selected", "bg-primary-500");
              item.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: center;
                height: 3rem;
                text-align: center;
                color: #111827;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s;
                position: relative;
              `;
              const span = item.querySelector("span");
              if (span) {
                span.style.color = "";
              }
            }
          });
        }
      }
    }

    // Get detailed place information using our server-side proxy endpoint
    async function getPlaceDetails(placeId: string, description: string) {
      console.log("üîç [CUSTOM-PLACES] getPlaceDetails called with:", { placeId, description });

      try {
        // Use our server-side proxy endpoint to avoid CORS issues
        const requestUrl = `/api/places-details?place_id=${placeId}&fields=formatted_address,name,address_components`;

        console.log("üîç [CUSTOM-PLACES] Getting place details for:", placeId);
        console.log("üîç [CUSTOM-PLACES] Request URL:", requestUrl);

        const response = await fetch(requestUrl);
        const data = await response.json();

        console.log("üîç [CUSTOM-PLACES] Place details response:", {
          status: data.status,
          result: !!data.result,
          formattedAddress: data.result?.formatted_address,
          fullResponse: data,
        });

        if (data.status === "OK" && data.result) {
          // Update the hidden input with the selected address
          const formattedAddress = data.result.formatted_address || description;
          console.log("üîç [CUSTOM-PLACES] Setting hidden input value:", formattedAddress);
          console.log("üîç [CUSTOM-PLACES] Hidden input element:", hiddenInput);

          hiddenInput.value = formattedAddress;
          console.log("üîç [CUSTOM-PLACES] Hidden input value after setting:", hiddenInput.value);

          // Update button text to show selected address
          updateButtonText(formattedAddress);

          // Close the slot machine modal
          const slotModal = document.getElementById(`${componentId}-slot-machine-modal`);
          slotModal?.remove();
          unlockBodyScroll();

          // Trigger change event
          hiddenInput.dispatchEvent(new Event("change", { bubbles: true }));

          console.log(
            "üó∫Ô∏è [CUSTOM-PLACES] Address selected and hidden input updated:",
            formattedAddress
          );
        } else {
          console.error("üîç [CUSTOM-PLACES] Failed to get place details:", data);
        }
      } catch (error) {
        console.error("üö® [CUSTOM-PLACES] Get place details error:", error);
      }
    }

    // Event listeners
    addBtn.addEventListener("click", () => {
      console.log("üîç [CUSTOM-PLACES] Add Address button clicked");
      showSlotMachineModal();
    });

    // Initialize component
    function initializeComponent() {
      console.log("üó∫Ô∏è [CUSTOM-PLACES] Component initialized successfully");
    }

    // Start initialization
    initializeComponent();

    // Cleanup function to unlock scroll if component is destroyed
    const cleanup = () => {
      unlockBodyScroll();
    };

    // Add cleanup on page unload
    window.addEventListener("beforeunload", cleanup);

    // Also cleanup if the component container is removed
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container) {
            cleanup();
            observer.disconnect();
          }
        });
      });
    });

    if (container.parentNode) {
      observer.observe(container.parentNode, { childList: true });
    }
  });
</script>
