---
// Reusable multi-step form component that renders from JSON configuration
import type { MultiStepFormConfig } from "../../lib/multi-step-form-config";
import { getButtonConfig } from "../../lib/multi-step-form-config";
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import Tooltip from "../common/TooltipFloating.astro";
import SlotMachineModalStaff from "./SlotMachineModalStaff.astro";
import InlineAddressSearch from "./InlineAddressSearch.astro";
import SlideToggle from "../common/SlideToggle.astro";
import UnitSlider from "./UnitSlider.astro";
import ToggleButton from "./ToggleButton.astro";
import FileUpload from "./FileUpload.astro";
import AuthProviders from "./AuthProviders.astro";
import { SMS_UTILS } from "../../lib/sms-utils";
import { globalClasses } from "../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
  /** TEST: Disables cascade/visibility animations to debug iOS keypad. Remove when fixed. */
  testNoCascade?: boolean;
}

const {
  config,
  containerClass = "min-w-sm max-w-md sm:max-w-lg md:max-w-xl lg:max-w-2xl mx-auto w-full",
  initialData = {},
  testNoCascade = false,
} = Astro.props;

// When first step has expandDown: false, start with centered panel (no expand-down/expand-up)
// const firstStep = config.steps.find((s) => s.stepNumber === 1);
// const initialCentered = firstStep?.expandDown === false;
const initialCentered = true;

const { globalInputClasses, multiStepInputClasses } = globalClasses();
const appendedGlobalInputClasses = `${globalInputClasses} text-center`;
/** Typewriter-agent style for all JSON config form inputs (no shadow, color-background overwrites dot pattern, blinking caret) */
const appendedMultiStepInputClasses = multiStepInputClasses;

// Get carrier options for mobile carrier component
const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));
---

<div data-multi-step-form tabindex="-1">
  <form
    id={config.formId}
    action={config.formAction}
    method={config.formMethod || "post"}
    class={config.progressBar ? "" : ""}
    data-form-config={JSON.stringify({ formId: config.formId, formConfig: config, initialData })}
  >
    <div
      class:list={[
        "multi-step-form-steps relative min-w-96 p-4 scrollbar-hide sm:p-6 md:p-8 lg:p-10",
        initialCentered ? "centered" : "expand-down",
        containerClass,
      ]}
      id={`${config.formId}-steps`}
      tabindex="-1"
    >
      {
        config.steps.map((step) => (
          <div
            class:list={[
              "step-content space-y-8 overflow-y-visible text-xl sm:space-y-8", // leave mt-20 for tooltips
              step.stepNumber === 1 ? "first-step" : "",
            ]}
            data-step={step.stepNumber}
            data-hide-progress-bar={step.hideProgressBar ? "true" : "false"}
            data-expand-down={step.expandDown === false ? "false" : "true"}
            tabindex="-1"
          >
            {/* Step Header */}

            {step.title || step.subtitle ? (
              <div class="step-title" tabindex="-1">
                {step.title && (
                  <h2
                    class={`inline ${
                      step.effect === "typewriter" || !step.effect ? "typewriter-text" : ""
                    }`}
                    data-text={step.title}
                    set:html={step.title || ""}
                    tabindex="-1"
                  />
                )}
                {step.subtitle && (
                  <p
                    class="mt-2 max-w-md text-sm text-gray-600 dark:text-gray-400 sm:mt-3 sm:text-base"
                    tabindex="-1"
                  >
                    {step.subtitle}
                  </p>
                )}
              </div>
            ) : null}

            {/* Auth Providers (for registration and login forms) - at top */}
            {(step.additionalContent === "google-oauth" ||
              step.additionalContent === "auth-providers") && (
              <div class="" tabindex="-1">
                <AuthProviders
                  mode={step.additionalContent === "auth-providers" ? "login" : "register"}
                />
                <div class="flex items-center gap-4 pb-4" tabindex="-1">
                  <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
                  <span class="text-sm uppercase text-zinc-500 dark:text-zinc-400">
                    {step.additionalContent === "auth-providers"
                      ? "or login with email"
                      : "or register with email"}
                  </span>
                  <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
                </div>
              </div>
            )}

            {/* Step Fields */}
            {step.isReview ? (
              // Review step - show summary
              <div
                class="color-background space-y-4 rounded-lg border border-gray-200 p-8 dark:border-gray-700"
                tabindex="-1"
              >
                {step.reviewFields?.map((fieldName) => (
                  <div
                    class="flex items-start justify-between border-b border-gray-200 pb-2 last:border-b-0 dark:border-gray-700"
                    tabindex="-1"
                  >
                    <div tabindex="-1">
                      <p class="text-sm capitalize text-gray-600 dark:text-gray-400" tabindex="-1">
                        {fieldName.replace(/([A-Z])/g, " $1").trim()}
                      </p>
                      <p
                        id={`review-${fieldName}`}
                        class="text-lg font-medium text-gray-900 dark:text-white"
                        tabindex="-1"
                      >
                        {fieldName === "password" ? "â€¢â€¢â€¢â€¢â€¢â€¢" : "-"}
                      </p>
                    </div>
                    <button
                      type="button"
                      class="edit-step text-sm font-medium text-primary-600 hover:text-primary-700 dark:text-primary-400"
                      data-edit={
                        config.steps.findIndex((s) => s.fields.some((f) => f.name === fieldName)) +
                        1
                      }
                    >
                      Edit
                    </button>
                  </div>
                ))}
              </div>
            ) : step.fields?.length ? (
              <div
                class:list={[
                  "step-form-fields-wrapper",
                  step.fieldLayout === "grid"
                    ? "grid grid-cols-2 gap-3 md:grid-cols-2 md:gap-6"
                    : "",
                  step.response ? "" : "",
                ]}
                tabindex="-1"
              >
                {step.fields.map((field) => (
                  <div
                    class:list={[
                      field.type === "hidden" ? "" : "input-wrapper w-full",
                      field.columns === 1 ? "md:col-span-2" : "",
                    ]}
                    data-conditional-field={field.conditional ? field.conditional.field : undefined}
                    data-conditional-value={
                      field.conditional
                        ? Array.isArray(field.conditional.value)
                          ? field.conditional.value.join(",")
                          : field.conditional.value
                        : undefined
                    }
                    style={field.conditional ? "display: none;" : undefined}
                    tabindex="-1"
                  >
                    {field.type === "component" && field.component === "SlotMachineModalStaff" ? (
                      <SlotMachineModalStaff
                        id={field.id}
                        name={field.name}
                        title={field.label || "Select an option"}
                        options={mobileCarrierOptions}
                        selectedValue=""
                        globalInputClasses={appendedMultiStepInputClasses}
                        {...field.componentProps}
                      />
                    ) : field.type === "component" && field.component === "SlideToggle" ? (
                      <div class="flex items-center justify-center py-8" tabindex="-1">
                        <SlideToggle id={field.id} name={field.name} {...field.componentProps} />
                      </div>
                    ) : field.type === "component" && field.component === "InlineAddressSearch" ? (
                      <InlineAddressSearch
                        id={field.id}
                        name={field.name}
                        globalInputClasses={appendedMultiStepInputClasses}
                        {...field.componentProps}
                      />
                    ) : field.type === "component" && field.component === "UnitSlider" ? (
                      <UnitSlider
                        name={field.name}
                        label={field.label || field.name}
                        value={Number(field.value) || 1}
                        required={field.required}
                        min={field.min}
                        max={field.max}
                        step={field.step}
                        {...field.componentProps}
                      />
                    ) : field.type === "component" && field.component === "ToggleButton" ? (
                      <div class="multi-step-toggle-group flex flex-wrap gap-3" tabindex="-1">
                        {field.options?.map((option) => (
                          <ToggleButton
                            value={option.value}
                            group={field.name}
                            type={field.toggleType || "radio"}
                            class={field.classes}
                          >
                            {option.label}
                          </ToggleButton>
                        ))}
                      </div>
                    ) : field.type === "component" && field.component === "FileUpload" ? (
                      <FileUpload
                        name={field.name}
                        label={field.label}
                        required={field.required}
                        accept={field.accept}
                        multiple={field.multiple}
                        maxFiles={field.maxFiles}
                        maxSize={field.maxSize}
                        {...field.componentProps}
                      />
                    ) : field.type === "range" ? (
                      <UnitSlider
                        name={field.name}
                        label={field.label || field.name}
                        value={Number(field.value) || Number(field.min) || 0}
                        required={field.required}
                        min={field.min || 0}
                        max={field.max || 100}
                        step={field.step || 1}
                      />
                    ) : field.type === "textarea" ? (
                      <textarea
                        id={field.id}
                        name={field.name}
                        placeholder={field.placeholder}
                        required={field.required}
                        rows={field.rows || 4}
                        autocomplete={field.autocomplete}
                        class={appendedMultiStepInputClasses}
                        data-error={field.errorMessage}
                        data-validate={field.validate}
                        data-validate-message={field.validateMessage}
                      />
                    ) : field.animatedPlaceholders && field.animatedPlaceholders.length > 0 ? (
                      <div
                        class:list={[
                          "relative",
                          "text-black dark:text-white",
                          field.icon ? "input-with-icon" : "",
                          field.iconPosition === "right" ? "icon-right" : "icon-left",
                        ]}
                        data-icon={field.icon}
                        tabindex="-1"
                      >
                        <input
                          type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                          id={field.id}
                          name={field.name}
                          placeholder=""
                          required={field.required}
                          autocomplete={field.autocomplete}
                          minlength={field.minlength}
                          autofocus={field.autofocus}
                          class:list={[
                            appendedMultiStepInputClasses,
                            field.icon && field.iconPosition === "right" ? "pr-12" : "",
                            field.icon && field.iconPosition !== "right" ? "pl-12" : "",
                          ]}
                          data-error={field.errorMessage}
                          data-validate={field.validate}
                          data-validate-message={field.validateMessage}
                          data-has-animated-placeholder="true"
                          data-original-placeholder={field.placeholder}
                          data-animated-placeholders={JSON.stringify(field.animatedPlaceholders)}
                        />
                        <span
                          class:list={[
                            "animated-placeholder pointer-events-none absolute -top-0.5 left-0 flex h-full w-full items-center",
                            field.animatedPlaceholderAlignment === "left"
                              ? `justify-start ${field.icon && field.iconPosition === "left" ? "" : "pl-3"}`
                              : field.animatedPlaceholderAlignment === "right"
                                ? `justify-end ${field.icon && field.iconPosition === "right" ? "" : "pr-3"}`
                                : "justify-center",
                            field.icon && field.iconPosition === "right" ? "mr-1.25 pr-12" : "",
                            field.icon && field.iconPosition !== "right" ? "ml-1.25 pl-12" : "",
                          ]}
                          data-for={field.id}
                          tabindex="-1"
                        >
                          {field.placeholder}
                        </span>
                      </div>
                    ) : field.type === "button-group" ? (
                      <div class="multi-step-button-group flex flex-wrap gap-3" tabindex="-1">
                        {field.buttons?.map((button) => {
                          const btnConfig = getButtonConfig(
                            button,
                            config.buttonDefaults?.[
                              button.type as keyof typeof config.buttonDefaults
                            ]
                          );
                          return (
                            <Button
                              id={button.id}
                              variant={btnConfig.variant}
                              size="sm"
                              icon={btnConfig.icon}
                              iconPosition={btnConfig.iconPosition}
                              class={btnConfig.classes}
                              dataAttributes={{
                                ...(button.dataValue && { "data-value": button.dataValue }),
                                ...(button.dataNext !== undefined && {
                                  "data-next": button.dataNext.toString(),
                                }),
                              }}
                            >
                              {btnConfig.label && (
                                <span class="button-text">
                                  <Fragment set:html={btnConfig.label} />
                                </span>
                              )}
                            </Button>
                          );
                        })}
                      </div>
                    ) : field.icon ? (
                      <div
                        class:list={[
                          "input-with-icon relative",
                          field.iconPosition === "right" ? "icon-right" : "icon-left",
                        ]}
                        data-icon={field.icon}
                        tabindex="-1"
                      >
                        <input
                          type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                          id={field.id}
                          name={field.name}
                          placeholder={field.placeholder}
                          required={field.required}
                          autocomplete={field.autocomplete}
                          minlength={field.minlength}
                          autofocus={field.autofocus}
                          class:list={[
                            appendedMultiStepInputClasses,
                            field.iconPosition === "right" ? "pl-12 pr-12" : "pl-12 pr-12",
                          ]}
                          data-error={field.errorMessage}
                          data-validate={field.validate}
                          data-validate-message={field.validateMessage}
                        />
                      </div>
                    ) : (
                      <input
                        type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                        id={field.id}
                        name={field.name}
                        placeholder={field.placeholder}
                        required={field.required}
                        autocomplete={field.autocomplete}
                        minlength={field.minlength}
                        autofocus={field.autofocus}
                        class={appendedMultiStepInputClasses}
                        data-error={field.errorMessage}
                        data-validate={field.validate}
                        data-validate-message={field.validateMessage}
                      />
                    )}
                  </div>
                ))}
              </div>
            ) : null}

            {/* Step Buttons */}
            {/* Choice buttons (radio-style options) */}
            {step.buttons.some((b) => b.type === "choice") && (
              <div
                class={`multi-step-choice-buttons flex ${step.buttons.some((b) => b.type === "choice" && b.classes?.includes("w-full")) ? "flex-col" : "flex-wrap justify-center"} mb-6 gap-3`}
                tabindex="-1"
              >
                {step.buttons
                  .filter((button) => button.type === "choice")
                  .map((button) => {
                    const btnConfig = getButtonConfig(
                      button,
                      config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                    );

                    return (
                      <Button
                        id={button.id}
                        type="button"
                        variant={btnConfig.variant || "outline"}
                        size={"sm"}
                        class={`${button.type}-step sms-choice ${button.classes || ""}`}
                        disabled={button.disabled}
                        dataAttributes={{
                          ...(button.dataNext !== undefined && {
                            "data-next": button.dataNext.toString(),
                          }),
                          ...(button.dataValue !== undefined && { "data-value": button.dataValue }),
                          ...(button.dataValue !== undefined && {
                            "data-sms-value": button.dataValue,
                          }), // Keep for backward compatibility with SMS
                        }}
                      >
                        {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                      </Button>
                    );
                  })}
              </div>
            )}

            {/* Navigation buttons (prev, next, submit, skip) */}
            <div
              class:list={[
                "step-form-buttons-wrapper",
                "flex",
                "gap-3",
                step.buttons.filter((b) => b.type !== "choice").length === 1
                  ? "justify-end"
                  : "justify-between",
                step.response ? "" : "",
              ]}
            >
              {step.buttons
                .filter((button) => button.type !== "choice")
                .map((button) => {
                  const btnConfig = getButtonConfig(
                    button,
                    config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                  );

                  const buttonEl = button.href ? (
                    <Button
                      id={button.id}
                      variant={btnConfig.variant}
                      size="sm"
                      icon={btnConfig.icon}
                      iconPosition={btnConfig.iconPosition}
                      href={button.href}
                      class={`${button.type}-step ${button.classes || ""}`}
                      disabled={button.disabled}
                    >
                      {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                    </Button>
                  ) : (
                    <Button
                      id={button.id}
                      variant={btnConfig.variant}
                      size="sm"
                      icon={btnConfig.icon}
                      iconPosition={btnConfig.iconPosition}
                      type="button"
                      class={`${button.type}-step ${button.classes || ""}`}
                      disabled={button.disabled}
                      dataAttributes={{
                        ...(button.dataNext !== undefined && {
                          "data-next": button.dataNext.toString(),
                        }),
                        ...(button.dataPrev !== undefined && {
                          "data-prev": button.dataPrev.toString(),
                        }),
                        ...(button.label && {
                          "data-default-label": button.label,
                        }),
                        ...(button.validLabel && {
                          "data-valid-label": button.validLabel,
                        }),
                      }}
                    >
                      {btnConfig.label &&
                        (btnConfig.label === "back" ? (
                          <span class="hidden sm:inline">
                            <Fragment set:html={btnConfig.label} />
                          </span>
                        ) : (
                          <span class="button-text">
                            <Fragment set:html={btnConfig.label} />
                          </span>
                        ))}
                      {/* Valid state icon (hidden by default, shown when valid; default check, override with button.validIcon e.g. "enter") */}
                      {btnConfig.iconPosition === "right" && (
                        <SimpleIcon
                          name={button.validIcon ?? "return"}
                          size={btnConfig.size}
                          class="icon-valid ml-2 hidden"
                        />
                      )}
                    </Button>
                  );
                  return button.tooltipText ? (
                    <Tooltip text={button.tooltipText} position={button.tooltipPosition || "top"}>
                      {buttonEl}
                    </Tooltip>
                  ) : (
                    buttonEl
                  );
                })}
            </div>
          </div>
        ))
      }
    </div>

    {/* Hidden Fields */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={field.value} />
      ))
    }
  </form>
</div>

<!-- Advanced Stepper - Fixed to bottom (outside of container to avoid flex interference) -->
{
  config.progressBar && (
    <div
      id={`${config.formId}-progress-bar`}
      class="fixed bottom-0 left-0 right-0 z-40 border-t border-gray-200 bg-white/90 px-4 py-4 backdrop-blur-md transition-opacity duration-300 dark:border-gray-700 dark:bg-gray-900/90"
      tabindex="-1"
    >
      <div class="mx-auto w-[90vw] max-w-6xl sm:w-[85vw] md:w-[80vw] lg:w-[75vw]" tabindex="-1">
        <ol class="flex w-full items-center" id={`${config.formId}-stepper`} tabindex="-1">
          {config.steps
            .filter((step) => !step.hideProgressBar)
            .map((step, index, filteredSteps) => (
              <li
                class={`relative flex items-center ${index < filteredSteps.length - 1 ? "w-full" : ""}`}
                data-step-indicator={step.stepNumber}
                tabindex="-1"
              >
                {/* Step Circle/Icon with Tooltip */}
                <Tooltip text={step.title} position="top" mobileClickable={true} html={true}>
                  <span
                    class="step-indicator relative flex h-3 w-3 shrink-0 items-center justify-center rounded-full bg-gray-300 transition-all duration-300 dark:bg-gray-700 sm:h-4 sm:w-4"
                    data-step-title={step.title}
                    tabindex="-1"
                  />
                </Tooltip>

                {/* Connecting Line */}
                {index < filteredSteps.length - 1 && (
                  <div
                    class="mx-2 h-1 w-full overflow-hidden rounded-full bg-transparent dark:bg-transparent"
                    tabindex="-1"
                  >
                    <div
                      class="step-progress-line h-full bg-transparent transition-all duration-500 ease-out dark:bg-transparent"
                      style="width: 0%"
                      tabindex="-1"
                    />
                  </div>
                )}
              </li>
            ))}
        </ol>
      </div>
    </div>
  )
}

<style is:global>
  /* Title scroll container with max height */
  .title-scroll-container {
    display: flex;
    position: relative;
    flex-direction: column;
  }

  /* Wrapper cascade: hidden until typewriter completes, then 250ms > fields > 250ms > buttons */
  .step-content.has-typewriter .step-form-fields-wrapper,
  .step-content.has-typewriter .step-form-buttons-wrapper {
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transition:
      max-height 0.4s ease-out,
      opacity 0.25s ease-out;
  }

  .step-content.typewriter-complete .step-form-fields-wrapper {
    max-height: 200rem;
    opacity: 1;
    overflow: visible;
    transition-delay: 250ms;
  }

  .step-content.typewriter-complete .step-form-buttons-wrapper {
    max-height: 200rem;
    opacity: 1;
    overflow: visible;
    transition-delay: 500ms;
  }

  /* For steps without typewriter, show wrappers immediately */
  .step-content:not(.has-typewriter) .step-form-fields-wrapper,
  .step-content:not(.has-typewriter) .step-form-buttons-wrapper {
    max-height: none;
    opacity: 1;
    overflow: visible;
  }

  /* Inner elements: opacity tied to wrapper reveal (no per-element stagger) */
  .step-content.has-typewriter .input-wrapper,
  .step-content.has-typewriter .inline-address-search-wrapper,
  .step-content.has-typewriter .step-form-fields-wrapper button,
  .step-content.has-typewriter .step-form-fields-wrapper a,
  .step-content.has-typewriter .step-form-buttons-wrapper button,
  .step-content.has-typewriter .step-form-buttons-wrapper a,
  .step-content.has-typewriter textarea {
    opacity: 0;
    transition: opacity 0.25s ease-out;
  }

  .step-content.typewriter-complete .input-wrapper,
  .step-content.typewriter-complete .inline-address-search-wrapper,
  .step-content.typewriter-complete textarea {
    opacity: 1;
    transition-delay: 250ms; /* sync with fields-wrapper */
  }

  .step-content.typewriter-complete .step-form-fields-wrapper button,
  .step-content.typewriter-complete .step-form-fields-wrapper a {
    opacity: 1;
    transition-delay: 250ms;
  }

  .step-content.typewriter-complete .step-form-buttons-wrapper button,
  .step-content.typewriter-complete .step-form-buttons-wrapper a {
    opacity: 1;
    transition-delay: 500ms; /* sync with buttons-wrapper */
  }

  /* For steps without typewriter effect, show content immediately */
  .step-content:not(.has-typewriter) .input-wrapper,
  .step-content:not(.has-typewriter) .inline-address-search-wrapper,
  .step-content:not(.has-typewriter) button,
  .step-content:not(.has-typewriter) a,
  .step-content:not(.has-typewriter) textarea {
    transform: translateY(0);
    opacity: 1;
  }

  /* TEST: When data-test-no-cascade, bypass all hiding - everything visible immediately for keypad debugging */
  [data-multi-step-form][data-test-no-cascade] .step-form-fields-wrapper,
  [data-multi-step-form][data-test-no-cascade] .step-form-buttons-wrapper {
    max-height: none !important;
    opacity: 1 !important;
    overflow: visible !important;
    transition: none !important;
    transition-delay: 0ms !important;
  }
  [data-multi-step-form][data-test-no-cascade] .input-wrapper,
  [data-multi-step-form][data-test-no-cascade] .inline-address-search-wrapper,
  [data-multi-step-form][data-test-no-cascade] button,
  [data-multi-step-form][data-test-no-cascade] a,
  [data-multi-step-form][data-test-no-cascade] textarea {
    opacity: 1 !important;
    transition: none !important;
    transition-delay: 0ms !important;
  }
</style>

<style>
  /* Wrapper: fixed. Initial top at 50dvh, expands down; when bottom would hit 4rem we switch to expand-up (class swap). */
  /* flex-start so step-content divs stack from top and user can scroll up through previous steps. */
  .multi-step-form-steps {
    /* position: fixed;
    top: 0;
    left: 50%; */
    /* transform: translateX(-50%); */
    /* max-height: calc(100vh - 5rem);
    max-height: calc(100dvh - 5rem);
    max-width: var(--multi-step-form-width, 42rem); */
    /* box-sizing: border-box;
    min-height: 0;
    overflow-x: hidden; */

    /* overflow-y: auto; */

    /* -webkit-overflow-scrolling: touch; */
  }

  /* Expand down: top at 50dvh, panel grows downward until it would hit the limit */
  .multi-step-form-steps.expand-down {
    top: 26.5dvh;
    bottom: auto;
  }

  /* Expand up: bottom at 4rem, panel grows upward after hitting the limit */
  .multi-step-form-steps.expand-up {
    top: auto;
    bottom: 26.5dvh;
  }

  /* Centered: when expandDown is false for current step, keep panel vertically centered */
  .multi-step-form-steps.centered {
    /* top: 50%;
    bottom: auto;
    justify-content: center;
    transform: translate(-50%, -50%); */
  }

  /* Hide steps that are neither completed nor active so we don't scroll to blank content */
  .multi-step-form-steps .step-content:not(.completed):not(.active) {
    display: none;
  }

  /* Completed and active steps: block layout inside the wrapper */

  /* First step starts below cursor so it can slide up into view on load */
  .step-content.first-step {
    /* opacity: 0; */
    /* transform: translateY(60vh); */
  }

  /* Override default slide-in when going backward - panel comes from above */

  /* Step indicator states */
  .step-indicator {
    background-color: rgb(209 213 219); /* gray-300 */
  }

  .dark .step-indicator {
    background-color: rgb(55 65 81); /* gray-700 */
  }

  .step-indicator.active {
    animation: pulse 2s infinite;
    background-color: var(--color-secondary-400);
  }

  .dark .step-indicator.active {
    animation: pulse 2s infinite;
    background-color: var(--color-secondary-600);
  }

  .step-indicator.completed {
    background-color: var(--color-success-500);
  }

  .dark .step-indicator.completed {
    background-color: var(--color-success-600);
  }

  /* Typewriter/Terminal style layout - fixed cursor line */
  [data-multi-step-form] {
    /* position: absolute;
    inset: 0;
    overflow: hidden; */
    /* display: flex;
    flex-direction: column;
    padding-left: max(1rem, env(safe-area-inset-left));
    padding-right: max(1rem, env(safe-area-inset-right)); */
  }

  /* Form is the scroll container; .multi-step-form-steps is the single scrollable content block */
  [data-multi-step-form] form {
    position: relative;
    /* margin: 0 auto; */
    /* width: 100%; */

    scroll-behavior: smooth;
    /* padding-top: 40vh; */
  }

  [data-multi-step-form] form .first-step {
    /* padding-top: 30vh; */
  }

  /* Responsive padding adjustments */
  /* @media (min-width: 640px) {
    [data-multi-step-form] {
      padding-left: max(2rem, env(safe-area-inset-left));
      padding-right: max(2rem, env(safe-area-inset-right));
    }
  } */

  /* @media (min-width: 768px) {
    [data-multi-step-form] {
      padding-left: max(3rem, env(safe-area-inset-left));
      padding-right: max(3rem, env(safe-area-inset-right));
    }
  } */

  /* @media (min-width: 1024px) {
    [data-multi-step-form] {
      padding-left: max(4rem, env(safe-area-inset-left));
      padding-right: max(4rem, env(safe-area-inset-right));
    }
  } */

  /* Visual cursor line indicator (optional, can be removed) */
  [data-multi-step-form]::before {
    /* content: ""; */
    /* position: fixed;
    top: 40vh;
    right: max(1rem, env(safe-area-inset-right));
    left: max(1rem, env(safe-area-inset-left));
    opacity: 0.1;
    z-index: 100;
    background: linear-gradient(90deg, transparent, var(--color-primary-500) 50%, transparent);
    height: 2px;
    pointer-events: none; */
  }

  /* @media (min-width: 640px) {
    [data-multi-step-form]::before {
      left: max(2rem, env(safe-area-inset-left));
      right: max(2rem, env(safe-area-inset-right));
    }
  }

  @media (min-width: 768px) {
    [data-multi-step-form]::before {
      left: max(3rem, env(safe-area-inset-left));
      right: max(3rem, env(safe-area-inset-right));
    }
  }

  @media (min-width: 1024px) {
    [data-multi-step-form]::before {
      left: max(4rem, env(safe-area-inset-left));
      right: max(4rem, env(safe-area-inset-right));
    }
  } */

  .step-content.completed .step-form-buttons-wrapper {
    /* margin-top: 0 !important; */
    /* height: 0;
    transition: height 0.3s ease-in-out; */
    display: none;
  }

  .step-content.completed.active .step-form-buttons-wrapper {
    display: flex;
  }

  /* When a panel is completed, collapse input wrapper width and align right */
  .step-content.completed .input-wrapper,
  .step-content.completed .inline-address-search-wrapper {
    transition:
      width 0.3s ease-out,
      margin 0.3s ease-out;
    margin-left: auto;
    width: fit-content;
    max-width: 100%;
  }

  .step-content.completed .input-wrapper input,
  .step-content.completed .input-wrapper textarea,
  .step-content.completed .inline-address-search-wrapper input {
    width: auto;
    min-width: 14ch;
  }

  /* ml-8 for response steps is applied via class in template (step.response) */

  /* Touch-friendly button groups on mobile: 44px min touch target, no tap delay */
  [data-multi-step-form] .multi-step-button-group button,
  [data-multi-step-form] .multi-step-choice-buttons button,
  [data-multi-step-form] .multi-step-toggle-group button {
    min-height: 44px;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
</style>

<script>
  import { initializeMultiStepForm } from "../../lib/multi-step-form-handler";
  // TypeIt typewriter loaded globally from App.astro (window.initTypewriterTexts, window.triggerActiveStepTypewriter)

  document.addEventListener("DOMContentLoaded", () => {
    // Tap-to-focus: tapping the field wrapper focuses the input (iOS keypad requires direct user gesture)
    document.addEventListener(
      "click",
      (e) => {
        const target = e.target as HTMLElement;
        if (target.closest("button") || target.closest("a")) return;
        const wrapper = target.closest(".input-wrapper");
        if (!wrapper) return;
        const input = wrapper.querySelector(
          "input:not([type=hidden]):not([readonly]), textarea, select"
        ) as HTMLInputElement | HTMLTextAreaElement | null;
        if (input?.focus && document.activeElement !== input) input.focus();
      },
      true
    );

    // Panel position: only .multi-step-form-steps height matters (spacer removed)
    let updateStepsPanelBottomRef: (() => void) | null = null;
    /** Run panel bottom update every frame for the given duration (e.g. during typewriter/cascade). */
    let runPanelBottomLoopRef: ((durationMs: number) => void) | null = null;
    const stepsEl = document.querySelector(".multi-step-form-steps") as HTMLElement | null;
    if (stepsEl) {
      // console.log("[MULTISTEP-DEBUG] steps panel found, setting up");
      const BOTTOM_MIN_PX = 4 * 16; // 4rem cutoff
      const THROTTLE_MS = 80;
      let lastPanelBottomRun = 0;

      function updateStepsPanelBottom(caller?: string) {
        const activeStep = stepsEl.querySelector(".step-content.active");
        const expandDownForStep = activeStep?.getAttribute("data-expand-down") !== "false";

        if (!expandDownForStep) {
          stepsEl.classList.add("centered");
          stepsEl.classList.remove("expand-down", "expand-up");
          // console.log("[MULTISTEP-DEBUG] updateStepsPanelBottom", {
          //   caller: caller ?? "unknown",
          //   mode: "centered",
          // });
          return;
        }

        stepsEl.classList.remove("centered");
        const stepsHeight = stepsEl.scrollHeight;
        const clientHeight = stepsEl.clientHeight;
        const offsetHeight = stepsEl.offsetHeight;
        const viewportHeight = window.innerHeight;
        const fiftyDvhPx = viewportHeight * 0.5;
        // Switch when panel bottom would hit limit: 50dvh + height >= viewport - 4rem => height >= 50dvh - 4rem
        const thresholdPx = fiftyDvhPx - BOTTOM_MIN_PX;
        const expandUp = stepsHeight >= thresholdPx;
        if (expandUp) {
          stepsEl.classList.add("expand-up");
          stepsEl.classList.remove("expand-down");
        } else {
          stepsEl.classList.add("expand-down");
          stepsEl.classList.remove("expand-up");
        }
        // console.log("[MULTISTEP-DEBUG] updateStepsPanelBottom", {
        //   caller: caller ?? "unknown",
        //   scrollHeight: stepsHeight,
        //   clientHeight,
        //   offsetHeight,
        //   fiftyDvhPx,
        //   thresholdPx,
        //   expandUp,
        // });
      }

      function throttledUpdateStepsPanelBottom(caller?: string) {
        const now = performance.now();
        const allowed = now - lastPanelBottomRun >= THROTTLE_MS;
        if (allowed) {
          lastPanelBottomRun = now;
          updateStepsPanelBottom(caller ?? "throttled");
        } else {
          // console.log("[MULTISTEP-DEBUG] throttledUpdateStepsPanelBottom skipped (throttle)", {
          //   caller: caller ?? "unknown",
          //   elapsed: now - lastPanelBottomRun,
          //   THROTTLE_MS,
          // });
        }
      }

      updateStepsPanelBottomRef = () => throttledUpdateStepsPanelBottom("ref");

      runPanelBottomLoopRef = (durationMs: number) => {
        // console.log("[MULTISTEP-DEBUG] runPanelBottomLoopRef started", { durationMs });
        const start = performance.now();
        const tick = () => {
          throttledUpdateStepsPanelBottom("loop");
          if (performance.now() - start < durationMs) requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      };

      updateStepsPanelBottom("DOMContentLoaded");

      window.addEventListener("resize", () => {
        // console.log("[MULTISTEP-DEBUG] resize â†’ throttledUpdateStepsPanelBottom");
        throttledUpdateStepsPanelBottom("resize");
      });

      const resizeObserver = new ResizeObserver(() => {
        // console.log("[MULTISTEP-DEBUG] ResizeObserver â†’ requestAnimationFrame(throttled)");
        requestAnimationFrame(() => throttledUpdateStepsPanelBottom("ResizeObserver"));
      });
      resizeObserver.observe(stepsEl);

      document.addEventListener("multistep-step-change", () => {
        // console.log("[MULTISTEP-DEBUG] multistep-step-change â†’ updateStepsPanelBottom + loop 15s");
        requestAnimationFrame(() =>
          requestAnimationFrame(() => updateStepsPanelBottom("multistep-step-change"))
        );
        runPanelBottomLoopRef?.(5000);
      });
    }

    // Listen for typewriter completion to trigger content animations (wrapper cascade: 250ms > fields > 250ms > buttons)
    document.addEventListener("typewriter-complete", (e) => {
      const target = e.target as HTMLElement;
      const stepContent = target.closest(".step-content");
      if (stepContent) {
        // Add the class to trigger wrapper cascade (fields at 250ms, buttons at 500ms)
        stepContent.classList.add("typewriter-complete");

        // Panel bottom: update every frame while wrappers expand so position tracks in real time
        requestAnimationFrame(() => requestAnimationFrame(updateStepsPanelBottomRef ?? (() => {})));
        const CASCADE_END_MS = 750; /* 500ms buttons delay + ~250ms opacity/expand */
        runPanelBottomLoopRef?.(CASCADE_END_MS + 600);

        // Focus first input after cascade (for desktop; on iOS, user taps the field to open keypad)
        const FOCUS_DELAY_AFTER_ANIMATIONS_MS = 150;
        let focusDone = false;
        const runFocus = () => {
          if (focusDone) return;
          focusDone = true;
          const focusFirstIn = (window as any).focusFirstInputIn;
          if (typeof focusFirstIn === "function") focusFirstIn(stepContent);
        };

        const buttonsWrapper = stepContent.querySelector(".step-form-buttons-wrapper");
        if (buttonsWrapper) {
          const onCascadeEnd = (e: TransitionEvent) => {
            if (e.target !== buttonsWrapper || e.propertyName !== "opacity") return;
            buttonsWrapper.removeEventListener("transitionend", onCascadeEnd as EventListener);
            setTimeout(runFocus, FOCUS_DELAY_AFTER_ANIMATIONS_MS);
          };
          buttonsWrapper.addEventListener("transitionend", onCascadeEnd as EventListener);
        }
        setTimeout(runFocus, CASCADE_END_MS + FOCUS_DELAY_AFTER_ANIMATIONS_MS + 200);
      }
    });

    // Mark steps with typewriter effect
    document.querySelectorAll(".step-content").forEach((step) => {
      const hasTypewriter = step.querySelector(".typewriter-text");
      if (hasTypewriter) {
        step.classList.add("has-typewriter");
      }
    });

    // Initialize rotating placeholders for all inputs with animated placeholders
    const animatedInputs = document.querySelectorAll(
      'input[data-has-animated-placeholder="true"]'
    ) as NodeListOf<HTMLInputElement>;

    // console.log(
    //   `[ANIMATED-PLACEHOLDER] ðŸŽ¯ Found ${animatedInputs.length} inputs with animated placeholders`
    // );

    // Store placeholder data for each field
    const placeholderData = new Map<
      string,
      { index: number; values: string[]; syncGroup?: string }
    >();

    // Initialize placeholder data for each input
    animatedInputs.forEach((input) => {
      const placeholders = input.getAttribute("data-animated-placeholders");
      const fieldId = input.id;

      // console.log(
      //   `[ANIMATED-PLACEHOLDER] ðŸ” Checking input: ${fieldId}, has value: ${!!input.value}, value length: ${input.value?.length || 0}`
      // );

      if (placeholders) {
        try {
          const values = JSON.parse(placeholders);

          // Note: Sync groups have been removed - all fields now use staggered delays
          // Previously firstName and lastName were synced, but this prevented the stagger effect

          placeholderData.set(fieldId, { index: 0, values, syncGroup: undefined });
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] âœ… Initialized ${fieldId} with ${values.length} placeholders`
          // );
        } catch (e) {
          console.error(
            `[ANIMATED-PLACEHOLDER] âŒ Failed to parse placeholders for ${fieldId}:`,
            e
          );
        }
      }
    });

    // Hide placeholder spans when input has value
    animatedInputs.forEach((input) => {
      const span = document.querySelector(
        `.animated-placeholder[data-for="${input.id}"]`
      ) as HTMLElement;
      if (span) {
        // console.log(`[ANIMATED-PLACEHOLDER] ðŸŽ¬ Setting up detection for ${input.id}`);

        // Helper function to check and hide/show placeholder
        // Hide only when: has value or autofilled. Show when empty so animation plays until data is entered.
        const checkAndHidePlaceholder = () => {
          const hasValue = input.value && input.value.length > 0;

          let isAutofilled = false;
          try {
            isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
          } catch (e) {
            console.log(
              `[ANIMATED-PLACEHOLDER] âš ï¸ Could not check autofill pseudo-class for ${input.id}`
            );
          }

          if (hasValue || isAutofilled) {
            span.style.display = "none";
          } else {
            span.style.display = "flex";
          }
        };

        input.addEventListener("focus", () => {
          checkAndHidePlaceholder();
        });
        input.addEventListener("blur", () => {
          checkAndHidePlaceholder();
        });

        // Listen for manual input changes
        input.addEventListener("input", () => {
          // console.log(`[ANIMATED-PLACEHOLDER] ðŸ“ Input event fired for ${input.id}`);
          checkAndHidePlaceholder();
        });

        // Listen for change events (fired by browser autofill in some cases)
        input.addEventListener("change", () => {
          // console.log(`[ANIMATED-PLACEHOLDER] ðŸ”„ Change event fired for ${input.id}`);
          checkAndHidePlaceholder();
        });

        // Listen for autofill detection via CSS animation
        input.addEventListener("animationstart", (e: AnimationEvent) => {
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] ðŸŽ¨ Animation started: ${e.animationName} for ${input.id}`
          // );
          if (e.animationName === "onAutoFillStart") {
            console.log(
              `[ANIMATED-PLACEHOLDER] ðŸŽ¯ Autofill CSS animation detected for ${input.id}`
            );
            checkAndHidePlaceholder();
          }
        });

        // Watch for attribute changes (some browsers add data attributes on autofill)
        const observer = new MutationObserver(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ðŸ”¬ Mutation observed for ${input.id}`);
          checkAndHidePlaceholder();
        });
        observer.observe(input, {
          attributes: true,
          attributeFilter: ["value", "data-value"],
        });

        // Check initial value immediately
        console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Initial check (0ms) for ${input.id}`);
        checkAndHidePlaceholder();

        // Delayed checks for autofill (fallback for browsers that don't support animation detection)
        // Browser autofill can happen at various times, so we check multiple times
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Delayed check (100ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 100);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Delayed check (500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 500);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Delayed check (1000ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 1000);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Delayed check (1500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 1500);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] â±ï¸ Delayed check (2500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 2500);
      }
    });

    function rotatePlaceholders() {
      // Find the active step to determine which inputs are visible
      const activeStep = document.querySelector(".step-content.active");

      animatedInputs.forEach((input, index) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        // Check both value and autofill state
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // console.log(
        //   `[ANIMATED-PLACEHOLDER] ðŸ”„ Rotate check ${input.id}: hasValue=${hasValue}, isAutofilled=${isAutofilled}, span.display=${span?.style.display}`
        // );

        if (span && data && !hasValue && !isAutofilled && span.style.display !== "none") {
          // Check if this input is in the active step
          const isInActiveStep = activeStep?.contains(input);

          if (!isInActiveStep) return;

          // Find the index of this input within the active step
          const activeStepInputs = Array.from(
            activeStep.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);

          // âš ï¸ PROTECTED CODE - DO NOT REMOVE âš ï¸
          // This stagger delay creates a cascading animation effect for successive placeholders.
          // See: .cursor/rules/multistep-form-placeholder-stagger.md
          // See: markdowns/animated-placeholder-stagger-delay.md
          // Stagger delay: 200ms per field for smooth cascade effect
          const staggerDelay = stepIndex * 200;

          setTimeout(() => {
            // Only rotate if visible
            span.style.animation = "slideOutDown 400ms ease-out forwards";

            setTimeout(() => {
              data.index = (data.index + 1) % data.values.length;
              span.textContent = data.values[data.index];
              span.style.animation = "slideInDown 400ms ease-out forwards";
            }, 400);
          }, staggerDelay);
        }
      });
    }

    // Reset and restart placeholder animation
    function resetPlaceholderAnimation() {
      // console.log(`[ANIMATED-PLACEHOLDER] ðŸ”„ Resetting placeholder animation`);

      // Find the active step to apply stagger delay correctly
      const activeStep = document.querySelector(".step-content.active");

      animatedInputs.forEach((input) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        // Check both value and autofill state
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // Skip if input has a value (from autofill or manual entry)
        if (hasValue || isAutofilled) {
          if (span) {
            span.style.display = "none";
          }
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] â­ï¸ Skipping reset for ${input.id} (has value: ${hasValue}, autofilled: ${isAutofilled})`
          // );
          return;
        }

        if (span && data) {
          // Check if this input is in the active step
          const isInActiveStep = activeStep?.contains(input);

          if (!isInActiveStep) {
            // Not in active step, just reset without animation
            data.index = 0;
            span.textContent = data.values[0];
            return;
          }

          // Find the index of this input within the active step for stagger delay
          const activeStepInputs = Array.from(
            activeStep.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);

          // Apply stagger delay for reset animation too (200ms per field)
          const staggerDelay = stepIndex * 200;

          setTimeout(() => {
            data.index = 0;
            span.textContent = data.values[0];
            span.style.animation = "slideInDown 400ms ease-out forwards";
          }, staggerDelay);
        }
      });
    }

    // Store interval ID so we can clear it
    let placeholderInterval: ReturnType<typeof setInterval> | null = null;

    // Start placeholder rotation
    function startPlaceholderRotation() {
      // console.log(`[ANIMATED-PLACEHOLDER] ðŸš€ Starting placeholder rotation`);

      // Clear any existing interval
      if (placeholderInterval) {
        clearInterval(placeholderInterval);
      }

      // Check all inputs for values one more time before starting animation
      // This catches browser autofill that may have completed
      animatedInputs.forEach((input) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // console.log(
        //   `[ANIMATED-PLACEHOLDER] ðŸŽ¬ Pre-animation check for ${input.id}: hasValue=${hasValue}, isAutofilled=${isAutofilled}`
        // );

        if (span && (hasValue || isAutofilled)) {
          span.style.display = "none";
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] âœ… Pre-animation: hiding placeholder for ${input.id} (has value: ${hasValue}, autofilled: ${isAutofilled})`
          // );
        }
      });

      // Reset to first placeholder
      resetPlaceholderAnimation();

      // Start new interval
      placeholderInterval = setInterval(rotatePlaceholders, 2000);
      // console.log(`[ANIMATED-PLACEHOLDER] â° Rotation interval started (2000ms)`);
    }

    // Rotate placeholders every 2 seconds. Defer start so it runs after form handler
    // has set .step-content.active (initializeMultiStepForm runs later in this same callback).
    if (animatedInputs.length > 0) {
      setTimeout(() => startPlaceholderRotation(), 0);

      // Watch for step changes and restart animation
      const stepObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "class") {
            const target = mutation.target as HTMLElement;
            if (target.classList.contains("active") && target.classList.contains("step-content")) {
              // Check if this step has animated placeholders
              const hasPlaceholders = target.querySelector(
                '[data-has-animated-placeholder="true"]'
              );
              if (hasPlaceholders) {
                // console.log("[PLACEHOLDER] Restarting placeholder animation for active step");
                startPlaceholderRotation();
              }
            }
          }
        });
      });

      // Observe all step-content elements
      const steps = document.querySelectorAll(".step-content");
      steps.forEach((step) => {
        stepObserver.observe(step, {
          attributes: true,
          attributeFilter: ["class"],
        });
      });
    }

    // Add focus/blur shadow animation to all form inputs using event delegation
    // This works for both existing and dynamically added inputs
    // Run immediately, not waiting for DOMContentLoaded
    // document.addEventListener(
    //   "focus",
    //   (e) => {
    //     const target = e.target as HTMLElement;
    //     if (
    //       target &&
    //       (target.tagName === "INPUT" ||
    //         target.tagName === "TEXTAREA" ||
    //         target.tagName === "SELECT") &&
    //       (target as HTMLInputElement).type !== "hidden"
    //     ) {
    //       const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
    //       // console.log("[FOCUS-SHADOW] Adding shadow to:", formElement.id || formElement.name);
    //       target.classList.add("shadow-focus");

    //       // Scroll the form so focused element is at cursor line (40vh from top of form viewport)
    //       setTimeout(() => {
    //         const form = target.closest("form");
    //         if (form) {
    //           const formRect = form.getBoundingClientRect();
    //           const elementRect = target.getBoundingClientRect();
    //           const delta = elementRect.top - (formRect.top + form.clientHeight * 0.4);
    //           form.scrollBy({ top: delta, behavior: "smooth" });
    //           console.log("[MULTISTEP-SCROLL] Form scrollBy (focus):", {
    //             element: formElement.id || formElement.name,
    //             delta,
    //             formScrollTopBefore: form.scrollTop,
    //             reason: "position input at cursor line (40vh)",
    //           });
    //         }
    //       }, 100);
    //     }
    //   },
    //   true
    // );

    // When user focuses an input (e.g. after scrolling up to edit), set that step's panel as .active
    document.addEventListener(
      "focus",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          !target ||
          (target.tagName !== "INPUT" &&
            target.tagName !== "TEXTAREA" &&
            target.tagName !== "SELECT") ||
          (target as HTMLInputElement).type === "hidden"
        ) {
          return;
        }
        const form = target.closest("form");
        if (!form?.closest("[data-multi-step-form]")) return;

        const stepContent = target.closest(".step-content");
        const stepNumber = parseInt(stepContent?.getAttribute("data-step") || "0", 10);
        if (!stepNumber) return;

        const handler = (
          form as HTMLFormElement & {
            multiStepHandler?: {
              setActiveStepByFocus: (n: number) => void;
              getCurrentStep?: () => number;
            };
          }
        ).multiStepHandler;

        // Don't allow focus to land on a step we haven't reached (errant click/tab on password etc.)
        const currentStep = handler?.getCurrentStep?.() ?? 1;
        if (stepNumber > currentStep) {
          console.log("[MULTISTEP-CLICK-DEBUG] focus blocked (future step)", {
            stepNumber,
            currentStep,
            targetId: target.id,
          });
          setTimeout(() => (target as HTMLInputElement).blur(), 0);
          return;
        }

        console.log("[MULTISTEP-CLICK-DEBUG] focus on input â†’ setActiveStepByFocus", {
          stepNumber,
          targetId: target.id,
          targetName: (target as HTMLInputElement).name,
        });
        if (handler?.setActiveStepByFocus) {
          handler.setActiveStepByFocus(stepNumber);
        }
      },
      true
    );

    document.addEventListener(
      "blur",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          target &&
          (target.tagName === "INPUT" ||
            target.tagName === "TEXTAREA" ||
            target.tagName === "SELECT")
        ) {
          const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
          // console.log("[FOCUS-SHADOW] Removing shadow from:", formElement.id || formElement.name);
          target.classList.remove("shadow-focus");
        }
      },
      true
    );

    // Prevent non-interactive elements from stealing focus
    // This prevents accidental taps on background elements from removing input focus
    document.addEventListener(
      "mousedown",
      (e) => {
        const target = e.target as HTMLElement;

        if (!target) return;

        // Get the currently focused element
        const focusedElement = document.activeElement as HTMLElement;

        // Check if an input/textarea/select is currently focused
        const isInputFocused =
          focusedElement &&
          (focusedElement.tagName === "INPUT" ||
            focusedElement.tagName === "TEXTAREA" ||
            focusedElement.tagName === "SELECT") &&
          (focusedElement as HTMLInputElement).type !== "hidden";

        if (!isInputFocused) return;

        // Define interactive elements that SHOULD be allowed to take focus
        const isInteractiveElement =
          target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.tagName === "SELECT" ||
          target.tagName === "BUTTON" ||
          target.tagName === "A" ||
          target.hasAttribute("contenteditable") ||
          target.closest("button") || // Check if inside a button
          target.closest("a"); // Check if inside a link

        // If clicking on a non-interactive element while an input has focus,
        // prevent focus loss
        if (!isInteractiveElement) {
          console.log("[MULTISTEP-CLICK-DEBUG] mousedown (MultiStepForm): prevented focus loss", {
            targetTag: target.tagName,
            targetClass: target.className?.slice?.(0, 60),
            focusedTag: focusedElement?.tagName,
          });
          e.preventDefault();
          // Ensure focus stays on the input
          setTimeout(() => {
            focusedElement.focus();
          }, 0);
        }
      },
      true
    );

    // Get all form configs from data-form-config attribute (avoids script-order / TDZ issues)
    function runMultiStepInit() {
      const forms = document.querySelectorAll("form[data-form-config]");
      if (forms.length === 0) return;
      forms.forEach((formEl) => {
        const form = formEl as HTMLFormElement;
        let formId: string;
        let formConfig: any;
        let initialData: Record<string, any> = {};
        try {
          const parsed = JSON.parse(form.getAttribute("data-form-config") ?? "{}");
          formId = parsed.formId;
          formConfig = parsed.formConfig;
          initialData = parsed.initialData ?? {};
        } catch (e) {
          console.error("[MULTISTEP-FORM] Invalid data-form-config on form", form.id || formEl, e);
          return;
        }
        if (!formId || !formConfig) {
          console.error("[MULTISTEP-FORM] Missing formId or formConfig in data-form-config");
          return;
        }

        console.log("[MULTISTEP-FORM] Attaching handler for form:", formId);

        // Pre-fill form fields with initial data
        Object.entries(initialData || {}).forEach(([key, value]) => {
          const input = form.querySelector(`[name="${key}"]`) as HTMLInputElement;
          if (input && value) {
            (input as HTMLInputElement).value = value as string;
            console.log(`[MULTISTEP-FORM] Pre-filled ${key}:`, value);

            // Hide animated placeholder if this input has one
            if (input.hasAttribute("data-has-animated-placeholder")) {
              const span = document.querySelector(
                `.animated-placeholder[data-for="${input.id}"]`
              ) as HTMLElement;
              if (span) {
                span.style.display = "none";
                console.log(`[MULTISTEP-FORM] Hid animated placeholder for ${key}`);
              }
            }
          }
        });

        // Initialize the form with skip logic
        initializeMultiStepForm(form, {
          initialData: initialData || {},
          formConfig,
        });
      });
    }

    // Run init when DOM is ready; if script loaded late (e.g. deferred), run immediately
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", runMultiStepInit);
    } else {
      runMultiStepInit();
    }
  });

  // Forgot password modal handler (for login form)
  // Only initialize if we're on the login form
  // if (document.getElementById("multi-step-login-form")) {
  //   const forgotPasswordBtn = document.getElementById("forgot-password-btn");

  //   // Modal open/close functionality
  //   async function openForgotPasswordModal() {
  //     try {
  //       const headers = new Headers();
  //       const globalInputClasses =
  //         document.querySelector('input:not([type="hidden"])')?.className || "";
  //       headers.set("x-global-input-classes", globalInputClasses);

  //       const response = await fetch("/partials/forgot-password-form", {
  //         headers: headers,
  //       });

  //       if (!response.ok) {
  //         console.error("Failed to fetch forgot password form partial:", response.status);
  //         return;
  //       }

  //       const formHTML = await response.text();

  //       const modalId = await (window as any).showNotice({
  //         type: "",
  //         title: "Forgot Password",
  //         message: formHTML,
  //         modal: true,
  //       });

  //       // Set up cancel button handler and focus email input when modal opens
  //       setTimeout(() => {
  //         const emailInput = document.querySelector(
  //           '#forgot-password-form input[name="email"]'
  //         ) as HTMLInputElement;
  //         emailInput?.focus();

  //         // Add cancel button click handler
  //         const cancelBtn = document.getElementById("cancel-forgot");
  //         if (cancelBtn) {
  //           cancelBtn.addEventListener("click", () => {
  //             if ((window as any).toastNotificationManager && modalId) {
  //               (window as any).toastNotificationManager.hide(modalId);
  //             }
  //           });
  //         }
  //       }, 100);
  //     } catch (error) {
  //       console.error("Failed to load forgot password form:", error);
  //       alert("Failed to load password reset form. Please try again.");
  //     }
  //   }

  //   // Event listeners for modal
  //   forgotPasswordBtn?.addEventListener("click", (e) => {
  //     e.preventDefault();
  //     openForgotPasswordModal();
  //   });

  //   // Handle form submission using event delegation (since form will be in modal)
  //   document.addEventListener("submit", async (e) => {
  //     const target = e.target as HTMLFormElement;
  //     if (target.id === "forgot-password-form") {
  //       e.preventDefault();

  //       const emailInput = target.querySelector('input[name="email"]') as HTMLInputElement;
  //       const email = emailInput?.value.trim();

  //       if (!email) {
  //         if ((window as any).showNotice) {
  //           (window as any).showNotice({
  //             type: "error",
  //             title: "Validation Error",
  //             message: "Please enter your email address.",
  //             persist: true,
  //             modal: true,
  //           });
  //         }
  //         return;
  //       }

  //       const sendResetLinkBtn = target.querySelector('button[type="submit"]') as HTMLButtonElement;

  //       if (sendResetLinkBtn) {
  //         sendResetLinkBtn.disabled = true;
  //         sendResetLinkBtn.textContent = "Sending...";
  //       }

  //       try {
  //         const response = await fetch("/api/auth/forgot-password", {
  //           method: "POST",
  //           headers: {
  //             "Content-Type": "application/json",
  //           },
  //           body: JSON.stringify({ email }),
  //         });

  //         const result = await response.json();

  //         if (response.ok) {
  //           if ((window as any).showNotice) {
  //             (window as any).showNotice({
  //               type: "success",
  //               title: "Reset Link Sent",
  //               message:
  //                 "If an account with that email exists, you will receive a password reset link shortly.",
  //               redirect: { url: "/", delay: 3500, showCountdown: true },
  //               modal: true,
  //             });
  //           }

  //           const closeBtn = document.querySelector(
  //             '[data-modal-hide="forgot-password-modal"]'
  //           ) as HTMLElement;
  //           if (closeBtn) closeBtn.click();
  //         } else {
  //           if ((window as any).showNotice) {
  //             (window as any).showNotice({
  //               type: "error",
  //               title: "Error",
  //               message: result.error || "Failed to send reset link. Please try again.",
  //               persist: true,
  //               modal: true,
  //             });
  //           }
  //         }
  //       } catch (error) {
  //         console.error("Forgot password error:", error);
  //         if ((window as any).showNotice) {
  //           (window as any).showNotice({
  //             type: "error",
  //             title: "Network Error",
  //             message: "Failed to send reset link. Please check your connection and try again.",
  //             persist: true,
  //             modal: true,
  //           });
  //         }
  //       } finally {
  //         if (sendResetLinkBtn) {
  //           sendResetLinkBtn.disabled = false;
  //           sendResetLinkBtn.textContent = "Send Reset Link";
  //         }
  //       }
  //     }
  //   });
  // }

  // Helper function to check if all fields in current step are valid
  function checkAllFieldsValid() {
    const activeStep = document.querySelector(".step-content.active");
    if (!activeStep) {
      console.log("[FIELD-VALIDATION] No active step found");
      return false;
    }

    const allInputsSelector =
      'input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea, select';
    const requiredInputs = activeStep.querySelectorAll(
      `input[required]:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea[required], select[required]`
    );
    // Include optional fields that have value (e.g. phone with required: false) so valid icon updates
    const inputsToCheck =
      requiredInputs.length > 0 ? requiredInputs : activeStep.querySelectorAll(allInputsSelector);

    function hasValue(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement): boolean {
      if (el instanceof HTMLSelectElement) return el.value !== "";
      const input = el as HTMLInputElement;
      if (input.type === "checkbox") return input.checked;
      if (input.type === "radio") {
        const name = input.name;
        if (!name) return input.checked;
        const group = activeStep.querySelectorAll<HTMLInputElement>(
          `input[type="radio"][name="${name}"]`
        );
        return Array.from(group).some((r) => r.checked);
      }
      return (el.value ?? "").length > 0;
    }

    let allValid = true;
    const fieldStates: { name: string; value: string; valid: boolean }[] = [];
    const seenRadioGroups = new Set<string>();

    inputsToCheck.forEach((input) => {
      const inputEl = input as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
      const inputAsInput = inputEl as HTMLInputElement;
      // When step has no required fields, only validate inputs that have value (e.g. optional phone)
      if (requiredInputs.length === 0 && !hasValue(inputEl as HTMLInputElement)) return;
      if (inputAsInput.type === "radio" && inputAsInput.name) {
        if (seenRadioGroups.has(inputAsInput.name)) return;
        seenRadioGroups.add(inputAsInput.name);
      }
      const hasVal = hasValue(inputEl as HTMLInputElement);
      const validByValidity = inputEl.validity?.valid !== false && hasVal;
      const validByClass = inputEl.classList?.contains("is-valid") && hasVal;
      const valid = inputAsInput.type === "radio" ? hasVal : validByValidity || validByClass;

      let displayValue: string;
      if (inputEl instanceof HTMLSelectElement) {
        displayValue = inputEl.value;
      } else if (inputAsInput.type === "checkbox") {
        displayValue = inputAsInput.checked ? "checked" : "";
      } else if (inputAsInput.type === "radio") {
        const checkedRadio =
          inputAsInput.name &&
          activeStep.querySelector<HTMLInputElement>(
            `input[type="radio"][name="${inputAsInput.name}"]:checked`
          );
        displayValue = checkedRadio?.value ?? "";
      } else {
        const v = (inputEl as HTMLInputElement | HTMLTextAreaElement).value ?? "";
        displayValue = v.substring(0, 20) + (v.length > 20 ? "..." : "");
      }

      fieldStates.push({
        name: inputEl.name || inputEl.id || "",
        value: displayValue,
        valid,
      });

      if (!valid) allValid = false;
    });

    // Step with no required fields and nothing filled: show default icon (e.g. "skip"), not valid
    if (requiredInputs.length === 0 && fieldStates.length === 0) allValid = false;

    console.log("[FIELD-VALIDATION] Current step field states:", fieldStates);

    if (allValid) {
      console.log("âœ… [FIELD-VALIDATION] ALL FIELDS IN PANEL ARE VALID!");
    } else {
      console.log("âŒ [FIELD-VALIDATION] Some fields are invalid or empty");
    }

    // When panel is valid: show valid icon, hide default icon (and vice versa). CSS in global.css uses button.is-valid to control .icon-valid/.icon-default display.
    activeStep.querySelectorAll("button").forEach((btn) => {
      const iconValid = btn.querySelector(".icon-valid");
      const iconDefault = btn.querySelector(".icon-default");
      if (!iconValid || !iconDefault) return;
      if (allValid) {
        btn.classList.add("is-valid");
        const buttonText = btn.querySelector(".button-text");
        const validLabel = btn.getAttribute("data-valid-label");
        const defaultLabel = btn.getAttribute("data-default-label");
        if (buttonText && validLabel && defaultLabel) buttonText.textContent = validLabel;
      } else {
        btn.classList.remove("is-valid");
        const buttonText = btn.querySelector(".button-text");
        const defaultLabel = btn.getAttribute("data-default-label");
        if (buttonText && defaultLabel) buttonText.textContent = defaultLabel;
      }
    });

    return allValid;
  }

  // Add validation state classes for visual feedback (all input types, textarea, select)
  document.addEventListener("DOMContentLoaded", () => {
    const form =
      document.querySelector(".multi-step-form-steps")?.closest("form") ??
      document.querySelector("[data-multi-step-form] form") ??
      document.querySelector("form");
    const scope = form ?? document;
    const fields = scope.querySelectorAll<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >(
      'input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea, select'
    );

    function hasValue(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement): boolean {
      if (el instanceof HTMLSelectElement) return el.value !== "";
      const input = el as HTMLInputElement;
      if (input.type === "checkbox" || input.type === "radio") return input.checked;
      return (el.value ?? "").length > 0;
    }

    function updateValidityState(
      target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    ) {
      const hasVal = hasValue(target as HTMLInputElement);
      const valid = target.validity?.valid !== false;
      if (hasVal) {
        if (valid) {
          target.classList.add("is-valid");
          target.classList.remove("is-invalid");
        } else {
          target.classList.add("is-invalid");
          target.classList.remove("is-valid");
        }
      } else {
        target.classList.remove("is-valid", "is-invalid");
      }
      checkAllFieldsValid();
    }

    fields.forEach((field) => {
      const isCheckboxOrRadio =
        field instanceof HTMLInputElement && (field.type === "checkbox" || field.type === "radio");
      const isSelect = field instanceof HTMLSelectElement;

      if (isCheckboxOrRadio || isSelect) {
        field.addEventListener("change", () => updateValidityState(field));
        field.addEventListener("blur", () => updateValidityState(field));
      } else {
        field.addEventListener("input", () => updateValidityState(field));
        field.addEventListener("blur", () => updateValidityState(field));
      }

      field.addEventListener("focus", () => {
        field.classList.remove("is-invalid");
      });

      // Initial state in case of pre-filled or server state
      updateValidityState(field);
    });
  });
</script>

<!-- Input-with-icon icons are injected by global initInputWithIcon() in App.astro (DOMContentLoaded + astro:after-swap) -->
