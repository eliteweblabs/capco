---
// Reusable multi-step form component that renders from JSON configuration
import type { MultiStepFormConfig } from "../../lib/multi-step-form-config";
import { getButtonConfig } from "../../lib/multi-step-form-config";
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import Tooltip from "../common/TooltipFloating.astro";
import SlotMachineModalStaff from "./SlotMachineModalStaff.astro";
import InlineAddressSearch from "./InlineAddressSearch.astro";
import SlideToggle from "../common/SlideToggle.astro";
import UnitSlider from "./UnitSlider.astro";
import ToggleButton from "./ToggleButton.astro";
import FileUpload from "./FileUpload.astro";
import AuthProviders from "./AuthProviders.astro";
import { SMS_UTILS } from "../../lib/sms-utils";
import { globalClasses } from "../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
}

const { config, containerClass = "", initialData = {} } = Astro.props;

const { globalInputClasses } = globalClasses();
const appendedGlobalInputClasses = `${globalInputClasses} text-center`;

// Get carrier options for mobile carrier component
const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));
---

<div data-multi-step-form class={containerClass} tabindex="-1">
  <form
    id={config.formId}
    action={config.formAction}
    method={config.formMethod || "post"}
    class={config.progressBar ? "" : ""}
  >
    {
      config.steps.map((step) => (
        <div
          class="step-content space-y-6 sm:space-y-8 md:space-y-10 lg:space-y-12"
          data-step={step.stepNumber}
          data-hide-progress-bar={step.hideProgressBar ? "true" : "false"}
          tabindex="-1"
        >
          {/* Step Header */}
          {/* {step.showIcon && step.icon && (
                <div
                  class="mx-auto mb-4 flex h-16 w-16 sm:h-20 sm:w-20 items-center justify-center rounded-full bg-primary-100 dark:bg-primary-900/30"
                  tabindex="-1"
                >
                  <SimpleIcon
                    name={step.icon}
                    size="xl"
                    class="text-primary-600 dark:text-primary-400"
                  />
                </div>
              )} */}
          {step.title && (
            <div class="title-scroll-container relative" tabindex="-1">
              <div class="title-scroll-fade-top" />
              <div class="title-scroll-wrapper" tabindex="-1">
                <h2
                  class={`inline text-2xl sm:text-3xl lg:text-4xl text-gray-900 dark:text-white ${
                    step.effect === "typewriter" || !step.effect ? "typewriter-text" : ""
                  }`}
                  data-text={step.title}
                  set:html={step.title}
                  tabindex="-1"
                />
              </div>
            </div>
          )}
          {step.subtitle && (
            <p
              class="mt-2 sm:mt-3 text-sm sm:text-base text-gray-600 dark:text-gray-400 max-w-md"
              tabindex="-1"
            >
              {step.subtitle}
            </p>
          )}

          {/* Auth Providers (for registration and login forms) - at top */}
          {(step.additionalContent === "google-oauth" ||
            step.additionalContent === "auth-providers") && (
            <>
              <div class="" tabindex="-1">
                <AuthProviders
                  mode={step.additionalContent === "auth-providers" ? "login" : "register"}
                />
              </div>
              <div class="flex items-center gap-4 pb-4" tabindex="-1">
                <div class="flex-1 h-px bg-zinc-300 dark:bg-zinc-600" />
                <span class="text-xs text-zinc-500 dark:text-zinc-400 uppercase">
                  {step.additionalContent === "auth-providers"
                    ? "or login with email"
                    : "or register with email"}
                </span>
                <div class="flex-1 h-px bg-zinc-300 dark:bg-zinc-600" />
              </div>
            </>
          )}

          {/* Step Fields */}
          {step.isReview ? (
            // Review step - show summary
            <div
              class="space-y-4 rounded-lg border border-gray-200 p-8 dark:border-gray-700 color-background"
              tabindex="-1"
            >
              {step.reviewFields?.map((fieldName) => (
                <div
                  class="flex items-start justify-between border-b border-gray-200 pb-2 dark:border-gray-700 last:border-b-0"
                  tabindex="-1"
                >
                  <div tabindex="-1">
                    <p class="text-sm text-gray-600 dark:text-gray-400 capitalize" tabindex="-1">
                      {fieldName.replace(/([A-Z])/g, " $1").trim()}
                    </p>
                    <p
                      id={`review-${fieldName}`}
                      class="text-lg font-medium text-gray-900 dark:text-white"
                      tabindex="-1"
                    >
                      {fieldName === "password" ? "••••••" : "-"}
                    </p>
                  </div>
                  <button
                    type="button"
                    class="edit-step text-sm font-medium text-primary-600 hover:text-primary-700 dark:text-primary-400"
                    data-edit={
                      config.steps.findIndex((s) => s.fields.some((f) => f.name === fieldName)) + 1
                    }
                  >
                    Edit
                  </button>
                </div>
              ))}
            </div>
          ) : (
            <div
              class:list={[
                step.fieldLayout === "grid" ? "grid grid-cols-2 gap-3 md:grid-cols-2 md:gap-6" : "",
              ]}
              tabindex="-1"
            >
              {step.fields.map((field) => (
                <div
                  class:list={[
                    field.type === "hidden" ? "" : "input-wrapper",
                    field.columns === 1 ? "md:col-span-2" : "",
                  ]}
                  data-conditional-field={field.conditional ? field.conditional.field : undefined}
                  data-conditional-value={
                    field.conditional
                      ? Array.isArray(field.conditional.value)
                        ? field.conditional.value.join(",")
                        : field.conditional.value
                      : undefined
                  }
                  style={field.conditional ? "display: none;" : undefined}
                  tabindex="-1"
                >
                  {field.type === "component" && field.component === "SlotMachineModalStaff" ? (
                    <SlotMachineModalStaff
                      id={field.id}
                      name={field.name}
                      title={field.label || "Select an option"}
                      options={mobileCarrierOptions}
                      selectedValue=""
                      globalInputClasses={appendedGlobalInputClasses}
                      {...field.componentProps}
                    />
                  ) : field.type === "component" && field.component === "SlideToggle" ? (
                    <div class="flex items-center justify-center py-8" tabindex="-1">
                      <SlideToggle id={field.id} name={field.name} {...field.componentProps} />
                    </div>
                  ) : field.type === "component" && field.component === "InlineAddressSearch" ? (
                    <InlineAddressSearch
                      id={field.id}
                      name={field.name}
                      globalInputClasses={appendedGlobalInputClasses}
                      {...field.componentProps}
                    />
                  ) : field.type === "component" && field.component === "UnitSlider" ? (
                    <UnitSlider
                      name={field.name}
                      label={field.label || field.name}
                      value={Number(field.value) || 1}
                      required={field.required}
                      min={field.min}
                      max={field.max}
                      step={field.step}
                      {...field.componentProps}
                    />
                  ) : field.type === "component" && field.component === "ToggleButton" ? (
                    <div class="flex flex-wrap gap-3" tabindex="-1">
                      {field.options?.map((option) => (
                        <ToggleButton
                          value={option.value}
                          group={field.name}
                          type={field.toggleType || "radio"}
                          class={field.classes}
                        >
                          {option.label}
                        </ToggleButton>
                      ))}
                    </div>
                  ) : field.type === "component" && field.component === "FileUpload" ? (
                    <FileUpload
                      name={field.name}
                      label={field.label}
                      required={field.required}
                      accept={field.accept}
                      multiple={field.multiple}
                      maxFiles={field.maxFiles}
                      maxSize={field.maxSize}
                      {...field.componentProps}
                    />
                  ) : field.type === "range" ? (
                    <UnitSlider
                      name={field.name}
                      label={field.label || field.name}
                      value={Number(field.value) || Number(field.min) || 0}
                      required={field.required}
                      min={field.min || 0}
                      max={field.max || 100}
                      step={field.step || 1}
                    />
                  ) : field.type === "textarea" ? (
                    <textarea
                      id={field.id}
                      name={field.name}
                      placeholder={field.placeholder}
                      required={field.required}
                      rows={field.rows || 4}
                      autocomplete={field.autocomplete}
                      class={appendedGlobalInputClasses}
                      data-error={field.errorMessage}
                    />
                  ) : field.animatedPlaceholders && field.animatedPlaceholders.length > 0 ? (
                    <div
                      class:list={[
                        "relative",
                        field.icon ? "input-with-icon" : "",
                        field.iconPosition === "right" ? "icon-right" : "icon-left",
                      ]}
                      data-icon={field.icon}
                      tabindex="-1"
                    >
                      <input
                        type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                        id={field.id}
                        name={field.name}
                        placeholder=""
                        required={field.required}
                        autocomplete={field.autocomplete}
                        minlength={field.minlength}
                        autofocus={field.autofocus}
                        class:list={[
                          appendedGlobalInputClasses,
                          field.icon && field.iconPosition === "right" ? "pr-12" : "",
                          field.icon && field.iconPosition !== "right" ? "pl-12" : "",
                        ]}
                        data-error={field.errorMessage}
                        data-has-animated-placeholder="true"
                        data-original-placeholder={field.placeholder}
                        data-animated-placeholders={JSON.stringify(field.animatedPlaceholders)}
                      />
                      <span
                        class:list={[
                          "animated-placeholder absolute left-0 top-0 flex items-center justify-center w-full h-full pointer-events-none text-gray-400 dark:text-gray-500",
                          field.icon && field.iconPosition === "right" ? "pr-7 mr-1.25" : "",
                          field.icon && field.iconPosition !== "right" ? "pl-7 ml-1.25" : "",
                        ]}
                        data-for={field.id}
                        tabindex="-1"
                      >
                        {field.placeholder}
                      </span>
                    </div>
                  ) : field.type === "button-group" ? (
                    <div class="flex flex-wrap gap-3" tabindex="-1">
                      {field.buttons?.map((button) => {
                        const btnConfig = getButtonConfig(
                          button,
                          config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                        );
                        return (
                          <Button
                            id={button.id}
                            variant={btnConfig.variant}
                            size="sm"
                            icon={btnConfig.icon}
                            iconPosition={btnConfig.iconPosition}
                            class={btnConfig.classes}
                            dataAttributes={{
                              ...(button.dataValue && { "data-value": button.dataValue }),
                              ...(button.dataNext !== undefined && {
                                "data-next": button.dataNext.toString(),
                              }),
                            }}
                          >
                            {btnConfig.label && (
                              <span class="button-text">
                                <Fragment set:html={btnConfig.label} />
                              </span>
                            )}
                          </Button>
                        );
                      })}
                    </div>
                  ) : field.icon ? (
                    <div
                      class:list={[
                        "relative input-with-icon",
                        field.iconPosition === "right" ? "icon-right" : "icon-left",
                      ]}
                      data-icon={field.icon}
                      tabindex="-1"
                    >
                      <input
                        type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                        id={field.id}
                        name={field.name}
                        placeholder={field.placeholder}
                        required={field.required}
                        autocomplete={field.autocomplete}
                        minlength={field.minlength}
                        autofocus={field.autofocus}
                        class:list={[
                          appendedGlobalInputClasses,
                          field.iconPosition === "right" ? "pr-12 pl-12" : "pl-12 pr-12",
                        ]}
                        data-error={field.errorMessage}
                      />
                    </div>
                  ) : (
                    <input
                      type={field.type as "text" | "email" | "tel" | "password" | "hidden"}
                      id={field.id}
                      name={field.name}
                      placeholder={field.placeholder}
                      required={field.required}
                      autocomplete={field.autocomplete}
                      minlength={field.minlength}
                      autofocus={field.autofocus}
                      class={appendedGlobalInputClasses}
                      data-error={field.errorMessage}
                    />
                  )}
                </div>
              ))}
            </div>
          )}

          {/* Step Buttons */}
          {/* Choice buttons (radio-style options) */}
          {step.buttons.some((b) => b.type === "choice") && (
            <div
              class={`flex ${step.buttons.some((b) => b.type === "choice" && b.classes?.includes("w-full")) ? "flex-col" : "justify-center flex-wrap"} gap-3 mb-6`}
              tabindex="-1"
            >
              {step.buttons
                .filter((button) => button.type === "choice")
                .map((button) => {
                  const btnConfig = getButtonConfig(
                    button,
                    config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                  );

                  return (
                    <Button
                      id={button.id}
                      type="button"
                      variant={btnConfig.variant || "outline"}
                      size={"sm"}
                      class={`${button.type}-step sms-choice ${button.classes || ""}`}
                      disabled={button.disabled}
                      dataAttributes={{
                        ...(button.dataNext !== undefined && {
                          "data-next": button.dataNext.toString(),
                        }),
                        ...(button.dataValue !== undefined && { "data-value": button.dataValue }),
                        ...(button.dataValue !== undefined && {
                          "data-sms-value": button.dataValue,
                        }), // Keep for backward compatibility with SMS
                      }}
                    >
                      {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                    </Button>
                  );
                })}
            </div>
          )}

          {/* Navigation buttons (prev, next, submit, skip) */}
          <div
            class:list={[
              "flex",
              "gap-3",
              step.buttons.filter((b) => b.type !== "choice").length === 1
                ? "justify-end"
                : "justify-between",
            ]}
          >
            {step.buttons
              .filter((button) => button.type !== "choice")
              .map((button) => {
                const btnConfig = getButtonConfig(
                  button,
                  config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                );

                return button.href ? (
                  <Button
                    id={button.id}
                    variant={btnConfig.variant}
                    size="sm"
                    icon={btnConfig.icon}
                    iconPosition={btnConfig.iconPosition}
                    href={button.href}
                    class={`${button.type}-step ${button.classes || ""}`}
                    disabled={button.disabled}
                  >
                    {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                  </Button>
                ) : (
                  <Button
                    id={button.id}
                    variant={btnConfig.variant}
                    size="sm"
                    icon={btnConfig.icon}
                    iconPosition={btnConfig.iconPosition}
                    type="button"
                    class={`${button.type}-step ${button.classes || ""} ${button.validLabel ? "has-valid-state" : ""}`}
                    disabled={button.disabled}
                    dataAttributes={{
                      ...(button.dataNext !== undefined && {
                        "data-next": button.dataNext.toString(),
                      }),
                      ...(button.dataPrev !== undefined && {
                        "data-prev": button.dataPrev.toString(),
                      }),
                      ...(button.label && {
                        "data-default-label": button.label,
                      }),
                      ...(button.validLabel && {
                        "data-valid-label": button.validLabel,
                      }),
                    }}
                  >
                    {btnConfig.label &&
                      (btnConfig.label === "back" ? (
                        <span class="hidden sm:inline">
                          <Fragment set:html={btnConfig.label} />
                        </span>
                      ) : (
                        <span class="button-text">
                          <Fragment set:html={btnConfig.label} />
                        </span>
                      ))}
                    {/* Valid state checkmark icon (hidden by default, shown when valid) */}
                    {button.validLabel && btnConfig.iconPosition === "right" && (
                      <SimpleIcon
                        name="check"
                        size={
                          btnConfig.size === "lg" ? "lg" : btnConfig.size === "xl" ? "xl" : "md"
                        }
                        class="ml-2 icon-valid hidden"
                      />
                    )}
                  </Button>
                );
              })}
          </div>
        </div>
      ))
    }

    {/* Hidden Fields */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={field.value} />
      ))
    }
  </form>
</div>

<!-- Advanced Stepper - Fixed to bottom (outside of container to avoid flex interference) -->
{
  config.progressBar && (
    <div
      id={`${config.formId}-progress-bar`}
      class="fixed bottom-0 left-0 right-0 z-40 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700 py-4 px-4 transition-opacity duration-300"
      tabindex="-1"
    >
      <div class="w-[90vw] sm:w-[85vw] md:w-[80vw] lg:w-[75vw] max-w-6xl mx-auto" tabindex="-1">
        <ol class="flex items-center w-full" id={`${config.formId}-stepper`} tabindex="-1">
          {config.steps
            .filter((step) => !step.hideProgressBar)
            .map((step, index, filteredSteps) => (
              <li
                class={`relative flex items-center ${index < filteredSteps.length - 1 ? "w-full" : ""}`}
                data-step-indicator={step.stepNumber}
                tabindex="-1"
              >
                {/* Step Circle/Icon with Tooltip */}
                <Tooltip text={step.title} position="top" mobileClickable={true} html={true}>
                  <span
                    class="relative step-indicator flex items-center justify-center w-3 h-3 sm:w-4 sm:h-4 rounded-full shrink-0 transition-all duration-300 bg-gray-300 dark:bg-gray-700"
                    data-step-title={step.title}
                    tabindex="-1"
                  />
                </Tooltip>

                {/* Connecting Line */}
                {index < filteredSteps.length - 1 && (
                  <div
                    class="w-full h-1 mx-2 bg-transparent dark:bg-transparent rounded-full overflow-hidden"
                    tabindex="-1"
                  >
                    <div
                      class="h-full bg-transparent dark:bg-transparent transition-all duration-500 ease-out step-progress-line"
                      style="width: 0%"
                      tabindex="-1"
                    />
                  </div>
                )}
              </li>
            ))}
        </ol>
      </div>
    </div>
  )
}

<style is:global>
  /* Title scroll container with max height */
  .title-scroll-container {
    position: relative;
    max-height: 400px;
    overflow: hidden;
    margin-bottom: 1rem;
    display: flex;
    flex-direction: column;
  }

  .title-scroll-wrapper {
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
    scroll-behavior: smooth;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    flex: 1;
    /* Hide scrollbar but keep functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
  }

  /* When content overflows, switch to normal alignment */
  .title-scroll-wrapper.has-overflow {
    justify-content: flex-start;
  }

  .title-scroll-wrapper::-webkit-scrollbar {
    display: none; /* Chrome/Safari/Opera */
  }

  /* Fade out gradient at top */
  .title-scroll-fade-top {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: linear-gradient(to bottom, var(--scroll-fade-color) 0%, transparent 100%);
    pointer-events: none;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  /* Show fade when scrolled */
  .title-scroll-container.is-scrolled .title-scroll-fade-top {
    opacity: 1;
  }

  /* Color variables for fade gradient */
  :root {
    --scroll-fade-color: rgba(255, 255, 255, 0.95);
  }

  .dark {
    --scroll-fade-color: rgba(17, 24, 39, 0.95);
  }

  /* Content reveal animation after typewriter completes */
  .step-content .input-wrapper,
  .step-content .inline-address-search-wrapper,
  .step-content button,
  .step-content a {
    opacity: 0;
    transform: translateY(20px);
    transition:
      opacity 0.4s ease-out,
      transform 0.4s ease-out;
  }

  /* When typewriter completes, reveal content */
  .step-content.typewriter-complete .input-wrapper,
  .step-content.typewriter-complete .inline-address-search-wrapper,
  .step-content.typewriter-complete button,
  .step-content.typewriter-complete a {
    opacity: 1;
    transform: translateY(0);
  }

  /* For steps without typewriter effect, show content immediately */
  .step-content:not(.has-typewriter) .input-wrapper,
  .step-content:not(.has-typewriter) .inline-address-search-wrapper,
  .step-content:not(.has-typewriter) button,
  .step-content:not(.has-typewriter) a {
    opacity: 1;
    transform: translateY(0);
  }

  /* Focus shadow animation - global so it works across all components */
  input:not([type="hidden"]),
  textarea,
  select {
    transition: box-shadow 250ms ease-in-out;
  }

  input:not([type="hidden"]):focus,
  textarea:focus,
  select:focus {
    box-shadow:
      0 4px 6px -1px color-mix(in srgb, var(--color-primary-500) 10%, transparent),
      0 2px 4px -2px color-mix(in srgb, var(--color-primary-500) 10%, transparent) !important;
  }

  /* Auto-filled fields get same shadow as focused fields */
  input:not([type="hidden"]):-webkit-autofill,
  textarea:-webkit-autofill,
  select:-webkit-autofill {
    box-shadow:
      0 4px 6px -1px color-mix(in srgb, var(--color-primary-500) 10%, transparent),
      0 2px 4px -2px color-mix(in srgb, var(--color-primary-500) 10%, transparent) !important;
  }

  /* Valid fields get same shadow as focused fields */
  input:not([type="hidden"]):valid:not(:placeholder-shown),
  textarea:valid:not(:placeholder-shown),
  select:valid:not(:placeholder-shown) {
    box-shadow:
      0 4px 6px -1px color-mix(in srgb, var(--color-primary-500) 10%, transparent),
      0 2px 4px -2px color-mix(in srgb, var(--color-primary-500) 10%, transparent) !important;
  }
</style>

<style>
  .step-content {
    display: none;
  }

  .step-content.active {
    display: block;
  }

  /* Step indicator states */
  .step-indicator {
    background-color: rgb(209 213 219); /* gray-300 */
  }

  .dark .step-indicator {
    background-color: rgb(55 65 81); /* gray-700 */
  }

  .step-indicator.active {
    background-color: var(--color-secondary-400);
    animation: pulse 2s infinite;
  }

  .dark .step-indicator.active {
    background-color: var(--color-secondary-600);
    animation: pulse 2s infinite;
  }

  .step-indicator.completed {
    background-color: var(--color-success-500);
  }

  .dark .step-indicator.completed {
    background-color: var(--color-success-600);
  }

  #multi-step-contact-form {
    width: 80dvw;
    max-width: 680px;
  }

  /* Button icon state management for validation feedback */
  button.has-valid-state .icon-valid {
    display: none;
  }

  button.has-valid-state.is-valid .icon-default {
    display: none;
  }

  button.has-valid-state.is-valid .icon-valid {
    display: inline-block;
    animation: iconSwapIn 300ms ease-out;
  }

  /* Icon swap animations */
  @keyframes iconSwapIn {
    0% {
      transform: scale(0) rotate(-90deg);
      opacity: 0;
    }
    50% {
      transform: scale(1.2) rotate(0deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
    }
  }
</style>

<script define:vars={{ formId: config.formId, formConfig: config, initialData }}>
  // Store config in window for the module script to access
  window[`${formId}_config`] = {
    formId,
    formConfig,
    initialData,
  };
</script>

<script>
  import { initializeMultiStepForm } from "../../lib/multi-step-form-handler";
  import "../../scripts/typewriter-text";

  document.addEventListener("DOMContentLoaded", () => {
    // Listen for typewriter completion to trigger content animations
    document.addEventListener("typewriter-complete", (e) => {
      const target = e.target as HTMLElement;
      const stepContent = target.closest(".step-content");
      if (stepContent) {
        console.log("[MULTISTEP-FORM] Typewriter complete, revealing content");

        // Collect all animatable elements in DOM order
        const elements: HTMLElement[] = [];

        // Get all input wrappers and address search wrappers
        const inputWrappers = stepContent.querySelectorAll(
          ".input-wrapper, .inline-address-search-wrapper"
        );
        inputWrappers.forEach((el) => elements.push(el as HTMLElement));

        // Get all buttons and anchors (both choice buttons and navigation buttons)
        const buttons = stepContent.querySelectorAll("button, a");
        buttons.forEach((el) => elements.push(el as HTMLElement));

        // Apply staggered delays (100ms between each)
        elements.forEach((element, index) => {
          const delay = index * 0.1; // 100ms = 0.1s
          element.style.transitionDelay = `${delay}s`;
          console.log(`[ANIMATION] Element ${index + 1}: ${delay}s delay`);
        });

        // Add the class to trigger animations
        stepContent.classList.add("typewriter-complete");
      }
    });

    // Mark steps with typewriter effect
    document.querySelectorAll(".step-content").forEach((step) => {
      const hasTypewriter = step.querySelector(".typewriter-text");
      if (hasTypewriter) {
        step.classList.add("has-typewriter");
      }
    });

    // Initialize rotating placeholders for all inputs with animated placeholders
    const animatedInputs = document.querySelectorAll(
      'input[data-has-animated-placeholder="true"]'
    ) as NodeListOf<HTMLInputElement>;

    // Store placeholder data for each field
    const placeholderData = new Map<
      string,
      { index: number; values: string[]; syncGroup?: string }
    >();

    // Initialize placeholder data for each input
    animatedInputs.forEach((input) => {
      const placeholders = input.getAttribute("data-animated-placeholders");
      const fieldId = input.id;

      if (placeholders) {
        try {
          const values = JSON.parse(placeholders);
          // Determine sync group based on field name (firstName and lastName should sync)
          const fieldName = input.name;
          let syncGroup: string | undefined = undefined;

          // Group firstName and lastName together
          if (fieldName === "firstName" || fieldName === "lastName") {
            // Find the step container to create a step-specific sync group
            const stepContent = input.closest(".step-content");
            const stepNumber = stepContent?.getAttribute("data-step");
            syncGroup = `name-step-${stepNumber}`;
          }

          placeholderData.set(fieldId, { index: 0, values, syncGroup });
          console.log(
            `[ANIMATED-PLACEHOLDER] Initialized ${fieldId} with ${values.length} placeholders${syncGroup ? ` (sync group: ${syncGroup})` : ""}`
          );
        } catch (e) {
          console.error(`[ANIMATED-PLACEHOLDER] Failed to parse placeholders for ${fieldId}:`, e);
        }
      }
    });

    // Hide placeholder spans when input has value
    animatedInputs.forEach((input) => {
      const span = document.querySelector(
        `.animated-placeholder[data-for="${input.id}"]`
      ) as HTMLElement;
      if (span) {
        // Helper function to check and hide/show placeholder
        const checkAndHidePlaceholder = () => {
          if (input.value) {
            span.style.display = "none";
            console.log(`[ANIMATED-PLACEHOLDER] Hiding placeholder for ${input.id} (has value)`);
          } else {
            span.style.display = "flex";
          }
        };

        // Listen for manual input changes
        input.addEventListener("input", checkAndHidePlaceholder);

        // Listen for autofill detection via CSS animation
        input.addEventListener("animationstart", (e: AnimationEvent) => {
          if (e.animationName === "onAutoFillStart") {
            console.log(`[ANIMATED-PLACEHOLDER] Autofill detected for ${input.id}`);
            checkAndHidePlaceholder();
          }
        });

        // Check initial value immediately
        checkAndHidePlaceholder();

        // Delayed checks for autofill (fallback for browsers that don't support animation detection)
        setTimeout(checkAndHidePlaceholder, 100);
        setTimeout(checkAndHidePlaceholder, 500);
      }
    });

    function rotatePlaceholders() {
      // Find the active step to determine which inputs are visible
      const activeStep = document.querySelector(".step-content.active");

      // Track which sync groups have been processed to keep them in sync
      const processedSyncGroups = new Set<string>();

      animatedInputs.forEach((input, index) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        if (span && data && !input.value && span.style.display !== "none") {
          // Check if this input is in the active step
          const isInActiveStep = activeStep?.contains(input);

          if (!isInActiveStep) return;

          // Find the index of this input within the active step
          const activeStepInputs = Array.from(
            activeStep.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);

          // If this field is part of a sync group, check if we've already processed it
          if (data.syncGroup) {
            if (processedSyncGroups.has(data.syncGroup)) {
              // Already processed by another field in the group, skip individual processing
              return;
            }
            // Mark this sync group as processed
            processedSyncGroups.add(data.syncGroup);

            // Find all fields in the same sync group
            const syncedFields = Array.from(placeholderData.entries())
              .filter(([_, d]) => d.syncGroup === data.syncGroup)
              .map(([id, _]) => id);

            // ⚠️ PROTECTED CODE - DO NOT ADD STAGGER DELAY HERE ⚠️
            // Synced fields (like firstName/lastName) must animate together simultaneously
            // See: .cursor/rules/multistep-form-placeholder-stagger.md
            // Rotate all synced fields together with NO stagger (they happen simultaneously)
            syncedFields.forEach((syncedFieldId) => {
              const syncedInput = document.getElementById(syncedFieldId) as HTMLInputElement;
              const syncedSpan = document.querySelector(
                `.animated-placeholder[data-for="${syncedFieldId}"]`
              ) as HTMLElement;
              const syncedData = placeholderData.get(syncedFieldId);

              if (
                syncedSpan &&
                syncedData &&
                !syncedInput?.value &&
                syncedSpan.style.display !== "none"
              ) {
                // No stagger delay - all synced fields animate together
                syncedSpan.style.animation = "slideOutDown 400ms ease-out forwards";

                setTimeout(() => {
                  syncedData.index = (syncedData.index + 1) % syncedData.values.length;
                  syncedSpan.textContent = syncedData.values[syncedData.index];
                  syncedSpan.style.animation = "slideInDown 400ms ease-out forwards";
                }, 400);
              }
            });
          } else {
            // ⚠️ PROTECTED CODE - DO NOT REMOVE ⚠️
            // This stagger delay creates a cascading animation effect for successive placeholders.
            // See: .cursor/rules/multistep-form-placeholder-stagger.md
            // See: markdowns/animated-placeholder-stagger-delay.md
            // Not part of a sync group, use normal staggered delay
            const staggerDelay = stepIndex * 100;

            console.log(`[ROTATE-PLACEHOLDER] ${fieldId}: stepIndex=${stepIndex}, staggerDelay=${staggerDelay}ms`);

            // Apply delay via CSS animation-delay for better visual stagger
            span.style.animationDelay = `${staggerDelay}ms`;
            span.style.animation = "slideOutDown 400ms ease-out forwards";
            console.log(`[ROTATE-PLACEHOLDER] Starting slideOut for ${fieldId} with ${staggerDelay}ms CSS delay`);

            setTimeout(() => {
              data.index = (data.index + 1) % data.values.length;
              span.textContent = data.values[data.index];
              span.style.animationDelay = "0ms"; // Reset delay for slideIn
              span.style.animation = "slideInDown 400ms ease-out forwards";
              console.log(`[ROTATE-PLACEHOLDER] Starting slideIn for ${fieldId}`);
            }, 400 + staggerDelay); // Wait for slideOut animation + stagger delay
          }
        }
      });
    }

    // Reset and restart placeholder animation
    function resetPlaceholderAnimation() {
      // Find the active step to apply stagger delay correctly
      const activeStep = document.querySelector(".step-content.active");
      
      animatedInputs.forEach((input) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        if (span && data && !input.value) {
          // Check if this input is in the active step
          const isInActiveStep = activeStep?.contains(input);
          
          if (!isInActiveStep) {
            // Not in active step, just reset without animation
            data.index = 0;
            span.textContent = data.values[0];
            return;
          }
          
          // Find the index of this input within the active step for stagger delay
          const activeStepInputs = Array.from(
            activeStep.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);
          
          // Apply stagger delay for reset animation too
          const staggerDelay = stepIndex * 100;
          
          console.log(`[RESET-PLACEHOLDER] ${fieldId}: stepIndex=${stepIndex}, staggerDelay=${staggerDelay}ms`);
          
          // Set animation with delay directly in CSS
          data.index = 0;
          span.textContent = data.values[0];
          span.style.animationDelay = `${staggerDelay}ms`;
          span.style.animation = "slideInDown 400ms ease-out forwards";
          console.log(`[RESET-PLACEHOLDER] Set animation for ${fieldId} with ${staggerDelay}ms CSS delay`);
        }
      });
    }

    // Store interval ID so we can clear it
    let placeholderInterval: ReturnType<typeof setInterval> | null = null;

    // Start placeholder rotation
    function startPlaceholderRotation() {
      // Clear any existing interval
      if (placeholderInterval) {
        clearInterval(placeholderInterval);
      }

      // Reset to first placeholder
      resetPlaceholderAnimation();

      // Start new interval
      placeholderInterval = setInterval(rotatePlaceholders, 2000);
    }

    // Rotate placeholders every 2 seconds
    if (animatedInputs.length > 0) {
      startPlaceholderRotation();

      // Watch for step changes and restart animation
      const stepObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "class") {
            const target = mutation.target as HTMLElement;
            if (target.classList.contains("active") && target.classList.contains("step-content")) {
              // Check if this step has animated placeholders
              const hasPlaceholders = target.querySelector(
                '[data-has-animated-placeholder="true"]'
              );
              if (hasPlaceholders) {
                console.log("[PLACEHOLDER] Restarting placeholder animation for active step");
                startPlaceholderRotation();
              }
            }
          }
        });
      });

      // Observe all step-content elements
      const steps = document.querySelectorAll(".step-content");
      steps.forEach((step) => {
        stepObserver.observe(step, {
          attributes: true,
          attributeFilter: ["class"],
        });
      });
    }

    // Add focus/blur shadow animation to all form inputs using event delegation
    // This works for both existing and dynamically added inputs
    // Run immediately, not waiting for DOMContentLoaded
    document.addEventListener(
      "focus",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          target &&
          (target.tagName === "INPUT" ||
            target.tagName === "TEXTAREA" ||
            target.tagName === "SELECT") &&
          (target as HTMLInputElement).type !== "hidden"
        ) {
          const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
          console.log("[FOCUS-SHADOW] Adding shadow to:", formElement.id || formElement.name);
          target.classList.add("shadow-focus");
        }
      },
      true
    );

    document.addEventListener(
      "blur",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          target &&
          (target.tagName === "INPUT" ||
            target.tagName === "TEXTAREA" ||
            target.tagName === "SELECT")
        ) {
          const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
          console.log("[FOCUS-SHADOW] Removing shadow from:", formElement.id || formElement.name);
          target.classList.remove("shadow-focus");
        }
      },
      true
    );

    // Prevent non-interactive elements from stealing focus
    // This prevents accidental taps on background elements from removing input focus
    document.addEventListener(
      "mousedown",
      (e) => {
        const target = e.target as HTMLElement;

        if (!target) return;

        // Get the currently focused element
        const focusedElement = document.activeElement as HTMLElement;

        // Check if an input/textarea/select is currently focused
        const isInputFocused =
          focusedElement &&
          (focusedElement.tagName === "INPUT" ||
            focusedElement.tagName === "TEXTAREA" ||
            focusedElement.tagName === "SELECT") &&
          (focusedElement as HTMLInputElement).type !== "hidden";

        if (!isInputFocused) return;

        // Define interactive elements that SHOULD be allowed to take focus
        const isInteractiveElement =
          target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.tagName === "SELECT" ||
          target.tagName === "BUTTON" ||
          target.tagName === "A" ||
          target.hasAttribute("contenteditable") ||
          target.closest("button") || // Check if inside a button
          target.closest("a"); // Check if inside a link

        // If clicking on a non-interactive element while an input has focus,
        // prevent focus loss
        if (!isInteractiveElement) {
          e.preventDefault();
          // Ensure focus stays on the input
          setTimeout(() => {
            focusedElement.focus();
          }, 0);
          console.log(
            "[FOCUS-LOCK] Prevented focus loss. Target:",
            target.tagName,
            target.className
          );
        }
      },
      true
    );

    // Get all form configs from window
    Object.keys(window).forEach((key) => {
      if (key.endsWith("_config")) {
        const { formId, formConfig, initialData } = window[key];
        const form = document.getElementById(formId) as HTMLFormElement;

        if (!form) {
          console.error(`[MULTISTEP-FORM] Form not found: ${formId}`);
          return;
        }

        console.log("[MULTISTEP-FORM] Initializing with data:", initialData);

        // Pre-fill form fields with initial data
        Object.entries(initialData).forEach(([key, value]) => {
          const input = form.querySelector(`[name="${key}"]`) as HTMLInputElement;
          if (input && value) {
            (input as HTMLInputElement).value = value as string;
            console.log(`[MULTISTEP-FORM] Pre-filled ${key}:`, value);

            // Hide animated placeholder if this input has one
            if (input.hasAttribute("data-has-animated-placeholder")) {
              const span = document.querySelector(
                `.animated-placeholder[data-for="${input.id}"]`
              ) as HTMLElement;
              if (span) {
                span.style.display = "none";
                console.log(`[MULTISTEP-FORM] Hid animated placeholder for ${key}`);
              }
            }
          }
        });

        // Initialize the form with skip logic
        initializeMultiStepForm(form, {
          initialData,
          formConfig,
        });
      }
    });
  });

  // Forgot password modal handler (for login form)
  // Only initialize if we're on the login form
  if (document.getElementById("multi-step-login-form")) {
    const forgotPasswordBtn = document.getElementById("forgot-password-btn");

    // Modal open/close functionality
    async function openForgotPasswordModal() {
      try {
        const headers = new Headers();
        const globalInputClasses =
          document.querySelector('input:not([type="hidden"])')?.className || "";
        headers.set("x-global-input-classes", globalInputClasses);

        const response = await fetch("/partials/forgot-password-form", {
          headers: headers,
        });

        if (!response.ok) {
          console.error("Failed to fetch forgot password form partial:", response.status);
          return;
        }

        const formHTML = await response.text();

        const modalId = await (window as any).showNotice({
          type: "",
          title: "Forgot Password",
          message: formHTML,
          modal: true,
        });

        // Set up cancel button handler and focus email input when modal opens
        setTimeout(() => {
          const emailInput = document.querySelector(
            '#forgot-password-form input[name="email"]'
          ) as HTMLInputElement;
          emailInput?.focus();

          // Add cancel button click handler
          const cancelBtn = document.getElementById("cancel-forgot");
          if (cancelBtn) {
            cancelBtn.addEventListener("click", () => {
              if ((window as any).toastNotificationManager && modalId) {
                (window as any).toastNotificationManager.hide(modalId);
              }
            });
          }
        }, 100);
      } catch (error) {
        console.error("Failed to load forgot password form:", error);
        alert("Failed to load password reset form. Please try again.");
      }
    }

    // Event listeners for modal
    forgotPasswordBtn?.addEventListener("click", (e) => {
      e.preventDefault();
      openForgotPasswordModal();
    });

    // Handle form submission using event delegation (since form will be in modal)
    document.addEventListener("submit", async (e) => {
      const target = e.target as HTMLFormElement;
      if (target.id === "forgot-password-form") {
        e.preventDefault();

        const emailInput = target.querySelector('input[name="email"]') as HTMLInputElement;
        const email = emailInput?.value.trim();

        if (!email) {
          if ((window as any).showNotice) {
            (window as any).showNotice({
              type: "error",
              title: "Validation Error",
              message: "Please enter your email address.",
              persist: true,
              modal: true,
            });
          }
          return;
        }

        const sendResetLinkBtn = target.querySelector('button[type="submit"]') as HTMLButtonElement;

        if (sendResetLinkBtn) {
          sendResetLinkBtn.disabled = true;
          sendResetLinkBtn.textContent = "Sending...";
        }

        try {
          const response = await fetch("/api/auth/forgot-password", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ email }),
          });

          const result = await response.json();

          if (response.ok) {
            if ((window as any).showNotice) {
              (window as any).showNotice({
                type: "success",
                title: "Reset Link Sent",
                message:
                  "If an account with that email exists, you will receive a password reset link shortly.",
                redirect: { url: "/", delay: 3500, showCountdown: true },
                modal: true,
              });
            }

            const closeBtn = document.querySelector(
              '[data-modal-hide="forgot-password-modal"]'
            ) as HTMLElement;
            if (closeBtn) closeBtn.click();
          } else {
            if ((window as any).showNotice) {
              (window as any).showNotice({
                type: "error",
                title: "Error",
                message: result.error || "Failed to send reset link. Please try again.",
                persist: true,
                modal: true,
              });
            }
          }
        } catch (error) {
          console.error("Forgot password error:", error);
          if ((window as any).showNotice) {
            (window as any).showNotice({
              type: "error",
              title: "Network Error",
              message: "Failed to send reset link. Please check your connection and try again.",
              persist: true,
              modal: true,
            });
          }
        } finally {
          if (sendResetLinkBtn) {
            sendResetLinkBtn.disabled = false;
            sendResetLinkBtn.textContent = "Send Reset Link";
          }
        }
      }
    });
  }

  // Helper function to check if all fields in current step are valid
  function checkAllFieldsValid() {
    const activeStep = document.querySelector(".step-content.active");
    if (!activeStep) {
      console.log("[FIELD-VALIDATION] No active step found");
      return false;
    }

    // Get all required inputs in the active step (not hidden)
    const requiredInputs = activeStep.querySelectorAll(
      'input[required]:not([type="hidden"]), textarea[required]'
    );

    if (requiredInputs.length === 0) {
      console.log("[FIELD-VALIDATION] No required fields in active step");
      return false;
    }

    let allValid = true;
    const fieldStates: { name: string; value: string; valid: boolean }[] = [];

    requiredInputs.forEach((input) => {
      const inputEl = input as HTMLInputElement | HTMLTextAreaElement;
      const isValid = inputEl.validity.valid && inputEl.value.length > 0;

      fieldStates.push({
        name: inputEl.name || inputEl.id,
        value: inputEl.value.substring(0, 20) + (inputEl.value.length > 20 ? "..." : ""),
        valid: isValid,
      });

      if (!isValid) {
        allValid = false;
      }
    });

    console.log("[FIELD-VALIDATION] Current step field states:", fieldStates);

    if (allValid) {
      console.log("✅ [FIELD-VALIDATION] ALL FIELDS IN PANEL ARE VALID!");
    } else {
      console.log("❌ [FIELD-VALIDATION] Some fields are invalid or empty");
    }

    return allValid;
  }

  // Add validation state classes for visual feedback
  document.addEventListener("DOMContentLoaded", () => {
    const inputs = document.querySelectorAll(
      'input[type="email"], input[type="password"], input[type="text"], input[type="tel"]'
    );

    inputs.forEach((input) => {
      // Check validity on input
      input.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;

        if (target.value.length > 0) {
          if (target.validity.valid) {
            target.classList.add("is-valid");
            target.classList.remove("is-invalid");
          } else {
            target.classList.add("is-invalid");
            target.classList.remove("is-valid");
          }
        } else {
          target.classList.remove("is-valid", "is-invalid");
        }

        // Check if all fields in panel are valid after each input
        checkAllFieldsValid();
      });

      // Check validity on blur
      input.addEventListener("blur", (e) => {
        const target = e.target as HTMLInputElement;

        if (target.value.length > 0) {
          if (target.validity.valid) {
            target.classList.add("is-valid");
            target.classList.remove("is-invalid");
          } else {
            target.classList.add("is-invalid");
            target.classList.remove("is-valid");
          }
        }

        // Check if all fields in panel are valid after blur
        checkAllFieldsValid();
      });

      // Remove invalid state on focus
      input.addEventListener("focus", (e) => {
        const target = e.target as HTMLInputElement;
        target.classList.remove("is-invalid");
      });
    });
  });
</script>

<style>
  /* Enhanced input styling with focus glow, pulse, and validation states */

  /* Base input styles with stronger focus glow */
  input[type="email"],
  input[type="password"],
  input[type="text"],
  input[type="tel"] {
    position: relative;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Create circular focus glow with pseudo-element */
  input[type="email"]:focus::before,
  input[type="password"]:focus::before,
  input[type="text"]:focus::before,
  input[type="tel"]:focus::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 75px;
    height: 75px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: radial-gradient(circle, rgba(14, 165, 233, 0.2) 0%, transparent 70%);
    mix-blend-mode: multiply;
    pointer-events: none;
    animation: pulse-circle 1s ease-in-out infinite;
    z-index: -1;
  }

  /* Focus state - subtle bottom glow + circular overlay */
  input[type="email"]:focus,
  input[type="password"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus {
    box-shadow:
      0 3px 9px -1.5px rgba(14, 165, 233, 0.15),
      0 6px 15px -3px rgba(14, 165, 233, 0.1);
  }

  :global(.dark) input[type="email"]:focus::before,
  :global(.dark) input[type="password"]:focus::before,
  :global(.dark) input[type="text"]:focus::before,
  :global(.dark) input[type="tel"]:focus::before {
    background: radial-gradient(circle, rgba(55, 185, 243, 0.25) 0%, transparent 70%);
  }

  :global(.dark) input[type="email"]:focus,
  :global(.dark) input[type="password"]:focus,
  :global(.dark) input[type="text"]:focus,
  :global(.dark) input[type="tel"]:focus {
    box-shadow:
      0 3px 9px -1.5px rgba(55, 185, 243, 0.2),
      0 6px 15px -3px rgba(55, 185, 243, 0.125);
  }

  /* Valid state - green glow from bottom with circular overlay */
  input[type="email"]:focus.is-valid::before,
  input[type="password"]:focus.is-valid::before,
  input[type="text"]:focus.is-valid::before,
  input[type="tel"]:focus.is-valid::before,
  input[type="email"].is-valid::before,
  input[type="password"].is-valid::before,
  input[type="text"].is-valid::before,
  input[type="tel"].is-valid::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 75px;
    height: 75px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: radial-gradient(circle, rgba(34, 197, 94, 0.2) 0%, transparent 70%);
    mix-blend-mode: multiply;
    pointer-events: none;
    animation: pulse-circle-green 1s ease-in-out infinite;
    z-index: -1;
  }

  input[type="email"]:focus.is-valid,
  input[type="password"]:focus.is-valid,
  input[type="text"]:focus.is-valid,
  input[type="tel"]:focus.is-valid,
  input[type="email"].is-valid,
  input[type="password"].is-valid,
  input[type="text"].is-valid,
  input[type="tel"].is-valid {
    box-shadow:
      0 3px 9px -1.5px rgba(34, 197, 94, 0.15),
      0 6px 15px -3px rgba(34, 197, 94, 0.1) !important;
  }

  :global(.dark) input[type="email"]:focus.is-valid::before,
  :global(.dark) input[type="password"]:focus.is-valid::before,
  :global(.dark) input[type="text"]:focus.is-valid::before,
  :global(.dark) input[type="tel"]:focus.is-valid::before,
  :global(.dark) input[type="email"].is-valid::before,
  :global(.dark) input[type="password"].is-valid::before,
  :global(.dark) input[type="text"].is-valid::before,
  :global(.dark) input[type="tel"].is-valid::before {
    background: radial-gradient(circle, rgba(74, 222, 128, 0.25) 0%, transparent 70%);
  }

  :global(.dark) input[type="email"]:focus.is-valid,
  :global(.dark) input[type="password"]:focus.is-valid,
  :global(.dark) input[type="text"]:focus.is-valid,
  :global(.dark) input[type="tel"]:focus.is-valid,
  :global(.dark) input[type="email"].is-valid,
  :global(.dark) input[type="password"].is-valid,
  :global(.dark) input[type="text"].is-valid,
  :global(.dark) input[type="tel"].is-valid {
    box-shadow:
      0 3px 9px -1.5px rgba(74, 222, 128, 0.2),
      0 6px 15px -3px rgba(74, 222, 128, 0.15) !important;
  }

  /* Invalid state - red/pink glow from bottom */
  input[type="email"]:invalid:not(:placeholder-shown):not(:focus),
  input[type="password"]:invalid:not(:placeholder-shown):not(:focus),
  input[type="text"]:invalid:not(:placeholder-shown):not(:focus),
  input[type="tel"]:invalid:not(:placeholder-shown):not(:focus),
  input.is-invalid:not(:focus) {
    box-shadow:
      0 3px 9px -1.5px rgba(239, 68, 68, 0.1),
      0 6px 15px -3px rgba(239, 68, 68, 0.075);
  }

  :global(.dark) input[type="email"]:invalid:not(:placeholder-shown):not(:focus),
  :global(.dark) input[type="password"]:invalid:not(:placeholder-shown):not(:focus),
  :global(.dark) input[type="text"]:invalid:not(:placeholder-shown):not(:focus),
  :global(.dark) input[type="tel"]:invalid:not(:placeholder-shown):not(:focus),
  :global(.dark) input.is-invalid:not(:focus) {
    box-shadow:
      0 3px 9px -1.5px rgba(251, 113, 133, 0.15),
      0 6px 15px -3px rgba(251, 113, 133, 0.1);
  }

  /* Autofill state - purple glow from bottom */
  input:-webkit-autofill,
  input:-webkit-autofill:hover,
  input:-webkit-autofill:focus {
    -webkit-box-shadow:
      0 3px 9px -1.5px rgba(139, 92, 246, 0.15),
      0 6px 15px -3px rgba(139, 92, 246, 0.1),
      0 0 0 1000px var(--autofill-bg) inset !important;
    box-shadow:
      0 3px 9px -1.5px rgba(139, 92, 246, 0.15),
      0 6px 15px -3px rgba(139, 92, 246, 0.1);
    -webkit-text-fill-color: var(--text-color) !important;
    transition: background-color 5000s ease-in-out 0s;
  }

  /* CSS Variables for autofill */
  :root {
    --autofill-bg: rgba(249, 250, 251, 0.9);
    --text-color: #111827;
  }

  :global(.dark) {
    --autofill-bg: rgba(17, 24, 39, 0.9);
    --text-color: #f9fafb;
  }

  /* Circular pulse animation for focus */
  @keyframes pulse-circle {
    0%,
    100% {
      width: 100px;
      height: 100px;
      opacity: 0.3;
    }
    50% {
      width: 140px;
      height: 140px;
      opacity: 0.4;
    }
  }

  /* Circular pulse animation for valid state */
  @keyframes pulse-circle-green {
    0%,
    100% {
      width: 100px;
      height: 100px;
      opacity: 0.3;
    }
    50% {
      width: 140px;
      height: 140px;
      opacity: 0.4;
    }
  }

  /* Input icon styling using ::before and ::after */
  .input-with-icon {
    position: relative;
  }

  /* Icon positioned on the left */
  .input-with-icon.icon-left::before {
    content: "";
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-50%);
    width: 1.25rem;
    height: 1.25rem;
    opacity: 0.5;
    z-index: 1;
    pointer-events: none;
    transition: opacity 0.3s ease;
    /* Icon SVG will be injected via JavaScript */
  }

  /* Icon positioned on the right */
  .input-with-icon.icon-right::after {
    content: "";
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
    width: 1.25rem;
    height: 1.25rem;
    opacity: 0.5;
    z-index: 1;
    pointer-events: none;
    transition: opacity 0.3s ease;
    /* Icon SVG will be injected via JavaScript */
  }

  /* Increase icon opacity on input focus */
  .input-with-icon:focus-within::before,
  .input-with-icon:focus-within::after {
    opacity: 0.7;
  }

  /* Dark mode icon color */
  :global(.dark) .input-with-icon::before,
  :global(.dark) .input-with-icon::after {
    filter: brightness(0.8);
  }

  :global(.dark) .input-with-icon:focus-within::before,
  :global(.dark) .input-with-icon:focus-within::after {
    filter: brightness(1);
  }
</style>

<script>
  // Inject icons into input wrappers using SimpleIcons
  import { getIcon } from "../../lib/simple-icons";

  document.addEventListener("DOMContentLoaded", () => {
    const inputWrappers = document.querySelectorAll(".input-with-icon[data-icon]");

    inputWrappers.forEach((wrapper) => {
      const iconName = wrapper.getAttribute("data-icon");
      const isRightIcon = wrapper.classList.contains("icon-right");

      if (iconName) {
        // Get icon SVG with appropriate size and color
        const iconSVG = getIcon(iconName, {
          size: 20,
          className: "text-gray-500 dark:text-gray-400",
        });

        // Create a temporary container to parse the SVG
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = iconSVG;
        const svgElement = tempDiv.firstElementChild as SVGElement;

        if (svgElement) {
          // Position the SVG
          svgElement.style.position = "absolute";
          svgElement.style[isRightIcon ? "right" : "left"] = "1rem";
          svgElement.style.top = "50%";
          svgElement.style.transform = "translateY(-50%)";
          svgElement.style.pointerEvents = "none";
          svgElement.style.zIndex = "1";
          svgElement.style.opacity = "0.5";
          svgElement.style.transition = "opacity 0.3s ease";

          // Add focus listener to increase opacity
          const input = wrapper.querySelector("input");
          if (input) {
            input.addEventListener("focus", () => {
              svgElement.style.opacity = "0.7";
            });
            input.addEventListener("blur", () => {
              svgElement.style.opacity = "0.5";
            });
          }

          // Insert the SVG into the wrapper
          wrapper.appendChild(svgElement);
        }
      }
    });
  });
</script>
