---
import SlotMachineMap from "./SlotMachineMap.astro";

interface Props {
  id: string;
  name: string;
  label: string;
  value?: string;
  placeholder?: string;
  required?: boolean;
  class?: string;
  projectStatus?: number;
}

const {
  id,
  name,
  label,
  value = "",
  placeholder = "Start typing an address...",
  required = false,
  class: className = "",
  projectStatus = 0,
} = Astro.props;

// Always render the address input (removed projectStatus restriction)
// if (projectStatus !== 0) {
//   return;
// }
---

<div class="relative custom-places-input">
  <label for={id} class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
    {label}
    {required ? " *" : ""}
  </label>

  <!-- Search Input -->
  <div class="relative mb-3">
    <input
      type="text"
      id={`${id}-search`}
      class={`places-search-input w-full rounded-md border border-gray-300 px-3 py-2.5 pr-10 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${className}`}
      placeholder={placeholder}
      autocomplete="off"
    />

    <!-- Search Button -->
    <button
      type="button"
      class="places-search-btn absolute right-2 top-1/2 transform -translate-y-1/2 p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors duration-200"
      title="Search for address"
    >
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg>
    </button>
  </div>

  <!-- Loading Indicator -->
  <div class="places-loading mb-3 hidden">
    <div class="flex items-center justify-center py-2">
      <svg class="h-4 w-4 animate-spin text-gray-400 mr-2" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"
        ></circle>
        <path
          class="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>
      <span class="text-sm text-gray-500 dark:text-gray-400">Searching for addresses...</span>
    </div>
  </div>

  <!-- Error Message -->
  <div class="places-error mb-3 text-sm text-red-600 dark:text-red-400 hidden"></div>

  <!-- Selected Address Display -->
  <div class="places-selected-container mb-3 hidden">
    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
      >Selected Address:</label
    >
    <div class="flex items-center justify-between bg-gray-50 dark:bg-gray-700 rounded-md p-3">
      <span class="places-selected-text text-sm text-gray-900 dark:text-white"></span>
      <button
        type="button"
        class="places-clear-btn text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 ml-2"
        title="Clear selection"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- Hidden input for form submission -->
  <input
    type="hidden"
    id={id}
    name={name}
    value={value}
    required={required}
    class="places-hidden-input"
  />

  <!-- Slot Machine Map Component -->
  <div class="places-slot-machine-container hidden">
    <SlotMachineMap
      id={`${id}-slot-machine`}
      title="Select Address"
      options={[]}
      selectedValue=""
      placeholder="Choose an address..."
      theme="blue"
      showCloseButton={true}
      showCancelButton={true}
      skipSaveToAPI={true}
    />
  </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // Simple approach: find the container and initialize
    const container = document.querySelector(".custom-places-input") as HTMLElement;
    if (!container) return;

    // Generate a unique ID for this component instance
    const componentId = `places-${Math.random().toString(36).substr(2, 9)}`;

    const searchInput = container.querySelector(".places-search-input") as HTMLInputElement;
    const hiddenInput = container.querySelector(".places-hidden-input") as HTMLInputElement;
    const searchBtn = container.querySelector(".places-search-btn") as HTMLButtonElement;
    const loadingIndicator = container.querySelector(".places-loading") as HTMLDivElement;
    const errorDiv = container.querySelector(".places-error") as HTMLDivElement;
    const selectedContainer = container.querySelector(
      ".places-selected-container"
    ) as HTMLDivElement;
    const selectedText = container.querySelector(".places-selected-text") as HTMLSpanElement;
    const clearBtn = container.querySelector(".places-clear-btn") as HTMLButtonElement;
    const slotMachineContainer = container.querySelector(
      ".places-slot-machine-container"
    ) as HTMLDivElement;

    if (!searchInput || !hiddenInput || !searchBtn) {
      console.error("üö® [CUSTOM-PLACES] Required elements not found");
      return;
    }

    let placesService: any = null;
    let autocompleteService: any = null;

    // Initialize Google Places services
    function initializePlacesServices() {
      if (
        typeof (window as any).google !== "undefined" &&
        (window as any).google.maps &&
        (window as any).google.maps.places
      ) {
        // Create a dummy div for PlacesService (required by Google)
        const dummyDiv = document.createElement("div");
        placesService = new (window as any).google.maps.places.PlacesService(dummyDiv);
        autocompleteService = new (window as any).google.maps.places.AutocompleteService();
        console.log("üó∫Ô∏è [CUSTOM-PLACES] Google Places services initialized");
        return true;
      }
      return false;
    }

    // Show loading state
    function showLoading() {
      loadingIndicator?.classList.remove("hidden");
      searchBtn.disabled = true;
    }

    // Hide loading state
    function hideLoading() {
      loadingIndicator?.classList.add("hidden");
      searchBtn.disabled = false;
    }

    // Show error message
    function showError(message: string) {
      if (errorDiv) {
        errorDiv.textContent = message;
        errorDiv.classList.remove("hidden");
      }
    }

    // Hide error message
    function hideError() {
      errorDiv?.classList.add("hidden");
    }

    // Show selected address
    function showSelectedAddress(address: string) {
      if (selectedText) {
        selectedText.textContent = address;
      }
      selectedContainer?.classList.remove("hidden");
    }

    // Hide selected address
    function hideSelectedAddress() {
      selectedContainer?.classList.add("hidden");
    }

    // Clear selection
    function clearSelection() {
      hiddenInput.value = "";
      searchInput.value = "";
      hideSelectedAddress();
      hideError();
    }

    // Search for places
    async function searchPlaces(query: string) {
      if (!query.trim()) {
        showError("Please enter an address to search");
        return;
      }

      if (!autocompleteService) {
        showError("Google Places service not available");
        return;
      }

      showLoading();
      hideError();

      try {
        const request = {
          input: query,
          types: ["address"],
          componentRestrictions: { country: "us" }, // Restrict to US addresses
        };

        // Use Promise to handle the callback-based API
        const predictions = await new Promise<any[]>((resolve, reject) => {
          autocompleteService!.getPlacePredictions(request, (predictions: any, status: any) => {
            if (
              status === (window as any).google?.maps?.places?.PlacesServiceStatus?.OK &&
              predictions
            ) {
              resolve(predictions);
            } else {
              reject(new Error(`Places API error: ${status}`));
            }
          });
        });

        if (predictions.length === 0) {
          showError("No addresses found. Please try a different search term.");
          return;
        }

        // Show slot machine modal with results
        showSlotMachineModal(predictions);
      } catch (error) {
        console.error("üö® [CUSTOM-PLACES] Search error:", error);
        showError("Failed to search for addresses. Please try again.");
      } finally {
        hideLoading();
      }
    }

    // Show slot machine modal with address options
    function showSlotMachineModal(predictions: any[]) {
      // Create options for slot machine
      const options = predictions.map((prediction) => ({
        value: prediction.place_id,
        label: prediction.description,
        disabled: false,
      }));

      // Update the SlotMachineMap component with new options
      const slotMachineElement = slotMachineContainer.querySelector(
        '[id$="-slot-machine"]'
      ) as HTMLElement;
      if (slotMachineElement) {
        // Trigger the slot machine modal
        slotMachineElement.click();

        // Update options dynamically (this would need to be handled by the SlotMachineMap component)
        // For now, we'll use a custom implementation
        showCustomSlotMachine(options);
      }
    }

    // Custom slot machine implementation for addresses
    function showCustomSlotMachine(
      options: Array<{ value: string; label: string; disabled: boolean }>
    ) {
      // Create modal HTML
      const modalHTML = `
        <div id="${componentId}-address-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <!-- Modal Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
              <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Select Address</h2>
              <button id="${componentId}-close-modal" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors duration-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>

            <!-- Modal Content -->
            <div class="p-6">
              <p class="text-sm text-gray-600 dark:text-gray-300 mb-4">
                Choose an address from the search results:
              </p>
              
              <!-- Slot Machine Container -->
              <div class="relative h-48 overflow-hidden border-2 border-gray-200 dark:border-gray-600 rounded-lg mb-4">
                <ul id="${componentId}-address-list" class="absolute inset-0 transition-transform duration-300 ease-out">
                  ${options
                    .map(
                      (option, index) => `
                    <li class="slot-machine-item flex items-center justify-center h-12 text-center cursor-pointer transition-all duration-200 hover:bg-blue-50 dark:hover:bg-blue-900/20" data-index="${index}" data-value="${option.value}">
                      <span class="text-sm font-medium text-gray-900 dark:text-white px-4">${option.label}</span>
                    </li>
                  `
                    )
                    .join("")}
                </ul>
              </div>

              <!-- Action Buttons -->
              <div class="flex justify-center gap-2">
                <button id="${componentId}-cancel-btn" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200">
                  Cancel
                </button>
                <button id="${componentId}-select-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md disabled:opacity-50" disabled>
                  Select
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      // Add modal to DOM
      document.body.insertAdjacentHTML("beforeend", modalHTML);
      setupSlotMachine(options);
    }

    // Set up slot machine functionality
    function setupSlotMachine(options: Array<{ value: string; label: string; disabled: boolean }>) {
      const addressList = document.getElementById(
        `${componentId}-address-list`
      ) as HTMLUListElement;
      const selectBtn = document.getElementById(`${componentId}-select-btn`) as HTMLButtonElement;
      const cancelBtn = document.getElementById(`${componentId}-cancel-btn`) as HTMLButtonElement;
      const closeBtn = document.getElementById(`${componentId}-close-modal`) as HTMLButtonElement;
      const modal = document.getElementById(`${componentId}-address-modal`) as HTMLDivElement;

      let selectedIndex = 0;
      const itemHeight = 48;

      // Center selected item
      function centerSelectedItem() {
        const containerHeight = 192;
        const centerOffset = (containerHeight - itemHeight) / 2;
        const targetY = -(selectedIndex * itemHeight) + centerOffset;
        addressList.style.transform = `translateY(${targetY}px)`;
        updateSelection();
      }

      // Update selection styling
      function updateSelection() {
        const items = addressList.querySelectorAll("li");
        items.forEach((item, index) => {
          if (index === selectedIndex) {
            item.classList.add("selected");
            item.style.cssText = `
              display: flex;
              align-items: center;
              justify-content: center;
              height: 3rem;
              text-align: center;
              color: white;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              background: linear-gradient(135deg, #3b82f6, #1d4ed8);
              border-radius: 8px;
              margin: 0 8px;
              box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            `;
            selectBtn.disabled = false;
          } else {
            item.classList.remove("selected");
            item.style.cssText = `
              display: flex;
              align-items: center;
              justify-content: center;
              height: 3rem;
              text-align: center;
              color: #111827;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.2s;
            `;
          }
        });
      }

      // Handle wheel events
      addressList.addEventListener("wheel", (e) => {
        e.preventDefault();
        const deltaY = e.deltaY;

        if (deltaY > 0) {
          selectedIndex = Math.min(selectedIndex + 1, options.length - 1);
        } else {
          selectedIndex = Math.max(selectedIndex - 1, 0);
        }

        centerSelectedItem();
      });

      // Handle click on items
      addressList.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        if (target) {
          const item = target.closest("li");
          if (item) {
            selectedIndex = parseInt(item.dataset.index || "0");
            centerSelectedItem();
          }
        }
      });

      // Handle select button
      selectBtn.addEventListener("click", () => {
        const selectedOption = options[selectedIndex];
        if (selectedOption) {
          getPlaceDetails(selectedOption.value, selectedOption.label);
        }
      });

      // Handle cancel/close buttons
      function closeModal() {
        modal?.remove();
      }

      cancelBtn?.addEventListener("click", closeModal);
      closeBtn?.addEventListener("click", closeModal);
      modal?.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });

      // Initialize
      centerSelectedItem();
    }

    // Get detailed place information
    function getPlaceDetails(placeId: string, description: string) {
      if (!placesService) {
        showError("Places service not available");
        return;
      }

      showLoading();

      const request = {
        placeId: placeId,
        fields: ["formatted_address", "geometry", "address_components"],
      };

      placesService.getDetails(request, (place: any, status: any) => {
        hideLoading();

        if (status === (window as any).google?.maps?.places?.PlacesServiceStatus?.OK && place) {
          // Update the hidden input with the selected address
          const formattedAddress = place.formatted_address || description;
          hiddenInput.value = formattedAddress;

          // Show selected address
          showSelectedAddress(formattedAddress);

          // Close the modal
          const modal = document.getElementById(`${componentId}-address-modal`);
          modal?.remove();

          // Trigger change event
          hiddenInput.dispatchEvent(new Event("change", { bubbles: true }));

          console.log("üó∫Ô∏è [CUSTOM-PLACES] Address selected:", formattedAddress);
        } else {
          showError("Failed to get address details. Please try again.");
        }
      });
    }

    // Event listeners
    searchBtn.addEventListener("click", () => {
      searchPlaces(searchInput.value);
    });

    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        searchPlaces(searchInput.value);
      }
    });

    // Auto-search as user types (with debounce)
    let searchTimeout: NodeJS.Timeout;
    searchInput.addEventListener("input", (e) => {
      const target = e.target as HTMLInputElement;
      const query = target.value.trim();

      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }

      // Hide any previous results
      hideError();

      // Only search if user has typed at least 3 characters
      if (query.length >= 3) {
        // Show loading indicator while waiting
        loadingIndicator?.classList.remove("hidden");
        searchBtn.disabled = true;

        searchTimeout = setTimeout(() => {
          searchPlaces(query);
        }, 500); // Wait 500ms after user stops typing
      } else if (query.length === 0) {
        // Clear results if input is empty
        hideSelectedAddress();
        hiddenInput.value = "";
      } else {
        // Hide loading if query is too short
        loadingIndicator?.classList.add("hidden");
        searchBtn.disabled = false;
      }
    });

    clearBtn?.addEventListener("click", clearSelection);

    // Initialize services when Google Maps is available
    if (typeof (window as any).google !== "undefined" && (window as any).google.maps) {
      initializePlacesServices();
    } else {
      // Wait for Google Maps to load via custom event
      window.addEventListener("googleMapsLoaded", () => {
        setTimeout(() => {
          if (initializePlacesServices()) {
            console.log(
              "üó∫Ô∏è [CUSTOM-PLACES] Google Places services initialized after googleMapsLoaded event"
            );
          } else {
            console.error("üö® [CUSTOM-PLACES] Failed to initialize Google Places services");
          }
        }, 100);
      });
    }
  });
</script>

<style>
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
  }

  /* Smooth transitions */
  .transition-transform {
    transition-property: transform;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 300ms;
  }
</style>
