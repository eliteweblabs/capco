---
/**
 * StandardForm - Single-page form renderer for MultiStepFormConfig
 * Accepts the same config as MultiStepForm; flattens all steps into one form.
 * Use when you want a traditional single-page form instead of step-by-step.
 *
 * Example: <StandardForm config={loginFormConfig} initialData={{ redirect: "/dashboard" }} />
 */
import type {
  MultiStepFormConfig,
  FormFieldConfig,
  FormStepConfig,
} from "../../lib/multi-step-form-config";
import { getButtonConfig } from "../../lib/multi-step-form-config";
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import AuthProviders from "./AuthProviders.astro";
import InlineAddressSearch from "./InlineAddressSearch.astro";
import UnitSlider from "./UnitSlider.astro";
import ToggleButton from "./ToggleButton.astro";
import FileUpload from "./FileUpload.astro";
import SlideToggle from "../common/SlideToggle.astro";
import SlotMachineModalStaff from "./SlotMachineModalStaff.astro";
import { SMS_UTILS } from "../../lib/sms-utils";
import { globalClasses } from "../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
}

const {
  config,
  containerClass = "min-w-sm max-w-md sm:max-w-lg md:max-w-xl lg:max-w-2xl mx-auto w-full",
  initialData = {},
} = Astro.props;

const { multiStepInputClasses } = globalClasses();
const appendedMultiStepInputClasses = multiStepInputClasses;

const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));

/** Flatten all fields from all steps (skip review steps) */
function flattenFields(steps: FormStepConfig[]): FormFieldConfig[] {
  return steps.filter((s) => !s.isReview).flatMap((s) => s.fields || []);
}

/** First step that has auth providers */
function getAuthProviderStep(steps: FormStepConfig[]): FormStepConfig | undefined {
  return steps.find(
    (s) => s.additionalContent === "google-oauth" || s.additionalContent === "auth-providers"
  );
}

/** Submit button from last step, or config default */
function getSubmitButton(config: MultiStepFormConfig) {
  const steps = config.steps.filter((s) => !s.isReview);
  const lastStep = steps[steps.length - 1];
  const submitBtn = lastStep?.buttons?.find((b) => b.type === "submit");
  const defaults = config.buttonDefaults?.submit || {};
  return getButtonConfig(submitBtn || { type: "submit", ...defaults }, defaults);
}

const allFields = flattenFields(config.steps);
const authStep = getAuthProviderStep(config.steps);
const submitConfig = getSubmitButton(config);

/** Resolve hidden field value: initialData overrides config */
function getHiddenValue(name: string): string {
  if (initialData[name] !== undefined && initialData[name] !== null) {
    return String(initialData[name]);
  }
  const fromConfig = config.hiddenFields?.find((f) => f.name === name);
  return fromConfig?.value ?? "";
}
---

<div data-standard-form class={containerClass}>
  <form
    id={config.formId}
    action={config.formAction}
    method={config.formMethod || "post"}
    class="space-y-6"
    data-form-config={JSON.stringify({ formId: config.formId, formConfig: config, initialData })}
  >
    {/* Auth providers (login/register) */}
    {
      authStep && (
        <div>
          <AuthProviders
            mode={authStep.additionalContent === "auth-providers" ? "login" : "register"}
          />
          <div class="flex items-center gap-4 pb-4">
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
            <span class="text-sm uppercase text-zinc-500 dark:text-zinc-400">
              {authStep.additionalContent === "auth-providers"
                ? "or login with email"
                : "or register with email"}
            </span>
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
          </div>
        </div>
      )
    }

    {/* Fields */}
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2 md:gap-6">
      {
        allFields.map((field) => {
          if (field.type === "hidden") {
            return (
              <input
                type="hidden"
                name={field.name}
                value={initialData[field.name] ?? field.value ?? ""}
              />
            );
          }

          const colClass = field.columns === 1 ? "md:col-span-2" : "";
          const wrapperClass = `input-wrapper w-full ${colClass}`;

          // Component types
          if (field.type === "component") {
            if (field.component === "SlotMachineModalStaff") {
              return (
                <div class={wrapperClass}>
                  <SlotMachineModalStaff
                    id={field.id}
                    name={field.name}
                    title={field.label || "Select an option"}
                    options={mobileCarrierOptions}
                    selectedValue=""
                    globalInputClasses={appendedMultiStepInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "SlideToggle") {
              return (
                <div class={`${wrapperClass} flex items-center justify-center py-4`}>
                  <SlideToggle id={field.id} name={field.name} {...field.componentProps} />
                </div>
              );
            }
            if (field.component === "InlineAddressSearch") {
              return (
                <div class={wrapperClass}>
                  <InlineAddressSearch
                    id={field.id}
                    name={field.name}
                    globalInputClasses={appendedMultiStepInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "UnitSlider") {
              return (
                <div class={wrapperClass}>
                  <UnitSlider
                    name={field.name}
                    label={field.label || field.name}
                    value={Number(field.value) || 1}
                    required={field.required}
                    min={field.min}
                    max={field.max}
                    step={field.step}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "ToggleButton") {
              return (
                <div class={`${wrapperClass} multi-step-toggle-group flex flex-wrap gap-3`}>
                  {field.options?.map((option) => (
                    <ToggleButton
                      value={option.value}
                      group={field.name}
                      type={field.toggleType || "radio"}
                      class={field.classes}
                    >
                      {option.label}
                    </ToggleButton>
                  ))}
                </div>
              );
            }
            if (field.component === "FileUpload") {
              return (
                <div class={wrapperClass}>
                  <FileUpload
                    name={field.name}
                    label={field.label}
                    required={field.required}
                    accept={field.accept}
                    multiple={field.multiple}
                    maxFiles={field.maxFiles}
                    maxSize={field.maxSize}
                    {...field.componentProps}
                  />
                </div>
              );
            }
          }

          if (field.type === "range") {
            return (
              <div class={wrapperClass}>
                <UnitSlider
                  name={field.name}
                  label={field.label || field.name}
                  value={Number(field.value) || Number(field.min) || 0}
                  required={field.required}
                  min={field.min || 0}
                  max={field.max || 100}
                  step={field.step || 1}
                />
              </div>
            );
          }

          if (field.type === "textarea") {
            return (
              <div class={wrapperClass}>
                {field.label && (
                  <label
                    for={field.id}
                    class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                  >
                    {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                  </label>
                )}
                <textarea
                  id={field.id}
                  name={field.name}
                  placeholder={field.placeholder}
                  required={field.required}
                  rows={field.rows || 4}
                  autocomplete={field.autocomplete}
                  class={appendedMultiStepInputClasses}
                  data-error={field.errorMessage}
                  data-validate={field.validate}
                  data-validate-message={field.validateMessage}
                />
              </div>
            );
          }

          {
            /* Input with animated placeholders */
          }
          if (field.animatedPlaceholders && field.animatedPlaceholders.length > 0) {
            return (
              <div
                class:list={[
                  wrapperClass,
                  "relative text-black dark:text-white",
                  field.icon ? "input-with-icon" : "",
                  field.iconPosition === "right" ? "icon-right" : "icon-left",
                ]}
                data-icon={field.icon}
              >
                <input
                  type={field.type as "text" | "email" | "tel" | "password"}
                  id={field.id}
                  name={field.name}
                  placeholder=""
                  required={field.required}
                  autocomplete={field.autocomplete}
                  minlength={field.minlength}
                  autofocus={field.autofocus}
                  class:list={[
                    appendedMultiStepInputClasses,
                    field.icon && field.iconPosition === "right" ? "pr-12" : "",
                    field.icon && field.iconPosition !== "right" ? "pl-12" : "",
                  ]}
                  data-error={field.errorMessage}
                  data-validate={field.validate}
                  data-validate-message={field.validateMessage}
                  data-has-animated-placeholder="true"
                  data-original-placeholder={field.placeholder}
                  data-animated-placeholders={JSON.stringify(field.animatedPlaceholders)}
                />
                <span
                  class:list={[
                    "animated-placeholder pointer-events-none absolute -top-0.5 left-0 flex h-full w-full items-center",
                    field.animatedPlaceholderAlignment === "left"
                      ? `justify-start ${field.icon && field.iconPosition === "left" ? "" : "pl-3"}`
                      : field.animatedPlaceholderAlignment === "right"
                        ? `justify-end ${field.icon && field.iconPosition === "right" ? "" : "pr-3"}`
                        : "justify-center",
                    field.icon && field.iconPosition === "right" ? "mr-1.25 pr-12" : "",
                    field.icon && field.iconPosition !== "right" ? "ml-1.25 pl-12" : "",
                  ]}
                  data-for={field.id}
                >
                  {field.placeholder}
                </span>
              </div>
            );
          }

          {
            /* Input with icon */
          }
          if (field.icon) {
            return (
              <div
                class:list={[
                  wrapperClass,
                  "input-with-icon relative",
                  field.iconPosition === "right" ? "icon-right" : "icon-left",
                ]}
                data-icon={field.icon}
              >
                <input
                  type={field.type as "text" | "email" | "tel" | "password"}
                  id={field.id}
                  name={field.name}
                  placeholder={field.placeholder}
                  required={field.required}
                  autocomplete={field.autocomplete}
                  minlength={field.minlength}
                  autofocus={field.autofocus}
                  class={`${appendedMultiStepInputClasses} pl-12 pr-12`}
                  data-error={field.errorMessage}
                  data-validate={field.validate}
                  data-validate-message={field.validateMessage}
                />
              </div>
            );
          }

          // Plain input
          return (
            <div class={wrapperClass}>
              {field.label && (
                <label
                  for={field.id}
                  class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                </label>
              )}
              <input
                type={field.type as "text" | "email" | "tel" | "password"}
                id={field.id}
                name={field.name}
                placeholder={field.placeholder}
                required={field.required}
                autocomplete={field.autocomplete}
                minlength={field.minlength}
                autofocus={field.autofocus}
                class={appendedMultiStepInputClasses}
                data-error={field.errorMessage}
                data-validate={field.validate}
                data-validate-message={field.validateMessage}
              />
            </div>
          );
        })
      }
    </div>

    {/* Submit button */}
    <div class="flex justify-end pt-4">
      <Button
        type="submit"
        variant={submitConfig.variant}
        size={submitConfig.size}
        icon={submitConfig.icon}
        iconPosition={submitConfig.iconPosition}
        class="submit-step"
      >
        {submitConfig.label && <span set:html={submitConfig.label} />}
      </Button>
    </div>

    {/* Hidden fields from config (initialData overrides) */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={getHiddenValue(field.name) || field.value} />
      ))
    }
  </form>
</div>
