---
interface Props {
  id: string;
  name: string;
  label: string;
  value?: string;
  placeholder?: string;
  required?: boolean;
  class?: string;
  projectStatus?: number;
}

const {
  id,
  name,
  label,
  value = "",
  placeholder = "Enter address...",
  required = false,
  class: className = "",
  projectStatus = 0,
} = Astro.props;

// Only render for projects with status 0 (new projects)
if (projectStatus !== 0) {
  return;
}
---

<div class="relative">
  <label for={id} class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
    {label}
    {required ? " *" : ""}
  </label>
  <input
    type="text"
    id={id}
    name={name}
    value={value}
    placeholder={placeholder}
    required={required}
    data-google-autocomplete
  />
  <!-- Loading indicator -->
  <div id={`${id}-loading`} class="absolute right-3 top-8 hidden">
    <svg class="h-4 w-4 animate-spin text-gray-400" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"
      ></circle>
      <path
        class="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
  </div>
</div>

<script define:vars={{ id }}>
  document.addEventListener("DOMContentLoaded", function () {
    // Initialize Google Maps Autocomplete when the API is ready
    function initializeAutocomplete() {
      const input = document.getElementById(id);
      const loadingIndicator = document.getElementById(`${id}-loading`);

      if (!input) {
        console.log("üó∫Ô∏è [GoogleAutocomplete] Input element not found:", id);
        return;
      }

      // Check if Google Maps is loaded
      if (!window.google?.maps?.places) {
        console.log("üó∫Ô∏è [GoogleAutocomplete] Google Maps not loaded, retrying in 500ms...");
        setTimeout(initializeAutocomplete, 500);
        return;
      }

      // console.log("üó∫Ô∏è [GoogleAutocomplete] Initializing for input:", id);
      // console.log("üó∫Ô∏è [GoogleAutocomplete] Google Maps API version:", window.google?.maps?.version);
      // console.log("üó∫Ô∏è [GoogleAutocomplete] Available APIs:", {
      //   maps: !!window.google?.maps,
      //   places: !!window.google?.maps?.places,
      //   autocomplete: !!window.google?.maps?.places?.Autocomplete,
      //   placeAutocompleteElement: !!window.google?.maps?.places?.PlaceAutocompleteElement,
      //   version: window.google?.maps?.version,
      // });

      // Verify API Key
      const apiKey = window.GOOGLE_MAPS_API_KEY;
      console.log("üó∫Ô∏è [GoogleAutocomplete] API Key Status:", {
        hasApiKey: !!apiKey,
        keyLength: apiKey?.length || 0,
        keyPrefix: apiKey?.substring(0, 8) + "..." || "none",
      });

      // Use the new PlaceAutocompleteElement API
      if (window.google?.maps?.places?.PlaceAutocompleteElement) {
        // console.log("üó∫Ô∏è [GoogleAutocomplete] Using new PlaceAutocompleteElement API");

        try {
          // Create autocomplete element
          const autocompleteElement = new google.maps.places.PlaceAutocompleteElement();

          // Set location bias for Boston area using LatLngBounds
          const bostonBounds = new google.maps.LatLngBounds(
            new google.maps.LatLng(41.8, -71.8), // Southwest corner
            new google.maps.LatLng(42.8, -70.2) // Northeast corner
          );
          autocompleteElement.locationBias = bostonBounds;

          // Set region code
          autocompleteElement.regionCode = "US";

          // Configure the element
          autocompleteElement.setAttribute("placeholder", input.placeholder || "Enter address...");
          autocompleteElement.setAttribute("data-google-autocomplete", "true");

          // console.log("üó∫Ô∏è [GoogleAutocomplete] New API attributes set:", {
          //   locationBias: bostonBounds,
          //   regionCode: "US",
          //   elementTagName: autocompleteElement.tagName,
          //   elementAttributes: Array.from(autocompleteElement.attributes).map(
          //     (attr) => `${attr.name}="${attr.value}"`
          //   ),
          // });

          // Verify locationBias parameter format
          // console.log("üó∫Ô∏è [GoogleAutocomplete] LocationBias Verification:", {
          //   format: "LatLngBounds object",
          //   locationBias: bostonBounds,
          //   southwest: bostonBounds.getSouthWest().toString(),
          //   northeast: bostonBounds.getNorthEast().toString(),
          //   isValid: bostonBounds && bostonBounds.getSouthWest && bostonBounds.getNorthEast,
          //   description: "Biases results toward Boston area using LatLngBounds",
          // });

          // Apply the same styling as the original input
          autocompleteElement.className = input.className;
          autocompleteElement.id = input.id;
          autocompleteElement.name = input.name;
          autocompleteElement.value = input.value;
          autocompleteElement.required = input.required;

          // Replace the original input with the new element
          input.parentNode?.replaceChild(autocompleteElement, input);

          // Update references
          const newInput = autocompleteElement;

          // Handle place selection with new API
          autocompleteElement.addEventListener("gmp-placeselect", (event) => {
            // console.log("üó∫Ô∏è [GoogleAutocomplete] Place selection event received:", event);

            const place = event.place;
            // console.log("üó∫Ô∏è [GoogleAutocomplete] Place object:", place);

            if (!place.formattedAddress) {
              console.log("üó∫Ô∏è [GoogleAutocomplete] No address details available");
              return;
            }

            // console.log("üó∫Ô∏è [GoogleAutocomplete] Place selected:", {
            //   formattedAddress: place.formattedAddress,
            //   location: place.location
            //     ? {
            //         lat: place.location.lat(),
            //         lng: place.location.lng(),
            //       }
            //     : null,
            //   addressComponents: place.addressComponents,
            //   types: place.types,
            // });

            // Update the input value
            newInput.value = place.formattedAddress;

            // Trigger change event for form handling
            newInput.dispatchEvent(new Event("change", { bubbles: true }));

            // Store additional data if needed
            newInput.dataset.placeData = JSON.stringify({
              formatted_address: place.formattedAddress,
              lat: place.location?.lat(),
              lng: place.location?.lng(),
              address_components: place.addressComponents,
            });
          });

          // Add error handling for API responses
          autocompleteElement.addEventListener("gmp-error", (event) => {
            // console.error("üó∫Ô∏è [GoogleAutocomplete] API Error:", event);
            // console.error("üó∫Ô∏è [GoogleAutocomplete] Error details:", {
            //   error: event.error,
            //   message: event.message,
            //   status: event.status,
            // });
          });

          // console.log(
          //   "üó∫Ô∏è [GoogleAutocomplete] Successfully initialized with PlaceAutocompleteElement for:",
          //   id
          // );
        } catch (error) {
          console.error("üó∫Ô∏è [GoogleAutocomplete] Error with PlaceAutocompleteElement:", error);
        }
      } else {
        console.error("üó∫Ô∏è [GoogleAutocomplete] PlaceAutocompleteElement API not available");
      }
    }

    // Start initialization
    // console.log("üó∫Ô∏è [GoogleAutocomplete] Starting initialization for input ID:", id);
    initializeAutocomplete();
  });
</script>

<style>
  /* Override Google PlaceAutocompleteElement styles to match other inputs */
  gmp-places-autocomplete {
    display: block !important;
  }

  gmp-places-autocomplete input {
    background-color: white !important;
    color: #111827 !important;
    border: 1px solid #d1d5db !important;
    border-radius: 6px !important;
    padding: 8px 12px !important;
    font-size: 14px !important;
    width: 100% !important;
    box-shadow: none !important;
    outline: none !important;
    height: auto !important;
  }

  gmp-places-autocomplete input::placeholder {
    color: #6b7280 !important;
  }

  gmp-places-autocomplete input:focus {
    border-color: #3b82f6 !important;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1) !important;
  }

  /* Dark mode styles */
  @media (prefers-color-scheme: dark) {
    gmp-places-autocomplete input {
      background-color: #374151 !important;
      color: #f9fafb !important;
      border-color: #4b5563 !important;
    }

    gmp-places-autocomplete input::placeholder {
      color: #9ca3af !important;
    }

    gmp-places-autocomplete input:focus {
      border-color: #60a5fa !important;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1) !important;
    }
  }

  /* Style the Google autocomplete dropdown */
  .pac-container {
    background-color: white;
    border-radius: 6px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    font-family: inherit;
    font-size: 14px;
    z-index: 1000;
  }

  .pac-item {
    padding: 8px 12px;
    border-bottom: 1px solid #f3f4f6;
    cursor: pointer;
    color: #111827;
  }

  .pac-item:hover {
    background-color: #f9fafb;
  }

  .pac-item:last-child {
    border-bottom: none;
  }

  .pac-item-query {
    font-weight: 500;
    color: #111827;
  }

  .pac-matched {
    font-weight: 600;
    color: #2563eb;
  }

  /* Dark mode styles */
  @media (prefers-color-scheme: dark) {
    .pac-container {
      background-color: #374151;
      border-color: #4b5563;
    }

    .pac-item {
      border-bottom-color: #4b5563;
      color: #f9fafb;
    }

    .pac-item:hover {
      background-color: #4b5563;
    }

    .pac-item-query {
      color: #f9fafb;
    }

    .pac-matched {
      color: #60a5fa;
    }
  }
</style>
