---
import Button from "../common/Button.astro";

// Generic Slot Machine Modal Component - Reusable for any picker scenario

interface Props {
  id: string; // Required: Unique identifier for this picker instance
  title: string; // Required: Modal title (e.g., "Select Status", "Choose Staff")
  options: Array<{ value: string; label: string; disabled?: boolean }>; // Required: Array of options
  selectedValue?: string; // Optional: Currently selected value
  placeholder?: string; // Optional: Placeholder text for button
  theme?: "blue" | "green" | "orange" | "red" | "purple"; // Optional: Color theme
  buttonText?: string; // Optional: Custom button text (defaults to selected label or placeholder)
  showCloseButton?: boolean; // Optional: Show X close button (default: true)
  showCancelButton?: boolean; // Optional: Show Cancel button (default: true)
  onSelect?: string; // Optional: Function name to call when item is selected
  search?: boolean; // Optional: Show search input (default: false)
  addNewOption?: boolean; // Optional: Show add new option button (default: false)
  skipSaveToAPI?: boolean; // Optional: Skip saving to API (default: false)
  name?: string; // Optional: Form field name (defaults to id)
}

const {
  id,
  title,
  options = [],
  selectedValue = "",
  placeholder = "Select an option...",
  theme = "blue",
  buttonText,
  showCloseButton = true,
  showCancelButton = true,
  onSelect = "handleSlotMachineSelect",
  search = false,
  addNewOption = false,
  skipSaveToAPI = false,
  name,
} = Astro.props;

// Ensure options is always an array
const optionsArray = Array.isArray(options) ? options : [];

// Find the selected option to get the button text
const selectedOption = optionsArray.find((option) => option.value === selectedValue);
const displayText = buttonText || selectedOption?.label || placeholder;
---

<!-- Slot Machine Picker Button -->
<Button id={id} variant="primary">
  {displayText}
  <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
  </svg>
</Button>

<!-- Hidden input to store the selected value -->
<input type="hidden" id={`${id}-value`} name={name || id} value={selectedValue} />

<script
  define:vars={{
    id,
    title,
    options: optionsArray,
    selectedValue,
    theme,
    showCloseButton,
    showCancelButton,
    onSelect,
    skipSaveToAPI,
  }}
>
  // Initialize the slot machine picker
  document.addEventListener("DOMContentLoaded", function () {
    const trigger = document.getElementById(id);
    const hiddenInput = document.getElementById(`${id}-value`);

    if (!trigger) {
      console.error(`ðŸŽ° [SLOT-MACHINE] Trigger button with ID '${id}' not found`);
      return;
    }

    // Set up click handler
    trigger.addEventListener("click", function (e) {
      e.stopPropagation();
      // // console.log(`ðŸŽ° [SLOT-MACHINE] Opening picker for ID: ${id}`);

      // Open the slot machine modal using variables directly
      showSlotMachineModal({
        id: id,
        title: title,
        options: options,
        selectedValue: selectedValue,
        theme: theme,
        showCloseButton: showCloseButton,
        showCancelButton: showCancelButton,
        onSelect: (value, label) => {
          // Update hidden input
          if (hiddenInput) {
            hiddenInput.value = value;
          }

          // Update button text
          trigger.innerHTML = `
            ${label}
            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
            </svg>
          `;

          // Call the onSelect callback if provided
          if (typeof window[onSelect] === "function") {
            window[onSelect](value, label, id);
          }

          // Auto-save to API endpoint using the component ID
          if (!skipSaveToAPI) {
            saveToAPI(id, value, label);
          }

          // // console.log(`ðŸŽ° [SLOT-MACHINE] Selected: ${label} (${value})`);
        },
      });
    });

    // Check for URL parameters to auto-open this specific picker
    function checkUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const modalParam = urlParams.get("modal");

      // console.log(`ðŸŽ° [SLOT-MACHINE] Checking URL parameters for ID '${id}':`, {
      //   modalParam,
      //   componentId: id,
      //   match: modalParam === id,
      // });

      if (modalParam === id) {
        // console.log(`ðŸŽ° [SLOT-MACHINE] URL parameter detected: modal=${id}`);

        // Wait for DOM to be ready, then trigger the picker
        setTimeout(() => {
          if (trigger) {
            // console.log(`ðŸŽ° [SLOT-MACHINE] Auto-opening picker for ID: ${id}`);
            trigger.click();

            // Clean up the URL parameter
            const newUrl = new URL(window.location);
            newUrl.searchParams.delete("modal");
            window.history.replaceState({}, "", newUrl);
            // console.log(`ðŸŽ° [SLOT-MACHINE] URL cleaned up: ${newUrl.href}`);
          } else {
            console.error(`ðŸŽ° [SLOT-MACHINE] Trigger button not found for auto-open`);
          }
        }, 100);
      }
    }

    // Check URL parameters on load
    checkUrlParameters();
  });

  // Auto-save function that uses component ID to determine API endpoint
  async function saveToAPI(componentId, value, label) {
    try {
      console.log(`ðŸŽ° [SLOT-MACHINE] Saving to API: /api/${componentId}`, { value, label });

      // Format data based on the component type
      let requestBody;

      if (componentId === "update-status") {
        // For status updates, send the format expected by update-status API
        requestBody = {
          projectId: parseInt(window.location.pathname.split("/").pop()) || null, // Get project ID from URL
          status: parseInt(value), // Convert value to integer
          currentUserId: null, // Will be handled by server-side auth
          oldStatus: null, // Could be enhanced to track previous status
        };
      } else if (componentId === "assign-staff") {
        // For staff assignment, send the format expected by update-project API
        requestBody = {
          projectId: parseInt(window.location.pathname.split("/").pop()) || null, // Get project ID from URL
          assigned_to_id: value, // Staff member ID
          assigned_to_name: label, // Staff member name
        };
      } else {
        // For other components, use generic format
        requestBody = {
          value: value,
          label: label,
          componentId: componentId,
        };
      }

      console.log(`ðŸŽ° [SLOT-MACHINE] Request body:`, requestBody, componentId);

      const response = await fetch(`/api/${componentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify(requestBody),
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`ðŸŽ° [SLOT-MACHINE] API response:`, result);

        // Show success notification
        if (result.notificationData && window.showModal) {
          const { type, title, message, duration } = result.notificationData;
          window.showModal(type, title, message, duration);
        } else if (result.success && window.showModal) {
          // Fallback success notification
          window.showModal(
            "success",
            "Success",
            result.message || "Operation completed successfully",
            3000
          );
        }

        // Also try the original notification handler if it exists
        if (window.handleUpdateStatusNotification) {
          window.handleUpdateStatusNotification(result, "SLOT-MACHINE");
        }

        // Close the modal after success
        setTimeout(() => {
          const modal = document.querySelector(`[data-modal-backdrop="${componentId}-modal"]`);
          if (modal) {
            modal.click(); // Click the backdrop to close
          }
        }, 1000);
      } else {
        const errorData = await response.json();
        console.error(`ðŸŽ° [SLOT-MACHINE] API error:`, errorData);
        throw new Error(errorData.error || `Failed to save ${componentId}`);
      }
    } catch (error) {
      console.error(`ðŸŽ° [SLOT-MACHINE] Error saving to API:`, error);

      // Show error notification if available
      if (window.showModal) {
        window.showModal("error", "Error", `Failed to save selection. Please try again.`, 5000);
      }
    }
  }

  // Generic slot machine modal function
  function showSlotMachineModal(config) {
    const {
      id,
      title,
      options,
      selectedValue,
      theme,
      showCloseButton = true,
      showCancelButton = true,
      onSelect,
    } = config;

    // Check for dynamically updated options
    const dynamicOptions = window.slotMachineOptions && window.slotMachineOptions[id];
    const finalOptions = dynamicOptions || options;

    // Use dynamic options if available, otherwise use static options

    // Create modal overlay
    const modal = document.createElement("div");
    modal.className = "fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50";
    modal.id = `${id}-modal`;

    // Create modal content
    const modalContent = document.createElement("div");
    modalContent.className =
      "bg-background-card dark:bg-background-card-dark rounded-lg p-6 max-w-sm w-full mx-4";
    modalContent.style.userSelect = "none";

    // Create title with close button
    const titleContainer = document.createElement("div");
    titleContainer.className = "relative flex items-center justify-center mb-4";

    const titleElement = document.createElement("h3");
    titleElement.className = "text-lg font-semibold text-gray-900 dark:text-white text-center";
    titleElement.textContent = title;

    titleContainer.appendChild(titleElement);

    // Add close X button if enabled
    if (showCloseButton) {
      const closeButton = document.createElement("button");
      closeButton.className = "close-button";
      closeButton.innerHTML = "Ã—";
      closeButton.style.cssText = `
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        font-size: 24px;
        font-weight: bold;
        color: #6b7280;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        min-height: 32px;
      `;

      closeButton.addEventListener("mouseenter", () => {
        closeButton.style.background = "#ef4444";
        closeButton.style.color = "white";
        closeButton.style.transform = "translateY(-50%) scale(1.1)";
      });

      closeButton.addEventListener("mouseleave", () => {
        closeButton.style.background = "transparent";
        closeButton.style.color = "#6b7280";
        closeButton.style.transform = "translateY(-50%) scale(1)";
      });

      closeButton.addEventListener("click", () => {
        cleanupModal();
        modal.remove();
      });

      titleContainer.appendChild(closeButton);
    }

    // Create slot machine container
    const slotContainer = document.createElement("div");
    slotContainer.className =
      "relative h-48 overflow-hidden border-2 border-gray-200 dark:border-gray-600 rounded-lg mb-4";

    // Create options list
    const optionsList = document.createElement("ul");
    optionsList.className = "absolute inset-0 transition-transform duration-300 ease-out";
    optionsList.style.transform = "translateY(0px)";

    // Add options
    finalOptions.forEach((option, index) => {
      const li = document.createElement("li");
      li.className = "slot-machine-item";
      li.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 3rem;
        text-align: center;
        color: #111827;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px;
        padding: 12px 16px;
        user-select: none;
        position: relative;
      `;

      const span = document.createElement("span");
      span.className = "slot-machine-item-text";
      span.style.cssText = `
        text-align: center;
        font-weight: 500;
        transition: all 0.2s;
        width: 100%;
      `;

      // Add selected styling if this is the current value
      if (option.value === selectedValue) {
        li.classList.add("selected");
        li.style.cssText += `
          background: bg-primary-500 !important;
          color: text-white !important;
          border-radius: 8px !important;
          margin: 0 8px !important;
          position: relative !important;
        `;
      }

      span.textContent = option.label;
      span.dataset.value = option.value;
      span.dataset.label = option.label;
      span.dataset.index = index;

      li.appendChild(span);
      optionsList.appendChild(li);
    });

    slotContainer.appendChild(optionsList);

    // Create action buttons
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "flex justify-center gap-2";

    // Add cancel button if enabled
    if (showCancelButton) {
      const cancelButton = document.createElement("button");
      cancelButton.className =
        "px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200";
      cancelButton.textContent = "Cancel";
      cancelButton.onclick = () => {
        cleanupModal();
        modal.remove();
      };
      buttonContainer.appendChild(cancelButton);
    }

    const selectButton = document.createElement("button");
    selectButton.className = `px-4 py-2 text-white rounded-lg disabled:opacity-50`;
    selectButton.textContent = "Select";
    selectButton.disabled = true;

    buttonContainer.appendChild(selectButton);

    // Assemble modal
    modalContent.appendChild(titleContainer);
    modalContent.appendChild(slotContainer);
    modalContent.appendChild(buttonContainer);
    modal.appendChild(modalContent);

    // Slot machine functionality
    let selectedIndex = finalOptions.findIndex(
      (option) => option.value.toString() === selectedValue.toString()
    );
    // Don't default to first item - only select if there's a valid selectedValue
    if (selectedIndex === -1) selectedIndex = -1;

    // Debug logging for selection
    // // console.log("ðŸŽ° [SLOT-MACHINE] Selection debug:", {
    //   selectedValue,
    //   selectedValueType: typeof selectedValue,
    //   options: finalOptions.map((opt) => ({
    //     value: opt.value,
    //     valueType: typeof opt.value,
    //     label: opt.label,
    //   })),
    //   selectedIndex,
    //   foundOption: finalOptions[selectedIndex],
    // });

    // Center selected item
    function centerSelectedItem() {
      // Only apply translateY if there's a valid selection
      if (selectedIndex >= 0) {
        // Use responsive item height based on screen size
        const itemHeight = window.innerWidth <= 768 ? 56 : 48;
        const containerHeight = 192;
        const centerOffset = (containerHeight - itemHeight) / 2;
        const targetY = -(selectedIndex * itemHeight) + centerOffset;

        // Use smooth transition
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = `translateY(${targetY}px)`;
      } else {
        // No selection - keep at default position
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = "translateY(0px)";
      }

      // Update centering (visual feedback only, no selection styling)
      updateCentering();
    }

    // Add checkmark to selected item
    function addCheckmark(item) {
      // Remove existing checkmark if any
      const existingCheckmark = item.querySelector(".checkmark");
      if (existingCheckmark) {
        existingCheckmark.remove();
      }

      const checkmark = document.createElement("div");
      checkmark.className = "checkmark";
      checkmark.innerHTML = "âœ“";
      checkmark.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        color: #10b981;
        font-weight: bold;
        font-size: 16px;
        animation: checkmarkPulse 1.5s ease-in-out infinite;
        z-index: 10;
      `;

      item.appendChild(checkmark);
    }

    // Remove checkmark from item
    function removeCheckmark(item) {
      const checkmark = item.querySelector(".checkmark");
      if (checkmark) {
        checkmark.remove();
      }
    }

    // Update selection styling (only for clicked items)
    function updateSelection() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        if (index === selectedIndex && selectedIndex >= 0) {
          item.classList.add("selected");
          // Reset and apply selected styles
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-radius: 8px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            border: 2px solid #1d4ed8;
          `;
          addCheckmark(item);
          selectButton.disabled = false;
        } else {
          item.classList.remove("selected");
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: #111827;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
          `;
          removeCheckmark(item);
        }
      });

      // Disable select button if no item is selected
      if (selectedIndex < 0) {
        selectButton.disabled = true;
      }
    }

    // Update visual centering (without selection styling)
    function updateCentering() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        // Only update the centering, not the selection styling
        if (index === selectedIndex && selectedIndex >= 0) {
          // Just center the item visually, don't apply selected styling
          item.style.transform = "scale(1.05)";
          item.style.transition = "transform 0.2s ease-out";
        } else {
          item.style.transform = "scale(1)";
          item.style.transition = "transform 0.2s ease-out";
        }
      });
    }

    // Handle wheel events (desktop)
    optionsList.addEventListener("wheel", (e) => {
      e.preventDefault();
      const deltaY = e.deltaY;

      // Calculate new index based on scroll direction
      if (deltaY > 0) {
        // Scrolling down - move to next item
        selectedIndex = Math.min(selectedIndex + 1, finalOptions.length - 1);
      } else {
        // Scrolling up - move to previous item
        selectedIndex = Math.max(selectedIndex - 1, 0);
      }

      // Smoothly center the selected item
      centerSelectedItem();
    });

    // Handle touch events (mobile)
    let touchStartY = 0;
    let touchStartTime = 0;
    let isScrolling = false;

    optionsList.addEventListener(
      "touchstart",
      (e) => {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isScrolling = false;
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (!isScrolling) {
          isScrolling = true;
        }
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchend",
      (e) => {
        e.preventDefault();
        if (!isScrolling) return;

        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        const deltaY = touchStartY - touchEndY;
        const deltaTime = touchEndTime - touchStartTime;

        // Only process if there was significant movement and it was quick enough
        if (Math.abs(deltaY) > 20 && deltaTime < 500) {
          if (deltaY > 0) {
            // Swiping up - move to next item
            selectedIndex = Math.min(selectedIndex + 1, finalOptions.length - 1);
          } else {
            // Swiping down - move to previous item
            selectedIndex = Math.max(selectedIndex - 1, 0);
          }

          // Smoothly center the selected item
          centerSelectedItem();
        }
      },
      { passive: false }
    );

    // Handle click on items
    optionsList.addEventListener("click", (e) => {
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on click
        updateSelection();
      }
    });

    // Handle touch on items for mobile
    optionsList.addEventListener("touchend", (e) => {
      e.preventDefault();
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on touch
        updateSelection();
      }
    });

    // Handle select button
    selectButton.addEventListener("click", () => {
      if (selectedIndex >= 0) {
        const selectedOption = finalOptions[selectedIndex];
        if (selectedOption && onSelect) {
          cleanupModal();
          modal.remove();
          onSelect(selectedOption.value, selectedOption.label);
        }
      }
    });

    // Cleanup function to restore body scroll
    function cleanupModal() {
      document.body.classList.remove("modal-open");
      document.body.style.overflow = "";
    }

    // Close modal when clicking outside
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        cleanupModal();
        modal.remove();
      }
    });

    // Initialize
    centerSelectedItem();
    // Apply selection styling to the initially selected item
    updateSelection();

    // Prevent body scroll when modal is open
    document.body.classList.add("modal-open");
    document.body.style.overflow = "hidden";

    // Add to DOM
    document.body.appendChild(modal);
  }

  // Expose function to update slot machine options dynamically
  window.updateSlotMachineOptions = function (componentId, newOptions) {
    // Store the new options for this component
    if (!window.slotMachineOptions) {
      window.slotMachineOptions = {};
    }
    window.slotMachineOptions[componentId] = newOptions;
  };
</script>

<style>
  /* Prevent body scroll when modal is open */
  body.modal-open {
    overflow: hidden !important;
    position: fixed !important;
    width: 100% !important;
  }

  /* Prevent text selection in modal */
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    touch-action: pan-y !important;
    -webkit-touch-callout: none !important;
  }

  /* Improve touch targets for mobile */
  @media (max-width: 768px) {
    .slot-machine-item {
      min-height: 56px !important;
      height: 56px !important;
      padding: 16px !important;
      font-size: 16px !important;
    }

    .slot-machine-item-text {
      font-size: 16px !important;
    }
  }

  @keyframes checkmarkPulse {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes checkmarkPulseDark {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    50% {
      opacity: 0.9;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 16px rgba(16, 185, 129, 1);
    }
  }
</style>
