---
import Button from "../common/Button.astro";
import BoxIcon from "../common/BoxIcon.astro";

// Generic Slot Machine Modal Component - Reusable for any picker scenario

interface Props {
  id: string; // Required: Unique identifier for this picker instance
  title: string; // Required: Modal title (e.g., "Select Status", "Choose Staff")
  options: Array<{ value: string; label: string; disabled?: boolean }>; // Required: Array of options
  selectedValue?: string; // Optional: Currently selected value
  placeholder?: string; // Optional: Placeholder text for button
  buttonText?: string; // Optional: Custom button text (defaults to selected label or placeholder)
  showCloseButton?: boolean; // Optional: Show X close button (default: true)
  showCancelButton?: boolean; // Optional: Show Cancel button (default: true)
  addNewOption?: boolean; // Optional: Show add new option button (default: false)
  skipSaveToAPI?: boolean; // Optional: Skip saving to API (default: false)
  name?: string; // Optional: Form field name (defaults to id)
  buttonClass?: string; // Optional: Custom button class (defaults to "")
  noResultsText?: string; // Optional: No results text (defaults to "No results found")
  // NEW FLEXIBLE PROPS:
  apiEndpoint?: string; // Optional: API endpoint for dynamic data
  searchText?: string; // Optional: Search input label (if provided, enables search)
  searchPlaceholder?: string; // Optional: Search input placeholder
  apiParams?: Record<string, any>; // Optional: Additional API parameters
  dataTransform?: string; // Optional: Function name to transform API response
  project?: any; // Optional: Project for API calls
  showImages?: boolean; // Optional: Whether to show images (for places)
  imageField?: string; // Optional: Field name for image URLs
  valueField?: string; // Optional: Field name to use for the value (default: "value")
  labelField?: string; // Optional: Field name to use for the label (default: "label")
  fetchOnLoad?: boolean; // Optional: Whether to fetch data immediately on modal open (default: false)
  projectId?: string; // Optional: Project ID for API calls
  showNotification?: boolean; // Optional: Whether to show notification (default: true)
  // project: any; // Optional: Status for API calls
  icon?: string; // Optional: Icon name for the button (default: "")
  buttonVariant?:
    | "primary"
    | "secondary"
    | "outline"
    | "ghost"
    | "link"
    | "success"
    | "warning"
    | "danger"
    | "loading"
    | "disabled"
    | "selected"
    | "anchor"; // Optional: Button variant (default: "primary")
}

const {
  id,
  title,
  options = [],
  selectedValue = "",
  placeholder = "Select an option...",
  buttonClass = "",
  buttonText,
  showCloseButton = true,
  showCancelButton = true,
  addNewOption = false,
  skipSaveToAPI = false,
  name,
  noResultsText = "No Options found",
  icon = "chevron-down",
  // NEW FLEXIBLE PROPS:
  apiEndpoint,
  searchText = "Search Options",
  searchPlaceholder = "Type to search options...",
  apiParams = {},
  dataTransform,
  showImages = false,
  imageField = "image_url",
  valueField = "value",
  labelField = "label",
  fetchOnLoad = false,
  projectId,
  showNotification = false,
  buttonVariant = "primary",
  project = {},
  // project = {},
} = Astro.props;

// Ensure options is always an array

const optionsArray = Array.isArray(options) ? options : [];

// Determine if search should be enabled (if searchText is provided)
const enableSearch = !!searchText;

// Find the selected option to get the button text
const selectedOption = optionsArray.find((option) => option.value === selectedValue);
const displayText = buttonText || selectedOption?.label || placeholder;
---

<!-- Slot Machine Picker Button -->
<Button
  id={id}
  variant={buttonVariant || "outline"}
  class={buttonClass || ""}
  icon={icon}
  iconPosition="right"
  data-refresh={name}
  data-project-id={projectId}
  size="sm"
>
  {displayText.replace(/<[^>]*>/g, "")}
</Button>

<!-- Hidden input to store the selected value -->
<input
  type="hidden"
  id={`${id}-value`}
  name={name || id}
  value={selectedValue}
  data-refresh={name}
  data-project-id={projectId}
  data-project={JSON.stringify(project)}
/>

<script
  define:vars={{
    id,
    title,
    options: optionsArray,
    selectedValue,
    showCloseButton,
    showCancelButton,
    skipSaveToAPI,
    enableSearch,
    apiEndpoint,
    searchText,
    searchPlaceholder,
    showNotification,
    apiParams,
    dataTransform,
    showImages,
    imageField,
    valueField,
    labelField,
    fetchOnLoad,
    projectId,
    noResultsText,
    project,
    // project,
  }}
>
  // Initialize the slot machine picker
  document.addEventListener("DOMContentLoaded", function () {
    const trigger = document.getElementById(id);
    const hiddenInput = document.getElementById(`${id}-value`);

    if (!trigger) {
      console.error(`üé∞ [SLOT-MACHINE] Trigger button with ID '${id}' not found`);
      return;
    }

    // Set up click handler
    trigger.addEventListener("click", function (e) {
      e.stopPropagation();
      // // console.log(`üé∞ [SLOT-MACHINE] Opening picker for ID: ${id}`);

      // Open the slot machine modal using variables directly
      // Use current hidden input value if it exists, otherwise fall back to original selectedValue
      const currentValue = hiddenInput ? hiddenInput.value : selectedValue;
      showSlotMachineModal({
        id: id,
        title: title,
        options: options,
        selectedValue: currentValue,
        showCloseButton: showCloseButton,
        showCancelButton: showCancelButton,
        valueField: valueField,
        labelField: labelField,
        fetchOnLoad: fetchOnLoad,
        searchText: searchText,
        searchPlaceholder: searchPlaceholder,
        onSelect: (value, label) => {
          // Update hidden input
          if (hiddenInput) {
            hiddenInput.value = value;
          }

          // Update button text by showing/hiding elements
          // const buttonText = trigger.querySelector(".button-text");
          // const buttonIcon = trigger.querySelector(".button-icon");

          // if (buttonText) {
          //   buttonText.textContent = label;
          // }

          // // Show the button icon if it exists
          // if (buttonIcon) {
          //   buttonIcon.style.display = "inline-block";
          // }

          console.log(`üé∞ [SLOT-MACHINE] ===== SELECTION MADE =====`);
          console.log(`üé∞ [SLOT-MACHINE] Selected value: ${value} (type: ${typeof value})`);
          console.log(`üé∞ [SLOT-MACHINE] Selected label: ${label} (type: ${typeof label})`);
          console.log(`üé∞ [SLOT-MACHINE] Component ID: ${id}`);
          console.log(`üé∞ [SLOT-MACHINE] Skip save to API: ${skipSaveToAPI}`);

          // Call the generic handleSelect function
          if (typeof window.handleSelect === "function") {
            console.log(`üé∞ [SLOT-MACHINE] Calling window.handleSelect function`);
            window.handleSelect(value, label, id);
          } else {
            console.log(`üé∞ [SLOT-MACHINE] No window.handleSelect function found`);
          }

          // Auto-save to API endpoint using the component ID
          if (!skipSaveToAPI) {
            console.log(`üé∞ [SLOT-MACHINE] Calling saveToAPI with:`, { id, value, label });
            saveToAPI(id, value, label);
          } else {
            console.log(`üé∞ [SLOT-MACHINE] Skipping saveToAPI because skipSaveToAPI is true`);
          }

          console.log(`üé∞ [SLOT-MACHINE] Selection process completed`);
        },
        enableSearch: enableSearch,
        apiEndpoint: apiEndpoint,
        searchText: searchText,
        searchPlaceholder: searchPlaceholder,
        apiParams: apiParams,
        dataTransform: dataTransform,
        showImages: showImages,
        imageField: imageField,
        valueField: valueField,
        labelField: labelField,
        fetchOnLoad: fetchOnLoad,
        noResultsText: noResultsText,
        // project: project,
      });
    });

    // Check for URL parameters to auto-open this specific picker
    function checkUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const modalParam = urlParams.get("modal");

      console.log(`üé∞ [SLOT-MACHINE] Checking URL parameters for ID '${id}':`, {
        modalParam,
        componentId: id,
        match: modalParam === id,
      });

      if (modalParam === id) {
        // console.log(`üé∞ [SLOT-MACHINE] URL parameter detected: modal=${id}`);

        // Wait for DOM to be ready, then trigger the picker
        setTimeout(() => {
          if (trigger) {
            // console.log(`üé∞ [SLOT-MACHINE] Auto-opening picker for ID: ${id}`);
            trigger.click();

            // Clean up the URL parameter
            const newUrl = new URL(window.location);
            newUrl.searchParams.delete("modal");
            window.history.replaceState({}, "", newUrl);
            // console.log(`üé∞ [SLOT-MACHINE] URL cleaned up: ${newUrl.href}`);
          } else {
            console.error(`üé∞ [SLOT-MACHINE] Trigger button not found for auto-open`);
          }
        }, 100);
      }
    }

    // Check URL parameters on load
    checkUrlParameters();
  });

  // Auto-save function that uses component ID to determine API endpoint
  async function saveToAPI(componentId, value, label) {
    try {
      console.log(`üé∞ [SLOT-MACHINE] ===== SAVE TO API START =====`);
      console.log(`üé∞ [SLOT-MACHINE] Component ID: ${componentId}`);
      console.log(`üé∞ [SLOT-MACHINE] Value: ${value} (type: ${typeof value})`);
      console.log(`üé∞ [SLOT-MACHINE] Label: ${label} (type: ${typeof label})`);
      console.log(`üé∞ [SLOT-MACHINE] ProjectId prop: ${projectId} (type: ${typeof projectId})`);
      console.log(`üé∞ [SLOT-MACHINE] Current URL: ${window.location.href}`);
      console.log(`üé∞ [SLOT-MACHINE] URL pathname: ${window.location.pathname}`);

      // Format data based on the component type
      let requestBody;

      // debugger;
      if (componentId === "update-status") {
        console.log(`üé∞ [SLOT-MACHINE] Processing UPDATE-STATUS request`);
        console.log(`üé∞ [SLOT-MACHINE] Raw projectId prop:`, projectId);
        console.log(`üé∞ [SLOT-MACHINE] Raw value:`, value);
        console.log(`üé∞ [SLOT-MACHINE] URL pathname:`, window.location.pathname);

        // const parsedProjectId =
        //   parseInt(projectId) || parseInt(window.location.pathname.split("/").pop()) || null;
        const parsedStatus = parseInt(value);

        // console.log(
        //   `üé∞ [SLOT-MACHINE] Parsed projectId: ${parsedProjectId} (type: ${typeof parsedProjectId})`
        // );
        // console.log(
        //   `üé∞ [SLOT-MACHINE] Parsed status: ${parsedStatus} (type: ${typeof parsedStatus})`
        // );

        // Additional validation checks
        // if (!parsedProjectId) {
        //   console.error(`üé∞ [SLOT-MACHINE] ERROR: Could not parse projectId!`);
        //   console.error(`üé∞ [SLOT-MACHINE] projectId prop:`, projectId);
        //   console.error(`üé∞ [SLOT-MACHINE] URL pathname:`, window.location.pathname);
        //   console.error(
        //     `üé∞ [SLOT-MACHINE] URL pathname split:`,
        //     window.location.pathname.split("/")
        //   );
        // }

        if (isNaN(parsedStatus)) {
          console.error(`üé∞ [SLOT-MACHINE] ERROR: Could not parse status!`);
          console.error(`üé∞ [SLOT-MACHINE] Raw value:`, value);
          console.error(`üé∞ [SLOT-MACHINE] Parsed status:`, parsedStatus);
        }

        // For status updates, send the format expected by update-status API
        // Get project data from data attribute
        const projectDataElement = document.getElementById(`${id}-value`);
        const projectData = projectDataElement
          ? JSON.parse(projectDataElement.getAttribute("data-project") || "{}")
          : {};

        console.log(`üé∞ [SLOT-MACHINE] Project object for ${id}:`, projectData);
        console.log(`üé∞ [SLOT-MACHINE] Project keys:`, Object.keys(projectData || {}));

        requestBody = {
          project: projectData,
          status: parsedStatus, // Convert value to integer
        };
        console.log(`üé∞ [SLOT-MACHINE] UPDATE-STATUS requestBody:`, requestBody);
      } else if (componentId === "assign-staff") {
        console.log(`üé∞ [SLOT-MACHINE] Processing ASSIGN-STAFF request`);
        // Get project data from data attribute
        const projectDataElement = document.getElementById(`${id}-value`);
        const projectData = projectDataElement
          ? JSON.parse(projectDataElement.getAttribute("data-project") || "{}")
          : {};
        const parsedProjectId =
          parseInt(projectData.id) || parseInt(window.location.pathname.split("/").pop()) || null;
        console.log(
          `üé∞ [SLOT-MACHINE] Parsed projectId: ${parsedProjectId} (type: ${typeof parsedProjectId})`
        );
        console.log(`üé∞ [SLOT-MACHINE] Staff ID: ${value} (type: ${typeof value})`);
        console.log(`üé∞ [SLOT-MACHINE] Staff Name: ${label} (type: ${typeof label})`);

        // For staff assignment, send the format expected by update-project API
        requestBody = {
          projectId: parsedProjectId,
          assigned_to_id: value, // Staff member ID
          assigned_to_name: label, // Staff member name
        };
        console.log(`üé∞ [SLOT-MACHINE] ASSIGN-STAFF requestBody:`, requestBody);
      } else {
        console.log(`üé∞ [SLOT-MACHINE] Processing GENERIC request for component: ${componentId}`);
        // For other components, use generic format
        requestBody = {
          value: value,
          label: label,
          componentId: componentId,
        };
        console.log(`üé∞ [SLOT-MACHINE] GENERIC requestBody:`, requestBody);
      }

      console.log(`üé∞ [SLOT-MACHINE] Final request body:`, requestBody);
      console.log(`üé∞ [SLOT-MACHINE] Making fetch request to: /api/${componentId}`);

      const response = await fetch(`/api/${componentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify(requestBody),
      });

      console.log(`üé∞ [SLOT-MACHINE] Fetch response status: ${response.status}`);
      console.log(`üé∞ [SLOT-MACHINE] Fetch response ok: ${response.ok}`);
      console.log(
        `üé∞ [SLOT-MACHINE] Fetch response headers:`,
        Object.fromEntries(response.headers.entries())
      );

      if (response.ok) {
        const result = await response.json();
        console.log(`üé∞ [SLOT-MACHINE] ===== API SUCCESS RESPONSE =====`);
        console.log(`üé∞ [SLOT-MACHINE] API response:`, result);

        // Show success notification

        // Also try the original notification handler if it exists
        if (window.handleUpdateStatusNotification) {
          window.handleUpdateStatusNotification(result, "SLOT-MACHINE");
        }

        // if (result.notificationData && window.showModal && showNotification) {
        //   const { type, title, message, duration } = result.notificationData;

        //   window.showModal(type, title, message, duration);
        // } else if (result.success && window.showModal && showNotification) {
        //   // Fallback success notification
        //   window.showModal(
        //     "success",
        //     "Success",
        //     result.message || "Operation completed successfully",
        //     3000
        //   );
        // }

        // Close the modal after success
        setTimeout(() => {
          const modal = document.querySelector(`[data-modal-backdrop="${componentId}-modal"]`);
          if (modal) {
            modal.click(); // Click the backdrop to close
          }
        }, 1000);
      } else {
        console.log(`üé∞ [SLOT-MACHINE] ===== API ERROR RESPONSE =====`);
        console.log(`üé∞ [SLOT-MACHINE] Response status: ${response.status}`);
        console.log(`üé∞ [SLOT-MACHINE] Response statusText: ${response.statusText}`);

        let errorData;
        try {
          errorData = await response.json();
          console.log(`üé∞ [SLOT-MACHINE] Error response body:`, errorData);
        } catch (parseError) {
          console.log(`üé∞ [SLOT-MACHINE] Could not parse error response as JSON:`, parseError);
          const textResponse = await response.text();
          console.log(`üé∞ [SLOT-MACHINE] Error response as text:`, textResponse);
          errorData = { error: textResponse };
        }

        console.error(`üé∞ [SLOT-MACHINE] API error:`, errorData);
        throw new Error(errorData.error || `Failed to save ${componentId}`);
      }
    } catch (error) {
      console.log(`üé∞ [SLOT-MACHINE] ===== CATCH BLOCK =====`);
      console.error(`üé∞ [SLOT-MACHINE] Error saving to API:`, error);
      console.error(`üé∞ [SLOT-MACHINE] Error name:`, error.name);
      console.error(`üé∞ [SLOT-MACHINE] Error message:`, error.message);
      console.error(`üé∞ [SLOT-MACHINE] Error stack:`, error.stack);

      // Show error notification if available
      if (window.showModal) {
        window.showModal("error", "Error", `Failed to save selection. Please try again.`, 5000);
      }
    }
  }

  // Helper function to create buttons using Button partial
  async function createButtonPartial(config) {
    try {
      const headers = new Headers();
      Object.entries(config).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          headers.set(`x-button-${key}`, value.toString());
        }
      });

      const response = await fetch("/partials/button", {
        headers: headers,
      });

      if (response.ok) {
        const buttonHTML = await response.text();
        const wrapper = document.createElement("div");
        wrapper.innerHTML = buttonHTML;
        return wrapper.firstElementChild;
      } else {
        console.error("Failed to fetch button partial:", response.status);
        return null;
      }
    } catch (error) {
      console.error("Error creating button partial:", error);
      return null;
    }
  }

  // Generic slot machine modal function
  async function showSlotMachineModal(config) {
    const {
      id,
      title,
      options,
      selectedValue,
      showCloseButton = true,
      showCancelButton = true,
      onSelect,
      enableSearch = false,
      apiEndpoint,
      searchText,
      searchPlaceholder,
      apiParams = {},
      dataTransform,
      showImages = false,
      imageField = "image_url",
      valueField = "value",
      labelField = "label",
      fetchOnLoad = false,
      noResultsText = "No results found",
    } = config;

    // Check for dynamically updated options
    const dynamicOptions = window.slotMachineOptions && window.slotMachineOptions[id];
    const finalOptions = dynamicOptions || options;

    // Initialize selectedIndex early to avoid reference errors
    let selectedIndex = finalOptions.findIndex((option) => {
      const optionValue = option[valueField] || option.value || option.place_id || option.id;
      return optionValue && selectedValue && optionValue.toString() === selectedValue.toString();
    });

    // Initialize originalOptions immediately for static options (before search setup)
    let originalOptions = [];
    if (!fetchOnLoad && finalOptions.length > 0) {
      originalOptions = [...finalOptions];
      console.log(
        `üîç [SLOT-MACHINE] Initialized originalOptions with ${originalOptions.length} static options`
      );
      console.log(`üîç [SLOT-MACHINE] Sample option structure:`, originalOptions[0]);
    }

    // Helper function to create LI elements consistently
    function createOptionElement(option, index, isSelected = false) {
      const li = document.createElement("li");
      li.className = liClassName;

      // Base styles
      let baseStyles = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 3rem;
        text-align: center;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px;
        padding: 12px 16px;
        user-select: none;
        position: relative;
      `;

      // Add selected styling if needed
      if (isSelected) {
        baseStyles += `
          background: bg-primary-500 !important;
          color: text-white !important;
          border-radius: 8px !important;
          margin: 0 8px !important;
        `;
        li.classList.add("selected");
      }

      li.style.cssText = baseStyles;

      const span = document.createElement("span");
      span.className = spanClassName;
      span.style.cssText = `
        text-align: center;
        font-weight: 500;
        transition: all 0.2s;
        width: 100%;
      `;

      // Set content and data attributes
      const labelText =
        option[labelField] || option.label || option.name || option.description || option;
      span.textContent = labelText;
      span.dataset.value =
        option[valueField] || option.value || option.place_id || option.id || option;
      span.dataset.label = labelText;
      span.dataset.index = index;

      li.appendChild(span);
      return li;
    }

    // Helper function to create message LI elements
    function createMessageElement(message, isError = false) {
      const li = document.createElement("li");
      li.className = `${liClassName} ${isError ? "error-message" : "info-message"}`;
      li.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 3rem;
        text-align: center;
        font-style: italic;
      `;
      li.textContent = message.replace(/<[^>]*>/g, "");
      return li;
    }

    // Helper function to populate options list
    function populateOptionsList(optionsArray, clearExisting = true) {
      if (clearExisting) {
        optionsList.innerHTML = "";
      }

      let newSelectedIndex = -1;

      if (optionsArray.length > 0) {
        optionsArray.forEach((option, index) => {
          const optionValue = option[valueField] || option.value || option.place_id || option.id;
          const isSelected =
            optionValue && selectedValue && optionValue.toString() === selectedValue.toString();

          // Track the new selected index in the filtered results
          if (isSelected) {
            newSelectedIndex = index;
          }

          const li = createOptionElement(option, index, isSelected);
          optionsList.appendChild(li);
        });
      } else {
        const messageLi = createMessageElement("No results found");
        optionsList.appendChild(messageLi);
      }

      // Handle single item case - if there's only one option and no selection, select it by default
      if (newSelectedIndex === -1 && optionsArray.length === 1) {
        newSelectedIndex = 0;
      }

      return newSelectedIndex;
    }

    // Lock body scroll to prevent background scrolling
    document.body.style.overflow = "hidden";

    // Create modal using partial route
    const headers = new Headers();
    headers.set("x-component-id", id);
    headers.set("x-modal-title", title);
    headers.set("x-show-search", enableSearch.toString());
    headers.set("x-cancel-button", "Cancel");
    headers.set("x-select-button", "Select");
    headers.set("x-no-results-text", noResultsText);

    // Add search-specific headers if search is enabled
    if (enableSearch) {
      headers.set("x-search-text", searchText || "");
      headers.set("x-search-placeholder", searchPlaceholder || "Type to search...");
    }

    const response = await fetch("/partials/slot-machine-modal", {
      headers: headers,
    });

    if (!response.ok) {
      console.error("Failed to fetch slot machine modal partial:", response.status);
      return;
    }

    const modalHTML = await response.text();
    const modalWrapper = document.createElement("div");
    modalWrapper.innerHTML = modalHTML;
    const modal = modalWrapper.firstElementChild;

    // Get the modal content from the partial
    const modalContent = modal.querySelector(".mx-4.max-h-\\[90vh\\].w-full.max-w-2xl");

    // Get references to elements from the partial
    const optionsList = modal.querySelector(`#${id}-slot-options-list`);
    const selectButton = modal.querySelector(`#${id}-slot-select-btn`);
    const cancelButton = modal.querySelector(`#${id}-slot-cancel-btn`);
    const closeButton = modal.querySelector(`#${id}-close-slot-modal`);
    const searchInput = modal.querySelector(`#${id}-slot-search-input`);
    const searchButton = modal.querySelector(`#${id}-slot-search-btn`);
    const liClassName = "text-primary dark:text-primary-dark";
    const spanClassName = "slot-machine-item-text";

    // Add event listeners to buttons from the partial
    if (closeButton) {
      closeButton.addEventListener("click", async () => {
        await cleanupModal();
        modal.remove();
      });
    }

    if (cancelButton) {
      cancelButton.addEventListener("click", async () => {
        await cleanupModal();
        modal.remove();
      });
    }

    // Focus search input after modal is fully rendered (only for non-fetchOnLoad modals)
    if (searchInput && !fetchOnLoad) {
      // Use setTimeout to ensure the modal is fully rendered
      setTimeout(() => {
        searchInput.focus();
      }, 100);
    }

    // Add search functionality if enabled
    if (enableSearch && searchInput) {
      console.log(
        `üîç [SLOT-MACHINE] Setting up search for ${id}, enableSearch: ${enableSearch}, searchInput: ${!!searchInput}, fetchOnLoad: ${fetchOnLoad}, finalOptions: ${finalOptions.length}`
      );
      let searchTimeout;
      // originalOptions is now initialized earlier in the function

      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();
        console.log(
          `üîç [SLOT-MACHINE] Search input changed: "${query}", originalOptions: ${originalOptions.length}`
        );

        // Clear previous timeout
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }

        // If fetchOnLoad is true OR we have pre-populated options without an API endpoint, filter existing options
        if (
          fetchOnLoad ||
          (!apiEndpoint && (originalOptions.length > 0 || finalOptions.length > 0))
        ) {
          // Store original options on first search
          if (originalOptions.length === 0) {
            // If we have finalOptions (pre-populated from props), use those
            if (finalOptions.length > 0) {
              originalOptions = finalOptions.map((option, index) => ({
                value: option[valueField] || option.value || "",
                label: option[labelField] || option.label || "",
                index: index,
              }));
            } else {
              // Otherwise, get from DOM
              originalOptions = Array.from(optionsList.querySelectorAll("li")).map((li, index) => {
                const span = li.querySelector("span");
                return {
                  value: span?.dataset.value || "",
                  label: span?.dataset.label || "",
                  index: index,
                };
              });
            }
          }

          // If search is cleared, restore all original options
          if (query.length === 0) {
            if (optionsList) {
              optionsList.innerHTML = "";
              originalOptions.forEach((option, index) => {
                const li = document.createElement("li");
                li.className = spanClassName;
                li.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 3rem;
        text-align: center;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px;
        padding: 12px 16px;
        user-select: none;
        position: relative;
      `;

                const span = document.createElement("span");
                span.className = spanClassName;
                span.style.cssText = `
        text-align: center;
        font-weight: 500;
        transition: all 0.2s;
        width: 100%;
      `;

                span.textContent = option.label;
                span.dataset.value = option.value;
                span.dataset.label = option.label;
                span.dataset.index = index;

                li.appendChild(span);
                optionsList.appendChild(li);
              });
            }
            return;
          }

          // Filter options based on search query
          console.log(`üîç [SLOT-MACHINE] Filtering options with query: "${query}"`);
          console.log(
            `üîç [SLOT-MACHINE] Original options:`,
            originalOptions.map((o) => ({ label: o.label, value: o.value }))
          );

          const filteredOptions = originalOptions.filter((option) => {
            const matches = option.label.toLowerCase().includes(query.toLowerCase());
            console.log(
              `üîç [SLOT-MACHINE] Option "${option.label}" matches "${query}": ${matches}`
            );
            return matches;
          });
          console.log(
            `üîç [SLOT-MACHINE] Filtered ${originalOptions.length} options to ${filteredOptions.length} results`
          );

          // Update the options list
          if (optionsList) {
            optionsList.innerHTML = "";

            if (filteredOptions.length > 0) {
              console.log(`üîç [SLOT-MACHINE] Showing ${filteredOptions.length} filtered results`);
              const newSelectedIndex = populateOptionsList(filteredOptions);
              selectedIndex = newSelectedIndex;

              // Update selection styling and center the selected item
              updateSelection();
              centerSelectedItem();
            } else {
              console.log(
                `üîç [SLOT-MACHINE] No matching results found, showing no-results message`
              );
              // Show "no results" message
              const messageLi = createMessageElement("No matching clients found");
              optionsList.innerHTML = "";
              optionsList.appendChild(messageLi);
              selectedIndex = -1;
            }
          }
          return;
        }

        // Original API-based search for non-fetchOnLoad cases
        if (apiEndpoint && query.length >= 2) {
          searchTimeout = setTimeout(async () => {
            try {
              console.log(`üîç [SLOT-MACHINE] Searching for: ${query}`);

              // Build search URL with API params
              const searchParams = new URLSearchParams({
                input: query,
                ...apiParams,
              });

              const response = await fetch(`${apiEndpoint}?${searchParams}`);
              if (!response.ok) {
                throw new Error(`Search failed: ${response.status}`);
              }

              const data = await response.json();
              console.log(`üîç [SLOT-MACHINE] Search results:`, data);

              // Transform data if transform function exists
              let transformedData = data;
              if (dataTransform && typeof window[dataTransform] === "function") {
                transformedData = window[dataTransform](data);
                console.log(`üîç [SLOT-MACHINE] Transformed data:`, transformedData);
              }

              // Handle different data formats
              let optionsArray = [];
              if (Array.isArray(transformedData)) {
                optionsArray = transformedData;
              } else if (transformedData && Array.isArray(transformedData.predictions)) {
                // Google Places format
                optionsArray = transformedData.predictions;
              } else if (transformedData && Array.isArray(transformedData.results)) {
                // Alternative format
                optionsArray = transformedData.results;
              } else if (
                transformedData &&
                transformedData.data &&
                Array.isArray(transformedData.data)
              ) {
                // Wrapped format
                optionsArray = transformedData.data;
              }

              console.log(`üîç [SLOT-MACHINE] Options array:`, optionsArray);

              // Update options list with search results
              if (optionsList) {
                const newSelectedIndex = populateOptionsList(optionsArray);
                selectedIndex = newSelectedIndex;
                updateSelection();
                centerSelectedItem();
              }
            } catch (error) {
              console.error(`üîç [SLOT-MACHINE] Search error:`, error);

              // Show error message
              if (optionsList) {
                const errorLi = createMessageElement("Error loading results", true);
                optionsList.innerHTML = "";
                optionsList.appendChild(errorLi);
              }
            }
          }, 300); // 300ms debounce
        } else if (query.length === 0) {
          // Restore original options when search is empty
          if (optionsList) {
            // Use originalOptions if available (for static options), otherwise use finalOptions
            const optionsToRestore = originalOptions.length > 0 ? originalOptions : finalOptions;
            const newSelectedIndex = populateOptionsList(optionsToRestore);
            selectedIndex = newSelectedIndex;
            updateSelection();
            centerSelectedItem();
          }
        }
      });
    }

    // Fetch data on load if fetchOnLoad is true
    if (fetchOnLoad && apiEndpoint && optionsList) {
      try {
        console.log(`üîÑ [SLOT-MACHINE] Fetching data on load for: ${apiEndpoint}`);

        // Build URL with API params
        const searchParams = new URLSearchParams(apiParams);
        const response = await fetch(`${apiEndpoint}?${searchParams}`);

        if (!response.ok) {
          throw new Error(`Fetch failed: ${response.status}`);
        }

        const data = await response.json();
        console.log(`üîÑ [SLOT-MACHINE] Load data response:`, data);

        // Transform data if transform function exists
        let transformedData = data;
        if (dataTransform && typeof window[dataTransform] === "function") {
          transformedData = window[dataTransform](data);
          console.log(`üîÑ [SLOT-MACHINE] Transformed load data:`, transformedData);
        }

        // Handle different data formats
        let optionsArray = [];
        if (Array.isArray(transformedData)) {
          optionsArray = transformedData;
        } else if (transformedData && Array.isArray(transformedData.predictions)) {
          // Google Places format
          optionsArray = transformedData.predictions;
        } else if (transformedData && Array.isArray(transformedData.results)) {
          // Alternative format
          optionsArray = transformedData.results;
        } else if (transformedData && Array.isArray(transformedData.clients)) {
          // Clients API format
          optionsArray = transformedData.clients;
        } else if (transformedData && transformedData.data && Array.isArray(transformedData.data)) {
          // Wrapped format
          optionsArray = transformedData.data;
        }

        console.log(`üîÑ [SLOT-MACHINE] Load options array:`, optionsArray);

        // Update finalOptions with fetched data
        if (optionsArray.length > 0) {
          const newSelectedIndex = populateOptionsList(optionsArray);
          selectedIndex = newSelectedIndex;
          updateSelection();
          centerSelectedItem();
        }
      } catch (error) {
        console.error(`üîÑ [SLOT-MACHINE] Error fetching data on load:`, error);
      }

      // Focus search input after fetchOnLoad data is populated
      if (searchInput) {
        setTimeout(() => {
          searchInput.focus();
        }, 100);
      }
    }

    // Populate options in the list from the partial (only if not fetched on load)
    if (optionsList && !fetchOnLoad) {
      optionsList.style.transform = "translateY(0px)";
      populateOptionsList(finalOptions);
    }

    // Slot machine functionality

    // Add event listener to select button from the partial
    if (selectButton) {
      selectButton.addEventListener("click", async () => {
        // Get the currently selected option from the DOM
        const currentOptions = optionsList.querySelectorAll("li");
        const selectedItem = currentOptions[selectedIndex];

        if (selectedItem && selectedIndex >= 0) {
          const span = selectedItem.querySelector("span");
          if (span) {
            const value = span.dataset.value;
            const label = span.dataset.label;

            await cleanupModal();
            modal.remove();

            // Call the generic handleSelect function
            if (typeof window.handleSelect === "function") {
              window.handleSelect(value, label, id);
            }
          }
        }
      });
    }

    // Add modal to DOM
    document.body.appendChild(modal);

    // Handle single item case - if there's only one option, select it by default
    if (selectedIndex === -1 && finalOptions.length === 1) {
      selectedIndex = 0;
    }

    // Debug logging for selection
    // // console.log("üé∞ [SLOT-MACHINE] Selection debug:", {
    //   selectedValue,
    //   selectedValueType: typeof selectedValue,
    //   options: finalOptions.map((opt) => ({
    //     value: opt.value,
    //     valueType: typeof opt.value,
    //     label: opt.label,
    //   })),
    //   selectedIndex,
    //   foundOption: finalOptions[selectedIndex],
    // });

    // Center selected item
    function centerSelectedItem() {
      // Only apply translateY if there's a valid selection
      if (selectedIndex >= 0) {
        // Use responsive item height based on screen size
        const itemHeight = window.innerWidth <= 768 ? 56 : 48;
        const containerHeight = 192;
        const centerOffset = (containerHeight - itemHeight) / 2;
        const targetY = -(selectedIndex * itemHeight) + centerOffset;

        // Use smooth transition
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = `translateY(${targetY}px)`;
      } else {
        // No selection - keep at default position
        optionsList.style.transition = "transform 0.2s ease-out";
        optionsList.style.transform = "translateY(0px)";
      }

      // Update centering (visual feedback only, no selection styling)
      updateCentering();
    }

    // Add checkmark to selected item
    function addCheckmark(item) {
      // Remove existing checkmark if any
      const existingCheckmark = item.querySelector(".checkmark");
      if (existingCheckmark) {
        existingCheckmark.remove();
      }

      const checkmark = document.createElement("div");
      checkmark.className = "checkmark";
      checkmark.innerHTML = "‚úì";
      checkmark.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        transition: all 0.2s ease-out;
        color: #ffffff;
        font-weight: bold;
        font-size: 16px;
        animation: checkmarkPulse 1.5s ease-in-out infinite;
        z-index: 10;
      `;

      item.appendChild(checkmark);
    }

    // Remove checkmark from item
    function removeCheckmark(item) {
      const checkmark = item.querySelector(".checkmark");
      if (checkmark) {
        checkmark.remove();
      }
    }

    // Update selection styling (only for clicked items)
    function updateSelection() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        if (index === selectedIndex && selectedIndex >= 0) {
          item.classList.add("selected", "bg-primary-500", "text-white");
          // Reset and apply selected styles
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
            border-radius: 8px;
            margin: 0 8px;
          `;
          addCheckmark(item);
          if (selectButton) selectButton.disabled = false;
        } else {
          item.classList.remove("selected", "bg-primary-500", "text-white");
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
          `;
          removeCheckmark(item);
        }
      });

      // Disable select button if no item is selected
      if (selectedIndex < 0) {
        if (selectButton) selectButton.disabled = true;
      }
    }

    // Update visual centering (without selection styling)
    function updateCentering() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        // Only update the centering, not the selection styling
        if (index === selectedIndex && selectedIndex >= 0) {
          // Just center the item visually, don't apply selected styling
          item.style.transform = "scale(1.05)";
          item.style.transition = "transform 0.2s ease-out";
        } else {
          item.style.transform = "scale(1)";
          item.style.transition = "transform 0.2s ease-out";
        }
      });
    }

    // Handle wheel events (desktop) with natural scroll sensitivity
    let wheelAccumulator = 0;
    const wheelThreshold = 50; // Require more scroll distance before moving items

    optionsList.addEventListener("wheel", (e) => {
      e.preventDefault();

      // Accumulate wheel delta to make scrolling feel more natural
      wheelAccumulator += e.deltaY;

      // Only move when we've accumulated enough scroll distance
      if (Math.abs(wheelAccumulator) >= wheelThreshold) {
        const deltaY = wheelAccumulator;
        wheelAccumulator = 0; // Reset accumulator

        // Get current options count from DOM
        const currentOptions = optionsList.querySelectorAll("li");
        const maxIndex = currentOptions.length - 1;

        // Calculate new index based on scroll direction
        if (deltaY > 0) {
          // Scrolling down - move to next item
          selectedIndex = Math.min(selectedIndex + 1, maxIndex);
        } else {
          // Scrolling up - move to previous item
          selectedIndex = Math.max(selectedIndex - 1, 0);
        }

        // Smoothly center the selected item and update selection
        centerSelectedItem();
        updateSelection();
      }
    });

    // Handle touch events (mobile)
    let touchStartY = 0;
    let touchStartTime = 0;
    let isScrolling = false;

    optionsList.addEventListener(
      "touchstart",
      (e) => {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isScrolling = false;
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (!isScrolling) {
          isScrolling = true;
        }
      },
      { passive: false }
    );

    optionsList.addEventListener(
      "touchend",
      (e) => {
        e.preventDefault();
        if (!isScrolling) return;

        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        const deltaY = touchStartY - touchEndY;
        const deltaTime = touchEndTime - touchStartTime;

        // Only process if there was significant movement and it was quick enough
        if (Math.abs(deltaY) > 20 && deltaTime < 500) {
          // Get current options count from DOM
          const currentOptions = optionsList.querySelectorAll("li");
          const maxIndex = currentOptions.length - 1;

          if (deltaY > 0) {
            // Swiping up - move to next item
            selectedIndex = Math.min(selectedIndex + 1, maxIndex);
          } else {
            // Swiping down - move to previous item
            selectedIndex = Math.max(selectedIndex - 1, 0);
          }

          // Smoothly center the selected item and update selection
          centerSelectedItem();
          updateSelection();
        }
      },
      { passive: false }
    );

    // Handle click on items
    optionsList.addEventListener("click", (e) => {
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on click
        updateSelection();
      }
    });

    // Handle touch on items for mobile
    optionsList.addEventListener("touchend", (e) => {
      e.preventDefault();
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on touch
        updateSelection();
      }
    });

    // Handle keyboard navigation
    document.addEventListener("keydown", (e) => {
      // Only handle keyboard events when modal is open
      if (!modal || !document.body.contains(modal)) return;

      const currentOptions = optionsList.querySelectorAll("li");
      const maxIndex = currentOptions.length - 1;

      switch (e.key) {
        case "ArrowUp":
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, 0);
          centerSelectedItem();
          updateSelection();
          break;

        case "ArrowDown":
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, maxIndex);
          centerSelectedItem();
          updateSelection();
          break;

        case "Enter":
          e.preventDefault();
          if (selectedIndex >= 0 && selectedIndex <= maxIndex) {
            // Trigger the same logic as clicking the select button
            const selectedItem = currentOptions[selectedIndex];
            if (selectedItem) {
              const span = selectedItem.querySelector("span");
              if (span) {
                const value = span.dataset.value;
                const label = span.dataset.label;

                // Close modal and call handleSelect
                cleanupModal();
                modal.remove();

                if (typeof window.handleSelect === "function") {
                  window.handleSelect(value, label, id);
                }
              }
            }
          }
          break;

        case "Escape":
          e.preventDefault();
          // Close modal without selecting
          cleanupModal();
          modal.remove();
          break;
      }
    });

    // Initial setup
    centerSelectedItem();
    updateSelection();

    // Cleanup function to restore body scroll
    function cleanupModal() {
      // Unlock body scroll
      document.body.style.overflow = "";
    }

    // Close modal when clicking outside
    modal.addEventListener("click", async (e) => {
      if (e.target === modal) {
        await cleanupModal();
        modal.remove();
      }
    });

    // Prevent body scroll when modal is open
    document.body.style.overflow = "hidden";
  }

  // Generic handleSelect function that works for any slot machine
  window.handleSelect = function (value, label, componentId) {
    console.log(`üé∞ [SLOT-MACHINE] ===== WINDOW.HANDLESELECT CALLED =====`);
    console.log(`üé∞ [SLOT-MACHINE] Value: ${value} (type: ${typeof value})`);
    console.log(`üé∞ [SLOT-MACHINE] Label: ${label} (type: ${typeof label})`);
    console.log(`üé∞ [SLOT-MACHINE] Component ID: ${componentId}`);

    // Find the hidden input for this component
    const hiddenInput = document.getElementById(`${componentId}-value`);
    if (hiddenInput) {
      hiddenInput.value = value;
      console.log(
        `üé∞ [SLOT-MACHINE] Updated hidden input ${componentId}-value with value: ${value}`
      );
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Hidden input ${componentId}-value not found`);
    }

    // Find the button and update its text
    const button = document.getElementById(componentId);
    if (button) {
      // Try to find the button-text span first
      const buttonTextSpan = button.querySelector(".button-text");
      if (buttonTextSpan) {
        console.log(`üé∞ [SLOT-MACHINE] Found button-text span, updating to: ${label}`);
        buttonTextSpan.textContent = label;
        console.log(`üé∞ [SLOT-MACHINE] Button text span updated successfully`);
        console.log(`üé∞ [SLOT-MACHINE] Button text span computed styles:`, {
          color: getComputedStyle(buttonTextSpan).color,
          display: getComputedStyle(buttonTextSpan).display,
          visibility: getComputedStyle(buttonTextSpan).visibility,
        });
      } else {
        // Fallback to updating the entire button content
        console.log(`üé∞ [SLOT-MACHINE] Button-text span not found, updating entire button content`);
        button.textContent = label;
        console.log(`üé∞ [SLOT-MACHINE] Updated button text to: ${label}`);
      }
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Button ${componentId} not found`);
    }

    console.log(`‚úÖ [SLOT-MACHINE] Selected: ${label} (${value}) for component: ${componentId}`);

    // Check if we should auto-save to API
    // For update-status and assign-staff, we should auto-save
    if (componentId === "update-status" || componentId === "assign-staff") {
      console.log(`üé∞ [SLOT-MACHINE] Auto-saving to API for component: ${componentId}`);
      saveToAPI(componentId, value, label);
    } else {
      console.log(`üé∞ [SLOT-MACHINE] Not auto-saving to API for component: ${componentId}`);
    }
  };

  // Expose function to update slot machine options dynamically
  window.updateSlotMachineOptions = function (componentId, newOptions) {
    // Store the new options for this component
    if (!window.slotMachineOptions) {
      window.slotMachineOptions = {};
    }
    window.slotMachineOptions[componentId] = newOptions;
  };
</script>

<style>
  /* Prevent text selection in modal */
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    touch-action: pan-y !important;
    -webkit-touch-callout: none !important;
  }

  /* Improve touch targets for mobile */
  @media (max-width: 768px) {
    .slot-machine-item {
      min-height: 56px !important;
      height: 56px !important;
      padding: 16px !important;
      font-size: 16px !important;
    }

    .slot-machine-item-text {
      font-size: 16px !important;
    }
  }

  .slot-machine-item > span {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
  }

  /* Smooth transitions */
  .transition-transform {
    transition-property: transform;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 300ms;
  }

  /* Slot machine container styling */
  .slot-machine-container {
    min-height: 12rem !important;
    max-height: 12rem !important;
    height: 12rem !important;
    display: block !important;
  }

  /* Ensure the slot machine list takes full height */
  .slot-machine-container ul {
    height: 100% !important;
    min-height: 12rem !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
  }

  /* Ensure slot machine items are visible */
  .slot-machine-item {
    min-height: 3rem !important;
    height: 3rem !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    transition: all 0.2s ease-in-out;
  }

  /* Ensure selected items have white text */
  .slot-machine-item.selected {
    color: white !important;
  }

  .slot-machine-item.selected span {
    color: white !important;
  }

  /* Default option text color */
  .slot-machine-item {
    color: #111827;
  }

  /* Checkmark pulse animation */
  @keyframes checkmarkPulse {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes checkmarkPulseDark {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    50% {
      opacity: 0.9;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 16px rgba(16, 185, 129, 1);
    }
  }

  /* Empty state styling */
  .slot-empty-state {
    transition: opacity 0.3s ease-in-out;
  }

  /* Message element styling */
  .error-message {
    color: #ef4444 !important;
  }

  .info-message {
    color: #6b7280 !important;
  }
</style>
