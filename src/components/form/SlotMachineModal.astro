---
// Generic Slot Machine Modal Component - Reusable for any picker scenario

interface Props {
  id: string; // Required: Unique identifier for this picker instance
  title: string; // Required: Modal title (e.g., "Select Status", "Choose Staff")
  options: Array<{ value: string; label: string; disabled?: boolean }>; // Required: Array of options
  selectedValue?: string; // Optional: Currently selected value
  placeholder?: string; // Optional: Placeholder text for button
  theme?: "blue" | "green" | "orange" | "red" | "purple"; // Optional: Color theme
  buttonText?: string; // Optional: Custom button text (defaults to selected label or placeholder)
  showCloseButton?: boolean; // Optional: Show X close button (default: true)
  showCancelButton?: boolean; // Optional: Show Cancel button (default: true)
  onSelect?: string; // Optional: Function name to call when item is selected
}

const {
  id,
  title,
  options = [],
  selectedValue = "",
  placeholder = "Select an option...",
  theme = "blue",
  buttonText,
  showCloseButton = true,
  showCancelButton = true,
  onSelect = "handleSlotMachineSelect",
} = Astro.props;

// Ensure options is always an array
const optionsArray = Array.isArray(options) ? options : [];

// Find the selected option to get the button text
const selectedOption = optionsArray.find((option) => option.value === selectedValue);
const displayText = buttonText || selectedOption?.label || placeholder;

// Theme colors
const themeColors = {
  blue: {
    button:
      "bg-blue-100 text-blue-800 hover:bg-blue-200 dark:bg-blue-900/30 dark:text-blue-400 dark:hover:bg-blue-900/50",
    modal: "bg-blue-600 hover:bg-blue-700",
    selected: "bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400",
  },
  green: {
    button:
      "bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-900/30 dark:text-green-400 dark:hover:bg-green-900/50",
    modal: "bg-green-600 hover:bg-green-700",
    selected: "bg-green-50 dark:bg-green-900/20 text-green-600 dark:text-green-400",
  },
  orange: {
    button:
      "bg-orange-100 text-orange-800 hover:bg-orange-200 dark:bg-orange-900/30 dark:text-orange-400 dark:hover:bg-orange-900/50",
    modal: "bg-orange-600 hover:bg-orange-700",
    selected: "bg-orange-50 dark:bg-orange-900/20 text-orange-600 dark:text-orange-400",
  },
  red: {
    button:
      "bg-red-100 text-red-800 hover:bg-red-200 dark:bg-red-900/30 dark:text-red-400 dark:hover:bg-red-900/50",
    modal: "bg-red-600 hover:bg-red-700",
    selected: "bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400",
  },
  purple: {
    button:
      "bg-purple-100 text-purple-800 hover:bg-purple-200 dark:bg-purple-900/30 dark:text-purple-400 dark:hover:bg-purple-900/50",
    modal: "bg-purple-600 hover:bg-purple-700",
    selected: "bg-purple-50 dark:bg-purple-900/20 text-purple-600 dark:text-purple-400",
  },
};

const colors = themeColors[theme];
---

<!-- Slot Machine Picker Button -->
<button
  type="button"
  class={`inline-flex items-center rounded-full px-3 py-1 text-sm font-medium cursor-pointer transition-colors ${colors.button}`}
  id={id}
>
  {displayText}
  <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
  </svg>
</button>

<!-- Hidden input to store the selected value -->
<input type="hidden" id={`${id}-value`} name={id} value={selectedValue} />

<script
  define:vars={{
    id,
    title,
    options: optionsArray,
    selectedValue,
    theme,
    colors,
    showCloseButton,
    showCancelButton,
    onSelect,
  }}
>
  // Initialize the slot machine picker
  document.addEventListener("DOMContentLoaded", function () {
    const trigger = document.getElementById(id);
    const hiddenInput = document.getElementById(`${id}-value`);

    if (!trigger) {
      console.error(`ðŸŽ° [SLOT-MACHINE] Trigger button with ID '${id}' not found`);
      return;
    }

    // Set up click handler
    trigger.addEventListener("click", function (e) {
      e.stopPropagation();
      console.log(`ðŸŽ° [SLOT-MACHINE] Opening picker for ID: ${id}`);

      // Open the slot machine modal using variables directly
      showSlotMachineModal({
        id: id,
        title: title,
        options: options,
        selectedValue: selectedValue,
        theme: theme,
        showCloseButton: showCloseButton,
        showCancelButton: showCancelButton,
        onSelect: (value, label) => {
          // Update hidden input
          if (hiddenInput) {
            hiddenInput.value = value;
          }

          // Update button text
          trigger.innerHTML = `
            ${label}
            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
            </svg>
          `;

          // Call the onSelect callback if provided
          if (typeof window[onSelect] === "function") {
            window[onSelect](value, label, id);
          }

          // Auto-save to API endpoint using the component ID
          saveToAPI(id, value, label);

          console.log(`ðŸŽ° [SLOT-MACHINE] Selected: ${label} (${value})`);
        },
      });
    });

    // Check for URL parameters to auto-open this specific picker
    function checkUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const modalParam = urlParams.get("modal");

      console.log(`ðŸŽ° [SLOT-MACHINE] Checking URL parameters for ID '${id}':`, {
        modalParam,
        componentId: id,
        match: modalParam === id,
      });

      if (modalParam === id) {
        console.log(`ðŸŽ° [SLOT-MACHINE] URL parameter detected: modal=${id}`);

        // Wait for DOM to be ready, then trigger the picker
        setTimeout(() => {
          if (trigger) {
            console.log(`ðŸŽ° [SLOT-MACHINE] Auto-opening picker for ID: ${id}`);
            trigger.click();

            // Clean up the URL parameter
            const newUrl = new URL(window.location);
            newUrl.searchParams.delete("modal");
            window.history.replaceState({}, "", newUrl);
            console.log(`ðŸŽ° [SLOT-MACHINE] URL cleaned up: ${newUrl.href}`);
          } else {
            console.error(`ðŸŽ° [SLOT-MACHINE] Trigger button not found for auto-open`);
          }
        }, 100);
      }
    }

    // Check URL parameters on load
    checkUrlParameters();
  });

  // Auto-save function that uses component ID to determine API endpoint
  async function saveToAPI(componentId, value, label) {
    try {
      console.log(`ðŸŽ° [SLOT-MACHINE] Saving to API: /api/${componentId}`, { value, label });

      // Format data based on the component type
      let requestBody;

      if (componentId === "update-status") {
        // For status updates, send the format expected by update-status API
        requestBody = {
          projectId: parseInt(window.location.pathname.split("/").pop()) || null, // Get project ID from URL
          status: parseInt(value), // Convert value to integer
          currentUserId: null, // Will be handled by server-side auth
          oldStatus: null, // Could be enhanced to track previous status
        };
      } else {
        // For other components, use generic format
        requestBody = {
          value: value,
          label: label,
          componentId: componentId,
        };
      }

      console.log(`ðŸŽ° [SLOT-MACHINE] Request body:`, requestBody);

      const response = await fetch(`/api/${componentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify(requestBody),
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`ðŸŽ° [SLOT-MACHINE] API response:`, result);

        // Show success notification if available
        if (result.notificationData && window.showModal) {
          window.showModal(
            result.notificationData.type || "success",
            result.notificationData.title || "Updated",
            result.notificationData.message || `${label} selected successfully`,
            result.notificationData.duration || 3000
          );
        }
      } else {
        const errorData = await response.json();
        console.error(`ðŸŽ° [SLOT-MACHINE] API error:`, errorData);
        throw new Error(errorData.error || `Failed to save ${componentId}`);
      }
    } catch (error) {
      console.error(`ðŸŽ° [SLOT-MACHINE] Error saving to API:`, error);

      // Show error notification if available
      if (window.showModal) {
        window.showModal("error", "Error", `Failed to save selection. Please try again.`, 5000);
      }
    }
  }

  // Generic slot machine modal function
  function showSlotMachineModal(config) {
    const {
      id,
      title,
      options,
      selectedValue,
      theme,
      showCloseButton = true,
      showCancelButton = true,
      onSelect,
    } = config;

    // Create modal overlay
    const modal = document.createElement("div");
    modal.className = "fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50";
    modal.id = `${id}-modal`;

    // Create modal content
    const modalContent = document.createElement("div");
    modalContent.className = "bg-white dark:bg-gray-800 rounded-lg p-6 max-w-sm w-full mx-4";
    modalContent.style.userSelect = "none";

    // Create title with close button
    const titleContainer = document.createElement("div");
    titleContainer.className = "relative flex items-center justify-center mb-4";

    const titleElement = document.createElement("h3");
    titleElement.className = "text-lg font-semibold text-gray-900 dark:text-white text-center";
    titleElement.textContent = title;

    titleContainer.appendChild(titleElement);

    // Add close X button if enabled
    if (showCloseButton) {
      const closeButton = document.createElement("button");
      closeButton.className = "close-button";
      closeButton.innerHTML = "Ã—";
      closeButton.style.cssText = `
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        font-size: 24px;
        font-weight: bold;
        color: #6b7280;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        min-height: 32px;
      `;

      closeButton.addEventListener("mouseenter", () => {
        closeButton.style.background = "#ef4444";
        closeButton.style.color = "white";
        closeButton.style.transform = "translateY(-50%) scale(1.1)";
      });

      closeButton.addEventListener("mouseleave", () => {
        closeButton.style.background = "transparent";
        closeButton.style.color = "#6b7280";
        closeButton.style.transform = "translateY(-50%) scale(1)";
      });

      closeButton.addEventListener("click", () => {
        cleanupModal();
        modal.remove();
      });

      titleContainer.appendChild(closeButton);
    }

    // Create slot machine container
    const slotContainer = document.createElement("div");
    slotContainer.className =
      "relative h-48 overflow-hidden border-2 border-gray-200 dark:border-gray-600 rounded-lg mb-4";

    // Create options list
    const optionsList = document.createElement("ul");
    optionsList.className = "absolute inset-0 transition-transform duration-300 ease-out";
    optionsList.style.transform = "translateY(0px)";

    // Add options
    options.forEach((option, index) => {
      const li = document.createElement("li");
      li.className = "slot-machine-item";
      li.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 3rem;
        text-align: center;
        color: #111827;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px;
        padding: 12px 16px;
        user-select: none;
        position: relative;
      `;

      const span = document.createElement("span");
      span.className = "slot-machine-item-text";
      span.style.cssText = `
        text-align: center;
        font-weight: 500;
        transition: all 0.2s;
        width: 100%;
      `;

      // Add selected styling if this is the current value
      if (option.value === selectedValue) {
        li.classList.add("selected");
        li.style.cssText += `
          background: ${colors.selected.split(" ")[0]} !important;
          color: ${colors.selected.split(" ")[1]} !important;
          border-radius: 8px !important;
          margin: 0 8px !important;
          position: relative !important;
        `;
      }

      span.textContent = option.label;
      span.dataset.value = option.value;
      span.dataset.label = option.label;
      span.dataset.index = index;

      li.appendChild(span);
      optionsList.appendChild(li);
    });

    slotContainer.appendChild(optionsList);

    // Create action buttons
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "flex justify-center gap-2";

    // Add cancel button if enabled
    if (showCancelButton) {
      const cancelButton = document.createElement("button");
      cancelButton.className =
        "px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200";
      cancelButton.textContent = "Cancel";
      cancelButton.onclick = () => {
        cleanupModal();
        modal.remove();
      };
      buttonContainer.appendChild(cancelButton);
    }

    const selectButton = document.createElement("button");
    selectButton.className = `px-4 py-2 ${colors.modal} text-white rounded-md disabled:opacity-50`;
    selectButton.textContent = "Select";
    selectButton.disabled = true;

    buttonContainer.appendChild(selectButton);

    // Assemble modal
    modalContent.appendChild(titleContainer);
    modalContent.appendChild(slotContainer);
    modalContent.appendChild(buttonContainer);
    modal.appendChild(modalContent);

    // Slot machine functionality
    let selectedIndex = options.findIndex(
      (option) => option.value.toString() === selectedValue.toString()
    );
    if (selectedIndex === -1) selectedIndex = 0;

    console.log("ðŸŽ° [SLOT-MACHINE] Selection debug:", {
      selectedValue,
      selectedValueType: typeof selectedValue,
      options: options.map((opt) => ({
        value: opt.value,
        valueType: typeof opt.value,
        label: opt.label,
      })),
      selectedIndex,
      foundOption: options[selectedIndex],
    });

    // Center selected item
    function centerSelectedItem() {
      const itemHeight = 48;
      const containerHeight = 192;
      const centerOffset = (containerHeight - itemHeight) / 2;
      const targetY = -(selectedIndex * itemHeight) + centerOffset;

      // Use smooth transition
      optionsList.style.transition = "transform 0.2s ease-out";
      optionsList.style.transform = `translateY(${targetY}px)`;

      // Update centering (visual feedback only, no selection styling)
      updateCentering();
    }

    // Add checkmark to selected item
    function addCheckmark(item) {
      // Remove existing checkmark if any
      const existingCheckmark = item.querySelector(".checkmark");
      if (existingCheckmark) {
        existingCheckmark.remove();
      }

      const checkmark = document.createElement("div");
      checkmark.className = "checkmark";
      checkmark.innerHTML = "âœ“";
      checkmark.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        color: #10b981;
        font-weight: bold;
        font-size: 16px;
        animation: checkmarkPulse 1.5s ease-in-out infinite;
        z-index: 10;
      `;

      item.appendChild(checkmark);
    }

    // Remove checkmark from item
    function removeCheckmark(item) {
      const checkmark = item.querySelector(".checkmark");
      if (checkmark) {
        checkmark.remove();
      }
    }

    // Update selection styling (only for clicked items)
    function updateSelection() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        if (index === selectedIndex) {
          item.classList.add("selected");
          // Reset and apply selected styles
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-radius: 8px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            border: 2px solid #1d4ed8;
          `;
          addCheckmark(item);
          selectButton.disabled = false;
        } else {
          item.classList.remove("selected");
          item.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 3rem;
            text-align: center;
            color: #111827;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            padding: 12px 16px;
            user-select: none;
            position: relative;
          `;
          removeCheckmark(item);
        }
      });
    }

    // Update visual centering (without selection styling)
    function updateCentering() {
      const items = optionsList.querySelectorAll("li");
      items.forEach((item, index) => {
        // Only update the centering, not the selection styling
        if (index === selectedIndex) {
          // Just center the item visually, don't apply selected styling
          item.style.transform = "scale(1.05)";
          item.style.transition = "transform 0.2s ease-out";
        } else {
          item.style.transform = "scale(1)";
          item.style.transition = "transform 0.2s ease-out";
        }
      });
    }

    // Handle wheel events
    optionsList.addEventListener("wheel", (e) => {
      e.preventDefault();
      const itemHeight = 48;
      const deltaY = e.deltaY;

      // Calculate new index based on scroll direction
      if (deltaY > 0) {
        // Scrolling down - move to next item
        selectedIndex = Math.min(selectedIndex + 1, options.length - 1);
      } else {
        // Scrolling up - move to previous item
        selectedIndex = Math.max(selectedIndex - 1, 0);
      }

      // Smoothly center the selected item
      centerSelectedItem();
    });

    // Handle click on items
    optionsList.addEventListener("click", (e) => {
      const span = e.target.closest("span[data-index]");
      if (span) {
        selectedIndex = parseInt(span.dataset.index);
        centerSelectedItem();
        // Apply full selection styling on click
        updateSelection();
      }
    });

    // Handle select button
    selectButton.addEventListener("click", () => {
      const selectedOption = options[selectedIndex];
      if (selectedOption && onSelect) {
        cleanupModal();
        modal.remove();
        onSelect(selectedOption.value, selectedOption.label);
      }
    });

    // Cleanup function to restore body scroll
    function cleanupModal() {
      document.body.classList.remove("modal-open");
      document.body.style.overflow = "";
    }

    // Close modal when clicking outside
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        cleanupModal();
        modal.remove();
      }
    });

    // Initialize
    centerSelectedItem();
    // Apply selection styling to the initially selected item
    updateSelection();

    // Prevent body scroll when modal is open
    document.body.classList.add("modal-open");
    document.body.style.overflow = "hidden";

    // Add to DOM
    document.body.appendChild(modal);
  }
</script>

<style>
  /* Prevent body scroll when modal is open */
  body.modal-open {
    overflow: hidden !important;
    position: fixed !important;
    width: 100% !important;
  }

  /* Prevent text selection in modal */
  .slot-machine-item {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
  }

  @keyframes checkmarkPulse {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes checkmarkPulseDark {
    0%,
    100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.8);
    }
    50% {
      opacity: 0.9;
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 0 16px rgba(16, 185, 129, 1);
    }
  }
</style>
