---
/**
 * AdminMedia Component
 * Media manager panel - can be embedded in any page
 */
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import { checkAuth } from "../../lib/auth";
import { supabaseAdmin } from "../../lib/supabase-admin";

export interface Props {
  currentUser: any;
  supabase: any;
  globalInputClasses?: string;
}

const { currentUser, supabase, globalInputClasses = "" } = Astro.props;

// Fetch media files from database
let projectFiles: any[] = [];
let globalFiles: any[] = [];
let storageFiles: any[] = [];
let error: string | null = null;

try {
  // Use supabaseAdmin for database queries (has proper permissions)
  if (supabaseAdmin) {
    // Fetch project files - use select("*") to get all columns regardless of naming convention
    const { data: files, error: filesError } = await supabaseAdmin
      .from("files")
      .select("*")
      .limit(200); // Get more files, we'll sort and limit in JS

    if (filesError) {
      console.error("âŒ [ADMIN-MEDIA] Error fetching project files:", filesError);
    } else {
      console.log(`âœ… [ADMIN-MEDIA] Fetched ${files?.length || 0} project files`);
      if (files && files.length > 0) {
        console.log("ðŸ“ [ADMIN-MEDIA] Sample project file:", {
          id: files[0].id,
          fileName: files[0].fileName || files[0].file_name,
          filePath: files[0].filePath || files[0].file_path,
          bucketName: files[0].bucketName || files[0].bucket_name,
          keys: Object.keys(files[0]),
        });
      }
      // Sort by uploadedAt (handle both naming conventions) and limit
      projectFiles = (files || [])
        .sort((a: any, b: any) => {
          const aDate = a.uploadedAt || a.uploaded_at;
          const bDate = b.uploadedAt || b.uploaded_at;
          if (!aDate) return 1;
          if (!bDate) return -1;
          return new Date(bDate).getTime() - new Date(aDate).getTime();
        })
        .slice(0, 100);
    }

    // Fetch global files - try both table name variations
    let gFiles: any[] = [];
    let gFilesError: any = null;
    
    // Try filesGlobal first (camelCase)
    const result1 = await supabaseAdmin
      .from("filesGlobal")
      .select("*")
      .limit(200);
    
    if (result1.error) {
      console.warn("âš ï¸ [ADMIN-MEDIA] filesGlobal table not found, trying files_global:", result1.error);
      // Try snake_case version
      const result2 = await supabaseAdmin
        .from("files_global")
        .select("*")
        .limit(200);
      
      if (result2.error) {
        gFilesError = result2.error;
        console.error("âŒ [ADMIN-MEDIA] Error fetching global files (both table names failed):", result2.error);
      } else {
        gFiles = result2.data || [];
      }
    } else {
      gFiles = result1.data || [];
    }

    if (!gFilesError) {
      console.log(`âœ… [ADMIN-MEDIA] Fetched ${gFiles?.length || 0} global files`);
      if (gFiles && gFiles.length > 0) {
        console.log("ðŸ“ [ADMIN-MEDIA] Sample global file:", {
          id: gFiles[0].id,
          fileName: gFiles[0].fileName || gFiles[0].file_name || gFiles[0].name,
          filePath: gFiles[0].filePath || gFiles[0].file_path,
          keys: Object.keys(gFiles[0]),
        });
      }
      // Sort by uploadedAt (handle both naming conventions) and limit
      globalFiles = gFiles
        .sort((a: any, b: any) => {
          const aDate = a.uploadedAt || a.uploaded_at;
          const bDate = b.uploadedAt || b.uploaded_at;
          if (!aDate) return 1;
          if (!bDate) return -1;
          return new Date(bDate).getTime() - new Date(aDate).getTime();
        })
        .slice(0, 100);
    }

    // Get list of files from storage bucket directly (to see what actually exists)
    console.log("ðŸ” [ADMIN-MEDIA] Querying storage bucket for files...");
    
    // List root level files
    const { data: rootFiles, error: rootError } = await supabaseAdmin.storage
      .from("project-media")
      .list("", { limit: 100, sortBy: { column: "created_at", order: "desc" } });
    
    if (rootError) {
      console.error("âŒ [ADMIN-MEDIA] Error listing root files:", rootError);
    } else {
      console.log(`ðŸ“¦ [ADMIN-MEDIA] Found ${rootFiles?.length || 0} items in storage root`);
    }

    // List global folder files
    const { data: globalStorageFiles, error: globalStorageError } = await supabaseAdmin.storage
      .from("project-media")
      .list("global", { limit: 100, sortBy: { column: "created_at", order: "desc" } });

    if (globalStorageError) {
      console.error("âŒ [ADMIN-MEDIA] Error listing global storage files:", globalStorageError);
    } else {
      console.log(`ðŸ“¦ [ADMIN-MEDIA] Found ${globalStorageFiles?.length || 0} files in storage/global folder`);
      if (globalStorageFiles && globalStorageFiles.length > 0) {
        console.log("ðŸ“¦ [ADMIN-MEDIA] Sample storage file:", globalStorageFiles[0]);
      }
      storageFiles = (globalStorageFiles || []).filter((f: any) => f.name !== ".emptyFolderPlaceholder");
    }
  } else {
    console.error("âŒ [ADMIN-MEDIA] supabaseAdmin not available");
    error = "Database connection not available";
  }
} catch (fetchError) {
  console.error("âŒ [ADMIN-MEDIA] Error fetching media:", fetchError);
  error = "Failed to fetch media files";
}

// Helper function to get filePath regardless of naming convention (camelCase or snake_case)
function getFilePath(file: any): string | null {
  return file.filePath || file.file_path || null;
}

// Helper function to get bucketName regardless of naming convention
function getBucketName(file: any): string {
  return file.bucketName || file.bucket_name || "project-media";
}

// Helper function to get fileName regardless of naming convention
function getFileName(file: any): string | null {
  return file.fileName || file.file_name || file.name || null;
}

// Helper function to get fileType regardless of naming convention
function getFileType(file: any): string | null {
  return file.fileType || file.file_type || null;
}

// Helper function to get fileSize regardless of naming convention
function getFileSize(file: any): number | null {
  return file.fileSize || file.file_size || null;
}

// Helper function to get uploadedAt regardless of naming convention
function getUploadedAt(file: any): string | null {
  return file.uploadedAt || file.uploaded_at || null;
}

// Helper function to get projectId regardless of naming convention
function getProjectId(file: any): number | null {
  return file.projectId || file.project_id || null;
}

// Generate signed URLs for all files
async function generateSignedUrls(files: any[], source: string) {
  if (!supabaseAdmin) {
    console.error("âŒ [ADMIN-MEDIA] supabaseAdmin not available");
    return files.map((f: any) => ({
      ...f,
      source: source,
      fileName: getFileName(f),
      filePath: getFilePath(f),
      fileType: getFileType(f),
      fileSize: getFileSize(f),
      uploadedAt: getUploadedAt(f),
      projectId: getProjectId(f),
      bucketName: getBucketName(f),
      publicUrl: null,
    }));
  }
  
  console.log(`ðŸ”§ [ADMIN-MEDIA] Generating signed URLs for ${files.length} files from ${source}`);
  
  return await Promise.all(
    files.map(async (f: any) => {
      const filePath = getFilePath(f);
      const bucketName = getBucketName(f);
      let publicUrl: string | null = null;

      if (!filePath) {
        console.warn(`âš ï¸ [ADMIN-MEDIA] File ${f.id} has no filePath:`, f);
        return {
          ...f,
          source: source,
          fileName: getFileName(f),
          filePath: null,
          fileType: getFileType(f),
          fileSize: getFileSize(f),
          uploadedAt: getUploadedAt(f),
          projectId: getProjectId(f),
          bucketName: bucketName,
          publicUrl: null,
        };
      }

      try {
        console.log(`ðŸ”§ [ADMIN-MEDIA] Generating signed URL for: bucket=${bucketName}, path=${filePath}`);
        const { data: urlData, error: urlError } = await supabaseAdmin.storage
          .from(bucketName)
          .createSignedUrl(filePath, 3600); // 1 hour expiry

        if (!urlError && urlData?.signedUrl) {
          publicUrl = urlData.signedUrl;
          console.log(`âœ… [ADMIN-MEDIA] Generated signed URL for ${filePath}`);
        } else {
          console.warn(`âŒ [ADMIN-MEDIA] Failed to generate signed URL for ${filePath}:`, urlError);
        }
      } catch (error) {
        console.error(`âŒ [ADMIN-MEDIA] Error generating signed URL for ${filePath}:`, error);
      }

      return {
        ...f,
        source: source,
        fileName: getFileName(f),
        filePath: filePath,
        fileType: getFileType(f),
        fileSize: getFileSize(f),
        uploadedAt: getUploadedAt(f),
        projectId: getProjectId(f),
        bucketName: bucketName,
        publicUrl: publicUrl,
      };
    })
  );
}

// Generate signed URLs for all files
const projectFilesWithUrls = await generateSignedUrls(projectFiles, "project");
const globalFilesWithUrls = await generateSignedUrls(globalFiles, "global");

// Also process storage files that might not be in database
const storageFilesWithUrls = await Promise.all(
  storageFiles.map(async (storageFile: any) => {
    const filePath = `global/${storageFile.name}`;
    let publicUrl: string | null = null;

    if (supabaseAdmin) {
      try {
        const { data: urlData, error: urlError } = await supabaseAdmin.storage
          .from("project-media")
          .createSignedUrl(filePath, 3600);

        if (!urlError && urlData?.signedUrl) {
          publicUrl = urlData.signedUrl;
        }
      } catch (error) {
        console.error(`Error generating URL for storage file ${filePath}:`, error);
      }
    }

    return {
      id: `storage-${storageFile.name}`,
      fileName: storageFile.name,
      filePath: filePath,
      fileType: storageFile.metadata?.mimetype || null,
      fileSize: storageFile.metadata?.size || null,
      uploadedAt: storageFile.created_at || null,
      source: "storage",
      bucketName: "project-media",
      publicUrl: publicUrl,
    };
  })
);

// Combine all files (database files + storage-only files)
const allFiles = [...projectFilesWithUrls, ...globalFilesWithUrls, ...storageFilesWithUrls];

// Stats
const stats = {
  total: allFiles.length,
  project: projectFiles.length,
  global: globalFiles.length,
  images: allFiles.filter((f: any) => {
    const fileType = f.fileType || f.file_type;
    return fileType?.startsWith("image/");
  }).length,
  documents: allFiles.filter((f: any) => {
    const fileType = f.fileType || f.file_type;
    return fileType?.includes("pdf") || fileType?.includes("document");
  }).length,
};

// Helper to format file size
function formatFileSize(bytes: number | null): string {
  if (!bytes) return "â€”";
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

// Helper to get file icon
function getFileIcon(fileType: string | null, fileName?: string | null): string {
  if (!fileType && !fileName) return "file";
  
  const type = fileType?.toLowerCase() || "";
  const name = fileName?.toLowerCase() || "";
  
  if (type.startsWith("image/") || name.match(/\.(webp|avif|svg|png|jpg|jpeg|gif|ico|bmp|tiff?)$/)) return "image";
  if (type.includes("pdf") || name.endsWith(".pdf")) return "file-pdf";
  if (type.includes("word") || type.includes("document") || name.match(/\.(doc|docx)$/)) return "file-word";
  if (type.includes("excel") || type.includes("spreadsheet") || name.match(/\.(xls|xlsx|csv)$/)) return "spreadsheet";
  if (type.includes("video") || name.match(/\.(mp4|webm|mov|avi|mkv)$/)) return "video";
  if (type.includes("audio") || name.match(/\.(mp3|wav|ogg|m4a|flac)$/)) return "music";
  if (type.includes("zip") || type.includes("archive") || name.match(/\.(zip|rar|7z|tar|gz)$/)) return "archive";
  
  return "file";
}
---

<div class="admin-media-component">
  <!-- Header -->
  <div class="mb-6">
    <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Media Manager</h1>
    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
      Browse, upload, and manage all media files across the system.
    </p>
  </div>

  <!-- Stats Cards -->
  <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-gray-900 dark:text-white">{stats.total}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Total Files</div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-blue-600 dark:text-blue-400">{stats.project}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Project Files</div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-green-600 dark:text-green-400">{stats.global}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Global Files</div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-purple-600 dark:text-purple-400">{stats.images}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Images</div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-orange-600 dark:text-orange-400">{stats.documents}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Documents</div>
    </div>
  </div>

  <!-- Actions Bar -->
  <div class="flex flex-wrap gap-3 mb-6 items-center">
    <Button id="upload-btn" variant="primary" icon="upload">
      Upload File
    </Button>
    <input type="file" id="file-input" class="hidden" multiple accept="image/*,image/webp,image/avif,image/svg+xml,application/pdf,.doc,.docx,.xls,.xlsx" />
    
    <div class="flex-1 min-w-[200px]">
      <input
        type="text"
        id="search-input"
        placeholder="Search files..."
        class={globalInputClasses}
      />
    </div>
    
    <select id="filter-source" class={`${globalInputClasses} w-auto`}>
      <option value="all">All Sources</option>
      <option value="project">Project Files</option>
      <option value="global">Global Files</option>
    </select>
    
    <select id="filter-type" class={`${globalInputClasses} w-auto`}>
      <option value="all">All Types</option>
      <option value="image">Images</option>
      <option value="pdf">PDFs</option>
      <option value="document">Documents</option>
      <option value="other">Other</option>
    </select>
  </div>

  <!-- Error Display -->
  {error && (
    <div class="mb-6 p-4 bg-red-100 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-700 dark:text-red-300">
      {error}
    </div>
  )}

  <!-- Files Grid -->
  <div id="files-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
    {allFiles.length === 0 ? (
      <div class="col-span-full text-center py-12 text-gray-500 dark:text-gray-400">
        <SimpleIcon name="folder-open" class="w-16 h-16 mx-auto mb-4 opacity-50" />
        <p class="text-lg font-medium">No files found</p>
        <p class="text-sm">Upload your first file to get started</p>
      </div>
    ) : (
      allFiles.map((file: any) => (
        <div 
          class="file-card group bg-white dark:bg-gray-800 rounded-lg shadow hover:shadow-lg transition-shadow overflow-hidden cursor-pointer"
          data-file-id={file.id}
          data-file-name={file.fileName}
          data-file-path={file.filePath}
          data-file-type={file.fileType}
          data-file-size={file.fileSize}
          data-file-url={file.publicUrl}
          data-file-source={file.source}
          data-project-id={file.projectId}
        >
          <!-- Preview -->
          <div class="aspect-square bg-gray-100 dark:bg-gray-700 flex items-center justify-center relative overflow-hidden">
            {(file.fileType?.startsWith("image/") || file.fileName?.match(/\.(webp|avif|svg|png|jpg|jpeg|gif)$/i)) && file.publicUrl ? (
              <img 
                src={file.publicUrl} 
                alt={file.fileName}
                class="w-full h-full object-cover"
                loading="lazy"
              />
            ) : (
              <SimpleIcon name={getFileIcon(file.fileType, file.fileName)} class="w-12 h-12 text-gray-400" />
            )}
            
            <!-- Source Badge -->
            <span class={`absolute top-2 right-2 text-xs px-2 py-1 rounded-full ${
              file.source === "global" 
                ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
                : "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
            }`}>
              {file.source === "global" ? "Global" : `P#${file.projectId || "?"}`}
            </span>
            
            <!-- Hover Actions -->
            <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
              <button 
                class="copy-url-btn p-2 bg-white rounded-full hover:bg-gray-100 text-gray-700"
                title="Copy URL"
              >
                <SimpleIcon name="copy" class="w-4 h-4" />
              </button>
              {file.publicUrl && (
                <a 
                  href={file.publicUrl} 
                  target="_blank"
                  class="p-2 bg-white rounded-full hover:bg-gray-100 text-gray-700"
                  title="Open in new tab"
                >
                  <SimpleIcon name="link-external" class="w-4 h-4" />
                </a>
              )}
              <button 
                id={`delete-btn-${file.id}`}
                class="delete-file-btn p-2 bg-red-500 rounded-full hover:bg-red-600 text-white"
                title="Delete"
                data-state="trash"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
              </button>
            </div>
          </div>
          
          <!-- Info -->
          <div class="p-3">
            <div class="text-sm font-medium text-gray-900 dark:text-white truncate" title={file.fileName}>
              {file.fileName || "Unnamed"}
            </div>
            <div class="text-xs text-gray-500 dark:text-gray-400 flex justify-between mt-1">
              <span>{formatFileSize(file.fileSize)}</span>
              <span>{file.uploadedAt ? new Date(file.uploadedAt).toLocaleDateString() : "â€”"}</span>
            </div>
          </div>
        </div>
      ))
    )}
  </div>

  <!-- Empty State for Filtered Results -->
  <div id="no-results" class="hidden text-center py-12 text-gray-500 dark:text-gray-400">
    <SimpleIcon name="search" class="w-16 h-16 mx-auto mb-4 opacity-50" />
    <p class="text-lg font-medium">No matching files</p>
    <p class="text-sm">Try adjusting your search or filters</p>
  </div>

  <!-- Upload Progress -->
  <div id="upload-progress" class="hidden fixed bottom-4 right-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 min-w-[300px]">
    <div class="flex items-center gap-3 mb-2">
      <div class="animate-spin">
        <SimpleIcon name="loader-2" class="w-5 h-5 text-primary-500" />
      </div>
      <span class="text-sm font-medium text-gray-900 dark:text-white">Uploading...</span>
    </div>
    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
      <div id="progress-bar" class="bg-primary-500 h-2 rounded-full transition-all" style="width: 0%"></div>
    </div>
    <div id="progress-text" class="text-xs text-gray-500 dark:text-gray-400 mt-1">0%</div>
  </div>
</div>

<style>
  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }

  .pulse {
    animation: pulse 0.8s ease-in-out infinite;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const uploadBtn = document.getElementById("upload-btn");
    const fileInput = document.getElementById("file-input") as HTMLInputElement;
    const searchInput = document.getElementById("search-input") as HTMLInputElement;
    const filterSource = document.getElementById("filter-source") as HTMLSelectElement;
    const filterType = document.getElementById("filter-type") as HTMLSelectElement;
    const filesGrid = document.getElementById("files-grid");
    const noResults = document.getElementById("no-results");
    const uploadProgress = document.getElementById("upload-progress");
    const progressBar = document.getElementById("progress-bar");
    const progressText = document.getElementById("progress-text");

    // Confirm delete utility (same as ProposalManager)
    function confirmDelete(buttonId: string, onConfirm: () => void, options: any = {}) {
      const {
        timeout = 3000,
        confirmIcon = '<span class="text-lg font-bold">?</span>',
        trashIcon = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>`,
      } = options;

      const button = document.getElementById(buttonId);
      if (!button) return;

      const currentState = button.getAttribute("data-state") || "trash";

      if (currentState === "trash") {
        // First click: Show confirmation icon
        button.innerHTML = confirmIcon;
        button.setAttribute("data-state", "confirm");
        button.title = "Click again to confirm deletion";
        button.className =
          "delete-file-btn p-2 bg-white text-red-600 rounded-full hover:bg-red-600 hover:text-white transition-all pulse";

        // Auto-revert after timeout
        const timeoutId = setTimeout(() => {
          if (button.getAttribute("data-state") === "confirm") {
            button.innerHTML = trashIcon;
            button.setAttribute("data-state", "trash");
            button.title = "Delete";
            button.className =
              "delete-file-btn p-2 bg-red-500 rounded-full hover:bg-red-600 text-white";
            button.removeAttribute("data-timeout-id");
          }
        }, timeout);

        button.setAttribute("data-timeout-id", timeoutId.toString());
      } else if (currentState === "confirm") {
        // Second click: Execute deletion
        const timeoutId = button.getAttribute("data-timeout-id");
        if (timeoutId) {
          clearTimeout(parseInt(timeoutId, 10));
        }
        
        // Reset button state
        button.innerHTML = trashIcon;
        button.setAttribute("data-state", "trash");
        button.title = "Delete";
        button.className =
          "delete-file-btn p-2 bg-red-500 rounded-full hover:bg-red-600 text-white";
        
        // Execute callback
        onConfirm();
      }
    }

    // Format file size helper
    function formatFileSize(bytes: number | null): string {
      if (!bytes) return "â€”";
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }

    // Upload handler
    uploadBtn?.addEventListener("click", () => {
      fileInput?.click();
    });

    fileInput?.addEventListener("change", async () => {
      const files = fileInput.files;
      if (!files || files.length === 0) return;

      uploadProgress?.classList.remove("hidden");
      let successCount = 0;
      let failCount = 0;
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const progress = ((i + 1) / files.length) * 100;
        
        try {
          const reader = new FileReader();
          const base64Promise = new Promise<string>((resolve, reject) => {
            reader.onload = () => resolve(reader.result as string);
            reader.onerror = reject;
          });
          reader.readAsDataURL(file);
          const base64 = await base64Promise;

          const response = await fetch("/api/admin/media", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              mediaData: base64,
              fileName: file.name,
              fileType: file.type,
              targetLocation: "global",
            }),
          });

          if (!response.ok) {
            const result = await response.json();
            throw new Error(result.error || "Upload failed");
          }
          
          successCount++;

          if (progressBar) progressBar.style.width = `${progress}%`;
          if (progressText) progressText.textContent = `${Math.round(progress)}%`;
        } catch (error) {
          console.error("Upload error:", error);
          failCount++;
          if ((window as any).showModal) {
            (window as any).showModal("error", "Upload Failed", `Failed to upload ${file.name}`, 3000);
          }
        }
      }

      // Hide progress indicator
      setTimeout(() => {
        uploadProgress?.classList.add("hidden");
        if (progressBar) progressBar.style.width = "0%";
        if (progressText) progressText.textContent = "0%";
      }, 500);

      // Show summary and reload only if files were uploaded
      if (successCount > 0) {
        if ((window as any).showModal) {
          (window as any).showModal(
            "success", 
            "Upload Complete", 
            `${successCount} file${successCount > 1 ? 's' : ''} uploaded successfully${failCount > 0 ? ` (${failCount} failed)` : ''}`, 
            2000
          );
        }
        
        // Reload to show new files (needed because server-side rendering)
        setTimeout(() => {
          location.reload();
        }, 2000);
      }
      
      // Reset file input
      fileInput.value = "";
    });

    // Search and filter
    function filterFiles() {
      const search = searchInput?.value.toLowerCase() || "";
      const source = filterSource?.value || "all";
      const type = filterType?.value || "all";
      
      const cards = filesGrid?.querySelectorAll(".file-card") as NodeListOf<HTMLElement>;
      let visibleCount = 0;

      cards?.forEach((card) => {
        const fileName = card.dataset.fileName?.toLowerCase() || "";
        const fileType = card.dataset.fileType?.toLowerCase() || "";
        const fileSource = card.dataset.fileSource || "";

        let show = true;

        if (search && !fileName.includes(search)) show = false;
        if (source !== "all" && fileSource !== source) show = false;

        if (type !== "all") {
          if (type === "image" && !fileType.startsWith("image/")) show = false;
          if (type === "pdf" && !fileType.includes("pdf")) show = false;
          if (type === "document" && !fileType.includes("word") && !fileType.includes("document") && !fileType.includes("excel")) show = false;
          if (type === "other" && (fileType.startsWith("image/") || fileType.includes("pdf") || fileType.includes("document"))) show = false;
        }

        card.style.display = show ? "" : "none";
        if (show) visibleCount++;
      });

      if (noResults) {
        noResults.classList.toggle("hidden", visibleCount > 0 || cards?.length === 0);
      }
    }

    searchInput?.addEventListener("input", filterFiles);
    filterSource?.addEventListener("change", filterFiles);
    filterType?.addEventListener("change", filterFiles);

    // File card click handlers
    filesGrid?.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      const card = target.closest(".file-card") as HTMLElement;
      
      if (!card) return;

      if (target.closest(".copy-url-btn")) {
        const url = card.dataset.fileUrl;
        if (url) {
          navigator.clipboard.writeText(url);
          if ((window as any).showModal) {
            (window as any).showModal("success", "Success", "URL copied to clipboard!", 2000);
          }
        }
        return;
      }

      if (target.closest(".delete-file-btn")) {
        const deleteBtn = target.closest(".delete-file-btn") as HTMLElement;
        const buttonId = deleteBtn.id;
        
        confirmDelete(buttonId, () => {
          deleteFile(card);
        });
        return;
      }
    });

    async function deleteFile(card: HTMLElement) {
      const fileId = card.dataset.fileId;
      const source = card.dataset.fileSource;
      
      if (!fileId) return;

      try {
        const response = await fetch("/api/admin/media", {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fileId, source }),
        });

        if (response.ok) {
          // Remove the card with a fade-out animation
          card.style.transition = "opacity 0.3s, transform 0.3s";
          card.style.opacity = "0";
          card.style.transform = "scale(0.9)";
          
          setTimeout(() => {
            card.remove();
            
            // Update stats after deletion
            updateStats();
            
            // Check if we need to show the empty state
            const remainingCards = filesGrid?.querySelectorAll(".file-card:not([style*='display: none'])");
            if (remainingCards && remainingCards.length === 0) {
              const noResultsElement = document.getElementById("no-results");
              if (noResultsElement) {
                noResultsElement.classList.remove("hidden");
              }
            }
          }, 300);
          
          if ((window as any).showModal) {
            (window as any).showModal("success", "Success", "File deleted successfully", 2000);
          }
        } else {
          const result = await response.json();
          throw new Error(result.error || "Delete failed");
        }
      } catch (error) {
        console.error("Delete error:", error);
        alert(`Failed to delete file: ${error}`);
      }
    }

    // Update stats dynamically
    function updateStats() {
      const cards = filesGrid?.querySelectorAll(".file-card") as NodeListOf<HTMLElement>;
      
      let totalCount = 0;
      let projectCount = 0;
      let globalCount = 0;
      let imageCount = 0;
      let documentCount = 0;
      
      cards?.forEach((card) => {
        totalCount++;
        const source = card.dataset.fileSource;
        const fileType = card.dataset.fileType?.toLowerCase() || "";
        
        if (source === "project") projectCount++;
        if (source === "global") globalCount++;
        if (fileType.startsWith("image/")) imageCount++;
        if (fileType.includes("pdf") || fileType.includes("document")) documentCount++;
      });
      
      // Update stat displays
      const stats = [
        { selector: ".bg-white.dark\\:bg-gray-800:nth-child(1) .text-2xl", value: totalCount },
        { selector: ".bg-white.dark\\:bg-gray-800:nth-child(2) .text-2xl", value: projectCount },
        { selector: ".bg-white.dark\\:bg-gray-800:nth-child(3) .text-2xl", value: globalCount },
        { selector: ".bg-white.dark\\:bg-gray-800:nth-child(4) .text-2xl", value: imageCount },
        { selector: ".bg-white.dark\\:bg-gray-800:nth-child(5) .text-2xl", value: documentCount },
      ];
      
      stats.forEach(({ selector, value }) => {
        const element = document.querySelector(selector);
        if (element) {
          element.textContent = value.toString();
        }
      });
    }
  });
</script>
