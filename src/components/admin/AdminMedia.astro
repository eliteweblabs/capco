---
/**
 * AdminMedia Component
 * Media manager panel - can be embedded in any page
 */
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";
import DeleteConfirmButton from "../common/DeleteConfirmButton.astro";
import GridFilter from "../../features/grid-filter/GridFilter.astro";
import { checkAuth } from "../../lib/auth";
import { supabaseAdmin } from "../../lib/supabase-admin";

export interface Props {
  currentUser: any;
  supabase: any;
  globalInputClasses?: string;
}

const { currentUser, supabase, globalInputClasses = "" } = Astro.props;

// Fetch media files from database
let projectFiles: any[] = [];
let globalFiles: any[] = [];
let storageFiles: any[] = [];
let rootFileList: any[] = [];
let error: string | null = null;

try {
  // Use supabaseAdmin for database queries (has proper permissions)
  if (supabaseAdmin) {
    // Fetch project files - use select("*") to get all columns regardless of naming convention
    const { data: files, error: filesError } = await supabaseAdmin
      .from("files")
      .select("*")
      .limit(200); // Get more files, we'll sort and limit in JS

    if (filesError) {
      console.error("‚ùå [ADMIN-MEDIA] Error fetching project files:", filesError);
    } else {
      console.log(`‚úÖ [ADMIN-MEDIA] Fetched ${files?.length || 0} project files`);
      if (files && files.length > 0) {
        console.log("üìÅ [ADMIN-MEDIA] Sample project file:", {
          id: files[0].id,
          fileName: files[0].fileName || files[0].file_name,
          filePath: files[0].filePath || files[0].file_path,
          bucketName: files[0].bucketName || files[0].bucket_name,
          keys: Object.keys(files[0]),
        });
      }
      // Sort by uploadedAt (handle both naming conventions) and limit
      projectFiles = (files || [])
        .sort((a: any, b: any) => {
          const aDate = a.uploadedAt || a.uploaded_at;
          const bDate = b.uploadedAt || b.uploaded_at;
          if (!aDate) return 1;
          if (!bDate) return -1;
          return new Date(bDate).getTime() - new Date(aDate).getTime();
        })
        .slice(0, 100);
    }

    // Fetch global files - try both table name variations
    let gFiles: any[] = [];
    let gFilesError: any = null;
    
    // Try filesGlobal first (camelCase)
    const result1 = await supabaseAdmin
      .from("filesGlobal")
      .select("*")
      .limit(200);
    
    if (result1.error) {
      console.warn("‚ö†Ô∏è [ADMIN-MEDIA] filesGlobal table not found, trying files_global:", result1.error);
      // Try snake_case version
      const result2 = await supabaseAdmin
        .from("files_global")
        .select("*")
        .limit(200);
      
      if (result2.error) {
        gFilesError = result2.error;
        console.error("‚ùå [ADMIN-MEDIA] Error fetching global files (both table names failed):", result2.error);
      } else {
        gFiles = result2.data || [];
      }
    } else {
      gFiles = result1.data || [];
    }

    if (!gFilesError) {
      console.log(`‚úÖ [ADMIN-MEDIA] Fetched ${gFiles?.length || 0} global files`);
      if (gFiles && gFiles.length > 0) {
        console.log("üìÅ [ADMIN-MEDIA] Sample global file:", {
          id: gFiles[0].id,
          fileName: gFiles[0].fileName || gFiles[0].file_name || gFiles[0].name,
          filePath: gFiles[0].filePath || gFiles[0].file_path,
          keys: Object.keys(gFiles[0]),
        });
      }
      // Sort by uploadedAt (handle both naming conventions) and limit
      globalFiles = gFiles
        .sort((a: any, b: any) => {
          const aDate = a.uploadedAt || a.uploaded_at;
          const bDate = b.uploadedAt || b.uploaded_at;
          if (!aDate) return 1;
          if (!bDate) return -1;
          return new Date(bDate).getTime() - new Date(aDate).getTime();
        })
        .slice(0, 100);
    }

    // Get list of files from storage bucket directly (to see what actually exists)
    console.log("üîç [ADMIN-MEDIA] Querying storage bucket for files...");
    
    // List root level files
    const { data: rootFiles, error: rootError } = await supabaseAdmin.storage
      .from("project-media")
      .list("", { limit: 100, sortBy: { column: "created_at", order: "desc" } });
    
    if (rootError) {
      console.error("‚ùå [ADMIN-MEDIA] Error listing root files:", rootError);
    } else {
      rootFileList = rootFiles || [];
      console.log(`üì¶ [ADMIN-MEDIA] Found ${rootFileList.length} items in storage root`);
    }

    // List global folder files
    const { data: globalStorageFiles, error: globalStorageError } = await supabaseAdmin.storage
      .from("project-media")
      .list("global", { limit: 100, sortBy: { column: "created_at", order: "desc" } });

    if (globalStorageError) {
      console.error("‚ùå [ADMIN-MEDIA] Error listing global storage files:", globalStorageError);
    } else {
      console.log(`üì¶ [ADMIN-MEDIA] Found ${globalStorageFiles?.length || 0} files in storage/global folder`);
      if (globalStorageFiles && globalStorageFiles.length > 0) {
        console.log("üì¶ [ADMIN-MEDIA] Sample storage file:", globalStorageFiles[0]);
      }
      storageFiles = (globalStorageFiles || []).filter((f: any) => f.name !== ".emptyFolderPlaceholder");
    }
  } else {
    console.error("‚ùå [ADMIN-MEDIA] supabaseAdmin not available");
    error = "Database connection not available";
  }
} catch (fetchError) {
  console.error("‚ùå [ADMIN-MEDIA] Error fetching media:", fetchError);
  error = "Failed to fetch media files";
}

// Screen media: delete DB records that point to missing storage files (orphans)
if (supabaseAdmin && !error) {
  try {
    const bucket = "project-media";
    const existingPaths = new Set<string>();

    // Root-level files
    const rootList = rootFileList || [];
    for (const item of rootList) {
      if (item.name && item.name !== ".emptyFolderPlaceholder") {
        existingPaths.add(item.name);
      }
    }
    // Global folder (we already have storageFiles)
    for (const f of storageFiles) {
      if (f.name) existingPaths.add(`global/${f.name}`);
    }

    // Fetch all project-media file paths from DB to find orphans and to list project folders
    const { data: allFilesForScreen } = await supabaseAdmin
      .from("files")
      .select("id, filePath")
      .eq("bucketName", bucket)
      .limit(1000);

    const dbPaths = (allFilesForScreen || []).map((r: any) => r.filePath || r.file_path).filter(Boolean) as string[];
    const uniqueParents = new Set<string>();
    for (const p of dbPaths) {
      const parts = p.split("/");
      if (parts.length > 1) {
        uniqueParents.add(parts.slice(0, -1).join("/"));
      }
    }
    const parents = Array.from(uniqueParents).slice(0, 80);
    for (const parent of parents) {
      const { data: folderList } = await supabaseAdmin.storage.from(bucket).list(parent, { limit: 500 });
      const list = folderList || [];
      for (const item of list) {
        if (item.name && item.name !== ".emptyFolderPlaceholder") {
          const fullPath = parent ? `${parent}/${item.name}` : item.name;
          existingPaths.add(fullPath);
        }
      }
    }

    // Delete orphaned rows in files (project-media)
    const orphanFileIds = (allFilesForScreen || [])
      .filter((r: any) => {
        const path = r.filePath || r.file_path;
        return path && !existingPaths.has(path);
      })
      .map((r: any) => r.id);
    if (orphanFileIds.length > 0) {
      const { error: delErr } = await supabaseAdmin.from("files").delete().in("id", orphanFileIds);
      if (delErr) console.error("‚ùå [ADMIN-MEDIA] Error deleting orphaned files:", delErr);
      else console.log(`üóëÔ∏è [ADMIN-MEDIA] Deleted ${orphanFileIds.length} orphaned file record(s) from files`);
      projectFiles = projectFiles.filter((f: any) => !orphanFileIds.includes(f.id));
    }

    // Delete orphaned rows in filesGlobal (path must exist in global/ in storage)
    const globalPathSet = new Set(storageFiles.map((f: any) => (f.name ? `global/${f.name}` : "")).filter(Boolean));
    const orphanGlobalIds = globalFiles
      .filter((f: any) => {
        const path = f.filePath || f.file_path || (f.fileName || f.file_name || f.name ? `global/${f.fileName || f.file_name || f.name}` : null);
        return path && !globalPathSet.has(path);
      })
      .map((f: any) => f.id);
    if (orphanGlobalIds.length > 0) {
      const { error: delErr } = await supabaseAdmin.from("filesGlobal").delete().in("id", orphanGlobalIds);
      if (delErr) {
        const res2 = await supabaseAdmin.from("files_global").delete().in("id", orphanGlobalIds);
        if (res2.error) console.error("‚ùå [ADMIN-MEDIA] Error deleting orphaned global file records:", delErr);
        else console.log(`üóëÔ∏è [ADMIN-MEDIA] Deleted ${orphanGlobalIds.length} orphaned record(s) from files_global`);
      } else {
        console.log(`üóëÔ∏è [ADMIN-MEDIA] Deleted ${orphanGlobalIds.length} orphaned record(s) from filesGlobal`);
      }
      globalFiles = globalFiles.filter((f: any) => !orphanGlobalIds.includes(f.id));
    }
  } catch (screenErr) {
    console.warn("‚ö†Ô∏è [ADMIN-MEDIA] Screening/orphan cleanup failed (non-fatal):", screenErr);
  }
}

// Helper function to get filePath regardless of naming convention (camelCase or snake_case)
function getFilePath(file: any): string | null {
  return file.filePath || file.file_path || null;
}

// Helper function to get bucketName regardless of naming convention
function getBucketName(file: any): string {
  return file.bucketName || file.bucket_name || "project-media";
}

// Helper function to get fileName regardless of naming convention
function getFileName(file: any): string | null {
  return file.fileName || file.file_name || file.name || null;
}

// Helper function to get fileType regardless of naming convention
function getFileType(file: any): string | null {
  return file.fileType || file.file_type || null;
}

// Helper function to get fileSize regardless of naming convention
function getFileSize(file: any): number | null {
  return file.fileSize || file.file_size || null;
}

// Helper function to get uploadedAt regardless of naming convention
function getUploadedAt(file: any): string | null {
  return file.uploadedAt || file.uploaded_at || null;
}

// Helper function to get projectId regardless of naming convention
function getProjectId(file: any): number | null {
  return file.projectId || file.project_id || null;
}

// Generate signed URLs for all files
async function generateSignedUrls(files: any[], source: string) {
  if (!supabaseAdmin) {
    console.error("‚ùå [ADMIN-MEDIA] supabaseAdmin not available");
    return files.map((f: any) => ({
      ...f,
      source: source,
      fileName: getFileName(f),
      filePath: getFilePath(f),
      fileType: getFileType(f),
      fileSize: getFileSize(f),
      uploadedAt: getUploadedAt(f),
      projectId: getProjectId(f),
      bucketName: getBucketName(f),
      publicUrl: null,
    }));
  }
  
  console.log(`üîß [ADMIN-MEDIA] Generating public URLs for ${files.length} files from ${source}`);
  
  return await Promise.all(
    files.map(async (f: any) => {
      const filePath = getFilePath(f);
      const bucketName = getBucketName(f);
      let publicUrl: string | null = null;

      if (!filePath) {
        console.warn(`‚ö†Ô∏è [ADMIN-MEDIA] File ${f.id} has no filePath:`, f);
        return {
          ...f,
          source: source,
          fileName: getFileName(f),
          filePath: null,
          fileType: getFileType(f),
          fileSize: getFileSize(f),
          uploadedAt: getUploadedAt(f),
          projectId: getProjectId(f),
          bucketName: bucketName,
          publicUrl: null,
        };
      }

      try {
        console.log(`üîß [ADMIN-MEDIA] Generating public URL for: bucket=${bucketName}, path=${filePath}`);
        const { data: urlData } = supabaseAdmin.storage
          .from(bucketName)
          .getPublicUrl(filePath);

        if (urlData?.publicUrl) {
          publicUrl = urlData.publicUrl;
          console.log(`‚úÖ [ADMIN-MEDIA] Generated public URL for ${filePath}`);
        } else {
          console.warn(`‚ùå [ADMIN-MEDIA] Failed to generate public URL for ${filePath}`);
        }
      } catch (error) {
        console.error(`‚ùå [ADMIN-MEDIA] Error generating public URL for ${filePath}:`, error);
      }

      return {
        ...f,
        source: source,
        fileName: getFileName(f),
        filePath: filePath,
        fileType: getFileType(f),
        fileSize: getFileSize(f),
        uploadedAt: getUploadedAt(f),
        projectId: getProjectId(f),
        bucketName: bucketName,
        publicUrl: publicUrl,
      };
    })
  );
}

// Generate public URLs for all files
const projectFilesWithUrls = await generateSignedUrls(projectFiles, "project");
const globalFilesWithUrls = await generateSignedUrls(globalFiles, "global");

// Filter out database records where the file doesn't exist in storage (orphaned records)
// Uses the already-fetched storageFiles list to check existence
function filterOrphanedFiles(files: any[], storageFileNames: Set<string>): any[] {
  if (files.length === 0) return files;
  
  const validFiles: any[] = [];
  
  for (const file of files) {
    const filePath = getFilePath(file);
    if (!filePath) {
      // Skip files without a path
      continue;
    }
    
    // Extract just the filename from the path (e.g., "global/image.jpg" -> "image.jpg")
    const fileName = filePath.split('/').pop() || '';
    const fileNameFromDb = getFileName(file) || fileName;
    
    // Determine if this is a global file (either from source or filePath)
    const isGlobalFile = file.source === 'global' || filePath.startsWith('global/');
    
    if (isGlobalFile) {
      // For global files, only show if they exist in storage
      // Check both the filename from path and the fileName from DB (in case of naming differences)
      if (storageFileNames.has(fileName) || storageFileNames.has(fileNameFromDb)) {
        validFiles.push(file);
      } else {
        console.log(`üóëÔ∏è [ADMIN-MEDIA] Filtering orphaned database record: ${filePath} (file not found in storage)`);
      }
    } else {
      // For project files, include them (they might be in project-specific folders we didn't list)
      validFiles.push(file);
    }
  }
  
  return validFiles;
}

// Create a Set of storage file names for quick lookup
const storageFileNames = new Set(storageFiles.map((f: any) => f.name));

// Filter orphaned records (files in DB but not in storage)
const projectFilesFiltered = filterOrphanedFiles(projectFilesWithUrls, storageFileNames);
const globalFilesFiltered = filterOrphanedFiles(globalFilesWithUrls, storageFileNames);

// Also process storage files that might not be in database
const storageFilesWithUrls = await Promise.all(
  storageFiles.map(async (storageFile: any) => {
    const filePath = `global/${storageFile.name}`;
    let publicUrl: string | null = null;

    if (supabaseAdmin) {
      try {
        const { data: urlData } = supabaseAdmin.storage
          .from("project-media")
          .getPublicUrl(filePath);

        if (urlData?.publicUrl) {
          publicUrl = urlData.publicUrl;
        }
      } catch (error) {
        console.error(`Error generating URL for storage file ${filePath}:`, error);
      }
    }

    return {
      id: `storage-${storageFile.name}`,
      fileName: storageFile.name,
      filePath: filePath,
      fileType: storageFile.metadata?.mimetype || null,
      fileSize: storageFile.metadata?.size || null,
      uploadedAt: storageFile.created_at || null,
      source: "storage",
      bucketName: "project-media",
      publicUrl: publicUrl,
    };
  })
);

// Combine all files (database files + storage-only files) - use filtered versions
const allFiles = [...projectFilesFiltered, ...globalFilesFiltered, ...storageFilesWithUrls];

// Stats
const stats = {
  total: allFiles.length,
  project: projectFiles.length,
  global: globalFiles.length,
  images: allFiles.filter((f: any) => {
    const fileType = f.fileType || f.file_type;
    return fileType?.startsWith("image/");
  }).length,
  documents: allFiles.filter((f: any) => {
    const fileType = f.fileType || f.file_type;
    return fileType?.includes("pdf") || fileType?.includes("document");
  }).length,
};

// Helper to format file size
function formatFileSize(bytes: number | null): string {
  if (!bytes) return "‚Äî";
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

// Helper to get file icon
function getFileIcon(fileType: string | null, fileName?: string | null): string {
  if (!fileType && !fileName) return "file";
  
  const type = fileType?.toLowerCase() || "";
  const name = fileName?.toLowerCase() || "";
  
  if (type.startsWith("image/") || name.match(/\.(webp|avif|svg|png|jpg|jpeg|gif|ico|bmp|tiff?)$/)) return "image";
  if (type.includes("pdf") || name.endsWith(".pdf")) return "file-pdf";
  if (type.includes("word") || type.includes("document") || name.match(/\.(doc|docx)$/)) return "file-word";
  if (type.includes("excel") || type.includes("spreadsheet") || name.match(/\.(xls|xlsx|csv)$/)) return "spreadsheet";
  if (type.includes("video") || name.match(/\.(mp4|webm|mov|avi|mkv)$/)) return "video";
  if (type.includes("audio") || name.match(/\.(mp3|wav|ogg|m4a|flac)$/)) return "music";
  if (type.includes("zip") || type.includes("archive") || name.match(/\.(zip|rar|7z|tar|gz)$/)) return "archive";
  
  return "file";
}
---

<div class="admin-media-component">
  <!-- Header -->
  <div class="mb-6">
    <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Media Manager</h1>
    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
      Browse, upload, and manage all media files across the system.
    </p>
  </div>

  <!-- Stats Cards -->
  <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
    <div class="bg-white dark:bg-gray-900 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-gray-900 dark:text-white">{stats.total}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Total Files</div>
    </div>
    <div class="bg-white dark:bg-gray-900 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-blue-600 dark:text-blue-400">{stats.project}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Project Files</div>
    </div>
    <div class="bg-white dark:bg-gray-900 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-green-600 dark:text-green-400">{stats.global}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Global Files</div>
    </div>
    <div class="bg-white dark:bg-gray-900 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-purple-600 dark:text-purple-400">{stats.images}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Images</div>
    </div>
    <div class="bg-white dark:bg-gray-900 rounded-lg shadow p-4">
      <div class="text-2xl font-bold text-orange-600 dark:text-orange-400">{stats.documents}</div>
      <div class="text-sm text-gray-500 dark:text-gray-400">Documents</div>
    </div>
  </div>

  <!-- Actions Bar -->
  <div class="flex flex-wrap gap-3 mb-6 items-center">
    <Button id="upload-btn" variant="primary" icon="upload">
      Upload File
    </Button>
    <input type="file" id="file-input" class="hidden" multiple accept="image/*,image/webp,image/avif,image/svg+xml,application/pdf,.doc,.docx,.xls,.xlsx" />
  </div>

  <!-- Filter Component with Multi-Select -->
  <GridFilter
    dropdownFilters={{
      source: {
        label: "Source",
        options: [
          { value: "all", label: "All Sources" },
          { value: "project", label: "Project Files" },
          { value: "global", label: "Global Files" },
        ],
        defaultValue: "all",
        multiSelect: true
      },
      type: {
        label: "Type",
        options: [
          { value: "all", label: "All Types" },
          { value: "image", label: "Images" },
          { value: "pdf", label: "PDFs" },
          { value: "document", label: "Documents" },
          { value: "other", label: "Other" },
        ],
        defaultValue: "all",
        multiSelect: true
      }
    }}
    itemSelector=".file-card"
    showSearch={true}
    searchPlaceholder="Search files..."
    searchDataAttribute="data-file-name"
    globalInputClasses={globalInputClasses}
    noResultsId="no-results"
  />

  <!-- Error Display -->
  {error && (
    <div class="mb-6 p-4 bg-red-100 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-700 dark:text-red-300">
      {error}
    </div>
  )}

  <!-- Files Masonry Grid (8 columns on XL) -->
  <div id="files-grid" class="masonry-grid grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-3 auto-rows-[150px]">
    {allFiles.length === 0 ? (
      <div class="col-span-full text-center py-12 text-gray-500 dark:text-gray-400">
        <SimpleIcon name="folder-open" class="w-16 h-16 mx-auto mb-4 opacity-50" />
        <p class="text-lg font-medium">No files found</p>
        <p class="text-sm">Upload your first file to get started</p>
      </div>
    ) : (
      allFiles.map((file: any, index: number) => {
        // Create varied grid sizes for masonry effect
        const sizes = [
          { col: 1, row: 1 }, // 1x1 square
          { col: 1, row: 2 }, // 1x2 tall
          { col: 1, row: 4 }, // 1x4 very tall
          { col: 2, row: 1 }, // 2x1 wide
          { col: 3, row: 1 }, // 3x1 extra wide
          { col: 2, row: 2 }, // 2x2 large square
          { col: 1, row: 3 }, // 1x3 tall
          { col: 2, row: 3 }, // 2x3 large tall
        ];
        const sizePattern = sizes[index % sizes.length];
        const colSpan = `col-span-${sizePattern.col}`;
        const rowSpan = `row-span-${sizePattern.row}`;
        
        return (
        <div 
          class={`file-card group bg-white dark:bg-gray-900 rounded-lg shadow hover:shadow-xl transition-all duration-300 overflow-hidden cursor-pointer relative ${colSpan} ${rowSpan}`}
          data-file-id={file.id}
          data-file-name={file.fileName}
          data-file-path={file.filePath}
          data-file-type={file.fileType}
          data-file-size={file.fileSize}
          data-file-url={file.publicUrl}
          data-file-source={file.source}
          data-project-id={file.projectId}
        >
          <!-- Preview -->
          <div class="h-full bg-gray-100 dark:bg-gray-700 flex items-center justify-center relative overflow-hidden">
            {(file.fileType?.startsWith("image/") || file.fileName?.match(/\.(webp|avif|svg|png|jpg|jpeg|gif)$/i)) && file.publicUrl ? (
              <img 
                data-src={file.publicUrl}
                alt={file.fileName}
                class="lazyload w-full h-full object-cover blur-sm"
                loading="lazy"
              />
            ) : (
              <SimpleIcon name={getFileIcon(file.fileType, file.fileName)} class="w-12 h-12 text-gray-400" />
            )}
            
            <!-- Source Badge -->
            <span class={`absolute top-2 right-2 text-xs px-2 py-1 rounded-full backdrop-blur-md ${
              file.source === "global" 
                ? "bg-green-500/90 text-white"
                : "bg-blue-500/90 text-white"
            }`}>
              {file.source === "global" ? "Global" : `P#${file.projectId || "?"}`}
            </span>
            
            <!-- Hover Actions Overlay (visible on hover; forced visible on touchscreens) -->
            <div class="media-card-overlay absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-all duration-300 flex flex-col items-center justify-center gap-3 p-4">
              <div class="flex gap-2">
                <button 
                  class="copy-url-btn p-3 bg-white rounded-full hover:bg-gray-100 text-gray-700 shadow-lg transform hover:scale-110 transition-transform"
                  title="Copy URL"
                >
                  <SimpleIcon name="copy" class="w-5 h-5" />
                </button>
                {file.publicUrl && (
                  <a 
                    href={file.publicUrl} 
                    target="_blank"
                    class="p-3 bg-white rounded-full hover:bg-gray-100 text-gray-700 shadow-lg transform hover:scale-110 transition-transform"
                    title="Open in new tab"
                  >
                    <SimpleIcon name="link-external" class="w-5 h-5" />
                  </a>
                )}
                <DeleteConfirmButton 
                  id={`delete-btn-${file.id}`}
                  variant="icon"
                  size="sm"
                />
              </div>
              
              <!-- File Info on Hover -->
              <div class="text-white text-center text-xs bg-black/30 backdrop-blur-md rounded-lg px-3 py-2 max-w-full">
                <p class="font-semibold truncate mb-1" title={file.fileName}>
                  {file.fileName || "Unnamed"}
                </p>
                <div class="flex items-center justify-center gap-2 text-[10px] opacity-90">
                  <span>{formatFileSize(file.fileSize)}</span>
                  <span>‚Ä¢</span>
                  <span>{file.uploadedAt ? new Date(file.uploadedAt).toLocaleDateString() : "‚Äî"}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    })
  )}
  </div>

  <!-- Empty State for Filtered Results -->
  <div id="no-results" class="hidden text-center py-12 text-gray-500 dark:text-gray-400">
    <SimpleIcon name="search" class="w-16 h-16 mx-auto mb-4 opacity-50" />
    <p class="text-lg font-medium">No matching files</p>
    <p class="text-sm">Try adjusting your search or filters</p>
  </div>

  <!-- Upload Progress (top-right near toast area so it doesn‚Äôt sit at bottom) -->
  <div id="upload-progress" class="hidden fixed top-4 right-4 sm:top-20 sm:right-4 z-[999998] bg-white dark:bg-gray-900 rounded-lg shadow-lg p-4 min-w-[300px]">
    <div class="flex items-center gap-3 mb-2">
      <div class="animate-spin">
        <SimpleIcon name="loader-2" class="w-5 h-5 text-primary-500" />
      </div>
      <span class="text-sm font-medium text-gray-900 dark:text-white">Uploading...</span>
    </div>
    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
      <div id="progress-bar" class="bg-primary-500 h-2 rounded-full transition-all" style="width: 0%"></div>
    </div>
    <div id="progress-text" class="text-xs text-gray-500 dark:text-gray-400 mt-1">0%</div>
  </div>
</div>

<style>
  /* Lazy loading styles */
  .lazyload,
  .lazyloading {
    opacity: 0;
    transition: opacity 0.3s;
  }
  
  .lazyloaded {
    opacity: 1;
    filter: none !important;
  }
  
  /* Optional: blur placeholder */
  .lazyload.blur-sm {
    filter: blur(5px);
  }

  /* Masonry Grid System - 8 columns on XL screens; DOM order = display order */
  .masonry-grid {
    display: grid;
    grid-auto-flow: dense; /* Fill gaps automatically */
  }

  .masonry-grid.masonry-recalculate {
    transition: grid-template-rows 0.2s ease;
  }

  /* Define all possible span combinations */
  .col-span-1 { grid-column: span 1; }
  .col-span-2 { grid-column: span 2; }
  .col-span-3 { grid-column: span 3; }
  .col-span-4 { grid-column: span 4; }
  
  .row-span-1 { grid-row: span 1; }
  .row-span-2 { grid-row: span 2; }
  .row-span-3 { grid-row: span 3; }
  .row-span-4 { grid-row: span 4; }

  /* Responsive adjustments */
  @media (max-width: 640px) {
    .masonry-grid {
      grid-template-columns: repeat(2, 1fr) !important;
    }
    .file-card {
      grid-column: span 1 !important;
      grid-row: span 1 !important;
    }
  }

  @media (min-width: 641px) and (max-width: 768px) {
    .masonry-grid {
      grid-template-columns: repeat(3, 1fr) !important;
    }
    .col-span-4 { grid-column: span 3 !important; }
  }

  @media (min-width: 769px) and (max-width: 1024px) {
    .masonry-grid {
      grid-template-columns: repeat(4, 1fr) !important;
    }
    .col-span-4 { grid-column: span 4 !important; }
  }

  @media (min-width: 1025px) and (max-width: 1280px) {
    .masonry-grid {
      grid-template-columns: repeat(6, 1fr) !important;
    }
    .col-span-4 { grid-column: span 3 !important; }
  }

  /* Touchscreens: always show overlay (no hover), so icons are visible */
  @media (hover: none) {
    .media-card-overlay {
      opacity: 1;
    }
  }

  /* Smooth transitions and hover effects */
  .file-card {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, box-shadow;
    min-height: 150px;
  }

  .file-card:hover {
    transform: translateY(-4px);
    z-index: 10;
  }

  /* Image loading optimization */
  .file-card img {
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
</style>

<script>
  // Simple Intersection Observer lazy loading (Astro-native, no dependencies)
  document.addEventListener("DOMContentLoaded", () => {
    const lazyImages = document.querySelectorAll('img.lazyload');
    
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            const src = img.getAttribute('data-src');
            
            if (src) {
              img.src = src;
              img.classList.add('lazyloading');
              
              img.onload = () => {
                img.classList.remove('lazyload', 'lazyloading', 'blur-sm');
                img.classList.add('lazyloaded');
              };
            }
            
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px', // Start loading 50px before visible
        threshold: 0.01
      });
      
      lazyImages.forEach(img => imageObserver.observe(img));
    } else {
      // Fallback for older browsers
      lazyImages.forEach(img => {
        const src = (img as HTMLImageElement).getAttribute('data-src');
        if (src) (img as HTMLImageElement).src = src;
      });
    }
    
    // Upload and file management
    const uploadBtn = document.getElementById("upload-btn");
    const fileInput = document.getElementById("file-input") as HTMLInputElement;
    const filesGrid = document.getElementById("files-grid");
    const noResults = document.getElementById("no-results");
    const uploadProgress = document.getElementById("upload-progress");
    const progressBar = document.getElementById("progress-bar");
    const progressText = document.getElementById("progress-text");

    // Format file size helper
    function formatFileSize(bytes: number | null): string {
      if (!bytes) return "‚Äî";
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }

    // Upload handler
    uploadBtn?.addEventListener("click", () => {
      fileInput?.click();
    });

    // Masonry size pattern (same as server) ‚Äì order is preserved: DOM order = grid flow order
    const sizes = [
      { col: 1, row: 1 }, { col: 1, row: 2 }, { col: 1, row: 4 }, { col: 2, row: 1 },
      { col: 3, row: 1 }, { col: 2, row: 2 }, { col: 1, row: 3 }, { col: 2, row: 3 },
    ];

    function createFileCardElement(
      file: { id: number; fileName: string; filePath: string; fileType?: string; fileSize?: number; publicUrl?: string },
      index: number
    ): HTMLElement {
      const size = sizes[index % sizes.length];
      const colSpan = `col-span-${size.col}`;
      const rowSpan = `row-span-${size.row}`;
      const isImage = (file.fileType?.startsWith("image/") || /\.(webp|avif|svg|png|jpg|jpeg|gif)$/i.test(file.fileName || ""));
      const sizeStr = formatFileSize(file.fileSize ?? null);
      const dateStr = new Date().toLocaleDateString();

      const card = document.createElement("div");
      card.className = `file-card group bg-white dark:bg-gray-900 rounded-lg shadow hover:shadow-xl transition-all duration-300 overflow-hidden cursor-pointer relative ${colSpan} ${rowSpan}`;
      card.dataset.fileId = String(file.id);
      card.dataset.fileName = file.fileName || "";
      card.dataset.filePath = file.filePath || "";
      card.dataset.fileType = file.fileType || "";
      card.dataset.fileSize = String(file.fileSize ?? "");
      card.dataset.fileUrl = file.publicUrl || "";
      card.dataset.fileSource = "global";
      card.dataset.projectId = "";

      const preview = document.createElement("div");
      preview.className = "h-full bg-gray-100 dark:bg-gray-700 flex items-center justify-center relative overflow-hidden";

      if (isImage && file.publicUrl) {
        const img = document.createElement("img");
        img.dataset.src = file.publicUrl;
        img.alt = file.fileName || "";
        img.className = "lazyload w-full h-full object-cover blur-sm";
        img.loading = "lazy";
        preview.appendChild(img);
      } else {
        const icon = document.createElement("span");
        icon.className = "w-12 h-12 text-gray-400 flex items-center justify-center";
        icon.setAttribute("aria-hidden", "true");
        icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="w-12 h-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>';
        preview.appendChild(icon);
      }

      const badge = document.createElement("span");
      badge.className = "absolute top-2 right-2 text-xs px-2 py-1 rounded-full backdrop-blur-md bg-green-500/90 text-white";
      badge.textContent = "Global";
      preview.appendChild(badge);

      const overlay = document.createElement("div");
      overlay.className = "media-card-overlay absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-all duration-300 flex flex-col items-center justify-center gap-3 p-4";

      const copyBtn = document.createElement("button");
      copyBtn.type = "button";
      copyBtn.className = "copy-url-btn p-3 bg-white rounded-full hover:bg-gray-100 text-gray-700 shadow-lg transform hover:scale-110 transition-transform";
      copyBtn.title = "Copy URL";
      copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';

      const linkWrap = document.createElement("div");
      if (file.publicUrl) {
        const link = document.createElement("a");
        link.href = file.publicUrl;
        link.target = "_blank";
        link.className = "p-3 bg-white rounded-full hover:bg-gray-100 text-gray-700 shadow-lg transform hover:scale-110 transition-transform";
        link.title = "Open in new tab";
        link.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>';
        linkWrap.appendChild(link);
      }

      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.id = `delete-btn-${file.id}`;
      deleteBtn.className = "p-3 bg-white rounded-full hover:bg-gray-100 text-red-500 shadow-lg transform hover:scale-110 transition-transform";
      deleteBtn.title = "Delete";
      deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>';
      deleteBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (confirm("Delete this file?")) {
          document.dispatchEvent(new CustomEvent("deleteConfirmed", { detail: { buttonId: deleteBtn.id }, bubbles: true }));
        }
      });

      const btns = document.createElement("div");
      btns.className = "flex gap-2";
      btns.append(copyBtn, linkWrap, deleteBtn);
      overlay.appendChild(btns);

      const info = document.createElement("div");
      info.className = "text-white text-center text-xs bg-black/30 backdrop-blur-md rounded-lg px-3 py-2 max-w-full";
      info.innerHTML = `<p class="font-semibold truncate mb-1" title="${(file.fileName || "Unnamed").replace(/"/g, "&quot;")}">${(file.fileName || "Unnamed").replace(/</g, "&lt;")}</p><div class="flex items-center justify-center gap-2 text-[10px] opacity-90"><span>${sizeStr}</span><span>‚Ä¢</span><span>${dateStr}</span></div>`;
      overlay.appendChild(info);

      preview.appendChild(overlay);
      card.appendChild(preview);
      return card;
    }

    function triggerMasonryRecalc() {
      if (!filesGrid) return;
      filesGrid.classList.add("masonry-recalculate");
      requestAnimationFrame(() => {
        setTimeout(() => filesGrid.classList.remove("masonry-recalculate"), 50);
      });
    }

    fileInput?.addEventListener("change", async () => {
      const files = fileInput.files;
      if (!files || files.length === 0) return;

      uploadProgress?.classList.remove("hidden");
      let successCount = 0;
      let failCount = 0;
      const uploadedFiles: { id: number; fileName: string; filePath: string; fileType?: string; fileSize?: number; publicUrl?: string }[] = [];

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const progress = ((i + 1) / files.length) * 100;
        
        try {
          const reader = new FileReader();
          const base64Promise = new Promise<string>((resolve, reject) => {
            reader.onload = () => resolve(reader.result as string);
            reader.onerror = reject;
          });
          reader.readAsDataURL(file);
          const base64 = await base64Promise;

          const response = await fetch("/api/admin/media", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              mediaData: base64,
              fileName: file.name,
              fileType: file.type,
              targetLocation: "global",
            }),
          });

          const result = await response.json();
          if (!response.ok) throw new Error(result.error || "Upload failed");
          
          successCount++;
          if (result.file) uploadedFiles.push(result.file);

          if (progressBar) progressBar.style.width = `${progress}%`;
          if (progressText) progressText.textContent = `${Math.round(progress)}%`;
        } catch (error) {
          console.error("Upload error:", error);
          failCount++;
          if ((window as any).showNotice) {
            (window as any).showNotice("error", "Upload Failed", `Failed to upload ${file.name}`, 3000);
          }
        }
      }

      // Hide progress indicator
      setTimeout(() => {
        uploadProgress?.classList.add("hidden");
        if (progressBar) progressBar.style.width = "0%";
        if (progressText) progressText.textContent = "0%";
      }, 500);

      if (successCount > 0) {
        if ((window as any).showNotice) {
          (window as any).showNotice(
            "success",
            "Upload Complete",
            `${successCount} file${successCount > 1 ? "s" : ""} uploaded successfully${failCount > 0 ? ` (${failCount} failed)` : ""}`,
            2000
          );
        }

        // Prepend new media to the beginning of the list (no full reload); masonry keeps DOM order
        if (filesGrid && uploadedFiles.length > 0) {
          const emptyState = filesGrid.querySelector(".col-span-full.text-center");
          if (emptyState) emptyState.remove();

          const cards = uploadedFiles.map((file, i) => createFileCardElement(file, i));
          // Prepend in reverse so first uploaded ends up first in DOM (newest at start)
          cards.reverse().forEach((card) => filesGrid.insertBefore(card, filesGrid.firstChild));
          triggerMasonryRecalc();
          if (typeof (window as any).lazyLoadImages === "function") (window as any).lazyLoadImages();
          else {
            const newImgs = filesGrid.querySelectorAll('img.lazyload[data-src]');
            newImgs.forEach((img) => {
              const src = img.getAttribute("data-src");
              if (src) { (img as HTMLImageElement).src = src; img.classList.remove("lazyload", "blur-sm"); img.classList.add("lazyloaded"); }
            });
          }
          updateStats();
        }
      }

      fileInput.value = "";
    });

    // File card click handlers
    filesGrid?.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      const card = target.closest(".file-card") as HTMLElement;
      
      if (!card) return;

      if (target.closest(".copy-url-btn")) {
        const url = card.dataset.fileUrl;
        if (url) {
          navigator.clipboard.writeText(url);
          if ((window as any).showNotice) {
            (window as any).showNotice("success", "Success", "URL copied to clipboard!", 2000);
          }
        }
        return;
      }
    });

    // Listen for delete confirmation events from DeleteConfirmButton
    document.addEventListener("deleteConfirmed", (e: Event) => {
      const customEvent = e as CustomEvent;
      const buttonId = customEvent.detail.buttonId;
      
      console.log("‚úÖ [MEDIA-DELETE] Delete confirmed event received:", { 
        buttonId,
        eventDetail: customEvent.detail 
      });
      
      // Find the file card that contains this button
      const button = document.getElementById(buttonId);
      console.log("üîç [MEDIA-DELETE] Button element:", button);
      
      const card = button?.closest(".file-card") as HTMLElement;
      console.log("üîç [MEDIA-DELETE] Card element:", { 
        card, 
        cardDataset: card?.dataset 
      });
      
      if (card) {
        deleteFile(card);
      } else {
        console.error("‚ùå [MEDIA-DELETE] Could not find file card for button:", buttonId);
      }
    });

    async function deleteFile(card: HTMLElement) {
      const fileId = card.dataset.fileId;
      const source = card.dataset.fileSource;
      
      console.log("üóëÔ∏è [MEDIA-DELETE] Delete initiated:", { 
        fileId, 
        fileIdType: typeof fileId,
        source,
        cardDataset: card.dataset 
      });
      
      if (!fileId) {
        console.error("‚ùå [MEDIA-DELETE] No file ID found in card dataset");
        return;
      }

      try {
        console.log("üì§ [MEDIA-DELETE] Sending DELETE request to /api/admin/media");
        const response = await fetch("/api/admin/media", {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fileId, source }),
        });

        console.log("üì• [MEDIA-DELETE] Response received:", { 
          ok: response.ok, 
          status: response.status,
          statusText: response.statusText 
        });

        const result = await response.json();
        console.log("üì¶ [MEDIA-DELETE] Response data:", result);

        if (response.ok) {
          // Remove the card with a fade-out animation
          card.style.transition = "opacity 0.3s, transform 0.3s";
          card.style.opacity = "0";
          card.style.transform = "scale(0.9)";
          
          setTimeout(() => {
            card.remove();
            
            // Update stats after deletion
            updateStats();
            
            // Check if we need to show the empty state
            const remainingCards = filesGrid?.querySelectorAll(".file-card:not([style*='display: none'])");
            if (remainingCards && remainingCards.length === 0) {
              const noResultsElement = document.getElementById("no-results");
              if (noResultsElement) {
                noResultsElement.classList.remove("hidden");
              }
            }
          }, 300);
          
          if ((window as any).showNotice) {
            (window as any).showNotice("success", "Success", "File deleted successfully", 2000);
          }
        } else {
          console.error("‚ùå [MEDIA-DELETE] Delete failed:", result);
          throw new Error(result.error || "Delete failed");
        }
      } catch (error) {
        console.error("‚ùå [MEDIA-DELETE] Delete error:", error);
        alert(`Failed to delete file: ${error}`);
      }
    }

    // Update stats dynamically
    function updateStats() {
      const cards = filesGrid?.querySelectorAll(".file-card") as NodeListOf<HTMLElement>;
      
      let totalCount = 0;
      let projectCount = 0;
      let globalCount = 0;
      let imageCount = 0;
      let documentCount = 0;
      
      cards?.forEach((card) => {
        totalCount++;
        const source = card.dataset.fileSource;
        const fileType = card.dataset.fileType?.toLowerCase() || "";
        
        if (source === "project") projectCount++;
        if (source === "global") globalCount++;
        if (fileType.startsWith("image/")) imageCount++;
        if (fileType.includes("pdf") || fileType.includes("document")) documentCount++;
      });
      
      // Update stat displays (selectors match stats cards: bg-white dark:bg-gray-900)
      const stats = [
        { selector: ".admin-media-component .grid.grid-cols-2 > div:nth-child(1) .text-2xl", value: totalCount },
        { selector: ".admin-media-component .grid.grid-cols-2 > div:nth-child(2) .text-2xl", value: projectCount },
        { selector: ".admin-media-component .grid.grid-cols-2 > div:nth-child(3) .text-2xl", value: globalCount },
        { selector: ".admin-media-component .grid.grid-cols-2 > div:nth-child(4) .text-2xl", value: imageCount },
        { selector: ".admin-media-component .grid.grid-cols-2 > div:nth-child(5) .text-2xl", value: documentCount },
      ];
      
      stats.forEach(({ selector, value }) => {
        const element = document.querySelector(selector);
        if (element) {
          element.textContent = value.toString();
        }
      });
    }
  });
</script>
