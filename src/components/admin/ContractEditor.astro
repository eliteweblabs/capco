---
interface Props {
  projectTitle: string;
  project?: any;
  editMode: boolean;
  projectStatus: number;
  statusData: any;
  currentUser: any;
}

import DigitalSignature from "../project/DigitalSignature.astro";

const { project, projectTitle, editMode, projectStatus, statusData, currentUser } = Astro.props;
const projectId = project.id;
---

{
  editMode ? (
    <div id="contract-editor-container" class="space-y-4">
      <div class="sticky bottom-0 flex items-center justify-between bg-white dark:bg-gray-800">
        <div class="flex gap-2">
          <button
            id="load-template-btn"
            type="button"
            class="rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
          >
            Reset to Template
          </button>
          <button
            id="save-contract-btn"
            type="button"
            class="rounded-md border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            Save Contract
          </button>
        </div>
      </div>

      {/* <!-- WYSIWYG Editor --> */}
      <div class="rounded-lg border border-gray-300 dark:border-gray-600">
        <div
          id="contract-editor"
          class="min-h-[500px] bg-white p-4 text-black dark:bg-gray-800 dark:text-white"
        >
          {/* <!-- Editor content will be inserted here --> */}
        </div>
      </div>
    </div>
  ) : (
    <>
      <div id="contract-container" class="space-y-4">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-semibold text-gray-900 dark:text-white">
            Contract - {projectTitle}
          </h3>
        </div>
      </div>

      {projectStatus > 49 && projectStatus < 50 && (
        <DigitalSignature
          id="proposal-signature"
          required={true}
          width={2400}
          height={580}
          project={project}
          statusData={statusData}
          currentUser={currentUser}
        />
      )}
    </>
  )
}

<script
  define:vars={{
    projectTitle,
    project,
    projectId,
    editMode,
  }}
>
  // Initialize Quill editor
  let contractEditor = null;
  let isDirty = false;
  let contractHtml = "";

  // Use the template loaded from file system (passed from frontmatter)

  async function fetchExistingContractOrTemplate(reset = false) {
    try {
      console.log("üîÑ [CONTRACT-EDITOR] Fetching existing contract from client-side...");
      console.log("üîç [CONTRACT-EDITOR] Project ID:", projectId);
      if (!reset) {
        const response = await fetch(`/api/get-project-contract`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: projectId,
            projectData: project,
          }),
        });

        console.log("üîç [CONTRACT-EDITOR] Response status:", response.status);

        const data = await response.json();

        console.log("üîç [CONTRACT-EDITOR] Client-side API response:", {
          success: data.success,
          hasContractHtml: !!data.data?.contractHtml,
          contractLength: data.data?.contractHtml?.length || 0,
          fullResponse: data,
        });
        console.log("‚úÖ [CONTRACT-EDITOR] Found existing contract for project:", projectId);
        console.log(
          "üìÑ [CONTRACT-EDITOR] Contract HTML length:",
          data.data.contractHtml?.length || 0
        );

        if (data.success && data.data?.contractHtml) {
          contractHtml = data.data.contractHtml;
        }
      }

      if (reset || !contractHtml) {
        // Fetch template from server
        console.log("üìÑ [CONTRACT-EDITOR] Fetching template from server");
        try {
          const templateResponse = await fetch(
            `/api/pdf/assemble?templateId=contract&projectId=${projectId}`
          );
          if (templateResponse.ok) {
            contractHtml = await templateResponse.text();
            console.log(
              "üìÑ [CONTRACT-EDITOR] Template fetched successfully, length:",
              contractHtml.length
            );
            return contractHtml;
          } else {
            console.error(
              "‚ùå [CONTRACT-EDITOR] Failed to fetch template:",
              templateResponse.status
            );
            return "<p>Error loading template</p>";
          }
        } catch (error) {
          console.error("‚ùå [CONTRACT-EDITOR] Error fetching template:", error);
          return "<p>Error loading template</p>";
        }
      }

      // Process template with placeholders using PROJECT_ prefixed placeholders
      return contractHtml;
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error fetching existing contract:", error);
      return null;
    }
  }

  async function initializeEditor() {
    console.log("üöÄ [CONTRACT-EDITOR] Initializing editor...");

    // Load Quill CSS and JS dynamically
    if (!document.querySelector("#quill-css")) {
      console.log("üì¶ [CONTRACT-EDITOR] Loading Quill CSS...");
      const quillCSS = document.createElement("link");
      quillCSS.id = "quill-css";
      quillCSS.rel = "stylesheet";
      quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
      document.head.appendChild(quillCSS);
    }

    if (!window.Quill) {
      console.log("üì¶ [CONTRACT-EDITOR] Loading Quill JS...");
      const quillJS = document.createElement("script");
      quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
      quillJS.onload = async () => {
        console.log("‚úÖ [CONTRACT-EDITOR] Quill JS loaded, creating editor...");
        await createEditor();
      };
      document.head.appendChild(quillJS);
    } else {
      console.log("‚úÖ [CONTRACT-EDITOR] Quill JS already loaded, creating editor...");
      await createEditor();
    }
  }

  async function createEditor() {
    console.log("üîß [CONTRACT-EDITOR] Creating Quill editor...");

    try {
      contractEditor = new window.Quill("#contract-editor", {
        theme: "snow",
        modules: {
          toolbar: [
            [{ header: [1, 2, 3, 4, 5, 6, false] }],
            ["bold", "italic", "underline", "strike"],
            [{ color: [] }, { background: [] }],
            [{ list: "ordered" }, { list: "bullet" }],
            [{ indent: "-1" }, { indent: "+1" }],
            [{ align: [] }],
            ["link", "blockquote", "code-block"],
            ["clean"],
          ],
        },
      });
      console.log("‚úÖ [CONTRACT-EDITOR] Quill editor created successfully");
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error creating editor:", error);
      return;
    }

    // Fetch existing contract from client-side
    console.log("üîÑ [CONTRACT-EDITOR] About to fetch existing contract...");
    const fetchedContract = await fetchExistingContractOrTemplate();

    // Load initial content using Quill's proper method

    // Use Quill's clipboard to properly handle HTML content
    const delta = contractEditor.clipboard.convert(fetchedContract);
    contractEditor.setContents(delta);

    console.log("‚úÖ [CONTRACT-EDITOR] Initial content loaded successfully");

    // Track changes
    contractEditor.on("text-change", () => {
      isDirty = true;
    });

    // Set up event listeners
    setupEventListeners();
  }

  async function setupEventListeners() {
    console.log("üîó [CONTRACT-EDITOR] Setting up event listeners...");

    // Load template button
    const loadBtn = document.getElementById("load-template-btn");
    console.log("üîó [CONTRACT-EDITOR] Load button found:", !!loadBtn);

    if (loadBtn) {
      loadBtn.addEventListener("click", async () => {
        if (confirm("This will replace the current content with the default template. Continue?")) {
          try {
            // Use Quill's proper method to load HTML content

            const delta = contractEditor.clipboard.convert(
              await fetchExistingContractOrTemplate(true)
            );
            contractEditor.setContents(delta);
            isDirty = true;
            console.log("‚úÖ [CONTRACT-EDITOR] Template loaded successfully");
          } catch (error) {
            console.error("‚ùå [CONTRACT-EDITOR] Error loading template:", error);
          }
        }
      });
      console.log("‚úÖ [CONTRACT-EDITOR] Event listener attached to load button");
    } else {
      console.error("‚ùå [CONTRACT-EDITOR] Load template button not found!");
    }

    // Save contract button
    document.getElementById("save-contract-btn")?.addEventListener("click", async () => {
      await saveContract();
    });
  }

  async function refreshContractData() {
    try {
      console.log("üîÑ [CONTRACT-EDITOR] Fetching updated contract data...");

      // Add a small delay to ensure database transaction is committed
      await new Promise((resolve) => setTimeout(resolve, 500));

      const response = await fetch(`/api/get-project-contract`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          projectId: projectId,
          projectData: project,
        }),
      });
      const data = await response.json();

      if (data.success && data.data?.contractHtml) {
        console.log("‚úÖ [CONTRACT-EDITOR] Updated contract data fetched:", {
          contractLength: data.data.contractHtml?.length || 0,
          contractPreview: data.data.contractHtml?.substring(0, 100) + "..." || "No content",
        });

        // Update the status to reflect that we now have an existing contract

        // Log the updated status
        console.log("‚úÖ [CONTRACT-EDITOR] Contract status updated:", {
          hasExistingContract: true,
          contractLength: data.data.contractHtml?.length || 0,
        });

        return true;
      } else {
        console.log("‚ÑπÔ∏è [CONTRACT-EDITOR] No updated contract data found");
        return false;
      }
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error refreshing contract data:", error);
      return false;
    }
  }

  async function saveContract() {
    const saveBtn = document.getElementById("save-contract-btn");
    const originalText = saveBtn?.textContent;

    try {
      saveBtn.textContent = "Saving...";
      saveBtn.disabled = true;

      const contractHtml = contractEditor.root.innerHTML;

      const response = await fetch("/api/save-project-contract", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          projectId: projectId,
          contractHtml: contractHtml,
        }),
      });

      const data = await response.json();

      console.log("üîç [CONTRACT-EDITOR] Save API response:", {
        success: data.success,
        hasContractHtml: !!data.contractHtml,
        contractLength: data.contractHtml?.length || 0,
        error: data.error,
      });

      if (data.success) {
        isDirty = false;
        showNotification("Contract saved successfully", "success");

        // Refresh the contract data from the server
        console.log("üîÑ [CONTRACT-EDITOR] Contract saved, refreshing contract data...");
        await refreshContractData();
      } else {
        throw new Error(data.error || "Failed to save contract");
      }
    } catch (error) {
      console.error("Error saving contract:", error);
      showNotification("Error saving contract: " + error.message, "error");
    } finally {
      saveBtn.textContent = originalText;
      saveBtn.disabled = false;
    }
  }

  function showNotification(message, type) {
    // Simple notification - you can replace with your preferred notification system
    const notification = document.createElement("div");
    notification.className = `fixed top-4 right-4 px-4 py-2 rounded-md text-white z-50 ${
      type === "success" ? "bg-green-500" : "bg-red-500"
    }`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  // Initialize when DOM is ready
  document.addEventListener("DOMContentLoaded", async () => {
    console.log("üìÑ [CONTRACT-EDITOR] DOM Content Loaded");
    if (editMode) {
      initializeEditor();
    } else {
      const contractContent = await fetchExistingContractOrTemplate();
      document.getElementById("contract-container").innerHTML = contractContent;
    }
  });
</script>
