---
interface Props {
  title: string;
  project?: any;
  editMode: boolean;
  projectStatus: number;
  statusData: any;
  currentUser: any;
}

import DigitalSignature from "../project/DigitalSignature.astro";
import StickyActions from "../project/StickyActions.astro";
import Button from "../common/Button.astro";
const { project, title, editMode, projectStatus, statusData, currentUser } = Astro.props;
const projectId = project.id;
---

{
  editMode && (
    <StickyActions columns="2">
      <>
        <Button id="load-template-btn" variant="secondary">
          Reset to Template
        </Button>
        <Button id="save-contract-btn" variant="success">
          Save Contract
        </Button>
      </>
    </StickyActions>
  )
}

{
  editMode ? (
    <div id="contract-editor-container" class="space-y-4">
      {/* <!-- WYSIWYG Editor --> */}
      <div class="rounded-lg border border-gray-300 dark:border-gray-600">
        <div
          id="contract-editor"
          class="min-h-[500px] bg-gray-100 p-4 text-black dark:bg-gray-800 dark:text-white"
        >
          {/* <!-- Editor content will be inserted here --> */}
        </div>
      </div>
    </div>
  ) : (
    <>
      {projectStatus >= 45 && (
        <div id="contract-container" class="space-y-4">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Contract - {title}</h3>
          </div>
        </div>
      )}

      {projectStatus === 45 && (
        <DigitalSignature
          id="proposal-signature"
          required={true}
          width={2400}
          height={580}
          project={project}
          statusData={statusData}
          currentUser={currentUser}
        />
      )}
    </>
  )
}

<script
  define:vars={{
    title,
    project,
    projectId,
    editMode,
  }}
  is:inline
>
  // Initialize Quill editor
  let contractEditor = null;
  let isDirty = false;
  let contractHtml = "";

  // Make contractEditor and project globally accessible for modal actions
  window.contractEditor = contractEditor;
  window.contractProject = project;

  // Use the template loaded from file system (passed from frontmatter)

  async function fetchExistingContractOrTemplate(reset = false) {
    try {
      console.log("üîÑ [CONTRACT-EDITOR] Fetching existing contract from client-side...");
      console.log("üîç [CONTRACT-EDITOR] Project ID:", projectId);
      if (!reset) {
        const response = await fetch(`/api/contract/get`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: projectId,
            projectData: project,
          }),
        });

        console.log("üîç [CONTRACT-EDITOR] Response status:", response.status);

        const data = await response.json();

        console.log("üîç [CONTRACT-EDITOR] Client-side API response:", {
          success: data.success,
          hasContractHtml: !!data.data?.contractHtml,
          contractLength: data.data?.contractHtml?.length || 0,
          fullResponse: data,
        });
        console.log("‚úÖ [CONTRACT-EDITOR] Found existing contract for project:", projectId);
        console.log(
          "üìÑ [CONTRACT-EDITOR] Contract HTML length:",
          data.data.contractHtml?.length || 0
        );

        if (data.success && data.data?.contractHtml) {
          contractHtml = data.data.contractHtml;
        }
      }

      if (reset || !contractHtml) {
        // Fetch template from server
        console.log("üìÑ [CONTRACT-EDITOR] Fetching template from server");
        try {
          const templateResponse = await fetch(
            `/api/pdf/assemble?templateId=contract&projectId=${projectId}`
          );
          if (templateResponse.ok) {
            contractHtml = await templateResponse.text();
            console.log(
              "üìÑ [CONTRACT-EDITOR] Template fetched successfully, length:",
              contractHtml.length
            );
            return contractHtml;
          } else {
            console.error(
              "‚ùå [CONTRACT-EDITOR] Failed to fetch template:",
              templateResponse.status
            );
            return "<p>Error loading template</p>";
          }
        } catch (error) {
          console.error("‚ùå [CONTRACT-EDITOR] Error fetching template:", error);
          return "<p>Error loading template</p>";
        }
      }

      // Process template with placeholders using PROJECT_ prefixed placeholders
      return contractHtml;
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error fetching existing contract:", error);
      return null;
    }
  }

  async function initializeEditor() {
    console.log("üöÄ [CONTRACT-EDITOR] Initializing editor...");

    // Load Quill CSS and JS dynamically
    if (!document.querySelector("#quill-css")) {
      console.log("üì¶ [CONTRACT-EDITOR] Loading Quill CSS...");
      const quillCSS = document.createElement("link");
      quillCSS.id = "quill-css";
      quillCSS.rel = "stylesheet";
      quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
      document.head.appendChild(quillCSS);
    }

    if (!window.Quill) {
      console.log("üì¶ [CONTRACT-EDITOR] Loading Quill JS...");
      const quillJS = document.createElement("script");
      quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
      quillJS.onload = async () => {
        console.log("‚úÖ [CONTRACT-EDITOR] Quill JS loaded, creating editor...");
        await createEditor();
      };
      document.head.appendChild(quillJS);
    } else {
      console.log("‚úÖ [CONTRACT-EDITOR] Quill JS already loaded, creating editor...");
      await createEditor();
    }
  }

  async function createEditor() {
    console.log("üîß [CONTRACT-EDITOR] Creating Quill editor...");

    try {
      contractEditor = new window.Quill("#contract-editor", {
        theme: "snow",
        modules: {
          toolbar: [
            [{ header: [1, 2, 3, 4, 5, 6, false] }],
            ["bold", "italic", "underline", "strike"],
            [{ color: [] }, { background: [] }],
            [{ list: "ordered" }, { list: "bullet" }],
            [{ indent: "-1" }, { indent: "+1" }],
            [{ align: [] }],
            ["link", "blockquote", "code-block"],
            ["clean"],
          ],
        },
        placeholder: "Enter contract content...",
        readOnly: false,
      });

      // Update global reference
      window.contractEditor = contractEditor;

      console.log("‚úÖ [CONTRACT-EDITOR] Quill editor created successfully");
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error creating editor:", error);
      return;
    }

    // Fetch existing contract from client-side
    console.log("üîÑ [CONTRACT-EDITOR] About to fetch existing contract...");
    const fetchedContract = await fetchExistingContractOrTemplate();

    // Load initial content using Quill's proper method

    // Use Quill's clipboard to properly handle HTML content
    const delta = contractEditor.clipboard.convert(fetchedContract);
    contractEditor.setContents(delta);

    console.log("‚úÖ [CONTRACT-EDITOR] Initial content loaded successfully");

    // Track changes
    contractEditor.on("text-change", () => {
      isDirty = true;
    });

    // Set up event listeners
    setupEventListeners();
  }

  async function setupEventListeners() {
    console.log("üîó [CONTRACT-EDITOR] Setting up event listeners...");

    // Load template button
    const loadBtn = document.getElementById("load-template-btn");
    console.log("üîó [CONTRACT-EDITOR] Load button found:", !!loadBtn);

    if (loadBtn) {
      loadBtn.addEventListener("click", async () => {
        // use custom global confirm like delete project
        if (window.showModal) {
          window.showModal(
            "warning",
            "Reset to Template",
            "This will replace the current content with the default template. This action cannot be undone.",
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                variant: "anchor",
                fullWidth: true,
                action: () => {},
              },
              {
                label: "Reset to Template",
                variant: "danger",
                fullWidth: true,
                action: async () => {
                  // Reset to template logic
                  try {
                    // Reset to default template (clear existing contract data)
                    console.log("Resetting to default template...");

                    // Fetch the default template from the server
                    try {
                      const templateResponse = await fetch(
                        `/api/pdf/assemble?templateId=contract&projectId=${projectId}`
                      );
                      if (templateResponse.ok) {
                        const templateContent = await templateResponse.text();
                        console.log("Template fetched from server:", templateContent);

                        // Load the template into the editor
                        loadTemplateIntoEditor(templateContent);
                      } else {
                        console.error("Failed to fetch template from server");
                        // Fallback to hardcoded template
                        const fallbackTemplate = `<!-- Default Contract Template -->
<div class="contract-container">
  <h1>Fire Protection System Contract</h1>
  <p>This is the default contract template...</p>
</div>`;
                        loadTemplateIntoEditor(fallbackTemplate);
                      }
                    } catch (error) {
                      console.error("Error fetching template:", error);
                      // Fallback to hardcoded template
                      const fallbackTemplate = `<!-- Default Contract Template -->
<div class="contract-container">
  <h1>Fire Protection System Contract</h1>
  <p>This is the default contract template...</p>
</div>`;
                      loadTemplateIntoEditor(fallbackTemplate);
                    }

                    function loadTemplateIntoEditor(templateContent) {
                      // Add small delay to ensure editor is ready
                      setTimeout(() => {
                        const editor = window.contractEditor;
                        console.log("Editor found:", !!editor);
                        console.log("Editor root:", !!editor?.root);

                        if (editor && editor.root) {
                          try {
                            // Clear existing content first
                            console.log("Clearing editor content...");
                            editor.setText("");

                            // Use Quill's proper method to set content
                            console.log("Converting template to delta...");
                            const delta = editor.clipboard.convert(templateContent);
                            console.log("Delta created:", delta);

                            console.log("Setting editor contents...");
                            editor.setContents(delta);
                            console.log("Template loaded successfully");

                            // Also clear the contract data from the database
                            console.log("Clearing contract data from database...");
                            fetch("/api/save-project-contract", {
                              method: "POST",
                              headers: { "Content-Type": "application/json" },
                              body: JSON.stringify({
                                projectId: projectId,
                                contractData: { contractHtml: templateContent },
                              }),
                            })
                              .then((response) => response.json())
                              .then((data) => {
                                console.log("Contract data cleared and reset:", data);
                              })
                              .catch((error) => {
                                console.error("Error clearing contract data:", error);
                              });
                          } catch (error) {
                            console.error("Error setting template content:", error);
                            // Fallback to direct HTML if Quill method fails
                            try {
                              console.log("Trying fallback method...");
                              editor.root.innerHTML = templateContent;
                              console.log("Fallback method succeeded");
                            } catch (fallbackError) {
                              console.error("Fallback method also failed:", fallbackError);
                            }
                          }
                        } else {
                          console.error("Contract editor not found or not ready");
                        }
                      }, 200);
                    }
                  } catch (error) {
                    console.error("Error loading template:", error);
                  }
                },
              },
            ]
          );
        }
      });
      console.log("‚úÖ [CONTRACT-EDITOR] Event listener attached to load button");
    } else {
      console.error("‚ùå [CONTRACT-EDITOR] Load template button not found!");
    }

    // Save contract button
    document.getElementById("save-contract-btn")?.addEventListener("click", async () => {
      await saveContract();
    });
  }

  async function refreshContractData() {
    try {
      console.log("üîÑ [CONTRACT-EDITOR] Fetching updated contract data...");

      // Add a small delay to ensure database transaction is committed
      await new Promise((resolve) => setTimeout(resolve, 500));

      const response = await fetch(`/api/get-project-contract`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          projectId: projectId,
          projectData: project,
        }),
      });
      const data = await response.json();

      if (data.success && data.data?.contractHtml) {
        console.log("‚úÖ [CONTRACT-EDITOR] Updated contract data fetched:", {
          contractLength: data.data.contractHtml?.length || 0,
          contractPreview: data.data.contractHtml?.substring(0, 100) + "..." || "No content",
        });

        // Update the status to reflect that we now have an existing contract

        // Log the updated status
        console.log("‚úÖ [CONTRACT-EDITOR] Contract status updated:", {
          hasExistingContract: true,
          contractLength: data.data.contractHtml?.length || 0,
        });

        return true;
      } else {
        console.log("‚ÑπÔ∏è [CONTRACT-EDITOR] No updated contract data found");
        return false;
      }
    } catch (error) {
      console.error("‚ùå [CONTRACT-EDITOR] Error refreshing contract data:", error);
      return false;
    }
  }

  async function saveContract() {
    const saveBtn = document.getElementById("save-contract-btn");
    const originalText = saveBtn?.textContent;

    try {
      saveBtn.textContent = "Saving...";
      saveBtn.disabled = true;

      const contractHtml = contractEditor.root.innerHTML;

      const response = await fetch("/api/save-project-contract", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          projectId: projectId,
          contractData: { contractHtml: contractHtml },
        }),
      });

      const data = await response.json();

      console.log("üîç [CONTRACT-EDITOR] Save API response:", {
        success: data.success,
        hasContractHtml: !!data.contractHtml,
        contractLength: data.contractHtml?.length || 0,
        error: data.error,
      });

      if (data.success) {
        isDirty = false;
        window.showModal("success", "Contract saved successfully", "", 2500);

        // Refresh the contract data from the server
        console.log("üîÑ [CONTRACT-EDITOR] Contract saved, refreshing contract data...");
        await refreshContractData();
      } else {
        throw new Error(data.error || "Failed to save contract");
      }
    } catch (error) {
      console.error("Error saving contract:", error);
      window.showModal("error", "error", "Error saving contract: " + error.message);
    } finally {
      saveBtn.textContent = originalText;
      saveBtn.disabled = false;
    }
  }

  function showNotification(message, type) {
    // Simple notification - you can replace with your preferred notification system
    const notification = document.createElement("div");
    notification.className = `fixed top-4 right-4 px-4 py-2 rounded-md text-white z-50 ${
      type === "success" ? "bg-green-500" : "bg-red-500"
    }`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  // Initialize when DOM is ready
  document.addEventListener("DOMContentLoaded", async () => {
    console.log("üìÑ [CONTRACT-EDITOR] DOM Content Loaded");
    if (editMode) {
      initializeEditor();
    } else {
      let contractContainer = document.getElementById("contract-container");
      if (contractContainer) {
        const contractContent = await fetchExistingContractOrTemplate();
        contractContainer.innerHTML = contractContent;
        console.log("‚úÖ [CONTRACT-EDITOR] Contract content loaded successfully");
      }
    }
  });
</script>
