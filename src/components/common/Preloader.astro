---
// Preloader: dot grid (all black) with random dots turning primary.
// Optimized: capped dot count, DocumentFragment, cached refs, deferred listeners, CSS transition for mask.
// #page stays hidden until ready. window.dotGrid for optional hover/magnetic/equalizer.
---

<div id="preloader-dot-grid" class="preloader-dot-grid color-background" aria-hidden="true"></div>

<script>
  const MIN_DOT_SIZE_PX = 13;
  const MAX_DOTS = 550; // Cap nodes and animations for performance
  const BRAKE_ROWS = 10;

  function ready() {
    document.body?.classList.remove("preloading");
    const page = document.getElementById("page");
    if (page) page.removeAttribute("hidden");
    const grid = document.getElementById("preloader-dot-grid");
    if (grid) grid.style.pointerEvents = "none";
  }

  if (document.readyState === "complete") {
    ready();
  } else {
    window.addEventListener("load", ready);
  }
  document.addEventListener("DOMContentLoaded", () => setTimeout(ready, 80));

  // SPA: after ClientRouter swap the new document has #page hidden again; unhide so content shows
  document.addEventListener("astro:page-load", ready);
  document.addEventListener("astro:after-swap", ready);

  const DotGridController = (function () {
    let gridEl: HTMLElement | null = null;
    let dotsCache: HTMLElement[] = [];
    let cols = 0;
    let rows = 0;
    let dotSize = MIN_DOT_SIZE_PX;
    let mode: "idle" | "hover" | "magnetic" | "equalizer" = "idle";
    let brakeIntensity = 0;
    let rafId = 0;
    let equalizerLevels: number[] = [];
    let mouseX = 0;
    let mouseY = 0;
    let touchStartY = 0;
    let overscrollSetup = false;

    function getDots(): HTMLElement[] {
      return dotsCache;
    }

    function setBrake(intensity: number) {
      brakeIntensity = Math.max(0, Math.min(1, intensity));
      if (!gridEl) return;
      if (brakeIntensity <= 0) {
        delete gridEl.dataset.brakeIntensity;
        gridEl.style.removeProperty("--brake-intensity");
      } else {
        gridEl.dataset.brakeIntensity = String(brakeIntensity.toFixed(2));
        gridEl.style.setProperty("--brake-intensity", String(brakeIntensity));
      }
    }

    function setupOverscroll() {
      if (overscrollSetup) return;
      overscrollSetup = true;
      document.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length) touchStartY = e.touches[0].clientY;
        },
        { passive: true }
      );
      document.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length && window.scrollY === 0) {
            const pull = e.touches[0].clientY - touchStartY;
            if (pull > 0) setBrake(Math.min(1, pull / 200));
          }
        },
        { passive: true }
      );
      document.addEventListener("touchend", () => setBrake(0), { passive: true });
      document.addEventListener(
        "wheel",
        (e) => {
          if (window.scrollY === 0 && e.deltaY < 0) {
            setBrake(Math.min(1, brakeIntensity + 0.15));
            setTimeout(() => setBrake(Math.max(0, brakeIntensity - 0.2)), 150);
          }
        },
        { passive: true }
      );
    }

    function updateHover() {
      const dots = dotsCache;
      const radius = 120;
      for (let i = 0; i < dots.length; i++) {
        const dot = dots[i];
        const r = (Number(dot.dataset.row) || 0) * dotSize + dotSize / 2;
        const c = (Number(dot.dataset.col) || 0) * dotSize + dotSize / 2;
        const dist = Math.hypot(mouseX - c, mouseY - r);
        const strength = dist < radius ? 1 - dist / radius : 0;
        dot.style.setProperty("--hover", String(strength));
      }
    }

    function updateMagnetic() {
      const dots = dotsCache;
      const pullRadius = 200;
      const strength = 8;
      for (let i = 0; i < dots.length; i++) {
        const dot = dots[i];
        const r = (Number(dot.dataset.row) || 0) * dotSize + dotSize / 2;
        const c = (Number(dot.dataset.col) || 0) * dotSize + dotSize / 2;
        const dx = mouseX - c;
        const dy = mouseY - r;
        const dist = Math.hypot(dx, dy) || 1;
        const pull = dist < pullRadius ? (1 - dist / pullRadius) * strength : 0;
        dot.style.transform = `translate(${dx / dist * pull}px, ${dy / dist * pull}px)`;
      }
    }

    function updateEqualizer() {
      const dots = dotsCache;
      const len = equalizerLevels.length;
      for (let i = 0; i < dots.length; i++) {
        const row = Number(dots[i].dataset.row) || 0;
        const t = rows <= 1 ? 0 : row / (rows - 1);
        const idx = Math.floor(t * (len - 1));
        const level = len ? (equalizerLevels[Math.min(idx, len - 1)] ?? 0.5) : 0.5;
        dots[i].style.setProperty("--eq", String(level));
      }
    }

    function tick() {
      if (mode === "hover") updateHover();
      else if (mode === "magnetic") updateMagnetic();
      else if (mode === "equalizer") updateEqualizer();
      rafId = requestAnimationFrame(tick);
    }

    function onMouseMove(e: MouseEvent) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    }

    function setMode(m: "idle" | "hover" | "magnetic" | "equalizer") {
      mode = m;
      if (!gridEl) return;
      gridEl.dataset.mode = m;
      const dots = dotsCache;
      for (let i = 0; i < dots.length; i++) {
        const d = dots[i];
        d.style.removeProperty("transform");
        d.style.removeProperty("--hover");
        d.style.removeProperty("--eq");
      }
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = 0;
      }
      document.removeEventListener("mousemove", onMouseMove);
      if (mode === "idle") return;
      if (mode === "hover" || mode === "magnetic") {
        document.addEventListener("mousemove", onMouseMove);
      }
      if (mode === "equalizer" && equalizerLevels.length === 0) {
        equalizerLevels = Array.from({ length: rows }, () => 0.3 + Math.random() * 0.5);
      }
      rafId = requestAnimationFrame(tick);
    }

    function setEqualizerLevels(levels: number[]) {
      equalizerLevels = levels.length
        ? levels
        : Array.from({ length: rows }, () => 0.3 + Math.random() * 0.5);
    }

    function init(grid: HTMLElement, opts: { cols: number; rows: number; dotSize: number; dots: HTMLElement[] }) {
      gridEl = grid;
      cols = opts.cols;
      rows = opts.rows;
      dotSize = opts.dotSize;
      dotsCache = opts.dots;
      // Defer overscroll listeners until idle so they don't block initial paint
      if (typeof requestIdleCallback !== "undefined") {
        requestIdleCallback(() => setupOverscroll(), { timeout: 2000 });
      } else {
        setTimeout(setupOverscroll, 300);
      }
    }

    return {
      init,
      setMode,
      setBrake,
      setEqualizerLevels,
      get mode() {
        return mode;
      },
    };
  })();

  (function initDotGrid() {
    const grid = document.getElementById("preloader-dot-grid");
    if (!grid) return;

    const w = window.innerWidth || 800;
    const h = window.innerHeight || 600;
    const area = w * h;
    // Scale dot size so we stay under MAX_DOTS while keeping coverage
    let dotSize = Math.max(MIN_DOT_SIZE_PX, Math.ceil(Math.sqrt(area / MAX_DOTS)));
    let cols = Math.ceil(w / dotSize);
    let rows = Math.ceil(h / dotSize);
    let total = cols * rows;
    if (total > MAX_DOTS) {
      dotSize = Math.max(MIN_DOT_SIZE_PX, Math.ceil(Math.sqrt(area / MAX_DOTS)));
      cols = Math.ceil(w / dotSize);
      rows = Math.ceil(h / dotSize);
      total = cols * rows;
    }

    grid.dataset.cols = String(cols);
    grid.dataset.rows = String(rows);
    (grid as HTMLElement).style.gridTemplateColumns = `repeat(${cols}, ${dotSize}px)`;
    (grid as HTMLElement).style.gridTemplateRows = `repeat(${rows}, ${dotSize}px)`;

    // Fisherâ€“Yates shuffle for animation order
    const indices = Array.from({ length: total }, (_, i) => i);
    for (let i = total - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    const maxDelayMs = 4000;
    const brakeThreshold = rows - BRAKE_ROWS;
    const fragment = document.createDocumentFragment();
    const dotsList: HTMLElement[] = [];

    for (let i = 0; i < total; i++) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const dot = document.createElement("span");
      dot.className = "preloader-dot";
      dot.style.setProperty("--delay", (indices[i] / total) * maxDelayMs + "ms");
      dot.dataset.row = String(row);
      dot.dataset.col = String(col);
      if (row >= brakeThreshold) dot.dataset.brakeZone = "true";
      fragment.appendChild(dot);
      dotsList.push(dot);
    }
    grid.appendChild(fragment);

    DotGridController.init(grid as HTMLElement, { cols, rows, dotSize, dots: dotsList });

    // Mask expand: use CSS transition instead of rAF loop
    const maskExpandDelayMs = maxDelayMs + 600;
    const body = document.body;
    const hasMask =
      body?.classList.contains("mask-center") ||
      body?.classList.contains("mask-top-left") ||
      body?.classList.contains("mask-top-right");

    if (hasMask) {
      const g = grid as HTMLElement;
      g.style.setProperty("--preloader-mask-radius", "70%");
      g.style.transition = "--preloader-mask-radius 0.6s ease-out";
      setTimeout(() => {
        g.style.setProperty("--preloader-mask-radius", "100%");
        grid.setAttribute("data-mask-full", "true");
      }, maskExpandDelayMs);
    }
  })();

  (window as any).dotGrid = DotGridController;
</script>

<style is:global>
  body.preloading footer {
    visibility: hidden;
    pointer-events: none;
  }

  .preloader-dot-grid {
    position: fixed;
    inset: 0;
    z-index: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, 13px);
    grid-auto-rows: 13px;
    gap: 0;
    align-content: start;
    justify-content: start;
    transition: opacity 0.4s ease-out;
  }
  .preloader-dot {
    width: 1px;
    height: 1px;
    background: #000;
    border-radius: 50%;
    justify-self: center;
    align-self: center;
    animation: preloader-dot-to-primary 0.5s ease-in-out var(--delay, 0) forwards;
    transition:
      transform 0.12s ease-out,
      box-shadow 0.12s ease-out;
  }
  .preloader-dot-grid.preloader-completing .preloader-dot {
    animation: preloader-dot-to-primary 0.2s cubic-bezier(0.4, 0, 1, 1) 0s forwards;
  }
  @keyframes preloader-dot-to-primary {
    from {
      background-color: #000;
    }
    to {
      background-color: var(--preloader-dot-primary, var(--color-primary-500));
    }
  }

  .preloader-dot-grid[data-brake-intensity] .preloader-dot[data-brake-zone="true"] {
    background: linear-gradient(
      180deg,
      #1a0505 0%,
      #8b0000 30%,
      #dc2626 60%,
      #f87171 100%
    ) !important;
    opacity: var(--brake-intensity, 0);
    box-shadow: 0 0 6px rgba(220, 38, 38, 0.6);
  }

  .preloader-dot-grid[data-mode="hover"] .preloader-dot {
    box-shadow: 0 0 calc(4px + 6 * var(--hover, 0))
      var(--preloader-dot-primary, var(--color-primary-500));
    opacity: calc(0.6 + 0.4 * var(--hover, 0));
  }

  .preloader-dot-grid[data-mode="equalizer"] .preloader-dot {
    transform: scale(0.4 + 0.8 * var(--eq, 0.5));
  }
</style>
