---
interface Props {
  title?: string;
  description?: string;
  currentUser?: any;
  session?: any;
  project?: any;
  supabase?: any;
  supabaseUrl?: string;
  projects?: any;
  isBackend?: boolean;
  id?: string;
  globalPrimaryTextClasses?: string;
  globalSecondaryTextClasses?: string;
  globalInputClasses?: string;
  year?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  noFooter?: boolean;
  globalCompanyAddress?: string;
  globalCompanyPhone?: string;
  globalCompanyEmail?: string;
  globalCompanyWebsite?: string;
  globalCompanyLogo?: string;
  globalCompanyLogoDark?: string;
  globalCompanyLogoLight?: string;
  statusData?: any;
}

const {
  title = undefined,
  description = undefined,
  currentUser = undefined,
  session = undefined,
  project = undefined,
  supabase = undefined,
  supabaseUrl = undefined,
  projects = undefined,
  id = undefined,

  statusData = undefined,
} = Astro.props;

import { globalCompanyData } from "../../pages/api/global-company-data";
const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
} = globalCompanyData();

import { globalClasses } from "../../pages/api/global-classes";
const { globalInputClasses, globalPrimaryTextClasses, globalSecondaryTextClasses } =
  globalClasses();

// Derived properties (8 props â†’ 13 total)
const isAuth = currentUser ? true : false;
const currentUserId = currentUser?.id || undefined;
const currentRole = currentUser?.profile.role || undefined;
const projectId = project?.id || undefined;
const currentUrl = Astro.url.pathname;

// Get navigation data
import { navigation } from "@/pages/api/navigation";
import { isBackendPage } from "@/pages/api/backend-page-check";
const isBackend = isBackendPage(currentUrl);
const navigationData = navigation(currentUrl, isAuth, currentRole || "Client", isBackend || false);
const { desktopNavigationHTML, visibleNavItems } = navigationData;

import "../../styles/global.css"; // Import Tailwind CSS
// import "../../styles/app.css"; // Import Tailwind CSS
import "../../styles/boxicons.css"; // this is sketchy

import Preloader from "./Preloader.astro";
import Footer from "./Footer.astro";
import UnifiedNotification from "./UnifiedNotification.astro";
import CookieBanner from "./CookieBanner.astro";
import SpeedDial from "./SpeedDial.astro";
import Navbar from "./Navbar.astro";
import Aside from "./Aside.astro";
import ScrollProgressIndicator from "./ScrollProgressIndicator.astro";
import TutorialOverlay from "./TutorialOverlay.astro";
import DebugPanel from "./DebugPanel.astro";

// Notification count loader will be loaded via script tag

// Prepare debug data for admin users
const debugData = {
  // Original props
  title,
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
  description,
  currentUser,
  session,
  project,
  supabase,
  supabaseUrl,
  projects,
  isBackend,
  id,
  statusData,
  // Derived properties
  isAuth,
  projectId,
  currentUrl,
  // Navigation data
  navigationData,
  desktopNavigationHTML,
  visibleNavItems,
  // Additional context
  astroUrl: Astro.url,
  astroRequest: {
    method: Astro.request.method,
    headers: Object.fromEntries(Astro.request.headers.entries()),
    url: Astro.request.url,
  },
};
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="author" content="Tomsens+REKKO" />
    <!-- <meta name="generator" content="Hugo 0.123.8" /> -->

    <!-- Safari 18 beta specific viewport fixes -->
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>
      {globalCompanyName + " â†’ " + (title || Astro.url.pathname.replace(/\//g, " ").trim())}
    </title>

    <meta name="description" content={description} />

    <!-- <link
      rel="stylesheet"
      href="https://www.unpkg.com/flowbite-datepicker@1.3.2/dist/css/datepicker.min.css"
    /> -->

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" sizes="any" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="any" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-project-title" content={globalCompanyName} />
    <meta name="generator" content={Astro.generator} />
    <!-- Safari Privacy Protection Meta Tags -->
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups" />
    <meta property="og:title" content={title + " â†’ " + globalCompanyName} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content="/img/capco-logo.png" />
    <meta property="og:url" content={Astro.url} />
    <meta name="twitter:card" content={description} />
    <meta name="twitter:title" content={title + " â†’ " + globalCompanyName} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content="/img/capco-logo.png" />

    <meta name="robots" content="max-image-preview:large" /><link
      rel="canonical"
      href={currentUrl}
    />
    <meta property="og:site_name" content="CAPCo Fire" /><meta
      property="og:type"
      content="website"
    />
    <!-- <link rel="canonical" href="https://flowbite.com/application-ui/demo/" />-->

    <!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    /> -->

    <!-- Font styles are handled by CSS files -->

    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />
    <!-- 

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="https://flowbite.com/application-ui/demo/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="https://flowbite.com/application-ui/demo/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="https://flowbite.com/application-ui/demo/favicon-16x16.png"
    />
    <link rel="icon" type="image/png" href="https://flowbite.com/application-ui/demo/favicon.ico" />
    <link rel="manifest" href="https://flowbite.com/application-ui/demo/site.webmanifest" />
    <link
      rel="mask-icon"
      href="https://flowbite.com/application-ui/demo/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="theme-color" content="#ffffff" /> -->

    <!-- Twitter -->
    <!-- <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta name="twitter:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      name="twitter:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta name="twitter:image" content="https://flowbite.com/application-ui/demo/" /> -->

    <!-- Facebook -->
    <!-- <meta property="og:url" content="https://flowbite.com/application-ui/demo/" />
    <meta property="og:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      property="og:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://flowbite.com/application-ui/demo/images/og-image.jpg"
    />
    <meta property="og:image:type" content="image/png" /> -->

    <script>
      import {
        initializeNotificationCount,
        loadNotificationCount,
        refreshNotificationCount,
        updateNotificationBellCount,
      } from "@/lib/notification-count-loader";

      // Make functions globally available
      (window as any).initializeNotificationCount = initializeNotificationCount;
      (window as any).updateNotificationBellCount = updateNotificationBellCount;
      (window as any).loadNotificationCount = loadNotificationCount;
      (window as any).refreshNotificationCount = refreshNotificationCount;

      // Global utility function to convert camelCase to Proper Case
      (window as any).camelToProper = (str: string): string => {
        if (!str) return "";

        // Handle special cases first
        const specialCases: { [key: string]: string } = {
          id: "ID",
          url: "URL",
          api: "API",
          sms: "SMS",
          email: "Email",
          phone: "Phone",
          status: "Status",
          project: "Project",
          user: "User",
          admin: "Admin",
          client: "Client",
          staff: "Staff",
          role: "Role",
          name: "Name",
          title: "Title",
          address: "Address",
          created: "Created",
          updated: "Updated",
          completed: "Completed",
          incomplete: "Incomplete",
          failed: "Failed",
          sent: "Sent",
          received: "Received",
          uploaded: "Uploaded",
          downloaded: "Downloaded",
          added: "Added",
          changed: "Changed",
          login: "Login",
          logout: "Logout",
          registration: "Registration",
          action: "Action",
          event: "Event",
          error: "Error",
          info: "Info",
          system: "System",
          notification: "Notification",
          discussion: "Discussion",
          punchlist: "Punchlist",
          proposal: "Proposal",
          assignment: "Assignment",
          comment: "Comment",
          file: "File",
        };

        // Split camelCase into words
        const words = str
          .replace(/([A-Z])/g, " $1")
          .trim()
          .split(" ");

        // Convert each word to proper case
        const properWords = words.map((word) => {
          const lowerWord = word.toLowerCase();

          // Check special cases first
          if (specialCases[lowerWord]) {
            return specialCases[lowerWord];
          }

          // Default: capitalize first letter
          return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        });

        return properWords.join(" ");
      };
    </script>

    <!-- Set global user data for client-side components -->
  </head>

  <body class="bg-gray-50 antialiased dark:bg-gray-900">
    <!-- Preloader -->
    <Preloader />

    <Navbar
      {desktopNavigationHTML}
      {currentUser}
      {session}
      {supabaseUrl}
      {id}
      {projects}
      {project}
      {isBackend}
    />

    <div class="safari-18-fix flex min-h-screen bg-gray-50 pt-16 dark:bg-gray-900">
      <Aside
        {currentUser}
        {project}
        {globalInputClasses}
        primaryTextClasses={globalPrimaryTextClasses}
        secondaryTextClasses={globalSecondaryTextClasses}
      />

      <div
        id="main-content"
        class=`relative flex min-h-full w-full flex-col overflow-x-scroll bg-gray-50 dark:bg-gray-900 ${currentUser && currentRole !== "Client" ? "" : ""}`
      >
        <main class="flex-1">
          <slot />
        </main>
        <!-- Footer -->
        <Footer
          {globalInputClasses}
          {globalSecondaryTextClasses}
          {globalPrimaryTextClasses}
          {currentUser}
          {globalCompanyName}
          {globalCompanyAddress}
          {globalCompanyPhone}
          {globalCompanyEmail}
          {globalCompanyWebsite}
          {globalCompanyLogo}
          {globalCompanyLogoDark}
          {globalCompanyLogoLight}
        />
      </div>
    </div>

    <!-- Unified Notification System -->
    <UnifiedNotification />
    <!-- Cookie Banner -->
    <CookieBanner />
    <!-- Speed Dial -->
    <SpeedDial
      currentUser={currentUser || undefined}
      {isBackend}
      {debugData}
      {globalPrimaryTextClasses}
      {globalSecondaryTextClasses}
      {globalInputClasses}
    />

    <ScrollProgressIndicator />

    <TutorialOverlay {currentUser} tutorialId="demo-tour" autoStart={false} {isAuth} />
    <!-- Debug Panel (Admin Only) -->
    <DebugPanel {currentUser} {debugData} />

    <!-- Flowbite JavaScript -->
    <script src="https://unpkg.com/flowbite@2.5.2/dist/flowbite.min.js"></script>

    <script>
      declare global {
        interface Window {
          // Global functions and utilities (alphabetized)
          acceptProposal?: () => void;
          addNewLineItem?: () => void;
          camelToProper?: (str: string) => string;
          clipboardData?: any;
          createLineItemRow?: (data: any) => HTMLElement;
          createButtonPartial?: (config: any) => Promise<HTMLElement | null>;
          deleteProject?: (projectId: any) => void;
          getProject?: (projectId: string | number) => Promise<any>;
          handleNewStatusModalAndEmail?: any;
          handleUrlNotification?: (type: string, message: string) => void;
          hideOnFormFocus?: (elementSelector: string, mobileOnly?: boolean) => void;
          hideNotification?: any;
          // UX Utility Functions
          scrollToTopOnMobile?: () => void;
          scrollToTop?: (behavior?: ScrollBehavior) => void;
          isMobile?: () => boolean;
          isTablet?: () => boolean;
          isDesktop?: () => boolean;
          getViewportSize?: () => "mobile" | "tablet" | "desktop";
          debounce?: <T extends (...args: any[]) => any>(func: T, wait: number) => T;
          throttle?: <T extends (...args: any[]) => any>(func: T, limit: number) => T;
          truncateString?: (str: string, maxLength?: number, suffix?: string) => string;
          hideOnMobileInput?: (elementSelector: string) => void;
          isSafariIOS?: () => boolean;
          isSafari?: () => boolean;
          isSafariBeta?: () => boolean;
          isSafari18OrLater?: () => boolean;
          fixSafariViewport?: () => void;
          immediateSafariViewportFix?: () => void;
          setupViewportHandling?: () => void;
          ensureViewportBounds?: (minHeight?: number, maxHeight?: number) => void;
          lockBodyScroll?: () => void;
          unlockBodyScroll?: () => void;
          initializeSubjectEditing?: () => void;
          proposalHelper?: any;
          proposalManager?: any;
          refreshManager?: any;
          requestPushNotificationPermission?: () => void;
          resetForm?: any;
          resetNotifications?: () => void;
          sendEmail?: (emailData: any, currentUser: any) => Promise<any>;
          setPageLoadStatusActionsFromUrl?: any;
          showModal?: any;
          switchTab?: any;
          toggleCommentForm?: () => void;
          trimText?: (text: string, maxLength?: number, suffix?: string) => string;
          trimWords?: (text: string, wordLimit?: number, suffix?: string) => string;
          updateCountBubble?: (
            parentElement: HTMLElement,
            count: number,
            options?: any
          ) => HTMLElement | null;
          updateProposalTotal?: () => void;
          updateStatus?: (project: any, newStatus: number, statuses?: any) => Promise<any>;
          validateEmail?: (email: string) => string | null;
          COUNT_BUBBLE_PRESETS?: {
            notification: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            punchlist: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            small: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
          };
        }
      }
      // Make data available globally for the proposal functions
      // import { setupConsoleInterceptor } from "../../lib/console-interceptor.ts";
      // Set Stripe publishable key globally for PaymentForm
      (window as any).STRIPE_PUBLISHABLE_KEY = import.meta.env.PUBLIC_STRIPE_PUBLISHABLE_KEY;
      console.log("ðŸ”§ [STRIPE] Publishable key loaded:", !!(window as any).STRIPE_PUBLISHABLE_KEY);

      // Helper function to create buttons using Button partial
      (window as any).createButtonPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-button-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/button", {
            headers: headers,
          });

          if (response.ok) {
            const buttonHTML = await response.text();
            const wrapper = document.createElement("div");
            wrapper.innerHTML = buttonHTML;
            return wrapper.firstElementChild;
          } else {
            console.error("Failed to fetch button partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating button partial:", error);
          return null;
        }
      };

      if (!String.prototype.startsWith) {
        console.log("ðŸ”§ [POLYFILL] Adding startsWith polyfill...");
        String.prototype.startsWith = function (search: string, pos?: number) {
          return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
        console.log("ðŸ”§ [POLYFILL] startsWith polyfill added successfully");
      } else {
        console.log("ðŸ”§ [POLYFILL] startsWith already available");
      }

      (window as any).hideNotification = function () {
        console.log("[FALLBACK-NOTIFICATION] Hiding notification");
      };

      (window as any).switchTab = function (tabName: string) {
        console.log(`[TAB] Switching to: ${tabName}`);

        // Find all tab contents
        const tabContents = document.querySelectorAll(".tab-content");

        // Hide all tabs first
        tabContents.forEach((tab) => {
          (tab as HTMLElement).style.display = "none";
        });

        // Show the selected tab
        const selectedTab = document.getElementById(`content-${tabName}`);
        if (selectedTab) {
          selectedTab.style.display = "block";

          // Check if this tab has an initialization function
          const initFuncName = selectedTab.getAttribute("data-tab-init");
          if (initFuncName && (window as any)[initFuncName]) {
            console.log(`[TAB] Initializing tab with function: ${initFuncName}`);
            (window as any)[initFuncName]();
          }
        }
      };

      (window as any).handleNewStatusModalAndEmail = function (response: any, context: string) {
        if (!response) {
          console.error(`ERROR [${context || "NOTIFICATION"}] API call failed:`, response.error);
          return;
        }

        if (!response.statusData || !(window as any).showModal) {
          console.warn(
            `WARNING [${context || "NOTIFICATION"}] No notification data or showModal function available`
          );
          return;
        }

        // Get the current status configuration
        const clientNotification = response.statusData?.client;
        const adminNotification = response.statusData?.admin;
        const currentNotification = response.statusData?.current;
        const currentUser = response.currentUser;

        clientNotification.email.currentUser = currentUser;
        adminNotification.email.currentUser = currentUser;
        // Send email if email configuration exists
        if (clientNotification?.email) {
          (window as any).sendEmail(clientNotification.email);
        }

        if (adminNotification?.email) {
          (window as any).sendEmail(adminNotification.email);
        }

        console.log("currentUser from notice", currentUser);
        if (currentNotification?.modal) {
          const modalData = {
            ...currentNotification.modal,
            redirect: currentNotification.modal.redirect
              ? {
                  url: currentNotification.modal.redirect.url,
                  showCountdown: currentNotification.modal.redirect.showCountdown || true,
                }
              : undefined,
          };
          console.log("ðŸ”” [STATUS-MODAL] Showing modal with data:", modalData);
          (window as any).showModal(modalData);
        } else {
          console.warn(`WARNING [${context || "NOTIFICATION"}] No notification found in response`);
        }
      };

      // Assign imported function to global window object
      // @ts-ignore - Function is imported and used, but TypeScript doesn't recognize the assignment

      (window as any).hideOnFormFocus = function () {
        // Check if we should only hide on mobile
        if (!(window as any).isMobile()) return;

        const element = document.querySelector(".hide-when-form-focus");
        if (!element) return;

        // Hide on input focus
        const hideOnFocus = () => {
          (element as HTMLElement).style.display = "none";
        };

        // Show on input blur
        const showOnBlur = () => {
          (element as HTMLElement).style.display = "block";
        };

        const selector = "input, textarea, select, form, button, label, .slot-machine-modal";
        // Add event listeners to all form inputs
        const inputs = document.querySelectorAll(selector);
        inputs.forEach((input) => {
          input.addEventListener("focus", hideOnFocus);
          input.addEventListener("blur", showOnBlur);
        });

        // Also handle dynamically added inputs
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newInputs = element.querySelectorAll
                  ? element.querySelectorAll(selector)
                  : [];
                newInputs.forEach((input) => {
                  input.addEventListener("focus", hideOnFocus);
                  input.addEventListener("blur", showOnBlur);
                });
              }
            });
          });
        });

        observer.observe(document.body, { childList: true, subtree: true });
      };

      // Auto-focus next field on autofill detection (browser/OS only, not manual typing) - COMMENTED OUT
      /*
      (window as any).setupAutofillNavigation = function () {
        const form = document.querySelector("form");
        if (!form) return;

        const inputs = Array.from(
          form.querySelectorAll("input, textarea, select")
        ) as HTMLInputElement[];

        inputs.forEach((input, index) => {
          let isUserTyping = false;
          let autofillDetected = false;

          // Track user typing to distinguish from autofill
          input.addEventListener("input", () => {
            isUserTyping = true;
            autofillDetected = false;
          });

          input.addEventListener("keydown", () => {
            isUserTyping = true;
            autofillDetected = false;
          });

          // Reset typing flag after user stops
          let typingTimeout: number;
          input.addEventListener("input", () => {
            clearTimeout(typingTimeout);
            typingTimeout = window.setTimeout(() => {
              isUserTyping = false;
            }, 1000);
          });

          // Handle autofill detection
          const handleAutofill = () => {
            // Only proceed if this is actual autofill, not user typing
            if (autofillDetected && !isUserTyping && input.value && input.value.trim() !== "") {
              console.log(
                "ðŸ” [AUTOFILL] Detected browser/OS autofill in field:",
                input.name || input.id
              );

              // Find next input in sequence
              const nextInput = inputs[index + 1];
              if (nextInput && !nextInput.disabled && nextInput.type !== "hidden") {
                console.log("ðŸ” [AUTOFILL] Moving to next field:", nextInput.name || nextInput.id);
                setTimeout(() => {
                  nextInput.focus();
                  // Trigger input event to ensure any validation runs
                  nextInput.dispatchEvent(new Event("input", { bubbles: true }));
                }, 100);
              }
            }
          };

          // Method 1: CSS animation detection (most reliable for autofill)
          input.addEventListener("animationstart", (e) => {
            if (e.animationName === "onAutoFillStart") {
              autofillDetected = true;
              handleAutofill();
            }
          });

          // Method 2: Focus + immediate value change (autofill signature)
          let focusTime = 0;
          input.addEventListener("focus", () => {
            focusTime = Date.now();
          });

          input.addEventListener("input", () => {
            const timeSinceFocus = Date.now() - focusTime;
            // If value changed within 100ms of focus, likely autofill
            if (timeSinceFocus < 100 && !isUserTyping) {
              autofillDetected = true;
              setTimeout(handleAutofill, 50);
            }
          });

          // Method 3: Detect autofill by checking if input was filled without user interaction
          let lastValue = input.value;
          let lastUserInteraction = Date.now();

          input.addEventListener("input", () => {
            lastUserInteraction = Date.now();
          });

          // Check for autofill every 500ms (reduced frequency)
          setInterval(() => {
            const timeSinceInteraction = Date.now() - lastUserInteraction;
            const valueChanged = input.value !== lastValue && input.value.trim() !== "";

            // If value changed and no recent user interaction, it's likely autofill
            if (valueChanged && timeSinceInteraction > 2000 && !isUserTyping) {
              autofillDetected = true;
              lastValue = input.value;
              handleAutofill();
            }
          }, 500);
        });
      };
      */

      (window as any).sendEmail = async function (emailData: any, currentUser: any) {
        try {
          // Transform the email data to match the update-delivery API structure
          const transformedData = {
            usersToNotify: emailData.usersToNotify, // TODO: Get actual user emails
            method: emailData.method || "email", // Use method instead of emailType
            emailSubject: emailData.emailSubject || "Project Update",
            emailContent: emailData.emailContent || JSON.stringify(emailData),
            buttonLink: emailData.buttonLink,
            buttonText: emailData.buttonText,
            project: {}, // TODO: Pass actual project data
            currentUser: currentUser, // TODO: Pass actual current user
          };

          console.log("ðŸ“§ [SEND-EMAIL] Sending email with data:", transformedData);

          const response = await fetch("/api/update-delivery", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(transformedData),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global sendEmail error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).getProject = async function (projectId: string | number) {
        const projectResponse = await fetch(`/api/get-project?id=${projectId}`);
        if (projectResponse.ok) {
          return await projectResponse.json();
        } else {
          throw new Error("Failed to fetch project");
        }
      };

      // Delete project function
      let isDeleting = false; // Flag to prevent multiple delete operations
      (window as any).deleteProject = function (projectId: any) {
        // Prevent multiple delete operations
        if (isDeleting) {
          console.log("Delete operation already in progress, ignoring request");
          return;
        }

        // Validate project ID - ensure it's a string
        console.log("ðŸ”§ [DELETE] projectId type:", typeof projectId, "value:", projectId);
        const projectIdStr = String(projectId);
        console.log("ðŸ”§ [DELETE] projectIdStr:", projectIdStr);
        if (!projectId || projectIdStr.startsWith("new-project-")) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "error",
              "Delete Failed",
              "Cannot delete a new project that hasn't been saved yet.",
              5000
            );
          }

          return;
        }

        // Show confirmation modal with action buttons
        if ((window as any).showModal) {
          (window as any).showModal(
            "error",
            "Delete Project",
            "Are you sure you want to delete this project? This action cannot be undone.",
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                variant: "anchor",
                fullWidth: true,
                action: () => {},
              },
              {
                label: "Delete",
                variant: "danger",
                fullWidth: true,
                action: () => {
                  // Set deleting flag to prevent multiple operations
                  isDeleting = true;

                  // Show loading state
                  const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
                  deleteBtn?.setAttribute("data-loading", "true");
                  if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML =
                      '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
                  }

                  // Make API call to delete project
                  console.log("Sending delete request for project:", projectId);
                  fetch(`/api/delete-project`, {
                    method: "DELETE",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ projectId }),
                  })
                    .then(async (response) => {
                      const data = await response.json();

                      if (!response.ok) {
                        throw new Error(data.error || "Failed to delete project");
                      }

                      // Show success modal
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "success",
                          "Project Deleted!",
                          data.message || "Project has been deleted successfully.",
                          1500
                        );
                      }

                      // Reset deleting flag
                      isDeleting = false;

                      document
                        .querySelectorAll("[data-project-id='" + projectId + "']")
                        ?.forEach((element) => {
                          element.remove();
                        });

                      // Redirect to dashboard after a short delay
                      // setTimeout(() => {
                      //   window.location.href = "/project/dashboard";
                      // }, 1500);
                    })
                    .catch((error) => {
                      console.error("Error deleting project:", error);

                      // Show error modal with specific error message
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "error",
                          "Delete Failed",
                          error.message || "Failed to delete project. Please try again.",
                          6000000
                        );
                      }

                      // Reset deleting flag and button state
                      isDeleting = false;
                      if (deleteBtn) {
                        deleteBtn.disabled = false;
                        deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                      }
                    });
                },
              },
            ]
          );
        }
      };

      // Request push notification permission
      (window as any).requestPushNotificationPermission = function () {
        console.log("ðŸ”” [APP] Checking notification permission...");
        console.log("ðŸ”” [APP] Notification in window:", "Notification" in window);
        console.log(
          "ðŸ”” [APP] Current permission:",
          "Notification" in window ? Notification.permission : "Not available"
        );

        // Check if we're on mobile Safari
        const isMobileSafari =
          /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
        console.log("ðŸ”” [APP] Mobile Safari detected:", isMobileSafari);

        if (isMobileSafari) {
          console.log(
            "ðŸ”” [APP] Mobile Safari detected - push notifications work when installed as PWA"
          );
          console.log("ðŸ”” [APP] Install as PWA (Add to Home Screen) for full notification support");

          // Check if running as PWA
          const isStandalone =
            (window as any).matchMedia("(display-mode: standalone)").matches ||
            (window.navigator as any).standalone === true;
          console.log("ðŸ”” [APP] Running as PWA:", isStandalone);

          if (!isStandalone) {
            console.log("ðŸ’¡ [APP] Install as PWA for better notification support");
            return;
          }
        }

        // Only request if user hasn't been prompted yet
        if ("Notification" in window && Notification.permission === "default") {
          console.log("ðŸ”” [APP] Requesting notification permission...");
          // Request permission immediately in user interaction context
          Notification.requestPermission().then((permission) => {
            console.log("ðŸ”” [APP] Permission result:", permission);
            if (permission === "granted") {
              console.log("ðŸ”” Push notifications enabled for authenticated user!");
              // Show a subtle notification
              if ((window as any).showModal) {
                (window as any).showModal(
                  "info",
                  "Notifications Enabled",
                  "You'll receive push notifications for project updates!",
                  3000
                );
              }
            } else {
              console.log("ðŸ”” Push notifications declined by user");
            }
          });
        } else {
          console.log("ðŸ”” [APP] Not requesting permission - already handled or not available");
        }
      };

      // Reset notification permissions for debugging
      (window as any).resetNotifications = function () {
        console.log("ðŸ”„ [APP] Resetting notification permissions...");

        // Check if we're on mobile Safari
        const isMobileSafari =
          /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);

        if (isMobileSafari) {
          console.log(
            "ðŸ“± [APP] Mobile Safari detected - push notifications work when installed as PWA"
          );
          console.log("ðŸ’¡ [APP] Install as PWA (Add to Home Screen) for full notification support");

          // Check if running as PWA
          const isStandalone =
            window.matchMedia("(display-mode: standalone)").matches ||
            (window.navigator as any).standalone === true;
          console.log("ðŸ”” [APP] Running as PWA:", isStandalone);

          if (!isStandalone) {
            console.log("ðŸ’¡ [APP] Install as PWA for better notification support");
            return;
          }
        }

        console.log(
          "ðŸ”„ [APP] Current permission:",
          "Notification" in window ? Notification.permission : "Not available"
        );

        // Clear any stored permission state
        localStorage.removeItem("notification-permission-requested");
        sessionStorage.removeItem("notification-permission-requested");

        // Force a new permission request
        if ("Notification" in window) {
          Notification.requestPermission().then((permission) => {
            console.log("ðŸ”„ [APP] Reset permission result:", permission);
            if (permission === "granted") {
              console.log("âœ… Notifications re-enabled!");
            } else {
              console.log("âŒ Notifications still denied");
            }
          });
        }
      };

      // Request notification permission on first user interaction
      let permissionRequested = false;
      const requestPermissionOnInteraction = () => {
        if (!permissionRequested) {
          permissionRequested = true;
          (window as any).requestPushNotificationPermission();
          // Remove listeners after first interaction
          document.removeEventListener("click", requestPermissionOnInteraction);
          document.removeEventListener("touchstart", requestPermissionOnInteraction);
        }
      };

      // Listen for first user interaction
      document.addEventListener("click", requestPermissionOnInteraction);
      document.addEventListener("touchstart", requestPermissionOnInteraction);

      (window as any).updateStatus = async function (
        project: any,
        status: number,
        currentStatusData?: any
      ) {
        (window as any).showModal(
          "info",
          "Processing...",
          "Please wait... This may take a few seconds.",
          5000
        );

        try {
          // If project exists, use it; otherwise fetch it
          let currentProject = project;
          if (!currentProject) {
            console.log("ðŸ“Š [UPDATE-STATUS] No project provided, fetching full project data...");
            try {
              currentProject = await (window as any).getProject(project);
            } catch (error) {
              console.log(
                "ðŸ“Š [UPDATE-STATUS] Could not fetch project, using minimal object:",
                error
              );
              currentProject = {
                id: project.id,
                status: 0,
              };
            }
          }

          const response = await fetch("/api/update-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              currentProject,
              newStatus: status,
              currentStatusData: currentStatusData || null, // Pass the current status data
            }),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global updateStatus error:", error);
          return { success: false, error: error.message };
        }
      };

      // Global count bubble utility
      (window as any).updateCountBubble = function (
        parentElement: HTMLElement,
        count: number,
        options: any = {}
      ) {
        if (!parentElement) {
          console.warn("ðŸ” [COUNT-BUBBLE] Parent element is null or undefined");
          return null;
        }

        const config = {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          parentClasses: "relative",
          maxCount: 99,
          showZero: false,
          ...options,
        };

        // Find existing bubble or create new one
        let countBubble = parentElement.querySelector(".count-bubble") as HTMLSpanElement;

        if (count > 0 || config.showZero) {
          // Create bubble if it doesn't exist
          if (!countBubble) {
            countBubble = document.createElement("span");
            countBubble.className = `count-bubble ${config.bubbleClasses}`;

            // Add parent classes if specified
            if (config.parentClasses) {
              parentElement.classList.add(...config.parentClasses.split(" "));
            }

            parentElement.appendChild(countBubble);
            console.log("ðŸ” [COUNT-BUBBLE] Created new bubble for element:", parentElement);
          }

          // Update bubble content and visibility
          const displayCount = count > config.maxCount ? `${config.maxCount}+` : count.toString();
          countBubble.textContent = displayCount;
          countBubble.style.display = "flex";

          // Update data attribute for accessibility
          parentElement.setAttribute("data-count", count.toString());

          console.log("ðŸ” [COUNT-BUBBLE] Updated bubble:", {
            count,
            displayCount,
            element: parentElement,
          });
        } else {
          // Hide bubble when count is 0 (unless showZero is true)
          if (countBubble) {
            countBubble.style.display = "none";
            parentElement.removeAttribute("data-count");
            console.log("ðŸ” [COUNT-BUBBLE] Hidden bubble (count is 0)");
          }
        }

        return countBubble;
      };

      // Count bubble presets - single source of truth
      (window as any).COUNT_BUBBLE_PRESETS = {
        default: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        notification: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-600 animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        small: {
          bubbleClasses:
            "absolute -right-1 -top-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 9,
          showZero: false,
        },
      };

      // String utility functions
      (window as any).unslugify = function (slug: string): string {
        return (
          slug
            .split("/")
            .filter(Boolean)
            .pop() // Get last segment
            ?.split("-")
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ") || "Home"
        );
      };

      // ===== UX UTILITY FUNCTIONS =====

      // Scroll utilities
      (window as any).scrollToTopOnMobile = function () {
        if (window.innerWidth < 768) {
          console.log("ðŸ“± [UX-UTILS] Scrolling to top on mobile device");
          (window as any).scrollTo({ top: 0, behavior: "smooth" });
        }
      };

      (window as any).scrollToTop = function (behavior = "smooth") {
        console.log("ðŸ“± [UX-UTILS] Scrolling to top");
        (window as any).scrollTo({ top: 0, behavior });
      };

      // Device detection
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };

      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };

      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).getViewportSize = function () {
        if (window.innerWidth < 768) return "mobile";
        if (window.innerWidth < 1024) return "tablet";
        return "desktop";
      };

      // Utility functions
      (window as any).debounce = function (func: any, wait: any) {
        let timeout: any;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      (window as any).throttle = function (func: any, limit: any) {
        let inThrottle: any;
        return function executedFunction(this: any, ...args: any[]) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // String utilities
      (window as any).truncateString = function (
        str: string,
        maxLength: number = 30,
        suffix: string = "..."
      ) {
        if (!str) return "";
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).validateEmail = function (email: string): string | null {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) ? null : "Invalid email format";
      };

      (window as any).isSafariBeta = function () {
        const ua = navigator.userAgent;
        // Check if iOS device
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        // Extract Safari version
        const versionMatch = ua.match(/Version\/(\d+)\./);
        const safariVersion = versionMatch ? parseInt(versionMatch[1]) : null;
        // Check if Safari (not Chrome/Firefox/Edge)
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        // Updated to handle beta 26 and later
        const isBetaVersion = safariVersion && safariVersion >= 18 && safariVersion <= 30;
        const result = isIOS && isSafari && isBetaVersion;

        return result;
      };
      (window as any).isSafariIOS = function () {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        return isIOS && isSafari;
      };
      (window as any).isSafari = function () {
        const ua = navigator.userAgent;
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
      };
      (window as any).isSafari18OrLater = function () {
        const ua = navigator.userAgent;
        const safariMatch = ua.match(/Version\/(\d+)/);
        if (!safariMatch) return false;
        const version = parseInt(safariMatch[1]);
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua) && version >= 18;
      };
      (window as any).fixSafariViewport = function () {
        if ((window as any).isSafariIOS()) {
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", vh + "px");
        }
      };
      (window as any).immediateSafariViewportFix = function () {
        if ((window as any).isSafariIOS()) {
          const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
          };
          setViewportHeight();
          window.addEventListener("orientationchange", () => setTimeout(setViewportHeight, 100));
          window.addEventListener("resize", setViewportHeight);
        }
      };
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };
      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };
      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).setupViewportHandling = function () {
        (window as any).immediateSafariViewportFix();
      };

      (window as any).ensureViewportBounds = function (minHeight = 400, maxHeight = 1200) {
        const currentHeight = window.innerHeight;
        if (currentHeight < minHeight || currentHeight > maxHeight) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "warning",
              "Viewport Issue",
              `Viewport height (${currentHeight}px) is outside recommended bounds (${minHeight}-${maxHeight}px)`,
              5000
            );
          }
        }
      };

      // Body scroll utilities
      (window as any).lockBodyScroll = function () {
        document.body.style.overflow = "hidden";
      };

      (window as any).unlockBodyScroll = function () {
        document.body.style.overflow = "";
      };

      /**
       * Handles URL parameter notifications (errors and success messages)
       * @param type - Notification type ('error' | 'success')
       * @param param - URL parameter value
       */
      (window as any).handleUrlNotification = function (
        type: "error" | "success",
        param: string
      ): void {
        const notifications = {
          // Error notifications
          error: {
            oauth_failed: {
              title: "Authentication Failed",
              message: "OAuth authentication failed. Please try again.",
            },
            verification_failed: {
              title: "Verification Failed",
              message: "Email verification failed. Please try again.",
            },
            verification_expired: {
              title: "Link Expired",
              message: "Verification link has expired. Please request a new one.",
            },
            verification_invalid: {
              title: "Invalid Link",
              message: "Invalid verification link.",
            },
            verification_error: {
              title: "Verification Error",
              message: "An error occurred during verification.",
            },
            no_token: {
              title: "Invalid Token",
              message: "Invalid or missing verification token.",
            },
            no_user: { title: "User Not Found", message: "User not found." },
            invalid_credentials: {
              title: "Invalid Credentials",
              message: "Invalid email or password.",
            },
            email_exists: {
              title: "Account Exists",
              message: "An account with this email already exists.",
            },
            weak_password: {
              title: "Weak Password",
              message: "Password must be at least 6 characters long.",
            },
            invalid_email: {
              title: "Invalid Email",
              message: "Please enter a valid email address.",
            },
            sms_missing_fields: {
              title: "SMS Error",
              message: "Please fill in all required fields for SMS.",
            },
            sms_invalid_phone: {
              title: "Invalid Phone",
              message: "Please enter a valid 10-digit phone number.",
            },
            sms_invalid_carrier: {
              title: "Invalid Carrier",
              message: "Please select a valid carrier.",
            },
            sms_send_failed: {
              title: "SMS Failed",
              message: "Failed to send SMS. Please try again.",
            },
            sms_email_error: {
              title: "Service Error",
              message: "Email service error. Please try again later.",
            },
            sms_unexpected_error: {
              title: "SMS Error",
              message: "An unexpected error occurred while sending SMS.",
            },
            default: { title: "Error", message: "An error occurred. Please try again." },
          },
          // Success notifications
          success: {
            registration_success: {
              title: "Account Created",
              message: "Registration successful! Please check your email to verify your account.",
            },
            verification_success: {
              title: "Email Verified",
              message: "Email verified successfully! You can now sign in.",
            },
            welcome: {
              title: "Welcome!",
              message: "Welcome! Your account has been verified and you're now signed in.",
            },
            logout_success: {
              title: "Signed Out",
              message: "You have been successfully signed out.",
              redirect: { url: "/", delay: 3500, showCountdown: true },
            },
            sms_sent_success: {
              title: "Message Sent",
              message: `Your message has been sent to ${import.meta.env.GLOBAL_COMPANY_NAME} successfully.`,
            },
            // oauth_success: {
            //   title: "OAuth Success",
            //   message: `Your OAuth login has been successful.`,
            // },
            default: { title: "Success!", message: param },
          },
        };

        const notification = (notifications[type] as any)[param] || notifications[type].default;

        if ((window as any).showModal) {
          // Use global UX utility function for mobile scroll
          (window as any).scrollToTopOnMobile();

          if (type === "error") {
            (window as any).showModal("error", notification.title, notification.message);
          } else {
            (window as any).showModal(
              "success",
              notification.title,
              notification.message,
              2500,
              notification.redirect
            );
          }
        } else {
          console.error(`ðŸ”” [${notification.title}] ${notification.message}`);
          console.error("ðŸ”” showModal is not available - notification system not initialized");
        }
      };

      // ===== END GLOBAL FUNCTIONS =====

      // Setup console interceptor (disables console.log in production)
      // setupConsoleInterceptor();

      // // Handle URL parameter notifications (errors and success messages)
      (window as any).processUrlNotifications = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const errorParam = urlParams.get("error");
        const successParam = urlParams.get("success");
        const messageParam = urlParams.get("message");

        if (errorParam) {
          console.log("ðŸ”” [URL-NOTIFICATION] Processing error parameter:", errorParam);
          (window as any).handleUrlNotification("error", errorParam);

          // Clean up URL by removing the error parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("error");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (successParam) {
          console.log("ðŸ”” [URL-NOTIFICATION] Processing success parameter:", successParam);
          (window as any).handleUrlNotification("success", successParam);

          // Clean up URL by removing the success parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("success");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (messageParam) {
          console.log("ðŸ”” [URL-NOTIFICATION] Processing message parameter:", messageParam);
          (window as any).handleUrlNotification("success", messageParam);

          // Clean up URL by removing the message parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("message");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }
      };

      // // Process URL notifications on page load with retry mechanism
      const processUrlNotificationsWithRetry = (attempts = 0) => {
        if ((window as any).showModal) {
          // showModal is available, process notifications
          (window as any).processUrlNotifications();
        } else if (attempts < 10) {
          // showModal not ready yet, retry after 100ms
          console.log(
            "ðŸ”” [URL-NOTIFICATION] showModal not ready, retrying... attempt",
            attempts + 1
          );
          setTimeout(() => processUrlNotificationsWithRetry(attempts + 1), 100);
        } else {
          console.error("ðŸ”” [URL-NOTIFICATION] showModal never became available after 10 attempts");
        }
      };

      document.addEventListener("DOMContentLoaded", () => processUrlNotificationsWithRetry());

      // // Also run immediately in case DOM is already loaded
      if (document.readyState === "loading") {
        // DOM is still loading, event listener will handle it
      } else {
        // DOM is already loaded, run immediately with retry
        processUrlNotificationsWithRetry();
      }

      // Suppress ResizeObserver loop warnings (they're usually harmless)
      window.addEventListener("error", (e: any) => {
        if (e.message === "ResizeObserver loop completed with undelivered notifications.") {
          e.stopImmediatePropagation();
        }
      });

      // Register service worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration: any) => {
              console.log("âœ… Service Worker registered successfully:", registration.scope);
            })
            .catch((error: any) => {
              console.log("âŒ Service Worker registration failed:", error);
            });
        });
      } else {
        console.log("âŒ Service Worker not supported in this browser");
      }

      // Global text trimming utilities
      (window as any).trimText = function (
        text: string,
        maxLength: number = 100,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).trimWords = function (
        text: string,
        wordLimit: number = 50,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        const words = text.trim().split(/\s+/);
        if (words.length <= wordLimit) return text;
        return words.slice(0, wordLimit).join(" ") + suffix;
      };

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize autofill navigation - COMMENTED OUT
        // (window as any).setupAutofillNavigation();

        // Initialize dark mode first to prevent preloader flash
        const hasExplicitPreference = localStorage.getItem("color-theme") !== null;

        if (hasExplicitPreference) {
          // User has explicitly set a preference, apply it
          if (localStorage.getItem("color-theme") === "dark") {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
          }
        } else {
          // No explicit preference, check system preference
          if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "dark");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "light");
          }
        }

        // Call immediately
        const isSafariBeta = (window as any).isSafariBeta();
        console.log("ðŸŽ [APP] isSafari18", isSafariBeta);
        if (isSafariBeta === true) {
          console.log(
            "ðŸŽ [SAFARI-18-BETA] Applying Safari sticky positioning fixes (lightweight mode)"
          );
          // <!-- Mobile debugging console (Eruda) - only load in development or with ?debug=true -->

          const isDevelopment = import.meta.env.DEV;
          const hasDebugParam = new URLSearchParams(window.location.search).get("debug") === "true";

          if (isDevelopment || hasDebugParam) {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/eruda";
            script.onload = function () {
              if ((window as any).eruda) {
                (window as any).eruda.init();
                console.log("ðŸ“± [ERUDA] Mobile debugging console loaded");
              }
            };
            document.body.appendChild(script);
          }

          // Fix 1: Force GPU compositing on all sticky elements
          const stickyElements = document.querySelectorAll(
            '[class*="sticky"], .sticky, [style*="position: sticky"]'
          );
          stickyElements.forEach((el) => {
            const element = el as HTMLElement;
            element.style.transform = "translateZ(0)"; // Force GPU layer
            element.style.willChange = "transform, top, bottom";
            element.style.webkitBackfaceVisibility = "hidden";
            element.style.backfaceVisibility = "hidden";
          });

          // Fix 2: Force repaint on scroll (lightweight - doesn't break scroll triggers)
          let scrollTimeout: number;
          const forceRepaint = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = window.setTimeout(() => {
              // Trigger a minimal repaint without changing layout
              document.body.style.transform = "translateZ(0)";
              requestAnimationFrame(() => {
                document.body.style.transform = "";
              });
            }, 100);
          };

          window.addEventListener("scroll", forceRepaint, { passive: true });

          // Fix 3: Add body class for CSS-based fixes
          // document.body.classList.add("safari-18-fix");

          // Fix 4: Handle header positioning - target the actual navbar
          const navbar = document.querySelector("nav.fixed");
          if (navbar) {
            const navbarElement = navbar as HTMLElement;
            console.log("ðŸŽ [SAFARI-FIX] Found navbar, applying fixes");

            // Force the positioning
            navbarElement.style.position = "fixed";
            navbarElement.style.top = "0";
            navbarElement.style.left = "0";
            navbarElement.style.right = "0";
            navbarElement.style.zIndex = "50";
            navbarElement.style.transform = "translateZ(0)";
            navbarElement.style.willChange = "transform";
            navbarElement.style.webkitBackfaceVisibility = "hidden";
            navbarElement.style.backfaceVisibility = "hidden";

            // Add a class for additional CSS targeting
            navbarElement.classList.add("safari-sticky-fix");

            console.log("ðŸŽ [SAFARI-FIX] Applied navbar fixes");
          } else {
            console.log('ðŸŽ [SAFARI-FIX] No navbar found with class "fixed"');
          }

          // Fix 5: Handle SpeedDial positioning
          const speedDial = document.querySelector("[data-speed-dial], .speed-dial");
          if (speedDial) {
            const speedDialElement = speedDial as HTMLElement;
            speedDialElement.style.position = "fixed";
            speedDialElement.style.bottom = "20px";
            speedDialElement.style.right = "20px";
            speedDialElement.style.zIndex = "1000";
            speedDialElement.style.transform = "translateZ(0)";
            speedDialElement.style.willChange = "transform";
          }
          const safariFixElement = document.querySelector(".safari-18-fix");
          if (safariFixElement) {
            // (safariFixElement as HTMLElement).style.height = "";
            (safariFixElement as HTMLElement).style.overflow = "scroll";
            (safariFixElement as HTMLElement).style.position = "fixed";
            (safariFixElement as HTMLElement).style.top = "0";
            (safariFixElement as HTMLElement).style.bottom = "0";
            (safariFixElement as HTMLElement).style.left = "0";
            (safariFixElement as HTMLElement).style.right = "0";
            (safariFixElement as HTMLElement).style.zIndex = "49";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
            (safariFixElement as HTMLElement).style.willChange = "transform";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
          }

          // Fix 6: Handle viewport height changes
          const handleViewportChange = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");

            // Force repaint on viewport change
            document.body.style.transform = "translateZ(0)";
            requestAnimationFrame(() => {
              document.body.style.transform = "";
            });
          };

          window.addEventListener("resize", handleViewportChange);
          window.addEventListener("orientationchange", () => {
            setTimeout(handleViewportChange, 100);
          });

          console.log(
            `ðŸŽ [SAFARI-18-BETA] Applied fixes to ${stickyElements.length} sticky elements (scroll triggers preserved)`
          );

          // Additional aggressive fix for navbar after a delay
          setTimeout(() => {
            const navbar = document.querySelector("nav.fixed");
            if (navbar) {
              const navbarElement = navbar as HTMLElement;
              console.log("ðŸŽ [SAFARI-FIX] Re-applying navbar fixes after delay");

              // Force all the styles again
              navbarElement.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 50 !important;
                transform: translateZ(0) !important;
                will-change: transform !important;
                -webkit-backface-visibility: hidden !important;
                backface-visibility: hidden !important;
              `;

              // Force a reflow
              navbarElement.offsetHeight;

              console.log("ðŸŽ [SAFARI-FIX] Re-applied navbar fixes");
            }
          }, 1000);
        }
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", async () => {
        (window as any).hideOnFormFocus();

        // Initialize notification count only if user is authenticated
        try {
          const notificationBell = document.getElementById("notification-bell");
          if (
            notificationBell &&
            notificationBell.dataset.userId &&
            (window as any).initializeNotificationCount
          ) {
            console.log(
              "ðŸ”” [APP] Initializing notifications for user:",
              notificationBell.dataset.userId
            );
            await (window as any).initializeNotificationCount();
          } else {
            console.log("ðŸ”” [APP] Skipping notification initialization - no authenticated user");
          }
        } catch (error) {
          console.error("ðŸ”” [APP] Error initializing notification count:", error);
        }
      });
    </script>
  </body>
</html>
