---
interface Props {
  title?: string;
  description?: string;
  currentUser?: any;
  session?: any;
  project?: any;
  supabase?: any;
  supabaseUrl?: string;
  noNavigation?: boolean;
  projects?: any;
  isBackend?: boolean;
  id?: string;
  globalPrimaryTextClasses?: string;
  globalSecondaryTextClasses?: string;
  globalInputClasses?: string;
  year?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  noFooter?: boolean;
  globalCompanyAddress?: string;
  globalCompanyPhone?: string;
  globalCompanyEmail?: string;
  globalCompanyWebsite?: string;
  globalCompanyLogo?: string;
  globalCompanyLogoDark?: string;
  globalCompanyLogoLight?: string;
  statusData?: any;
}

// UX utility functions are defined inline in the script section below

// Global CSS Classes will be defined in client-side script

const {
  title = undefined,
  description = undefined,
  currentUser = undefined,
  session = undefined,
  project = undefined,
  supabase = undefined,
  supabaseUrl = undefined,
  noNavigation = false,
  projects = undefined,
  id = undefined,
  globalPrimaryTextClasses = "",
  globalSecondaryTextClasses = "",
  globalInputClasses = "",
  globalCompanyName = undefined,
  globalCompanySlogan = undefined,
  globalCompanyAddress = undefined,
  globalCompanyPhone = undefined,
  globalCompanyEmail = undefined,
  globalCompanyWebsite = undefined,
  globalCompanyLogo = undefined,
  globalCompanyLogoDark = undefined,
  globalCompanyLogoLight = undefined,
  statusData = undefined,
} = Astro.props;

// console.log("[App] currentUser:", currentUser);
// console.log("[App] session:", session);
// console.log("[App] project:", project);
// console.log("[App] supabase:", supabase);
// console.log("üîç [App] supabaseUrl:", supabaseUrl);
// console.log("üîç [App] noNavigation:", noNavigation);

// Derived properties (8 props ‚Üí 13 total)
const isAuth = currentUser ? true : false;
const currentUserId = currentUser?.id || undefined;
const currentRole = currentUser?.profile.role || undefined;
const projectId = project?.id || undefined;
const currentUrl = Astro.url.pathname;

// Get navigation data
import { navigation } from "@/pages/api/navigation";
import { isBackendPage } from "@/pages/api/backend-page-check";
const isBackend = isBackendPage(currentUrl);
const navigationData = navigation(currentUrl, isAuth, currentRole || "Client", isBackend || false);
const { desktopNavigationHTML, visibleNavItems } = navigationData;

import "../../styles/boxicons.css"; // this is sketchy
import "../../styles/global.css"; // Import Tailwind CSS
import Preloader from "./Preloader.astro";
import Footer from "./Footer.astro";
import UnifiedNotification from "./UnifiedNotification.astro";
import CookieBanner from "./CookieBanner.astro";
import SpeedDial from "./SpeedDial.astro";
import Navbar from "./Navbar.astro";
import Aside from "./Aside.astro";
import ScrollProgressIndicator from "./ScrollProgressIndicator.astro";

// Prepare debug data for admin users
const debugData = {
  // Original props
  title,
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
  description,
  currentUser,
  session,
  project,
  supabase,
  supabaseUrl,
  noNavigation,
  projects,
  isBackend,
  id,
  statusData,
  // Derived properties
  isAuth,
  projectId,
  currentUrl,
  // Navigation data
  navigationData,
  desktopNavigationHTML,
  visibleNavItems,
  // Additional context
  astroUrl: Astro.url,
  astroRequest: {
    method: Astro.request.method,
    headers: Object.fromEntries(Astro.request.headers.entries()),
    url: Astro.request.url,
  },
};
---

<!doctype html>
<html lang="en" class="v2fLMH8w3xgUEQcl63H9">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="author" content="Tomsens+REKKO" />
    <!-- <meta name="generator" content="Hugo 0.123.8" /> -->

    <!-- Safari 18 beta specific viewport fixes -->
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <title>{title + " ‚Üí " + globalCompanyName}</title>
    <meta name="description" content={description} />

    <link
      rel="stylesheet"
      href="https://www.unpkg.com/flowbite-datepicker@1.3.2/dist/css/datepicker.min.css"
    />
    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" sizes="any" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="any" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="CAPCo Fire App" />
    <meta name="generator" content={Astro.generator} />

    <!-- Safari Privacy Protection Meta Tags -->
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups" />
    <meta property="og:title" content={title + " ‚Üí " + globalCompanyName} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content="/img/capco-logo.png" />
    <meta property="og:url" content={Astro.url} />
    <meta name="twitter:card" content={description} />
    <meta name="twitter:title" content={title + " ‚Üí " + globalCompanyName} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content="/img/capco-logo.png" />

    <meta name="robots" content="max-image-preview:large" /><link
      rel="canonical"
      href={currentUrl}
    />
    <meta property="og:site_name" content="CAPCo Fire" /><meta
      property="og:type"
      content="website"
    />
    <!-- <link rel="canonical" href="https://flowbite.com/application-ui/demo/" />-->

    <!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    /> -->

    <!-- Font styles are handled by CSS files -->

    <!-- 
    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="https://flowbite.com/application-ui/demo/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="https://flowbite.com/application-ui/demo/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="https://flowbite.com/application-ui/demo/favicon-16x16.png"
    />
    <link rel="icon" type="image/png" href="https://flowbite.com/application-ui/demo/favicon.ico" />
    <link rel="manifest" href="https://flowbite.com/application-ui/demo/site.webmanifest" />
    <link
      rel="mask-icon"
      href="https://flowbite.com/application-ui/demo/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="theme-color" content="#ffffff" /> -->

    <!-- Twitter -->
    <!-- <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta name="twitter:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      name="twitter:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta name="twitter:image" content="https://flowbite.com/application-ui/demo/" /> -->

    <!-- Facebook -->
    <!-- <meta property="og:url" content="https://flowbite.com/application-ui/demo/" />
    <meta property="og:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      property="og:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://flowbite.com/application-ui/demo/images/og-image.jpg"
    />
    <meta property="og:image:type" content="image/png" /> -->

    <script>
      if (
        localStorage.getItem("color-theme") === "dark" ||
        (!("color-theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("v2fLMH8w3xgUEQcl63H9", "dark");
      } else {
        document.documentElement.classList.remove("v2fLMH8w3xgUEQcl63H9", "dark");
      }
    </script>
  </head>

  <!-- Set global user data for client-side components -->

  <body class="jtAJHOc7mn7b4IKRO59D h8KYXnua2NT4kTVzieom KRANKvs7gs1E_d0fCA0k">
    <!-- Preloader -->
    <Preloader />

    <Navbar
      desktopNavigationHTML={desktopNavigationHTML}
      currentUser={currentUser}
      session={session}
      supabaseUrl={supabaseUrl}
      id={id}
      projects={projects}
      project={project}
      isBackend={isBackend}
    />

    <div
      class="YRrCJSr_j5nopfm4duUc wBVMFkIGfrKshbvi2gS1 jtAJHOc7mn7b4IKRO59D UZ9xFK4mqjHjj8e8yJwf h8KYXnua2NT4kTVzieom safari-fix"
    >
      <Aside currentUser={currentUser} project={project} globalInputClasses={globalInputClasses} />

      <div
        id="main-content"
        class=`ahOqFrhzLjivRe8a1kX_ uLPch_bqyJDXwe5tynMV t6gkcSf0Bt4MLItXvDJ_ pdl952ted2i71qBLPIcQ jtAJHOc7mn7b4IKRO59D h8KYXnua2NT4kTVzieom ${currentUser && currentRole !== "Client" ? "Syhv8OuxgyaGMa27BMXo" : ""}`
      >
        <main>
          <slot />
        </main>
        <!-- Footer -->
        <Footer
          globalInputClasses={globalInputClasses}
          globalSecondaryTextClasses={globalSecondaryTextClasses}
          globalPrimaryTextClasses={globalPrimaryTextClasses}
          currentUser={currentUser}
          globalCompanyName={globalCompanyName}
          globalCompanyAddress={globalCompanyAddress}
          globalCompanyPhone={globalCompanyPhone}
          globalCompanyEmail={globalCompanyEmail}
          globalCompanyWebsite={globalCompanyWebsite}
          globalCompanyLogo={globalCompanyLogo}
          globalCompanyLogoDark={globalCompanyLogoDark}
          globalCompanyLogoLight={globalCompanyLogoLight}
        />
      </div>
    </div>

    <!-- Unified Notification System -->
    <UnifiedNotification />
    <!-- Cookie Banner -->
    <CookieBanner />
    <!-- Speed Dial -->
    <SpeedDial
      currentUser={currentUser || undefined}
      isBackend={isBackend}
      debugData={debugData}
      globalPrimaryTextClasses={globalPrimaryTextClasses}
      globalSecondaryTextClasses={globalSecondaryTextClasses}
      globalInputClasses={globalInputClasses}
    />

    <ScrollProgressIndicator />

    <!-- Debug Panel (Admin Only) -->

    <script src="../../assets/js/app.bundle.js"></script>

    <!-- Flowbite JavaScript -->
    <!-- <script src="https://unpkg.com/flowbite@2.5.2/dist/flowbite.min.js"></script> -->

    <!-- Mobile debugging console (Eruda) - only load in development or with ?debug=true -->
    <script>
      // Load Eruda mobile console for debugging on mobile devices
      // Access via URL parameter: ?debug=true or automatically in development
      const isDevelopment = import.meta.env.DEV;
      const hasDebugParam = new URLSearchParams(window.location.search).get("debug") === "true";

      if (isDevelopment || hasDebugParam) {
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/eruda";
        script.onload = function () {
          if (window.eruda) {
            window.eruda.init();
            console.log("üì± [ERUDA] Mobile debugging console loaded");
          }
        };
        document.body.appendChild(script);
      }
    </script>

    <script>
      declare global {
        interface Window {
          // Global functions and utilities (alphabetized)
          acceptProposal?: () => void;
          addNewLineItem?: () => void;
          clipboardData?: any;
          createLineItemRow?: (data: any) => HTMLElement;
          createButtonPartial?: (config: any) => Promise<HTMLElement | null>;
          deleteProject?: (projectId: any) => void;
          getProject?: (projectId: string | number) => Promise<any>;
          handleNewStatusNotification?: any;
          handleUrlNotification?: (type: string, message: string) => void;
          hideOnFormFocus?: (elementSelector: string, mobileOnly?: boolean) => void;
          hideNotification?: any;
          // UX Utility Functions
          scrollToTopOnMobile?: () => void;
          scrollToTop?: (behavior?: ScrollBehavior) => void;
          isMobile?: () => boolean;
          isTablet?: () => boolean;
          isDesktop?: () => boolean;
          getViewportSize?: () => "mobile" | "tablet" | "desktop";
          debounce?: <T extends (...args: any[]) => any>(func: T, wait: number) => T;
          throttle?: <T extends (...args: any[]) => any>(func: T, limit: number) => T;
          hideOnMobileInput?: (elementSelector: string) => void;
          isSafariIOS?: () => boolean;
          isSafari?: () => boolean;
          isSafariBeta?: () => boolean;
          isSafari18OrLater?: () => boolean;
          fixSafariViewport?: () => void;
          immediateSafariViewportFix?: () => void;
          setupViewportHandling?: () => void;
          ensureViewportBounds?: (minHeight?: number, maxHeight?: number) => void;
          lockBodyScroll?: () => void;
          unlockBodyScroll?: () => void;
          initializeSubjectEditing?: () => void;
          proposalHelper?: any;
          proposalManager?: any;
          refreshManager?: any;
          requestPushNotificationPermission?: () => void;
          resetForm?: any;
          resetNotifications?: () => void;
          sendEmail?: (emailData: any, currentUser: any) => Promise<any>;
          setPageLoadProjectStatus?: any;
          showModal?: any;
          switchTab?: any;
          toggleCommentForm?: () => void;
          trimText?: (text: string, maxLength?: number, suffix?: string) => string;
          trimWords?: (text: string, wordLimit?: number, suffix?: string) => string;
          updateCountBubble?: (
            parentElement: HTMLElement,
            count: number,
            options?: any
          ) => HTMLElement | null;
          updateProposalTotal?: () => void;
          updateStatus?: (project: any, newStatus: number, statuses?: any) => Promise<any>;
          validateEmail?: (email: string) => string | null;
          COUNT_BUBBLE_PRESETS?: {
            notification: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            punchlist: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            small: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
          };
        }
      }
      // Make data available globally for the proposal functions
      import { setupConsoleInterceptor } from "../../lib/console-interceptor.ts";

      // Ensure startsWith is available - with debugging
      console.log("üîß [POLYFILL] Checking startsWith availability...");
      console.log(
        "üîß [POLYFILL] String.prototype.startsWith exists:",
        !!String.prototype.startsWith
      );

      // Set Stripe publishable key globally for PaymentForm
      (window as any).STRIPE_PUBLISHABLE_KEY = import.meta.env.PUBLIC_STRIPE_PUBLISHABLE_KEY;
      console.log("üîß [STRIPE] Publishable key loaded:", !!(window as any).STRIPE_PUBLISHABLE_KEY);

      // Helper function to create buttons using Button partial
      (window as any).createButtonPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-button-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/button", {
            headers: headers,
          });

          if (response.ok) {
            const buttonHTML = await response.text();
            const wrapper = document.createElement("div");
            wrapper.innerHTML = buttonHTML;
            return wrapper.firstElementChild;
          } else {
            console.error("Failed to fetch button partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating button partial:", error);
          return null;
        }
      };

      if (!String.prototype.startsWith) {
        console.log("üîß [POLYFILL] Adding startsWith polyfill...");
        String.prototype.startsWith = function (search: string, pos?: number) {
          return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
        console.log("üîß [POLYFILL] startsWith polyfill added successfully");
      } else {
        console.log("üîß [POLYFILL] startsWith already available");
      }

      // Safari detection functions are imported from ux-utils.ts
      // No need to redefine them here - they're already available globally

      // Local Window interface for this component's TypeScript intellisense

      // showModal is now handled by UnifiedNotification.astro

      (window as any).hideNotification = function () {
        console.log("[FALLBACK-NOTIFICATION] Hiding notification");
      };

      (window as any).switchTab = function (tabName: string) {
        console.log(`[TAB] Switching to: ${tabName}`);
        // Implementation for tab switching
      };

      (window as any).handleNewStatusNotification = function (response: any, context: any) {
        if (!response) {
          console.error(`ERROR [${context || "NOTIFICATION"}] API call failed:`, response.error);
          return;
        }

        if (!response.statusData || !(window as any).showModal) {
          console.warn(
            `WARNING [${context || "NOTIFICATION"}] No notification data or showModal function available`
          );
          return;
        }

        // Get the current status configuration
        const clientNotification = response.statusData?.client;
        const adminNotification = response.statusData?.admin;
        const currentNotification = response.statusData?.current;
        const currentUser = response.currentUser;

        // Send email if email configuration exists
        if (clientNotification?.email) {
          (window as any).sendEmail(clientNotification.email, currentUser);
        }

        if (adminNotification?.email) {
          (window as any).sendEmail(adminNotification.email);
        }

        if (currentNotification?.modal) {
          const modalData = currentNotification.modal;
          // Handle redirect object structure

          //     type: "success" | "error" | "warning" | "info";
          // title: string;
          // message: string;
          // duration?: number; // 0 = no auto-hide, >0 = auto-hide after ms
          // persist?: boolean; // false = close existing modals, true = keep existing modals
          // redirect?: {
          //   url: string;
          //   delay?: number; // Delay in milliseconds before redirect
          //   showCountdown?: boolean; // Show countdown in message
          // };
          // actions?: Array<{
          //   label: string;
          //   action: () => void;
          //   primary?: boolean; // Primary button styling
          // }>;
          // onClose?: () => void; //
          (window as any).showModal(modalData);
        } else {
          console.warn(`WARNING [${context || "NOTIFICATION"}] No notification found in response`);
        }
      };

      // Assign imported function to global window object
      // @ts-ignore - Function is imported and used, but TypeScript doesn't recognize the assignment

      (window as any).hideOnFormFocus = function (
        elementSelector: string,
        mobileOnly: boolean = false
      ) {
        // Check if we should only hide on mobile
        if (mobileOnly && window.innerWidth >= 768) return;

        const element = document.querySelector(elementSelector);
        if (!element) return;

        // Hide on input focus
        const hideOnFocus = () => {
          (element as HTMLElement).style.display = "none";
        };

        // Show on input blur
        const showOnBlur = () => {
          (element as HTMLElement).style.display = "block";
        };

        // Add event listeners to all form inputs
        const inputs = document.querySelectorAll("input, textarea, select");
        inputs.forEach((input) => {
          input.addEventListener("focus", hideOnFocus);
          input.addEventListener("blur", showOnBlur);
        });

        // Also handle dynamically added inputs
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newInputs = element.querySelectorAll
                  ? element.querySelectorAll("input, textarea, select")
                  : [];
                newInputs.forEach((input) => {
                  input.addEventListener("focus", hideOnFocus);
                  input.addEventListener("blur", showOnBlur);
                });
              }
            });
          });
        });

        observer.observe(document.body, { childList: true, subtree: true });
      };

      (window as any).sendEmail = async function (emailData: any, currentUser: any) {
        try {
          // Transform the email data to match the email-delivery API structure
          const transformedData = {
            usersToNotify: emailData.users_to_notify, // TODO: Get actual user emails
            emailType: emailData.email_type || "status_update",
            emailSubject: emailData.email_subject || "Project Update",
            emailContent: emailData.email_content || JSON.stringify(emailData),
            buttonLink: emailData.button_link,
            buttonText: emailData.button_text,
            project: {}, // TODO: Pass actual project data
            currentUser: currentUser, // TODO: Pass actual current user
          };

          console.log("üìß [SEND-EMAIL] Sending email with data:", transformedData);

          const response = await fetch("/api/email-delivery", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(transformedData),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global sendEmail error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).validateEmail = function (email: string) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) ? null : "Invalid email format";
      };

      (window as any).getProject = async function (projectId: string | number) {
        const projectResponse = await fetch(`/api/get-project?id=${projectId}`);
        if (projectResponse.ok) {
          return await projectResponse.json();
        } else {
          throw new Error("Failed to fetch project");
        }
      };

      // Delete project function
      let isDeleting = false; // Flag to prevent multiple delete operations
      (window as any).deleteProject = function (projectId: any) {
        // Prevent multiple delete operations
        if (isDeleting) {
          console.log("Delete operation already in progress, ignoring request");
          return;
        }

        // Validate project ID - ensure it's a string
        console.log("üîß [DELETE] projectId type:", typeof projectId, "value:", projectId);
        const projectIdStr = String(projectId);
        console.log("üîß [DELETE] projectIdStr:", projectIdStr);
        if (!projectId || projectIdStr.startsWith("new-project-")) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "error",
              "Delete Failed",
              "Cannot delete a new project that hasn't been saved yet.",
              5000
            );
          }
          return;
        }

        // Show confirmation modal with action buttons
        if ((window as any).showModal) {
          (window as any).showModal(
            "warning",
            "Delete Project",
            "Are you sure you want to delete this project? This action cannot be undone.",
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                action: () => {},
              },
              {
                label: "Delete",
                action: () => {
                  // Set deleting flag to prevent multiple operations
                  isDeleting = true;

                  // Show loading state
                  const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
                  deleteBtn?.setAttribute("data-loading", "true");
                  if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML =
                      '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
                  }

                  // Make API call to delete project
                  console.log("Sending delete request for project:", projectId);
                  fetch(`/api/delete-project`, {
                    method: "DELETE",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ projectId }),
                  })
                    .then(async (response) => {
                      const data = await response.json();

                      if (!response.ok) {
                        throw new Error(data.error || "Failed to delete project");
                      }

                      // Show success modal
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "success",
                          "Project Deleted!",
                          data.message || "Project has been deleted successfully.",
                          1500
                        );
                      }

                      // Reset deleting flag
                      isDeleting = false;

                      document
                        .querySelectorAll("[data-project-id='" + projectId + "']")
                        ?.forEach((element) => {
                          element.remove();
                        });

                      // Redirect to dashboard after a short delay
                      // setTimeout(() => {
                      //   window.location.href = "/project/dashboard";
                      // }, 1500);
                    })
                    .catch((error) => {
                      console.error("Error deleting project:", error);

                      // Show error modal with specific error message
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "error",
                          "Delete Failed",
                          error.message || "Failed to delete project. Please try again.",
                          6000000
                        );
                      }

                      // Reset deleting flag and button state
                      isDeleting = false;
                      if (deleteBtn) {
                        deleteBtn.disabled = false;
                        deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                      }
                    });
                },
              },
            ]
          );
        }
      };

      // Request push notification permission
      (window as any).requestPushNotificationPermission = function () {
        console.log("üîî [APP] Checking notification permission...");
        console.log("üîî [APP] Notification in window:", "Notification" in window);
        console.log(
          "üîî [APP] Current permission:",
          "Notification" in window ? Notification.permission : "Not available"
        );

        // Check if we're on mobile Safari
        const isMobileSafari =
          /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
        console.log("üîî [APP] Mobile Safari detected:", isMobileSafari);

        if (isMobileSafari) {
          console.log(
            "üîî [APP] Mobile Safari detected - push notifications work when installed as PWA"
          );
          console.log("üîî [APP] Install as PWA (Add to Home Screen) for full notification support");

          // Check if running as PWA
          const isStandalone =
            window.matchMedia("(display-mode: standalone)").matches ||
            (window.navigator as any).standalone === true;
          console.log("üîî [APP] Running as PWA:", isStandalone);

          if (!isStandalone) {
            console.log("üí° [APP] Install as PWA for better notification support");
            return;
          }
        }

        // Only request if user hasn't been prompted yet
        if ("Notification" in window && Notification.permission === "default") {
          console.log("üîî [APP] Requesting notification permission...");
          // Request permission immediately in user interaction context
          Notification.requestPermission().then((permission) => {
            console.log("üîî [APP] Permission result:", permission);
            if (permission === "granted") {
              console.log("üîî Push notifications enabled for authenticated user!");
              // Show a subtle notification
              if ((window as any).showModal) {
                (window as any).showModal(
                  "info",
                  "Notifications Enabled",
                  "You'll receive push notifications for project updates!",
                  3000
                );
              }
            } else {
              console.log("üîî Push notifications declined by user");
            }
          });
        } else {
          console.log("üîî [APP] Not requesting permission - already handled or not available");
        }
      };

      // Reset notification permissions for debugging
      (window as any).resetNotifications = function () {
        console.log("üîÑ [APP] Resetting notification permissions...");

        // Check if we're on mobile Safari
        const isMobileSafari =
          /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);

        if (isMobileSafari) {
          console.log(
            "üì± [APP] Mobile Safari detected - push notifications work when installed as PWA"
          );
          console.log("üí° [APP] Install as PWA (Add to Home Screen) for full notification support");

          // Check if running as PWA
          const isStandalone =
            window.matchMedia("(display-mode: standalone)").matches ||
            (window.navigator as any).standalone === true;
          console.log("üîî [APP] Running as PWA:", isStandalone);

          if (!isStandalone) {
            console.log("üí° [APP] Install as PWA for better notification support");
            return;
          }
        }

        console.log(
          "üîÑ [APP] Current permission:",
          "Notification" in window ? Notification.permission : "Not available"
        );

        // Clear any stored permission state
        localStorage.removeItem("notification-permission-requested");
        sessionStorage.removeItem("notification-permission-requested");

        // Force a new permission request
        if ("Notification" in window) {
          Notification.requestPermission().then((permission) => {
            console.log("üîÑ [APP] Reset permission result:", permission);
            if (permission === "granted") {
              console.log("‚úÖ Notifications re-enabled!");
            } else {
              console.log("‚ùå Notifications still denied");
            }
          });
        }
      };

      // Request notification permission on first user interaction
      let permissionRequested = false;
      const requestPermissionOnInteraction = () => {
        if (!permissionRequested) {
          permissionRequested = true;
          (window as any).requestPushNotificationPermission();
          // Remove listeners after first interaction
          document.removeEventListener("click", requestPermissionOnInteraction);
          document.removeEventListener("touchstart", requestPermissionOnInteraction);
        }
      };

      // Listen for first user interaction
      document.addEventListener("click", requestPermissionOnInteraction);
      document.addEventListener("touchstart", requestPermissionOnInteraction);

      (window as any).updateStatus = async function (
        project: any,
        status: number,
        currentStatusData?: any
      ) {
        (window as any).showModal(
          "info",
          "Processing...",
          "Please wait... This may take a few seconds.",
          5000
        );

        try {
          // If project exists, use it; otherwise fetch it
          let currentProject = project;
          if (!currentProject) {
            console.log("üìä [UPDATE-STATUS] No project provided, fetching full project data...");
            try {
              currentProject = await (window as any).getProject(project);
            } catch (error) {
              console.log(
                "üìä [UPDATE-STATUS] Could not fetch project, using minimal object:",
                error
              );
              currentProject = {
                id: project.id,
                status: 0,
              };
            }
          }

          const response = await fetch("/api/update-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              currentProject,
              newStatus: status,
              currentStatusData: currentStatusData || null, // Pass the current status data
            }),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global updateStatus error:", error);
          return { success: false, error: error.message };
        }
      };

      // Global count bubble utility
      (window as any).updateCountBubble = function (
        parentElement: HTMLElement,
        count: number,
        options: any = {}
      ) {
        if (!parentElement) {
          console.warn("üîç [COUNT-BUBBLE] Parent element is null or undefined");
          return null;
        }

        const config = {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark",
          parentClasses: "relative",
          maxCount: 99,
          showZero: false,
          ...options,
        };

        // Find existing bubble or create new one
        let countBubble = parentElement.querySelector(".count-bubble") as HTMLSpanElement;

        if (count > 0 || config.showZero) {
          // Create bubble if it doesn't exist
          if (!countBubble) {
            countBubble = document.createElement("span");
            countBubble.className = `count-bubble ${config.bubbleClasses}`;

            // Add parent classes if specified
            if (config.parentClasses) {
              parentElement.classList.add(...config.parentClasses.split(" "));
            }

            parentElement.appendChild(countBubble);
            console.log("üîç [COUNT-BUBBLE] Created new bubble for element:", parentElement);
          }

          // Update bubble content and visibility
          const displayCount = count > config.maxCount ? `${config.maxCount}+` : count.toString();
          countBubble.textContent = displayCount;
          countBubble.style.display = "flex";

          // Update data attribute for accessibility
          parentElement.setAttribute("data-count", count.toString());

          console.log("üîç [COUNT-BUBBLE] Updated bubble:", {
            count,
            displayCount,
            element: parentElement,
          });
        } else {
          // Hide bubble when count is 0 (unless showZero is true)
          if (countBubble) {
            countBubble.style.display = "none";
            parentElement.removeAttribute("data-count");
            console.log("üîç [COUNT-BUBBLE] Hidden bubble (count is 0)");
          }
        }

        return countBubble;
      };

      // Count bubble presets
      (window as any).COUNT_BUBBLE_PRESETS = {
        notification: {
          bubbleClasses:
            "absolute inline-flex items-center justify-center w-6 h-6 text-xs font-bold text-white bg-primary-500 border-2 border-white rounded-full top-0 end-0 dark:border-gray-900 animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        punchlist: {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark",
          maxCount: 99,
          showZero: false,
        },
        small: {
          bubbleClasses:
            "absolute -right-1 -top-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white",
          maxCount: 9,
          showZero: false,
        },
      };

      // Project management
      (window as any).resetForm = function (formId: string) {
        console.log(`[FORM] Resetting form: ${formId}`);
        // Implementation for form reset
      };

      (window as any).clipboardData = function (data: any) {
        console.log("[CLIPBOARD] Data:", data);
        // Implementation for clipboard operations
      };

      // Proposal management
      (window as any).proposalManager = {};
      (window as any).proposalHelper = {};
      (window as any).addNewLineItem = function () {
        console.log("[PROPOSAL] Adding new line item");
        // Implementation for adding line items
      };
      (window as any).initializeSubjectEditing = function () {
        console.log("[PROPOSAL] Initializing subject editing");
        // Implementation for subject editing
      };
      (window as any).acceptProposal = function () {
        console.log("[PROPOSAL] Accepting proposal");
        // Implementation for accepting proposals
      };
      (window as any).createLineItemRow = function (data: any) {
        console.log("[PROPOSAL] Creating line item row:", data);
        // Implementation for creating line item rows
        return document.createElement("div");
      };
      (window as any).updateProposalTotal = function () {
        console.log("[PROPOSAL] Updating proposal total");
        // Implementation for updating totals
      };

      // Contact form
      (window as any).contactUpload = function (file: any) {
        console.log("[CONTACT] Uploading file:", file);
        // Implementation for contact form uploads
      };

      // Discussion management
      (window as any).toggleCommentForm = function () {
        console.log("[DISCUSSION] Toggling comment form");
        // Implementation for toggling comment forms
      };
      (window as any).refreshManager = {};
      (window as any).setPageLoadProjectStatus = function (status: any) {
        console.log("[PROJECT] Setting page load status:", status);
        // Implementation for setting project status
      };

      // ===== UX UTILITY FUNCTIONS =====

      // Scroll utilities
      (window as any).scrollToTopOnMobile = function () {
        if (window.innerWidth < 768) {
          console.log("üì± [UX-UTILS] Scrolling to top on mobile device");
          (window as any).scrollTo({ top: 0, behavior: "smooth" });
        }
      };

      (window as any).scrollToTop = function (behavior = "smooth") {
        console.log("üì± [UX-UTILS] Scrolling to top");
        (window as any).scrollTo({ top: 0, behavior });
      };

      // Device detection
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };

      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };

      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).getViewportSize = function () {
        if (window.innerWidth < 768) return "mobile";
        if (window.innerWidth < 1024) return "tablet";
        return "desktop";
      };

      // Utility functions
      (window as any).debounce = function (func: any, wait: any) {
        let timeout: any;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      (window as any).throttle = function (func: any, limit: any) {
        let inThrottle: any;
        return function executedFunction(this: any, ...args: any[]) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // Form utilities
      (window as any).hideOnMobileInput = function (elementSelector: any) {
        if (window.innerWidth >= 768) return;

        const element = document.querySelector(elementSelector);
        if (!element) return;

        const hideOnFocus = () => {
          (element as HTMLElement).style.display = "none";
        };

        const showOnBlur = () => {
          (element as HTMLElement).style.display = "block";
        };

        // Simple and reliable approach: Hide on input focus, show on blur
        let isKeyboardOpen = false;

        function hideOnInputFocus() {
          if (!isKeyboardOpen) {
            console.log("üì± Input focused - hiding elements");
            isKeyboardOpen = true;
            hideElement(document.getElementById("speed-dial"));
            hideElement(document.querySelector("[data-sticky-sms]") as HTMLElement);
          }
        }

        function showOnInputBlur() {
          if (isKeyboardOpen) {
            console.log("üì± Input blurred - showing elements");
            isKeyboardOpen = false;
            showElement(document.getElementById("speed-dial"));
            showElement(document.querySelector("[data-sticky-sms]") as HTMLElement);
          }
        }

        function hideElement(element: HTMLElement | null) {
          if (element) element.style.display = "none";
        }

        function showElement(element: HTMLElement | null) {
          if (element) element.style.display = "block";
        }

        // Simple input focus/blur detection
        const inputs = document.querySelectorAll("input, textarea, select");
        inputs.forEach((input: any) => {
          input.addEventListener("focus", hideOnInputFocus);
          input.addEventListener("blur", showOnInputBlur);
        });
      };

      // Make UX utility functions available globally
      (window as any).isSafariBeta = function () {
        const ua = navigator.userAgent;

        // Extract Safari version
        const versionMatch = ua.match(/Version\/(\d+)\./);
        const safariVersion = versionMatch ? parseInt(versionMatch[1]) : null;

        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        const isVersion18Plus = safariVersion && safariVersion >= 18;
        const result = isSafari && isVersion18Plus;

        console.log("üçé [APP] Safari Beta Detection:", {
          userAgent: ua,
          safariVersion: safariVersion,
          isSafari: isSafari,
          isVersion18Plus: isVersion18Plus,
          result: result,
        });

        return result;
      };
      (window as any).isSafariIOS = function () {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        return isIOS && isSafari;
      };
      (window as any).isSafari = function () {
        const ua = navigator.userAgent;
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
      };
      (window as any).isSafari18OrLater = function () {
        const ua = navigator.userAgent;
        const safariMatch = ua.match(/Version\/(\d+)/);
        if (!safariMatch) return false;
        const version = parseInt(safariMatch[1]);
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua) && version >= 18;
      };
      (window as any).fixSafariViewport = function () {
        if ((window as any).isSafariIOS()) {
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", vh + "px");
        }
      };
      (window as any).immediateSafariViewportFix = function () {
        if ((window as any).isSafariIOS()) {
          const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
          };
          setViewportHeight();
          window.addEventListener("orientationchange", () => setTimeout(setViewportHeight, 100));
          window.addEventListener("resize", setViewportHeight);
        }
      };
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };
      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };
      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).setupViewportHandling = function () {
        (window as any).immediateSafariViewportFix();
      };

      (window as any).ensureViewportBounds = function (minHeight = 400, maxHeight = 1200) {
        const currentHeight = window.innerHeight;
        if (currentHeight < minHeight || currentHeight > maxHeight) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "warning",
              "Viewport Issue",
              `Viewport height (${currentHeight}px) is outside recommended bounds (${minHeight}-${maxHeight}px)`,
              5000
            );
          }
        }
      };

      // Body scroll utilities
      (window as any).lockBodyScroll = function () {
        document.body.style.overflow = "hidden";
      };

      (window as any).unlockBodyScroll = function () {
        document.body.style.overflow = "";
      };

      /**
       * Handles URL parameter notifications (errors and success messages)
       * @param type - Notification type ('error' | 'success')
       * @param param - URL parameter value
       */
      (window as any).handleUrlNotification = function (
        type: "error" | "success",
        param: string
      ): void {
        const notifications = {
          // Error notifications
          error: {
            oauth_failed: {
              title: "Authentication Failed",
              message: "OAuth authentication failed. Please try again.",
            },
            verification_failed: {
              title: "Verification Failed",
              message: "Email verification failed. Please try again.",
            },
            verification_expired: {
              title: "Link Expired",
              message: "Verification link has expired. Please request a new one.",
            },
            verification_invalid: {
              title: "Invalid Link",
              message: "Invalid verification link.",
            },
            verification_error: {
              title: "Verification Error",
              message: "An error occurred during verification.",
            },
            no_token: {
              title: "Invalid Token",
              message: "Invalid or missing verification token.",
            },
            no_user: { title: "User Not Found", message: "User not found." },
            invalid_credentials: {
              title: "Invalid Credentials",
              message: "Invalid email or password.",
            },
            email_exists: {
              title: "Account Exists",
              message: "An account with this email already exists.",
            },
            weak_password: {
              title: "Weak Password",
              message: "Password must be at least 6 characters long.",
            },
            invalid_email: {
              title: "Invalid Email",
              message: "Please enter a valid email address.",
            },
            sms_missing_fields: {
              title: "SMS Error",
              message: "Please fill in all required fields for SMS.",
            },
            sms_invalid_phone: {
              title: "Invalid Phone",
              message: "Please enter a valid 10-digit phone number.",
            },
            sms_invalid_carrier: {
              title: "Invalid Carrier",
              message: "Please select a valid carrier.",
            },
            sms_send_failed: {
              title: "SMS Failed",
              message: "Failed to send SMS. Please try again.",
            },
            sms_email_error: {
              title: "Service Error",
              message: "Email service error. Please try again later.",
            },
            sms_unexpected_error: {
              title: "SMS Error",
              message: "An unexpected error occurred while sending SMS.",
            },
            default: { title: "Error", message: "An error occurred. Please try again." },
          },
          // Success notifications
          success: {
            registration_success: {
              title: "Account Created",
              message: "Registration successful! Please check your email to verify your account.",
            },
            verification_success: {
              title: "Email Verified",
              message: "Email verified successfully! You can now sign in.",
            },
            welcome: {
              title: "Welcome!",
              message: "Welcome! Your account has been verified and you're now signed in.",
            },
            logout_success: {
              title: "Signed Out",
              message: "You have been successfully signed out.",
              redirect: { url: "/", delay: 2500, showCountdown: true },
            },
            sms_sent_success: {
              title: "Message Sent",
              message: `Your message has been sent to ${import.meta.env.GLOBAL_COMPANY_NAME} successfully.`,
            },
            default: { title: "Success!", message: param },
          },
        };

        const notification = (notifications[type] as any)[param] || notifications[type].default;

        if ((window as any).showModal) {
          // Use global UX utility function for mobile scroll
          (window as any).scrollToTopOnMobile();

          if (type === "error") {
            (window as any).showModal("error", notification.title, notification.message);
          } else {
            (window as any).showModal(
              notification.title,
              notification.message,
              "success",
              2500,
              notification.redirect
            );
          }
        } else {
          console.error(`üîî [${notification.title}] ${notification.message}`);
          console.error("üîî showModal is not available - notification system not initialized");
        }

        // Note: URL cleanup is handled by processUrlNotifications with delay
      };

      // ===== END GLOBAL FUNCTIONS =====

      // Setup console interceptor (disables console.log in production)
      setupConsoleInterceptor();

      // // Handle URL parameter notifications (errors and success messages)
      (window as any).processUrlNotifications = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const errorParam = urlParams.get("error");
        const successParam = urlParams.get("success");
        const messageParam = urlParams.get("message");

        if (errorParam) {
          console.log("üîî [URL-NOTIFICATION] Processing error parameter:", errorParam);
          (window as any).handleUrlNotification("error", errorParam);

          // Clean up URL by removing the error parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("error");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (successParam) {
          console.log("üîî [URL-NOTIFICATION] Processing success parameter:", successParam);
          (window as any).handleUrlNotification("success", successParam);

          // Clean up URL by removing the success parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("success");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (messageParam) {
          console.log("üîî [URL-NOTIFICATION] Processing message parameter:", messageParam);
          (window as any).handleUrlNotification("success", messageParam);

          // Clean up URL by removing the message parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("message");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }
      };

      // // Process URL notifications on page load with retry mechanism
      const processUrlNotificationsWithRetry = (attempts = 0) => {
        if ((window as any).showModal) {
          // showModal is available, process notifications
          (window as any).processUrlNotifications();
        } else if (attempts < 10) {
          // showModal not ready yet, retry after 100ms
          console.log(
            "üîî [URL-NOTIFICATION] showModal not ready, retrying... attempt",
            attempts + 1
          );
          setTimeout(() => processUrlNotificationsWithRetry(attempts + 1), 100);
        } else {
          console.error("üîî [URL-NOTIFICATION] showModal never became available after 10 attempts");
        }
      };

      document.addEventListener("DOMContentLoaded", () => processUrlNotificationsWithRetry());

      // // Also run immediately in case DOM is already loaded
      if (document.readyState === "loading") {
        // DOM is still loading, event listener will handle it
      } else {
        // DOM is already loaded, run immediately with retry
        processUrlNotificationsWithRetry();
      }

      // Suppress ResizeObserver loop warnings (they're usually harmless)
      window.addEventListener("error", (e: any) => {
        if (e.message === "ResizeObserver loop completed with undelivered notifications.") {
          e.stopImmediatePropagation();
        }
      });

      // Register service worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration: any) => {
              console.log("‚úÖ Service Worker registered successfully:", registration.scope);
            })
            .catch((error: any) => {
              console.log("‚ùå Service Worker registration failed:", error);
            });
        });
      } else {
        console.log("‚ùå Service Worker not supported in this browser");
      }

      // Global text trimming utilities
      (window as any).trimText = function (
        text: string,
        maxLength: number = 100,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).trimWords = function (
        text: string,
        wordLimit: number = 50,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        const words = text.trim().split(/\s+/);
        if (words.length <= wordLimit) return text;
        return words.slice(0, wordLimit).join(" ") + suffix;
      };

      // Apply iOS Safari Mobile Beta specific CSS and workaround
      // if (
      //   (window as any).isSafariIOS() &&
      //   (window as any).isSafariBeta() &&
      //   (window as any).isMobile()
      // ) {
      //   console.log("üçé [APP] iOS Safari Mobile Beta detected - Applying fixes and workaround");

      //   // Trigger the orientation workaround
      //   (window as any).isSafariBeta();

      //   // Add iOS Safari Mobile Beta class to body
      //   document.body.classList.add("ios-safari-mobile-beta");

      //   // Apply the specific CSS class to the target element
      //   const targetElement = document.querySelector(
      //     ".YRrCJSr_j5nopfm4duUc.wBVMFkIGfrKshbvi2gS1.jtAJHOc7mn7b4IKRO59D.UZ9xFK4mqjHjj8e8yJwf.h8KYXnua2NT4kTVzieom"
      //   );
      //   if (targetElement) {
      //     targetElement.classList.add("ios-safari-mobile-beta-fix");
      //     console.log("üçé [APP] Applied iOS Safari Mobile Beta CSS fix to target element");
      //   }
      // } else {
      //   console.log("üåê [APP] Not iOS Safari Mobile Beta - Skipping specific CSS fixes");
      // }

      document.addEventListener("DOMContentLoaded", () => {
        // Call immediately
        const isSafari18 = (window as any).isSafariBeta();
        console.log("üçé [APP] isSafari18", isSafari18);
        if (isSafari18 === true) {
          console.log("üçé [SAFARI-18-BETA] Applying Safari sticky positioning fixes (lightweight mode)");

          // Fix 1: Force GPU compositing on all sticky elements
          const stickyElements = document.querySelectorAll('[class*="sticky"], .sticky, [style*="position: sticky"]');
          stickyElements.forEach((el) => {
            const element = el as HTMLElement;
            element.style.transform = "translateZ(0)"; // Force GPU layer
            element.style.willChange = "transform, top, bottom";
            element.style.webkitBackfaceVisibility = "hidden";
            element.style.backfaceVisibility = "hidden";
          });

          // Fix 2: Force repaint on scroll (lightweight - doesn't break scroll triggers)
          let scrollTimeout: number;
          const forceRepaint = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = window.setTimeout(() => {
              // Trigger a minimal repaint without changing layout
              document.body.style.transform = "translateZ(0)";
              requestAnimationFrame(() => {
                document.body.style.transform = "";
              });
            }, 100);
          };

          window.addEventListener("scroll", forceRepaint, { passive: true });
          
          // Fix 3: Add body class for CSS-based fixes
          document.body.classList.add("safari-18-fix");
          
          console.log(`üçé [SAFARI-18-BETA] Applied fixes to ${stickyElements.length} sticky elements (scroll triggers preserved)`);
        }
          // Force orientation change workaround
          // const originalOrientation = screen.orientation?.type || "portrait";

          // // Request landscape orientation
          // if (screen.orientation && (screen.orientation as any).lock) {
          //   (screen.orientation as any)
          //     .lock("landscape")
          //     .then(() => {
          //       // Wait a moment then switch back to portrait
          //       setTimeout(() => {
          //         (screen.orientation as any)
          //           .lock("portrait")
          //           .then(() => {
          //             console.log("üçé [SAFARI-18-BETA] Orientation workaround completed");
          //           })
          //           .catch(() => {
          //             // Fallback if orientation lock fails
          //             console.log("üçé [SAFARI-18-BETA] Orientation lock failed, using fallback");
          //           });
          //       }, 100);
          //     })
          //     .catch(() => {
          //       // Fallback if orientation lock is not supported
          //       console.log("üçé [SAFARI-18-BETA] Orientation lock not supported");
          //     });
          // }
        }
      });
    </script>
  </body>
</html>
