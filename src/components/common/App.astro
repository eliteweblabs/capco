---
interface Props {
  title?: string;
  description?: string;
  currentUser?: any;
  session?: any;
  project?: any;
  supabase?: any;
  supabaseUrl?: string;
  projects?: any;
  isBackend?: boolean;
  id?: string;
  globalPrimaryTextClasses?: string;
  globalSecondaryTextClasses?: string;
  globalInputClasses?: string;
  year?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  noFooter?: boolean;
  globalCompanyAddress?: string;
  globalCompanyPhone?: string;
  globalCompanyEmail?: string;
  globalCompanyWebsite?: string;
  globalCompanyLogo?: string;
  globalCompanyLogoDark?: string;
  globalCompanyLogoLight?: string;
  statusData?: any;
  mainClasses?: string;
}

const {
  title = undefined,
  description = undefined,
  currentUser = undefined,
  session = undefined,
  project = undefined,
  supabase = undefined,
  supabaseUrl = undefined,
  projects = undefined,
  id = undefined,

  statusData = undefined,
  mainClasses = undefined,
} = Astro.props;

import { globalCompanyData } from "../../pages/api/global/global-company-data";

const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
  primaryColor,
} = globalCompanyData();

import { globalClasses } from "../../pages/api/global/global-classes";
const { globalInputClasses, globalPrimaryTextClasses, globalSecondaryTextClasses } =
  globalClasses();

// Derived properties (8 props ‚Üí 13 total)
const isAuth = currentUser ? true : false;
const currentUserId = currentUser?.id || undefined;
const currentRole = currentUser?.profile.role || undefined;
const projectId = project?.id || undefined;
const currentUrl = Astro.url.pathname;

// Get navigation data
import { navigation } from "@/pages/api/utils/navigation";
import { isBackendPage } from "@/pages/api/utils/backend-page-check";
const isBackend = isBackendPage(currentUrl);
const navigationData = navigation(currentUrl, isAuth, currentRole || "Client", isBackend || false);
const { desktopNavigationHTML, visibleNavItems } = navigationData;

import "../../styles/global.css"; // Import Tailwind CSS
// import "../../styles/app.css"; // Import Tailwind CSS

import Preloader from "./Preloader.astro";
import Footer from "./Footer.astro";
import UnifiedNotification from "./UnifiedNotification.astro";
import CookieBanner from "./CookieBanner.astro";
import SpeedDial from "./SpeedDial.astro";
import Navbar from "./Navbar.astro";
import Aside from "./Aside.astro";
import ScrollProgressIndicator from "./ScrollProgressIndicator.astro";
import TutorialOverlay from "./TutorialOverlay.astro";
import DebugPanel from "./DebugPanel.astro";
import NotificationDropdown from "./NotificationDropdown.astro";

// Notification count loader will be loaded via script tag

// Prepare debug data for admin users
const debugData = {
  // Original props
  title,
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
  description,
  currentUser,
  session,
  project,
  supabase,
  supabaseUrl,
  projects,
  isBackend,
  id,
  statusData,
  // Derived properties
  isAuth,
  projectId,
  currentUrl,
  // Navigation data
  navigationData,
  desktopNavigationHTML,
  visibleNavItems,
  // Additional context
  astroUrl: Astro.url,
  astroRequest: {
    method: Astro.request.method,
    headers: Object.fromEntries(Astro.request.headers.entries()),
    url: Astro.request.url,
  },
};
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="author" content="Tomsens+REKKO" />
    <!-- <meta name="generator" content="Hugo 0.123.8" /> -->

    <!-- Safari 18 beta specific viewport fixes -->
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>
      {globalCompanyName + " ‚Üí " + (title || Astro.url.pathname.replace(/\//g, " ").trim())}
    </title>

    <meta name="description" content={description} />

    <!-- <link
      rel="stylesheet"
      href="https://www.unpkg.com/flowbite-datepicker@1.3.2/dist/css/datepicker.min.css"
    /> -->

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" sizes="any" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="any" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-project-title" content={globalCompanyName} />
    <meta name="generator" content={Astro.generator} />
    <!-- Safari Privacy Protection Meta Tags -->
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups" />
    <meta property="og:title" content={title + " ‚Üí " + globalCompanyName} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content="/img/capco-logo.png" />
    <meta property="og:url" content={Astro.url} />
    <meta name="twitter:card" content={description} />
    <meta name="twitter:title" content={title + " ‚Üí " + globalCompanyName} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content="/img/capco-logo.png" />

    <meta name="robots" content="max-image-preview:large" /><link
      rel="canonical"
      href={currentUrl}
    />
    <meta property="og:site_name" content="CAPCo Fire" /><meta
      property="og:type"
      content="website"
    />
    <!-- <link rel="canonical" href="https://flowbite.com/application-ui/demo/" />-->

    <!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    /> -->

    <!-- Font styles are handled by CSS files -->

    <link rel="stylesheet" href="https://flowbite.com/application-ui/demo/app.css" />
    <!-- 

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="https://flowbite.com/application-ui/demo/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="https://flowbite.com/application-ui/demo/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="https://flowbite.com/application-ui/demo/favicon-16x16.png"
    />
    <link rel="icon" type="image/png" href="https://flowbite.com/application-ui/demo/favicon.ico" />
    <link rel="manifest" href="https://flowbite.com/application-ui/demo/site.webmanifest" />
    <link
      rel="mask-icon"
      href="https://flowbite.com/application-ui/demo/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="theme-color" content="#ffffff" /> -->

    <!-- Twitter -->
    <!-- <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta name="twitter:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      name="twitter:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta name="twitter:image" content="https://flowbite.com/application-ui/demo/" /> -->

    <!-- Facebook -->
    <!-- <meta property="og:url" content="https://flowbite.com/application-ui/demo/" />
    <meta property="og:title" content="Tailwind CSS Dashboard - Flowbite" />
    <meta
      property="og:description"
      content="Get started with a premium admin dashboard interface built with Tailwind CSS and Flowbite featuring over 50 example pages of charts, calendars, kanban boards, dashboards, CRUD pages, mailing systems, and more."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://flowbite.com/application-ui/demo/images/og-image.jpg"
    />
    <meta property="og:image:type" content="image/png" /> -->

    <script>
      import {
        initializeNotificationCount,
        loadNotificationCount,
        refreshNotificationCount,
        updateNotificationBellCount,
      } from "@/lib/notification-count-loader";

      // Make functions globally available
      (window as any).initializeNotificationCount = initializeNotificationCount;
      (window as any).updateNotificationBellCount = updateNotificationBellCount;
      (window as any).loadNotificationCount = loadNotificationCount;
      (window as any).refreshNotificationCount = refreshNotificationCount;
    </script>

    <!-- Set global user data for client-side components -->
  </head>

  <body class="antialiased">
    <!-- Preloader -->
    <Preloader />

    <Navbar
      {desktopNavigationHTML}
      {currentUser}
      {session}
      {supabaseUrl}
      {id}
      {projects}
      {project}
      {isBackend}
    />

    <div class="safari-18-fix flex mt-14">
      <Aside
        {currentUser}
        {project}
        {globalInputClasses}
        primaryTextClasses={globalPrimaryTextClasses}
        secondaryTextClasses={globalSecondaryTextClasses}
        {projects}
      />

      <div
        id="main-content"
        class=`relative flex w-full flex-col ${mainClasses} ${currentUser && currentRole !== "Client" ? "" : ""}`
      >
        <main class="flex-1">
          <slot />
        </main>
        <!-- Footer -->
        <Footer
          {globalInputClasses}
          {globalSecondaryTextClasses}
          {globalPrimaryTextClasses}
          {currentUser}
          {globalCompanyName}
          {globalCompanyAddress}
          {globalCompanyPhone}
          {globalCompanyEmail}
          {globalCompanyWebsite}
          {globalCompanyLogo}
          {globalCompanyLogoDark}
          {primaryColor}
          {globalCompanyLogoLight}
          {isBackendPage}
        />
      </div>
    </div>

    <!-- Unified Notification System -->
    <UnifiedNotification />
    <!-- Cookie Banner -->
    <CookieBanner />
    <!-- Speed Dial -->
    <SpeedDial
      currentUser={currentUser || undefined}
      {isBackend}
      {debugData}
      {globalPrimaryTextClasses}
      {globalSecondaryTextClasses}
      {globalInputClasses}
    />

    <ScrollProgressIndicator />
    {currentUser && <NotificationDropdown currentUser={currentUser} />}
    <TutorialOverlay {currentUser} tutorialId="demo-tour" autoStart={false} {isAuth} />
    <DebugPanel {currentUser} {debugData} />

    <!-- Flowbite JavaScript -->
    <script src="https://unpkg.com/flowbite@2.5.2/dist/flowbite.min.js"></script>

    <script>
      declare global {
        interface Window {
          // Global functions and utilities (alphabetized)
          acceptProposal?: () => void;
          addNewLineItem?: () => void;
          camelToProper?: (str: string) => string;
          clipboardData?: any;
          createLineItemRow?: (data: any) => HTMLElement;
          createButtonPartial?: (config: any) => Promise<HTMLElement | null>;
          deleteProject?: (projectId: any) => void;
          getProject?: (projectId: string | number) => Promise<any>;
          handleNewStatusModalAndEmail?: any;
          handleUrlNotification?: (type: string, message: string) => void;
          hideOnFormFocus?: (elementSelector: string, mobileOnly?: boolean) => void;
          hideNotification?: any;
          // UX Utility Functions
          scrollToTopOnMobile?: () => void;
          scrollToTop?: (behavior?: ScrollBehavior) => void;
          isMobile?: () => boolean;
          isTablet?: () => boolean;
          isDesktop?: () => boolean;
          getViewportSize?: () => "mobile" | "tablet" | "desktop";
          debounce?: <T extends (...args: any[]) => any>(func: T, wait: number) => T;
          throttle?: <T extends (...args: any[]) => any>(func: T, limit: number) => T;
          truncateString?: (str: string, maxLength?: number, suffix?: string) => string;
          hideOnMobileInput?: (elementSelector: string) => void;
          isSafariIOS?: () => boolean;
          isSafari?: () => boolean;
          isSafariBeta?: () => boolean;
          isSafari18OrLater?: () => boolean;
          fixSafariViewport?: () => void;
          immediateSafariViewportFix?: () => void;
          setupViewportHandling?: () => void;
          ensureViewportBounds?: (minHeight?: number, maxHeight?: number) => void;
          lockBodyScroll?: () => void;
          unlockBodyScroll?: () => void;
          initializeSubjectEditing?: () => void;
          proposalHelper?: any;
          proposalManager?: any;
          refreshManager?: any;
          requestPushNotificationPermission?: () => void;
          resetForm?: any;
          resetNotifications?: () => void;
          sendEmail?: (emailData: any, currentUser: any) => Promise<any>;
          setPageLoadStatusActionsFromUrl?: any;
          showModal?: any;
          switchTab?: any;
          toggleCommentForm?: () => void;
          trimText?: (text: string, maxLength?: number, suffix?: string) => string;
          trimWords?: (text: string, wordLimit?: number, suffix?: string) => string;
          updateCountBubble?: (
            parentElement: HTMLElement,
            count: number,
            options?: any
          ) => HTMLElement | null;
          updateProposalTotal?: () => void;
          updateStatus?: (project: any, newStatus: number, statuses?: any) => Promise<any>;
          validateEmail?: (email: string) => string | null;
          COUNT_BUBBLE_PRESETS?: {
            notification: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            punchlist: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
            small: {
              bubbleClasses: string;
              maxCount: number;
              showZero: boolean;
            };
          };
        }
      }
      // Make data available globally for the proposal functions
      // import { setupConsoleInterceptor } from "../../lib/console-interceptor.ts";
      // Set Stripe publishable key globally for PaymentForm
      (window as any).STRIPE_PUBLISHABLE_KEY = import.meta.env.PUBLIC_STRIPE_PUBLISHABLE_KEY;
      console.log("üîß [STRIPE] Publishable key loaded:", !!(window as any).STRIPE_PUBLISHABLE_KEY);

      // Helper function to create buttons using Button partial
      (window as any).createButtonPartial = async function (config: any) {
        try {
          const headers = new Headers();
          Object.entries(config).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
              headers.set(`x-button-${key}`, value.toString());
            }
          });

          const response = await fetch("/partials/button", {
            headers: headers,
          });

          if (response.ok) {
            const buttonHTML = await response.text();
            return buttonHTML; // Return HTML string instead of DOM element
          } else {
            console.error("Failed to fetch button partial:", response.status);
            return null;
          }
        } catch (error) {
          console.error("Error creating button partial:", error);
          return null;
        }
      };

      if (!String.prototype.startsWith) {
        console.log("üîß [POLYFILL] Adding startsWith polyfill...");
        String.prototype.startsWith = function (search: string, pos?: number) {
          return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
        console.log("üîß [POLYFILL] startsWith polyfill added successfully");
      }

      // Global utility function to convert camelCase to Proper Case
      (window as any).camelToProper = (str: string): string => {
        if (!str) return "";

        // Handle special cases first
        const specialCases: { [key: string]: string } = {
          id: "ID",
          url: "URL",
          api: "API",
          sms: "SMS",
          email: "Email",
          phone: "Phone",
          status: "Status",
          project: "Project",
          user: "User",
          admin: "Admin",
          client: "Client",
          staff: "Staff",
          role: "Role",
          name: "Name",
          title: "Title",
          address: "Address",
          created: "Created",
          updated: "Updated",
          completed: "Completed",
          incomplete: "Incomplete",
          failed: "Failed",
          sent: "Sent",
          received: "Received",
          uploaded: "Uploaded",
          downloaded: "Downloaded",
          added: "Added",
          changed: "Changed",
          login: "Login",
          logout: "Logout",
          registration: "Registration",
          action: "Action",
          event: "Event",
          error: "Error",
          info: "Info",
          system: "System",
          notification: "Notification",
          discussion: "Discussion",
          punchlist: "Punchlist",
          proposal: "Proposal",
          assignment: "Assignment",
          comment: "Comment",
          file: "File",
        };

        // Split camelCase into words
        const words = str
          .replace(/([A-Z])/g, " $1")
          .trim()
          .split(" ");

        // Convert each word to proper case
        const properWords = words.map((word) => {
          const lowerWord = word.toLowerCase();

          // Check special cases first
          if (specialCases[lowerWord]) {
            return specialCases[lowerWord];
          }

          // Default: capitalize first letter
          return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        });

        return properWords.join(" ");
      };

      (window as any).hideNotification = function () {
        console.log("[FALLBACK-NOTIFICATION] Hiding notification");
      };

      // switchTab function is now defined in individual pages that need it
      // This prevents conflicts with page-specific tab switching logic

      (window as any).handleNewStatusModalAndEmail = function (response: any, context: string) {
        if (!response) {
          console.error(`ERROR [${context || "NOTIFICATION"}] API call failed:`, response.error);
          return;
        }

        if (!response.statusData || !(window as any).showModal) {
          console.warn(
            `WARNING [${context || "NOTIFICATION"}] No notification data or showModal function available`
          );
          return;
        }

        // Get the current status configuration
        const clientNotification = response.statusData?.client;
        const adminNotification = response.statusData?.admin;
        const currentNotification = response.statusData?.current;
        const currentUser = response.currentUser;

        clientNotification.email.currentUser = currentUser;
        adminNotification.email.currentUser = currentUser;
        // Send email if email configuration exists
        if (clientNotification?.email) {
          (window as any).sendEmail(clientNotification.email);
        }

        if (adminNotification?.email) {
          (window as any).sendEmail(adminNotification.email);
        }

        console.log("currentUser from notice", currentUser);
        if (currentNotification?.modal) {
          const modalData = {
            ...currentNotification.modal,
            redirect: currentNotification.modal.redirect
              ? {
                  url: currentNotification.modal.redirect.url,
                  showCountdown: currentNotification.modal.redirect.showCountdown || true,
                }
              : undefined,
          };
          console.log("üîî [STATUS-MODAL] Showing modal with data:", modalData);
          (window as any).showModal(modalData);
        } else {
          console.warn(`WARNING [${context || "NOTIFICATION"}] No notification found in response`);
        }
      };

      (window as any).hideOnFormFocus = function () {
        // Check if we should only hide on mobile
        if (!(window as any).isMobile()) return;

        const element = document.querySelector(".hide-when-form-focus");
        if (!element) return;

        // Hide on input focus
        const hideOnFocus = () => {
          (element as HTMLElement).style.display = "none";
        };

        // Show on input blur
        const showOnBlur = () => {
          (element as HTMLElement).style.display = "block";
        };

        const selector = "input, textarea, select, form, button, label, .slot-machine-modal";
        // Add event listeners to all form inputs
        const inputs = document.querySelectorAll(selector);
        inputs.forEach((input) => {
          input.addEventListener("focus", hideOnFocus);
          input.addEventListener("focus-within", hideOnFocus);
          input.addEventListener("blur", showOnBlur);
        });

        // Also handle dynamically added inputs
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newInputs = element.querySelectorAll
                  ? element.querySelectorAll(selector)
                  : [];
                newInputs.forEach((input) => {
                  input.addEventListener("focus", hideOnFocus);
                  input.addEventListener("blur", showOnBlur);
                });
              }
            });
          });
        });

        observer.observe(document.body, { childList: true, subtree: true });
      };

      (window as any).sendEmail = async function (emailData: any, currentUser: any) {
        try {
          console.log("üìß [SEND-EMAIL] Received email data:", emailData);
          console.log("üìß [SEND-EMAIL] usersToNotify:", emailData.usersToNotify);
          console.log("üìß [SEND-EMAIL] method:", emailData.method);

          // Transform the email data to match the update-delivery API structure
          const transformedData = {
            usersToNotify: emailData.usersToNotify || [],
            method: emailData.method || "email",
            emailSubject: emailData.emailSubject || "Project Update",
            emailContent: emailData.emailContent || "Project status has been updated",
            buttonLink: emailData.buttonLink,
            buttonText: emailData.buttonText,
            project: emailData.project || {},
            currentUser: currentUser,
          };

          console.log("üìß [SEND-EMAIL] Sending email with transformed data:", transformedData);

          const response = await fetch("/api/delivery/update-delivery", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(transformedData),
          });

          const result = await response.json();
          console.log("üìß [SEND-EMAIL] Email response:", result);
          return result;
        } catch (error: any) {
          console.error("Global sendEmail error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).getProject = async function (projectId: string | number) {
        const projectResponse = await fetch(`/api/get-project?id=${projectId}`);
        if (projectResponse.ok) {
          return await projectResponse.json();
        } else {
          throw new Error("Failed to fetch project");
        }
      };

      let isDeleting = false; // Flag to prevent multiple delete operations
      (window as any).deleteProject = function (projectId: any) {
        // Prevent multiple delete operations
        if (isDeleting) {
          console.log("Delete operation already in progress, ignoring request");
          return;
        }

        // Validate project ID - ensure it's a string
        console.log("üîß [DELETE] projectId type:", typeof projectId, "value:", projectId);
        const projectIdStr = String(projectId);
        console.log("üîß [DELETE] projectIdStr:", projectIdStr);
        if (!projectId || projectIdStr.startsWith("new-project-")) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "error",
              "Delete Failed",
              "Cannot delete a new project that hasn't been saved yet.",
              5000
            );
          }
          return;
        }

        // Show confirmation modal with action buttons
        if ((window as any).showModal) {
          (window as any).showModal(
            "error",
            "Delete Project",
            "Are you sure you want to delete this project? This action cannot be undone.",
            6000000, // 6000 seconds timeout
            [
              {
                label: "Cancel",
                variant: "anchor",
                fullWidth: true,
                action: () => {},
              },
              {
                label: "Delete",
                variant: "danger",
                fullWidth: true,
                action: () => {
                  // Set deleting flag to prevent multiple operations
                  isDeleting = true;

                  // Show loading state
                  const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
                  deleteBtn?.setAttribute("data-loading", "true");
                  if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML =
                      '<i data-lucide="loader-2" class="animate-spin mr-1"></i>Deleting...';
                  }

                  // Make API call to delete project
                  console.log("Sending delete request for project:", projectId);
                  fetch(`/api/projects/delete`, {
                    method: "DELETE",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ projectId }),
                  })
                    .then(async (response) => {
                      const data = await response.json();

                      if (!response.ok) {
                        throw new Error(data.error || "Failed to delete project");
                      }

                      // Show success modal
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "success",
                          "Project Deleted!",
                          data.message || "Project has been deleted successfully.",
                          1500
                        );
                      }

                      // Reset deleting flag
                      isDeleting = false;

                      document
                        .querySelectorAll("[data-project-id='" + projectId + "']")
                        ?.forEach((element) => {
                          element.remove();
                        });
                    })
                    .catch((error) => {
                      console.error("Error deleting project:", error);

                      // Show error modal with specific error message
                      if ((window as any).showModal) {
                        (window as any).showModal(
                          "error",
                          "Delete Failed",
                          error.message || "Failed to delete project. Please try again.",
                          6000000
                        );
                      }

                      // Reset deleting flag and button state
                      isDeleting = false;
                      if (deleteBtn) {
                        deleteBtn.disabled = false;
                        deleteBtn.innerHTML =
                          '<i data-lucide="trash-2" class="mr-1"></i>Delete Project';
                      }
                    });
                },
              },
            ]
          );
        }
      };

      (window as any).updateStatus = async function (
        project: any,
        status: number,
        currentStatusData?: any
      ) {
        try {
          // If project exists, use it; otherwise fetch it
          let currentProject = project;
          if (!currentProject) {
            try {
              currentProject = await (window as any).getProject(project);
            } catch (error) {
              console.error(
                "üìä [UPDATE-STATUS] Could not fetch project, using minimal object:",
                error
              );
              currentProject = {
                id: project.id,
                status: 0,
              };
            }
          }

          const response = await fetch("/api/status/upsert", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              currentProject,
              newStatus: status,
              currentStatusData: currentStatusData || null, // Pass the current status data
            }),
          });
          return await response.json();
        } catch (error: any) {
          console.error("Global updateStatus error:", error);
          return { success: false, error: error.message };
        }
      };

      (window as any).updateCountBubble = function (
        parentElement: HTMLElement,
        count: number,
        options: any = {}
      ) {
        if (!parentElement) {
          console.warn("üîç [COUNT-BUBBLE] Parent element is null or undefined");
          return null;
        }

        const config = {
          bubbleClasses:
            "absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          parentClasses: "relative",
          maxCount: 99,
          showZero: false,
          ...options,
        };

        // Find existing bubble or create new one
        let countBubble = parentElement.querySelector(".count-bubble") as HTMLSpanElement;

        if (count > 0 || config.showZero) {
          // Create bubble if it doesn't exist
          if (!countBubble) {
            countBubble = document.createElement("span");
            countBubble.className = `count-bubble ${config.bubbleClasses}`;

            // Add parent classes if specified
            if (config.parentClasses) {
              parentElement.classList.add(...config.parentClasses.split(" "));
            }

            parentElement.appendChild(countBubble);
            console.log("üîç [COUNT-BUBBLE] Created new bubble for element:", parentElement);
          }

          // Update bubble content and visibility
          const displayCount = count > config.maxCount ? `${config.maxCount}+` : count.toString();
          countBubble.textContent = displayCount;
          countBubble.style.display = "flex";

          // Update data attribute for accessibility
          parentElement.setAttribute("data-count", count.toString());
        } else {
          // Hide bubble when count is 0 (unless showZero is true)
          if (countBubble) {
            countBubble.style.display = "none";
            parentElement.removeAttribute("data-count");
            console.log("üîç [COUNT-BUBBLE] Hidden bubble (count is 0)");
          }
        }

        return countBubble;
      };

      // Count bubble presets - single source of truth
      (window as any).COUNT_BUBBLE_PRESETS = {
        default: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        notification: {
          bubbleClasses:
            "absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-600 animate-pulse",
          maxCount: 99,
          showZero: false,
        },
        small: {
          bubbleClasses:
            "absolute -right-1 -top-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary-500 text-xs font-bold text-white dark:bg-primary-dark animate-pulse",
          maxCount: 9,
          showZero: false,
        },
      };

      // String utility functions
      (window as any).unslugify = function (slug: string): string {
        return (
          slug
            .split("/")
            .filter(Boolean)
            .pop() // Get last segment
            ?.split("-")
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ") || "Home"
        );
      };

      // ===== UX UTILITY FUNCTIONS =====

      // Scroll utilities
      (window as any).scrollToTopOnMobile = function () {
        if (window.innerWidth < 768) {
          console.log("üì± [UX-UTILS] Scrolling to top on mobile device");
          (window as any).scrollTo({ top: 0, behavior: "smooth" });
        }
      };

      (window as any).scrollToTop = function (behavior = "smooth") {
        console.log("üì± [UX-UTILS] Scrolling to top");
        (window as any).scrollTo({ top: 0, behavior });
      };

      // Device detection
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };

      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };

      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).getViewportSize = function () {
        if (window.innerWidth < 768) return "mobile";
        if (window.innerWidth < 1024) return "tablet";
        return "desktop";
      };

      // Utility functions
      (window as any).debounce = function (func: any, wait: any) {
        let timeout: any;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      (window as any).throttle = function (func: any, limit: any) {
        let inThrottle: any;
        return function executedFunction(this: any, ...args: any[]) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // String utilities
      (window as any).truncateString = function (
        str: string,
        maxLength: number = 30,
        suffix: string = "..."
      ) {
        if (!str) return "";
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).validateEmail = function (email: string): string | null {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) ? null : "Invalid email format";
      };

      (window as any).isSafariBeta = function () {
        const ua = navigator.userAgent;
        // Check if iOS device
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        // Extract Safari version
        const versionMatch = ua.match(/Version\/(\d+)\./);
        const safariVersion = versionMatch ? parseInt(versionMatch[1]) : null;
        // Check if Safari (not Chrome/Firefox/Edge)
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        // Updated to handle beta 26 and later
        const isBetaVersion = safariVersion && safariVersion >= 18 && safariVersion <= 30;
        const result = isIOS && isSafari && isBetaVersion;

        return result;
      };
      (window as any).isSafariIOS = function () {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
        return isIOS && isSafari;
      };
      (window as any).isSafari = function () {
        const ua = navigator.userAgent;
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua);
      };
      (window as any).isSafari18OrLater = function () {
        const ua = navigator.userAgent;
        const safariMatch = ua.match(/Version\/(\d+)/);
        if (!safariMatch) return false;
        const version = parseInt(safariMatch[1]);
        return /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/.test(ua) && version >= 18;
      };
      (window as any).fixSafariViewport = function () {
        if ((window as any).isSafariIOS()) {
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", vh + "px");
        }
      };
      (window as any).immediateSafariViewportFix = function () {
        if ((window as any).isSafariIOS()) {
          const setViewportHeight = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");
          };
          setViewportHeight();
          window.addEventListener("orientationchange", () => setTimeout(setViewportHeight, 100));
          window.addEventListener("resize", setViewportHeight);
        }
      };
      (window as any).isMobile = function () {
        return window.innerWidth < 768;
      };
      (window as any).isTablet = function () {
        return window.innerWidth >= 768 && window.innerWidth < 1024;
      };
      (window as any).isDesktop = function () {
        return window.innerWidth >= 1024;
      };

      (window as any).setupViewportHandling = function () {
        (window as any).immediateSafariViewportFix();
      };

      (window as any).ensureViewportBounds = function (minHeight = 400, maxHeight = 1200) {
        const currentHeight = window.innerHeight;
        if (currentHeight < minHeight || currentHeight > maxHeight) {
          if ((window as any).showModal) {
            (window as any).showModal(
              "warning",
              "Viewport Issue",
              `Viewport height (${currentHeight}px) is outside recommended bounds (${minHeight}-${maxHeight}px)`,
              5000
            );
          }
        }
      };

      // Body scroll utilities
      (window as any).lockBodyScroll = function () {
        document.body.style.overflow = "hidden";
      };

      (window as any).unlockBodyScroll = function () {
        document.body.style.overflow = "";
      };

      /**
       * Handles URL parameter notifications (errors and success messages)
       * @param type - Notification type ('error' | 'success')
       * @param param - URL parameter value
       */
      (window as any).handleUrlNotification = function (
        type: "error" | "success",
        param: string
      ): void {
        const notifications = {
          // Error notifications
          error: {
            oauth_failed: {
              title: "Authentication Failed",
              message: "OAuth authentication failed. Please try again.",
            },
            verification_failed: {
              title: "Verification Failed",
              message: "Email verification failed. Please try again.",
            },
            verification_expired: {
              title: "Link Expired",
              message: "Verification link has expired. Please request a new one.",
            },
            verification_invalid: {
              title: "Invalid Link",
              message: "Invalid verification link.",
            },
            verification_error: {
              title: "Verification Error",
              message: "An error occurred during verification.",
            },
            no_token: {
              title: "Invalid Token",
              message: "Invalid or missing verification token.",
            },
            no_user: { title: "User Not Found", message: "User not found." },
            invalid_credentials: {
              title: "Invalid Credentials",
              message: "Invalid email or password.",
            },
            email_exists: {
              title: "Account Exists",
              message: "An account with this email already exists.",
            },
            weak_password: {
              title: "Weak Password",
              message: "Password must be at least 6 characters long.",
            },
            invalid_email: {
              title: "Invalid Email",
              message: "Please enter a valid email address.",
            },
            sms_missing_fields: {
              title: "SMS Error",
              message: "Please fill in all required fields for SMS.",
            },
            sms_invalid_phone: {
              title: "Invalid Phone",
              message: "Please enter a valid 10-digit phone number.",
            },
            sms_invalid_carrier: {
              title: "Invalid Carrier",
              message: "Please select a valid carrier.",
            },
            sms_send_failed: {
              title: "SMS Failed",
              message: "Failed to send SMS. Please try again.",
            },
            sms_email_error: {
              title: "Service Error",
              message: "Email service error. Please try again later.",
            },
            sms_unexpected_error: {
              title: "SMS Error",
              message: "An unexpected error occurred while sending SMS.",
            },
            default: { title: "Error", message: "An error occurred. Please try again." },
          },
          // Success notifications
          success: {
            registration_success: {
              title: "Account Created",
              message: "Registration successful! Please check your email to verify your account.",
            },
            verification_success: {
              title: "Email Verified",
              message: "Email verified successfully! You can now sign in.",
            },
            welcome: {
              title: "Welcome!",
              message: "Welcome! Your account has been verified and you're now signed in.",
            },
            logout_success: {
              title: "Signed Out",
              message: "You have been successfully signed out.",
              // redirect: { url: "/", delay: 3500, showCountdown: true },
            },
            sms_sent_success: {
              title: "Message Sent",
              message: `Your message has been sent to ${import.meta.env.GLOBAL_COMPANY_NAME} successfully.`,
            },
            // oauth_success: {
            //   title: "OAuth Success",
            //   message: `Your OAuth login has been successful.`,
            // },
            default: { title: "Success!", message: param },
          },
        };

        const notification = (notifications[type] as any)[param] || notifications[type].default;

        if ((window as any).showModal) {
          // Use global UX utility function for mobile scroll
          (window as any).scrollToTopOnMobile();

          if (type === "error") {
            (window as any).showModal("error", notification.title, notification.message);
          } else {
            (window as any).showModal(
              "success",
              notification.title,
              notification.message,
              2500,
              notification.redirect
            );
          }
        } else {
          console.error(`üîî [${notification.title}] ${notification.message}`);
          console.error("üîî showModal is not available - notification system not initialized");
        }
      };

      // ===== END GLOBAL FUNCTIONS =====

      // Setup console interceptor (disables console.log in production)
      // setupConsoleInterceptor();

      // // Handle URL parameter notifications (errors and success messages)
      (window as any).processUrlNotifications = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const errorParam = urlParams.get("error");
        const successParam = urlParams.get("success");
        const messageParam = urlParams.get("message");

        if (errorParam) {
          console.log("üîî [URL-NOTIFICATION] Processing error parameter:", errorParam);
          (window as any).handleUrlNotification("error", errorParam);

          // Clean up URL by removing the error parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("error");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (successParam) {
          console.log("üîî [URL-NOTIFICATION] Processing success parameter:", successParam);
          (window as any).handleUrlNotification("success", successParam);

          // Clean up URL by removing the success parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("success");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }

        if (messageParam) {
          console.log("üîî [URL-NOTIFICATION] Processing message parameter:", messageParam);
          (window as any).handleUrlNotification("success", messageParam);

          // Clean up URL by removing the message parameter - DELAYED to allow modal to render
          setTimeout(() => {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("message");
            window.history.replaceState({}, document.title, newUrl.pathname + newUrl.search);
          }, 500);
        }
      };

      // // Process URL notifications on page load with retry mechanism
      const processUrlNotificationsWithRetry = (attempts = 0) => {
        if ((window as any).showModal) {
          // showModal is available, process notifications
          (window as any).processUrlNotifications();
        } else if (attempts < 10) {
          // showModal not ready yet, retry after 100ms
          console.log(
            "üîî [URL-NOTIFICATION] showModal not ready, retrying... attempt",
            attempts + 1
          );
          setTimeout(() => processUrlNotificationsWithRetry(attempts + 1), 100);
        } else {
          console.error("üîî [URL-NOTIFICATION] showModal never became available after 10 attempts");
        }
      };

      document.addEventListener("DOMContentLoaded", () => processUrlNotificationsWithRetry());

      // // Also run immediately in case DOM is already loaded
      if (document.readyState === "loading") {
        // DOM is still loading, event listener will handle it
      } else {
        // DOM is already loaded, run immediately with retry
        processUrlNotificationsWithRetry();
      }

      // Suppress ResizeObserver loop warnings (they're usually harmless)
      window.addEventListener("error", (e: any) => {
        if (e.message === "ResizeObserver loop completed with undelivered notifications.") {
          e.stopImmediatePropagation();
        }
      });

      // Register service worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration: any) => {
              console.log("‚úÖ Service Worker registered successfully:", registration.scope);
            })
            .catch((error: any) => {
              console.log("‚ùå Service Worker registration failed:", error);
            });
        });
      } else {
        console.log("‚ùå Service Worker not supported in this browser");
      }

      // Global text trimming utilities
      (window as any).trimText = function (
        text: string,
        maxLength: number = 100,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - suffix.length) + suffix;
      };

      (window as any).trimWords = function (
        text: string,
        wordLimit: number = 50,
        suffix: string = "..."
      ): string {
        if (!text) return "";
        const words = text.trim().split(/\s+/);
        if (words.length <= wordLimit) return text;
        return words.slice(0, wordLimit).join(" ") + suffix;
      };

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize autofill navigation - COMMENTED OUT
        // (window as any).setupAutofillNavigation();

        // Initialize dark mode first to prevent preloader flash
        const hasExplicitPreference = localStorage.getItem("color-theme") !== null;

        if (hasExplicitPreference) {
          // User has explicitly set a preference, apply it
          if (localStorage.getItem("color-theme") === "dark") {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
          }
        } else {
          // No explicit preference, check system preference
          if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.classList.add("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "dark");
          } else {
            document.documentElement.classList.remove("dark", "zD1iTsv7EQco3GO_szee");
            localStorage.setItem("color-theme", "light");
          }
        }

        // Call immediately
        const isSafariBeta = (window as any).isSafariBeta();
        console.log("üçé [APP] isSafari18", isSafariBeta);
        if (isSafariBeta === true) {
          console.log(
            "üçé [SAFARI-18-BETA] Applying Safari sticky positioning fixes (lightweight mode)"
          );
          // <!-- Mobile debugging console (Eruda) - only load in development or with ?debug=true -->

          const isDevelopment = import.meta.env.DEV;
          const hasDebugParam = new URLSearchParams(window.location.search).get("debug") === "true";

          if (isDevelopment || hasDebugParam) {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/eruda";
            script.onload = function () {
              if ((window as any).eruda) {
                (window as any).eruda.init();
                console.log("üì± [ERUDA] Mobile debugging console loaded");
              }
            };
            document.body.appendChild(script);
          }

          // Fix 1: Force GPU compositing on all sticky elements
          const stickyElements = document.querySelectorAll(
            '[class*="sticky"], .sticky, [style*="position: sticky"]'
          );
          stickyElements.forEach((el) => {
            const element = el as HTMLElement;
            element.style.transform = "translateZ(0)"; // Force GPU layer
            element.style.willChange = "transform, top, bottom";
            element.style.webkitBackfaceVisibility = "hidden";
            element.style.backfaceVisibility = "hidden";
          });

          // Fix 2: Force repaint on scroll (lightweight - doesn't break scroll triggers)
          let scrollTimeout: number;
          const forceRepaint = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = window.setTimeout(() => {
              // Trigger a minimal repaint without changing layout
              document.body.style.transform = "translateZ(0)";
              requestAnimationFrame(() => {
                document.body.style.transform = "";
              });
            }, 100);
          };

          window.addEventListener("scroll", forceRepaint, { passive: true });

          // Fix 3: Add body class for CSS-based fixes
          // document.body.classList.add("safari-18-fix");

          // Fix 4: Handle header positioning - target the actual navbar
          const navbar = document.querySelector("nav.fixed");
          if (navbar) {
            const navbarElement = navbar as HTMLElement;
            console.log("üçé [SAFARI-FIX] Found navbar, applying fixes");

            // Force the positioning
            navbarElement.style.position = "fixed";
            navbarElement.style.top = "0";
            navbarElement.style.left = "0";
            navbarElement.style.right = "0";
            navbarElement.style.zIndex = "50";
            navbarElement.style.transform = "translateZ(0)";
            navbarElement.style.willChange = "transform";
            navbarElement.style.webkitBackfaceVisibility = "hidden";
            navbarElement.style.backfaceVisibility = "hidden";

            // Add a class for additional CSS targeting
            navbarElement.classList.add("safari-sticky-fix");

            console.log("üçé [SAFARI-FIX] Applied navbar fixes");
          } else {
            console.log('üçé [SAFARI-FIX] No navbar found with class "fixed"');
          }

          // Fix 5: Handle SpeedDial positioning
          const speedDial = document.querySelector("[data-speed-dial], .speed-dial");
          if (speedDial) {
            const speedDialElement = speedDial as HTMLElement;
            speedDialElement.style.position = "fixed";
            speedDialElement.style.bottom = "20px";
            speedDialElement.style.right = "20px";
            speedDialElement.style.zIndex = "1000";
            speedDialElement.style.transform = "translateZ(0)";
            speedDialElement.style.willChange = "transform";
          }
          const safariFixElement = document.querySelector(".safari-18-fix");
          if (safariFixElement) {
            // (safariFixElement as HTMLElement).style.height = "";
            (safariFixElement as HTMLElement).style.overflow = "scroll";
            (safariFixElement as HTMLElement).style.position = "fixed";
            (safariFixElement as HTMLElement).style.top = "0";
            (safariFixElement as HTMLElement).style.bottom = "0";
            (safariFixElement as HTMLElement).style.left = "0";
            (safariFixElement as HTMLElement).style.right = "0";
            (safariFixElement as HTMLElement).style.zIndex = "49";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
            (safariFixElement as HTMLElement).style.willChange = "transform";
            (safariFixElement as HTMLElement).style.transform = "translateZ(0)";
          }

          // Fix 6: Handle viewport height changes
          const handleViewportChange = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty("--vh", vh + "px");

            // Force repaint on viewport change
            document.body.style.transform = "translateZ(0)";
            requestAnimationFrame(() => {
              document.body.style.transform = "";
            });
          };

          window.addEventListener("resize", handleViewportChange);
          window.addEventListener("orientationchange", () => {
            setTimeout(handleViewportChange, 100);
          });

          console.log(
            `üçé [SAFARI-18-BETA] Applied fixes to ${stickyElements.length} sticky elements (scroll triggers preserved)`
          );

          // Additional aggressive fix for navbar after a delay
          setTimeout(() => {
            const navbar = document.querySelector("nav.fixed");
            if (navbar) {
              const navbarElement = navbar as HTMLElement;
              console.log("üçé [SAFARI-FIX] Re-applying navbar fixes after delay");

              // Force all the styles again
              navbarElement.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 50 !important;
                transform: translateZ(0) !important;
                will-change: transform !important;
                -webkit-backface-visibility: hidden !important;
                backface-visibility: hidden !important;
              `;

              // Force a reflow
              navbarElement.offsetHeight;

              console.log("üçé [SAFARI-FIX] Re-applied navbar fixes");
            }
          }, 1000);
        }
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", async () => {
        (window as any).hideOnFormFocus();

        // Initialize notification count only if user is authenticated
        try {
          const notificationBell = document.getElementById("notification-bell");
          if (
            notificationBell &&
            notificationBell.dataset.userId &&
            (window as any).initializeNotificationCount
          ) {
            console.log(
              "üîî [APP] Initializing notifications for user:",
              notificationBell.dataset.userId
            );
            await (window as any).initializeNotificationCount();
          } else {
            console.log("üîî [APP] Skipping notification initialization - no authenticated user");
          }
        } catch (error) {
          console.error("üîî [APP] Error initializing notification count:", error);
        }
      });
    </script>

    <!-- Initialize Lucide Icons -->
    <script type="module">
      // Initialize Lucide icons using UNPKG CDN
      import { createIcons, icons } from "https://unpkg.com/lucide@latest/dist/esm/lucide.js";
      console.log("üîß [LUCIDE] Initializing Lucide icons...");
      console.log("üîß [LUCIDE] Available icons count:", Object.keys(icons).length);
      console.log("üîß [LUCIDE] Sample icons:", Object.keys(icons).slice(0, 10));

      // Check if our specific icons exist
      const ourIcons = ["UserPlus", "CheckSquare", "BarChart3", "MessageCircle", "MessageSquare"];
      const foundIcons = ourIcons.filter((icon) => icons[icon]);
      const missingIcons = ourIcons.filter((icon) => !icons[icon]);
      console.log("üîß [LUCIDE] Found icons:", foundIcons);
      console.log("üîß [LUCIDE] Missing icons:", missingIcons);

      // Wait for DOM to be ready and manually render icons
      const initializeIcons = () => {
        setTimeout(() => {
          // Try the standard createIcons approach first
          try {
            createIcons({ icons });
            console.log("‚úÖ [LUCIDE] createIcons({ icons }) called");
          } catch (error) {
            console.log("‚ùå [LUCIDE] createIcons failed:", error);
          }

          // If that doesn't work, try manual rendering with a different approach
          setTimeout(() => {
            const lucideElements = document.querySelectorAll("[data-lucide]");
            let renderedCount = 0;

            lucideElements.forEach((element) => {
              const iconName = element.getAttribute("data-lucide");
              if (icons[iconName]) {
                try {
                  // Try to get the icon function and call it
                  const iconFunction = icons[iconName];
                  if (typeof iconFunction === "function") {
                    const svg = iconFunction();
                    if (svg && typeof svg === "string") {
                      element.innerHTML = svg;
                      renderedCount++;
                      console.log(`‚úÖ [LUCIDE] Manually rendered: ${iconName}`);
                    }
                  }
                } catch (error) {
                  console.log(`‚ùå [LUCIDE] Failed to render ${iconName}:`, error);
                }
              } else {
                console.log(`‚ùå [LUCIDE] Icon not found: ${iconName}`);
              }
            });

            console.log(`üîß [LUCIDE] Icons rendered: ${renderedCount}/${lucideElements.length}`);

            // If no icons were rendered, try a fallback approach
            if (renderedCount === 0) {
              console.log("üîß [LUCIDE] Trying fallback approach...");
              lucideElements.forEach((element) => {
                const iconName = element.getAttribute("data-lucide");
                // Create a simple fallback SVG for common icons
                const fallbackSVGs = {
                  User: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>',
                  UserPlus:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="19" y1="8" x2="19" y2="14"></line><line x1="22" y1="11" x2="16" y2="11"></line></svg>',
                  CheckSquare:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9,11 12,14 22,4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>',
                  BarChart3:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"></path><path d="M18 17V9"></path><path d="M13 17V5"></path><path d="M8 17v-3"></path></svg>',
                  MessageCircle:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>',
                  MessageSquare:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>',
                  Check:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20,6 9,17 4,12"></polyline></svg>',
                  Shield:
                    '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>',
                  Send: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22,2 15,22 11,13 2,9 22,2"></polygon></svg>',
                  Zap: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"></polygon></svg>',
                };

                if (fallbackSVGs[iconName]) {
                  element.innerHTML = fallbackSVGs[iconName];
                  renderedCount++;
                  console.log(`‚úÖ [LUCIDE] Fallback rendered: ${iconName}`);
                }
              });

              console.log(
                `üîß [LUCIDE] Fallback icons rendered: ${renderedCount}/${lucideElements.length}`
              );
            }
          }, 200);
        }, 100);
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeIcons);
      } else {
        initializeIcons();
      }
    </script>

    <!-- Global Image Error Handler -->
    <script>
      // Global error handler for broken image URLs (especially Supabase storage)
      document.addEventListener("DOMContentLoaded", () => {
        // Handle all img elements with error handling
        const images = document.querySelectorAll("img");

        images.forEach((img) => {
          img.addEventListener("error", (event) => {
            const target = event.target as HTMLImageElement;
            const src = target.src;

            // Check if it's a Supabase storage URL that's failing
            if (src && src.includes("supabase.co/storage")) {
              console.warn("‚ö†Ô∏è [IMAGE-ERROR] Supabase storage image failed to load:", src);

              // Hide the broken image and show a fallback
              target.style.display = "none";

              // Create a fallback element if it doesn't exist
              if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                const fallback = document.createElement("div");
                fallback.className =
                  "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                fallback.style.width = target.style.width || "100%";
                fallback.style.height = target.style.height || "100%";
                fallback.innerHTML = "üì∑";
                target.parentNode?.insertBefore(fallback, target.nextSibling);
              }
            }
          });
        });

        // Handle dynamically added images
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as Element;
                const newImages = element.querySelectorAll("img");
                newImages.forEach((img) => {
                  img.addEventListener("error", (event) => {
                    const target = event.target as HTMLImageElement;
                    const src = target.src;

                    if (src && src.includes("supabase.co/storage")) {
                      console.warn("‚ö†Ô∏è [IMAGE-ERROR] Supabase storage image failed to load:", src);
                      target.style.display = "none";

                      if (!target.nextElementSibling?.classList.contains("image-fallback")) {
                        const fallback = document.createElement("div");
                        fallback.className =
                          "image-fallback bg-gray-200 flex items-center justify-center text-gray-500";
                        fallback.style.width = target.style.width || "100%";
                        fallback.style.height = target.style.height || "100%";
                        fallback.innerHTML = "üì∑";
                        target.parentNode?.insertBefore(fallback, target.nextSibling);
                      }
                    }
                  });
                });
              }
            });
          });
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
      });

      // Global error handler for unhandled promise rejections (network errors)
      window.addEventListener("unhandledrejection", (event) => {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("ERR_CONNECTION_CLOSED")
        ) {
          console.warn(
            "‚ö†Ô∏è [NETWORK-ERROR] Connection closed error suppressed:",
            event.reason.message
          );
          event.preventDefault(); // Prevent the error from showing in console
        }
      });

      // Global error handler for general errors
      window.addEventListener("error", (event) => {
        if (event.message && event.message.includes("ERR_CONNECTION_CLOSED")) {
          console.warn("‚ö†Ô∏è [NETWORK-ERROR] Connection closed error suppressed:", event.message);
          event.preventDefault(); // Prevent the error from showing in console
        }
      });
    </script>

    <!-- Plausible Analytics Script -->
    <script
      defer
      data-domain="capcofire.com"
      src="https://plausible-analytics-ce-production-6fd8.up.railway.app/js/script.file-downloads.hash.outbound-links.pageview-props.revenue.tagged-events.js"
    ></script>
    <script>
      // @ts-ignore
      (window as any).plausible =
        (window as any).plausible ||
        function () {
          // @ts-ignore
          (window.plausible.q = window.plausible.q || []).push(arguments);
        };
    </script>
  </body>
</html>
