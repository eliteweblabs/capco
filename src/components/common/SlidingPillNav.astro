---
// Sliding pill navigation component
import Button from "./Button.astro";

export interface NavItem {
  id?: string;
  label: string;
  icon?: string;
  variant?: string;
  dataAttributes?: Record<string, string>;
  onclick?: string;
  clientHide?: boolean;
}

interface Props {
  items?: NavItem[];
  activeItem?: number;
  class?: string;
  navId?: string;
  navClass?: string;
  urlParam?: string; // URL parameter to check (default: "status")
  currentUser?: any; // Current user object to check role
}

const {
  items = [],
  activeItem = 0,
  class: className = "",
  navId,
  navClass = "",
  urlParam = "status",
  currentUser,
} = Astro.props as Props;

// Filter items based on clientHide parameter
const filteredItems = items.filter((item) => {
  // If clientHide is true and current user is a Client, hide this item
  if (item.clientHide && currentUser?.profile?.role === "Client") {
    return false;
  }
  return true;
});
---

<nav
  id={navId}
  class={`scrollbar-hide mb-0 pb-0 relative flex gap-1 overflow-x-scroll h-11 whitespace-nowrap my-4 ${navClass}`}
  data-active-item={activeItem}
  data-url-param={urlParam}
>
  <!-- Sliding pill background -->
  <div
    id="nav-pill-bg"
    class="z-1 absolute h-11 bg-white shadow-sm transition-all duration-300 ease-out dark:bg-gray-800"
    style="width: 0px; left: 0px;"
  >
  </div>

  {
    filteredItems.map((item: NavItem, index: number) => (
      <Button
        id={item.id}
        variant={(item.variant as any) || "anchor"}
        size="sm"
        icon={item.icon}
        iconPosition="left"
        class="tab-button pill-nav-item relative rounded-full transition-colors duration-200"
        data-index={index}
        data-active={index === activeItem ? "true" : "false"}
        dataAttributes={item.dataAttributes || {}}
        onclick={item.onclick}
      >
        {item.label}
      </Button>
    ))
  }
</nav>

<script>
  // Generic sliding pill navigation - works with any nav that has the right structure
  function initializeSlidingPillNav(navId: string) {
    const nav = document.getElementById(navId);
    if (!nav) return;

    const pillBg = nav.querySelector('[id$="-pill-bg"]') || nav.querySelector("#nav-pill-bg");
    const buttons = nav.querySelectorAll("button[data-index], button[id], a[data-index], a[id]");

    // Update active button data attributes only (styling handled by parent component)
    function updateActiveButton(activeButton: Element | null) {
      if (!nav) return;

      // Remove active state from all buttons (data attributes only)
      nav.querySelectorAll("button, a").forEach((btn) => {
        btn.setAttribute("data-active", "false");
      });

      // Set active state on the selected button (data attribute only)
      if (activeButton) {
        activeButton.setAttribute("data-active", "true");
      }
    }

    // Update sliding pill position
    function updateSlidingPill(activeButton: Element | null) {
      if (!pillBg || !activeButton || !nav) return;

      const navRect = nav.getBoundingClientRect();
      const buttonRect = activeButton.getBoundingClientRect();

      // Calculate position relative to the nav container, accounting for scroll offset
      const left = buttonRect.left - navRect.left + nav.scrollLeft;
      const width = buttonRect.width;

      // Update pill position and size
      (pillBg as HTMLElement).style.left = `${left}px`;
      (pillBg as HTMLElement).style.width = `${width}px`;

      // Always try to center the active item
      setTimeout(() => {
        const buttonRect = activeButton.getBoundingClientRect();
        const navRect = nav.getBoundingClientRect();

        // Calculate button position relative to nav container
        const buttonLeft = buttonRect.left - navRect.left + nav.scrollLeft;

        // Center the button in the nav
        const scrollTo = buttonLeft - nav.clientWidth / 2 + buttonRect.width / 2;

        // Ensure we don't scroll past the bounds
        const maxScroll = nav.scrollWidth - nav.clientWidth;
        const boundedScrollTo = Math.max(0, Math.min(scrollTo, maxScroll));

        nav.scrollTo({
          left: boundedScrollTo,
          behavior: "smooth",
        });
      }, 300);
    }

    // Handle button clicks - only update sliding pill background
    buttons.forEach((button: Element) => {
      button.addEventListener("click", function (this: HTMLElement) {
        updateActiveButton(this);
        updateSlidingPill(this);

        // Simple scroll into view after 300ms delay
      });
    });

    // Function to determine active button from URL
    function getActiveButtonFromURL(): Element | null {
      if (!nav) return null;

      // Get URL parameter name from nav data attribute
      const urlParam = nav.getAttribute("data-url-param") || "status";
      const urlParams = new URLSearchParams(window.location.search);
      const paramValue = urlParams.get(urlParam);

      if (paramValue) {
        // Check if the parameter value is a number (dashboard project status) or string (project tab)
        const isNumeric = /^\d+$/.test(paramValue);

        if (isNumeric) {
          // Handle numeric status values (dashboard project statuses)
          // console.log(
          //   `ðŸŽ¯ [SLIDING-PILL] Numeric status detected: ${paramValue} - this is a project status, not a tab`
          // );
          // For dashboard project statuses, don't try to activate a tab
          // Let the dashboard handle project filtering by numeric status
          return null;
        } else {
          // Handle string status values (project page tabs)
          // console.log(`ðŸŽ¯ [SLIDING-PILL] String status detected: ${paramValue} - switching to tab`);
          // Call switchTab to handle the tab content switching
          window.switchTab(paramValue);
          // Try to find button with ID "{urlParam}-{paramValue}"
          const targetButton = nav.querySelector(`#${urlParam}-${paramValue}`);
          if (targetButton) {
            return targetButton;
          }
        }
      }

      // Always fallback to first button to ensure sliding pill is visible
      const firstButton =
        nav.querySelector("button, a") ||
        nav.querySelector("button:first-of-type, a:first-of-type");
      if (firstButton) {
        // Mark the first button as active
        firstButton.setAttribute("data-active", "true");
        return firstButton;
      }

      return null;
    }

    // Initialize pill position - find button from URL or marked as active
    setTimeout(() => {
      let activeButton = getActiveButtonFromURL();

      // If no active button found, force the first button to be active
      if (!activeButton) {
        const firstButton =
          nav.querySelector("button, a") ||
          nav.querySelector("button:first-of-type, a:first-of-type");
        if (firstButton) {
          firstButton.setAttribute("data-active", "true");
          activeButton = firstButton;
        }
      }

      if (activeButton) {
        updateActiveButton(activeButton);
        updateSlidingPill(activeButton);
      }
    }, 300);

    // Handle window resize to reposition pill
    let resizeTimeout: NodeJS.Timeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const activeButton = nav.querySelector('[data-active="true"]');
        if (activeButton) {
          updateSlidingPill(activeButton);
        }
      }, 100);
    });
  }

  // Initialize function that can be called immediately or on DOMContentLoaded
  function initializeAllNavs() {
    // Initialize any sliding pill navs found on the page
    const slidingNavs = document.querySelectorAll('[class*="sliding-pill-nav"], [id*="nav"]');
    slidingNavs.forEach((nav) => {
      if (nav.id) {
        initializeSlidingPillNav(nav.id);
      }
    });

    // Also initialize common nav IDs
    const commonNavIds = ["project-nav", "tab-nav", "pill-nav", "project-tab-nav"];
    commonNavIds.forEach((navId) => {
      if (document.getElementById(navId)) {
        initializeSlidingPillNav(navId);
      }
    });
  }

  // Initialize immediately if DOM is ready, otherwise wait for DOMContentLoaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeAllNavs);
  } else {
    // DOM is already loaded, initialize immediately
    initializeAllNavs();
  }
</script>

<style>
  .pill-nav-item[data-active="true"],
  .pill-nav-item[data-active="true"]:hover {
    color: black !important;
  }

  .dark .pill-nav-item[data-active="true"],
  .dark .pill-nav-item[data-active="true"]:hover {
    color: white !important;
  }
</style>
