---
// Enable this component to work as both regular component and partial
export const partial = true;
import { getTooltipClasses } from "../../lib/tooltip-styles";

// Tooltip component for standardized tooltip styling throughout the project
export interface Props {
  text?: string;
  position?: "top" | "bottom" | "left" | "right";
  className?: string;
  tooltipClass?: string;
  disabled?: boolean;
  open?: boolean;
  dismissable?: boolean;
  mobileClickable?: boolean;
}

// Check if this is being used as a partial (X-headers present) or regular component
const isPartial =
  Astro.request.headers.has("x-tooltip-text") || Astro.request.headers.has("x-tooltip-position");

// Extract props from either Astro.props or X-headers
const text = Astro.props.text || Astro.request.headers.get("x-tooltip-text") || "";
const position = (Astro.props.position || Astro.request.headers.get("x-tooltip-position") || "top") as "top" | "bottom" | "left" | "right";
const className = Astro.props.className || Astro.request.headers.get("x-tooltip-class-name") || "";
const tooltipClass = Astro.props.tooltipClass || Astro.request.headers.get("x-tooltip-class") || "";
const disabled =
  Astro.props.disabled || Astro.request.headers.get("x-tooltip-disabled") === "true" || false;
const open = Astro.props.open || Astro.request.headers.get("x-tooltip-open") === "true" || false;
const dismissable = Astro.props.dismissable || Astro.request.headers.get("x-tooltip-dismissable") === "true" || false;
const mobileClickable = Astro.props.mobileClickable || Astro.request.headers.get("x-tooltip-mobile-clickable") === "true" || false;

// Get slot content for partial mode
const slotContent = Astro.request.headers.get("x-tooltip-slot-content") || "";

// Use shared tooltip styling logic
const { wrapperClasses, tooltipClasses, arrowClasses } = getTooltipClasses({
  position,
  className,
  tooltipClass,
  disabled,
  open,
  dismissable,
  mobileClickable,
});
---

<span class={wrapperClasses} style="vertical-align: baseline; white-space: nowrap;">
  {isPartial && slotContent ? <Fragment set:html={slotContent} /> : <slot />}
  <span class={tooltipClasses} data-dismissable={dismissable ? "true" : "false"}>
    <span class="cursor-pointer">{text}</span>
    {dismissable && (
      <button
        type="button"
        class="ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full transition-colors hover:bg-white/20"
        aria-label="Close tooltip"
        onclick="this.closest('[data-dismissable=\"true\"]').style.display = 'none'"
      >
        <svg
          class="h-3 w-3"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    )}
    <span class={arrowClasses} style="display: block;"></span>
  </span>
</span>

<script>
  // Mobile clickable tooltip handler
  // This script enables tooltips to be toggled on touch devices when mobileClickable is enabled
  document.addEventListener('DOMContentLoaded', function() {
    const mobileTooltips = document.querySelectorAll('.mobile-clickable-tooltip');
    
    // Only proceed if there are mobile-clickable tooltips on the page
    if (mobileTooltips.length === 0) return;
    
    // Check if device supports touch
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    if (isTouchDevice) {
      mobileTooltips.forEach(wrapper => {
        const tooltipContent = wrapper.querySelector('.tooltip-content');
        if (!tooltipContent) return;
        
        let isTooltipOpen = false;
        
        // Handle tap on the wrapper or its children (except interactive elements)
        wrapper.addEventListener('click', function(e) {
          // Don't intercept clicks on buttons, links, or inputs within the wrapper
          const target = e.target as HTMLElement;
          if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT') {
            return;
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          // Toggle tooltip visibility
          isTooltipOpen = !isTooltipOpen;
          if (isTooltipOpen) {
            tooltipContent.classList.remove('opacity-0');
            tooltipContent.classList.add('opacity-100');
          } else {
            tooltipContent.classList.remove('opacity-100');
            tooltipContent.classList.add('opacity-0');
          }
        });
        
        // Close tooltip when clicking outside
        document.addEventListener('click', function(e) {
          if (isTooltipOpen && !wrapper.contains(e.target as Node)) {
            isTooltipOpen = false;
            tooltipContent.classList.remove('opacity-100');
            tooltipContent.classList.add('opacity-0');
          }
        });
      });
    }
  });
</script>
