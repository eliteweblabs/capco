---
export interface Props {
  id?: string;
  accept?: string; // e.g., ".pdf", "image/*", etc.
  multiple?: boolean;
  maxSize?: number; // in MB
  label?: string;
  description?: string;
  required?: boolean;
  disabled?: boolean;
  class?: string;
}

const {
  id = `dropzone-${Math.random().toString(36).substr(2, 9)}`,
  accept = "*/*",
  multiple = false,
  maxSize,
  label = "Drop files here or click to browse",
  description,
  required = false,
  disabled = false,
  class: className = "",
} = Astro.props;

const inputId = `${id}-input`;
const browseBtnId = `${id}-browse-btn`;
---

<div
  {id}
  class={`dropzone-container ${className} ${disabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer"} rounded-lg border-2 border-dashed border-gray-300 p-6 text-center transition-colors hover:border-primary-400 dark:border-gray-600 dark:hover:border-primary-500`}
>
  <div class="dropzone-content space-y-4">
    <div class="mx-auto h-12 w-12 text-gray-400">
      <svg class="h-full w-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
        ></path>
      </svg>
    </div>
    <div>
      <p class="font-medium text-gray-600 dark:text-gray-300">{label}</p>
      {description && <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">{description}</p>}
      {
        maxSize && (
          <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
            Maximum file size: {maxSize}MB
          </p>
        )
      }
    </div>
    <button
      type="button"
      id={browseBtnId}
      class="bg-primary-50 hover:bg-primary-100 text-primary-700 px-4 py-2 rounded-lg font-semibold text-sm transition-colors dark:bg-primary-900/20 dark:hover:bg-primary-900/40 dark:text-primary-400"
      {disabled}
    >
      Browse Files
    </button>
  </div>
  <input
    type="file"
    id={inputId}
    {accept}
    {multiple}
    {required}
    {disabled}
    class="hidden"
    data-dropzone-id={id}
    data-accept={accept}
    data-multiple={multiple}
    data-max-size={maxSize}
  />
</div>

<style>
  .dropzone-container {
    position: relative;
  }

  .dropzone-container.drag-over {
    border-color: rgb(59 130 246);
    background-color: rgb(239 246 255);
  }

  .dark .dropzone-container.drag-over {
    border-color: rgb(96 165 250);
    background-color: rgb(30 58 138 / 0.2);
  }

  .dropzone-container:has(input:disabled) {
    pointer-events: none;
  }
</style>

<script
  define:vars={{
    dropzoneId: id,
    acceptType: accept,
    allowMultiple: multiple,
    maxFileSize: maxSize,
  }}
>
  /**
   * Initialize a dropzone component
   * @param {Object} config - Configuration object
   * @param {string} config.id - Dropzone ID
   * @param {string} [config.accept] - Accepted file types
   * @param {boolean} [config.multiple=false] - Allow multiple files
   * @param {number} [config.maxSize] - Maximum file size in MB
   * @param {Function} [config.onFileSelect] - Callback for file selection
   * @param {Function} [config.onError] - Callback for errors
   */
  function initializeDropzone({ id, accept, multiple = false, maxSize, onFileSelect, onError }) {
    const dropzone = document.getElementById(id);
    const input = document.getElementById(`${id}-input`);
    const browseBtn = document.getElementById(`${id}-browse-btn`);

    if (!dropzone || !input || !browseBtn) {
      console.error(`Dropzone elements not found for ID: ${id}`);
      return;
    }

    // Browse button click handler
    browseBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!input.disabled) {
        input.click();
      }
    });

    // Dropzone click handler (click anywhere on dropzone to browse)
    dropzone.addEventListener("click", (e) => {
      // Don't trigger if clicking the browse button (it has its own handler)
      if (e.target === browseBtn || browseBtn.contains(e.target)) {
        return;
      }
      if (!input.disabled) {
        input.click();
      }
    });

    // File input change handler
    input.addEventListener("change", (e) => {
      const target = e.target;
      const files = target.files;
      if (files && files.length > 0) {
        // Use setTimeout to ensure Chrome processes the change event correctly
        setTimeout(() => {
          handleFiles(files);
        }, 0);
      }
      // Reset input to allow selecting the same file again
      // Use a longer timeout to ensure Chrome processes the change event first
      setTimeout(() => {
        input.value = "";
      }, 100);
    });

    // Drag and drop handlers
    dropzone.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!input.disabled) {
        dropzone.classList.add("drag-over");
      }
    });

    dropzone.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove("drag-over");
    });

    dropzone.addEventListener("drop", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove("drag-over");

      if (input.disabled) return;

      const files = e.dataTransfer.files;
      handleFiles(files);
    });

    function handleFiles(files) {
      if (!files || files.length === 0) return;

      // Validate file count
      if (!multiple && files.length > 1) {
        const errorMsg = "Please select only one file";
        if (onError) {
          onError(errorMsg);
        } else {
          alert(errorMsg);
        }
        return;
      }

      // Validate file types
      if (accept && accept !== "*/*") {
        const acceptTypes = accept.split(",").map((type) => type.trim());
        const fileArray = Array.from(files);

        for (const file of fileArray) {
          const isValidType = acceptTypes.some((acceptType) => {
            if (acceptType.startsWith(".")) {
              // Extension match
              return file.name.toLowerCase().endsWith(acceptType.toLowerCase());
            } else if (acceptType.includes("/*")) {
              // MIME type wildcard match
              const baseType = acceptType.split("/")[0];
              return file.type.startsWith(baseType + "/");
            } else {
              // Exact MIME type match
              return file.type === acceptType;
            }
          });

          if (!isValidType) {
            const errorMsg = `File "${file.name}" is not an accepted file type. Accepted types: ${accept}`;
            if (onError) {
              onError(errorMsg);
            } else {
              alert(errorMsg);
            }
            return;
          }
        }
      }

      // Validate file sizes
      if (maxSize) {
        const maxSizeBytes = maxSize * 1024 * 1024; // Convert MB to bytes
        const fileArray = Array.from(files);

        for (const file of fileArray) {
          if (file.size > maxSizeBytes) {
            const errorMsg = `File "${file.name}" exceeds maximum size of ${maxSize}MB`;
            if (onError) {
              onError(errorMsg);
            } else {
              alert(errorMsg);
            }
            return;
          }
        }
      }

      // All validations passed, trigger callback
      if (onFileSelect) {
        onFileSelect(files);
      } else {
        // Fallback: dispatch custom event
        // Use setTimeout to ensure Chrome processes the event correctly
        setTimeout(() => {
          const event = new CustomEvent("dropzone-files-selected", {
            detail: { files, dropzoneId: id },
            bubbles: true,
            composed: true,
          });
          dropzone.dispatchEvent(event);
        }, 0);
      }
    }

    // Expose method to get files programmatically
    dropzone.getFiles = () => input.files;
    dropzone.clearFiles = () => {
      input.value = "";
    };
  }

  // Initialize on DOM ready
  if (typeof window !== "undefined") {
    const initialize = () => {
      initializeDropzone({
        id: dropzoneId,
        accept: acceptType,
        multiple: allowMultiple,
        maxSize: maxFileSize,
        onFileSelect: (files) => {
          // Dispatch custom event for file selection
          // Use setTimeout to ensure Chrome processes the event correctly
          setTimeout(() => {
            const dropzone = document.getElementById(dropzoneId);
            if (dropzone) {
              const event = new CustomEvent("dropzone-files-selected", {
                detail: { files, dropzoneId },
                bubbles: true,
                composed: true,
              });
              dropzone.dispatchEvent(event);
            }
          }, 0);
        },
        onError: (error) => {
          // Dispatch custom event for errors
          // Use setTimeout to ensure Chrome processes the event correctly
          setTimeout(() => {
            const dropzone = document.getElementById(dropzoneId);
            if (dropzone) {
              const event = new CustomEvent("dropzone-error", {
                detail: { error, dropzoneId },
                bubbles: true,
                composed: true,
              });
              dropzone.dispatchEvent(event);
            }
          }, 0);
        },
      });
    };

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initialize);
    } else {
      // DOM already loaded
      initialize();
    }
  }
</script>
