---
/**
 * ConfigurableInput â€“ single source for rendering inputs from JSON config.
 * Shared by Forms, Tables, MultiStepForm.
 *
 * Input types:
 *   Generic: input, telephone, googleAddress, textarea, slider, toggle,
 *            stepper, dateTime, buttonGroup, dropdownSelect
 *   Custom:  staffSelect
 */
import type {
  InputOption,
  ResolvedInputFieldConfig,
  InputContext,
} from "../../lib/input-field-config";

import UnitSlider from "../form/UnitSlider.astro";
import SlideToggle from "./SlideToggle.astro";
import NumberStepper from "./NumberStepper.astro";
import Stepper from "./Stepper.astro";
import PhoneAndSMS from "../form/PhoneAndSMS.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import ToggleButton from "../form/ToggleButton.astro";
import StaffSelectTooltip from "../form/StaffSelectTooltip.astro";
import InputLabelWrap from "./InputLabelWrap.astro";

export interface Props {
  config: ResolvedInputFieldConfig;
  context: InputContext;
  value?: string | number | boolean | string[] | null;
  /** For table context: entity id (e.g. project.id) */
  entityId?: string | number;
  /** For form/multistep */
  globalInputClasses?: string;
  /** For staffSelect, googleAddress */
  currentUser?: unknown;
  /** For staffSelect, googleAddress */
  project?: unknown;
  /** For stepper date variant */
  onIncrement?: string;
  onDecrement?: string;
  /** For table: center-align cell */
  compact?: boolean;
  /** Override label visibility */
  showLabel?: boolean;
}

const {
  config,
  context,
  value,
  entityId,
  globalInputClasses = "",
  currentUser,
  project,
  onIncrement,
  onDecrement,
  compact = context === "table",
  showLabel = context !== "table",
} = Astro.props;

const id = config.id;
const name = config.name ?? config.id;
const label = config.label ?? name;
const readOnly = config.readOnly ?? false;
const required = config.required ?? false;
const placeholder = config.placeholder ?? "";

// Resolve value for different config types
const strValue = value != null && value !== "" ? String(value) : "";
const numValue =
  typeof value === "number" ? value : value === "" || value == null ? 0 : Number(value) || 0;
const boolValue = value === true || value === "true" || value === 1 || value === "1";
const options = (config as any).options ?? [];
// For buttonGroup multi-select: value can be string[] or comma-separated
const selectedValues: string[] = Array.isArray(value)
  ? value
  : typeof value === "string" && value.includes(",")
    ? value
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean)
    : strValue
      ? [strValue]
      : [];

// Table refresh/polling: when context=table, entityId + meta/field enable RefreshManager integration
const refreshMeta = config.meta ?? config.field;
const hasTableRefresh = context === "table" && entityId != null && refreshMeta && !readOnly;
const tableRefreshAttrs = hasTableRefresh
  ? {
      "data-refresh": refreshMeta,
      "data-meta": refreshMeta,
      "data-meta-value": strValue || (typeof value === "number" ? String(value) : ""),
      "data-project-id": String(entityId),
    }
  : {};
// onchange for inline save (calls updateProjectField with parsed value)
const tableOnchangeSave = hasTableRefresh
  ? "if(window.updateProjectField){const v=this.type==='number'?Number(this.value):this.value;window.updateProjectField(this,v);}"
  : undefined;
---

{
  config.type === "input" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <input
        type={(config as any).inputType ?? "text"}
        id={id}
        name={name}
        value={strValue}
        placeholder={placeholder}
        required={required}
        readonly={readOnly}
        min={(config as any).min}
        max={(config as any).max}
        step={(config as any).step}
        minlength={(config as any).minlength}
        autocomplete={(config as any).autocomplete ?? "off"}
        class={globalInputClasses}
        {...tableRefreshAttrs}
        {...(tableOnchangeSave && { onchange: tableOnchangeSave })}
      />
    </InputLabelWrap>
  ) : config.type === "telephone" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <PhoneAndSMS
        id={id}
        name={name}
        value={strValue}
        placeholder={placeholder}
        showSMS={(config as any).showSMS ?? true}
        smsChecked={(config as any).smsChecked ?? false}
        selectedCarrier={(config as any).selectedCarrier ?? ""}
        globalInputClasses={globalInputClasses}
      />
    </InputLabelWrap>
  ) : config.type === "googleAddress" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <SlotMachineModal
        id={name}
        icon="map-pin"
        title={label}
        options={[]}
        selectedValue={strValue}
        placeholder={placeholder || "Search for an address..."}
        showCloseButton={true}
        showCancelButton={true}
        buttonText={`${label}${required ? " *" : ""}`}
        buttonClass="w-full mb-4"
        buttonVariant="primary"
        searchText="Search Address"
        searchPlaceholder="Type to search addresses..."
        fetchApiEndpoint={(config as any).fetchApiEndpoint ?? "/api/google/places-autocomplete"}
        apiParams={(config as any).apiParams ?? { types: "address", components: "country:us" }}
        valueField={(config as any).valueField ?? "description"}
        noResultsText="Type to search addresses..."
        currentUser={currentUser}
        project={project}
        currentLocation={(config as any).currentLocation ?? true}
      />
    </InputLabelWrap>
  ) : config.type === "textarea" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <textarea
        id={id}
        name={name}
        rows={(config as any).rows ?? 4}
        placeholder={placeholder}
        required={required}
        readonly={readOnly}
        class={`${globalInputClasses} resize-y`}
        {...tableRefreshAttrs}
        {...(tableOnchangeSave && { onchange: tableOnchangeSave })}
      >
        {strValue}
      </textarea>
    </InputLabelWrap>
  ) : config.type === "slider" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <UnitSlider
        projectId={entityId ?? "default"}
        name={name}
        label={showLabel ? "" : label}
        value={numValue}
        required={required}
        readOnly={readOnly}
        min={(config as any).min}
        max={(config as any).max}
        step={(config as any).step}
      />
    </InputLabelWrap>
  ) : config.type === "toggle" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <SlideToggle
        id={id}
        name={name}
        label={showLabel ? "" : label}
        checked={boolValue}
        icon={(config as any).icon}
        color={(config as any).color ?? "primary"}
        size={(config as any).size ?? "md"}
      />
    </InputLabelWrap>
  ) : config.type === "stepper" ? (
    (config as any).variant === "date" && entityId != null ? (
      <Stepper
        entityId={entityId}
        value={value != null && value !== "" ? String(value) : ""}
        showStepper={!readOnly}
        onIncrement={onIncrement ?? `adjustDueDate(${entityId}, 1)`}
        onDecrement={onDecrement ?? `adjustDueDate(${entityId}, -1)`}
        meta={config.meta ?? config.field ?? "dueDate"}
        refresh={config.meta ?? config.field ?? "dueDate"}
        placeholder={placeholder}
      />
    ) : (
      <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
        <NumberStepper
          id={id}
          name={name}
          value={numValue}
          min={(config as any).min}
          max={(config as any).max}
          step={(config as any).step ?? 1}
          disabled={readOnly}
          class={globalInputClasses}
          dataRefresh={hasTableRefresh ? refreshMeta : undefined}
          dataMetaValue={hasTableRefresh ? numValue : undefined}
          dataProjectId={hasTableRefresh ? entityId : undefined}
          onchangeInline={
            hasTableRefresh
              ? "if(window.updateProjectField)window.updateProjectField(this,Number(this.value));"
              : undefined
          }
        />
      </InputLabelWrap>
    )
  ) : config.type === "dateTime" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <input
        type={(config as any).inputType ?? "date"}
        id={id}
        name={name}
        value={strValue}
        required={required}
        readonly={readOnly}
        class={globalInputClasses}
        {...tableRefreshAttrs}
        {...(tableOnchangeSave && { onchange: tableOnchangeSave })}
      />
    </InputLabelWrap>
  ) : config.type === "buttonGroup" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <div class={`flex flex-wrap gap-2 ${readOnly ? "cursor-not-allowed opacity-75" : ""}`}>
        {(options as InputOption[]).map((opt) => {
          const isSelected =
            selectedValues.includes(opt.value) ||
            (typeof opt === "object" && (opt as any).selected === true);
          return (
            <ToggleButton
              value={opt.value}
              group={name}
              type={(config as any).groupType === "multi-select" ? "multi-select" : "radio"}
              class={`${(config as any).cssClass ?? ""} ${isSelected ? "toggle-button selected" : "toggle-button"} ${
                readOnly ? "pointer-events-none" : ""
              }`.trim()}
            >
              {opt.label}
            </ToggleButton>
          );
        })}
      </div>
    </InputLabelWrap>
  ) : config.type === "dropdownSelect" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <div>
        {(config as any).searchable ? (
          <SlotMachineModal
            id={id}
            title={label}
            options={options}
            selectedValue={strValue}
            placeholder={placeholder || "Select..."}
            showCloseButton={true}
            showCancelButton={true}
            name={name}
            noResultsText="No results found"
            searchText="Search"
            searchPlaceholder="Type to search..."
          />
        ) : (
          <select
            id={id}
            name={name}
            required={required}
            disabled={readOnly}
            class={globalInputClasses}
            {...tableRefreshAttrs}
            {...(tableOnchangeSave && { onchange: tableOnchangeSave })}
          >
            {placeholder ? <option value="">{placeholder}</option> : null}
            {(options as InputOption[]).map((opt) => (
              <option value={opt.value} selected={opt.value === strValue} disabled={opt.disabled}>
                {opt.label}
              </option>
            ))}
          </select>
        )}
      </div>
    </InputLabelWrap>
  ) : config.type === "staffSelect" ? (
    <InputLabelWrap id={id} label={label} required={required} show={showLabel} compact={compact}>
      <StaffSelectTooltip
        id={id}
        title={(config as any).title ?? label}
        options={options}
        selectedValue={strValue}
        placeholder={placeholder || "Select staff..."}
        name={name}
        fetchApiEndpoint={(config as any).fetchApiEndpoint}
        saveApiEndpoint={(config as any).saveApiEndpoint}
        project={project}
        currentUser={currentUser}
        icon={(config as any).icon ?? "user"}
        updateCallback={(config as any).updateCallback}
      />
    </InputLabelWrap>
  ) : (
    <p class="text-amber-600 dark:text-amber-400">Unknown input type: {config.type}</p>
  )
}
