---
/**
 * My Check-In Indicator (Admin/Staff)
 * Navbar icon shown when user is checked in. Dropdown: live duration, notes textarea, Stop button.
 * Synced with CheckInButton via sessionStorage + custom event.
 */
import SimpleIcon from "./SimpleIcon.astro";

interface Props {
  currentUser?: any;
  globalIconButtonClasses?: string;
}

const { currentUser, globalIconButtonClasses = "w-10 h-10 inline-flex items-center rounded-full justify-center p-2 text-black dark:text-white md:hover:bg-gray-100 dark:hover:bg-gray-700 dark:focus:ring-gray-700 focus:outline-none" } = Astro.props;

const currentRole = currentUser?.profile?.role;
if (currentRole !== "Admin" && currentRole !== "Staff") {
  return null;
}
---

<div
  id="my-checkin-indicator"
  class="hidden"
  aria-label="You are checked in"
>
  <button
    type="button"
    id="my-checkin-trigger"
    title="You are checked in – click to stop"
    data-popover-toggle="my-checkin-dropdown"
    data-popover-trigger="click"
    data-popover-target="my-checkin-dropdown"
    class={`relative ${globalIconButtonClasses}`}
    aria-label="Check-in active – open menu to stop"
  >
    <span class="flex h-8 w-8 items-center justify-center rounded-full bg-emerald-100 dark:bg-emerald-900/50 text-emerald-600 dark:text-emerald-400 animate-pulse" title="Checked in">
      <SimpleIcon name="stopwatch" size="md" />
    </span>
  </button>

  <div
    id="my-checkin-dropdown"
    data-popover
    role="tooltip"
    class="invisible fixed z-[1250] inline-block w-72 overflow-hidden rounded-lg border border-gray-200 bg-white opacity-0 shadow-lg transition-opacity duration-200 dark:border-gray-700 dark:bg-gray-800"
  >
    <div class="p-4">
      <div class="mb-2 flex items-center justify-between">
        <span class="text-sm font-medium text-gray-900 dark:text-white">Timer active</span>
        <span id="my-checkin-duration" class="text-sm font-mono text-gray-600 dark:text-gray-400">0m</span>
      </div>
      <div id="my-checkin-project" class="mb-3 text-xs text-gray-500 dark:text-gray-400"></div>
      <label for="my-checkin-notes-input" class="mb-1 block text-xs font-medium text-gray-700 dark:text-gray-300">Notes (optional)</label>
      <textarea
        id="my-checkin-notes-input"
        rows="2"
        class="mb-4 w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm dark:border-gray-600 dark:bg-gray-900 dark:text-white"
        placeholder="Add notes before stopping…"
      ></textarea>
      <button
        type="button"
        id="my-checkin-stop-btn"
        class="flex w-full items-center justify-center gap-2 rounded-md bg-red-600 px-3 py-2 text-sm font-medium text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800"
      >
        <SimpleIcon name="log-out" size="sm" />
        Stop timer
      </button>
    </div>
  </div>
</div>

<script>
  (function () {
    const STORAGE_KEY = "location-checkin-state";
    const TIME_ENTRY_KEY = "location-checkin-time-entry-id";
    const POLL_MS = 15000;

    const container = document.getElementById("my-checkin-indicator");
    const durationEl = document.getElementById("my-checkin-duration");
    const projectEl = document.getElementById("my-checkin-project");
    const notesInput = document.getElementById("my-checkin-notes-input") as HTMLTextAreaElement | null;
    const stopBtn = document.getElementById("my-checkin-stop-btn");

    let entry: { id: number; startedAt: string; projectId?: number | null; projectTitle?: string | null; notes?: string | null } | null = null;
    let tickInterval: ReturnType<typeof setInterval> | null = null;
    let pingInterval: ReturnType<typeof setInterval> | null = null;

    function formatDuration(ms: number): string {
      const mins = Math.floor(ms / 60000);
      if (mins < 60) return mins + "m";
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      return m ? h + "h " + m + "m" : h + "h";
    }

    function tick() {
      if (!entry || !durationEl) return;
      const ms = Date.now() - new Date(entry.startedAt).getTime();
      durationEl.textContent = formatDuration(ms);
    }

    function getPosition(): Promise<{ lat: number; lng: number; accuracy?: number }> {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error("Geolocation not supported"));
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude, accuracy: pos.coords.accuracy }),
          reject,
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
        );
      });
    }

    function startPingInterval() {
      if (!entry) return;
      const sendPing = () => {
        getPosition()
          .then((pos) =>
            fetch("/api/location/ping", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              credentials: "include",
              body: JSON.stringify({
                timeEntryId: entry!.id,
                projectId: entry!.projectId ?? null,
                lat: pos.lat,
                lng: pos.lng,
                accuracy: pos.accuracy,
              }),
            })
          )
          .catch(() => {});
      };
      sendPing();
      pingInterval = setInterval(sendPing, 60 * 1000);
    }

    function stopPingInterval() {
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
    }

    function show(e: { id: number; startedAt: string; projectId?: number | null; projectTitle?: string | null; notes?: string | null }) {
      entry = e;
      if (container) container.classList.remove("hidden");
      if (projectEl) projectEl.textContent = e.projectTitle || "General / No project";
      if (notesInput) notesInput.value = e.notes || "";
      tick();
      tickInterval = setInterval(tick, 1000);
      startPingInterval();
    }

    function hide() {
      entry = null;
      stopPingInterval();
      if (container) container.classList.add("hidden");
      if (durationEl) durationEl.textContent = "0m";
      if (projectEl) projectEl.textContent = "";
      if (notesInput) notesInput.value = "";
      if (tickInterval) {
        clearInterval(tickInterval);
        tickInterval = null;
      }
      try {
        sessionStorage.removeItem(STORAGE_KEY);
        sessionStorage.removeItem(TIME_ENTRY_KEY);
      } catch (_) {}
      window.dispatchEvent(new CustomEvent("checkInStopped"));
    }

    async function fetchActive() {
      try {
        const res = await fetch("/api/time-entries/active", { credentials: "include" });
        const data = await res.json();
        return data.entry;
      } catch {
        return null;
      }
    }

    async function load() {
      const active = await fetchActive();
      if (active) {
        if (!entry || entry.id !== active.id) show(active);
      } else {
        hide();
      }
    }

    async function handleStop() {
      if (!entry || !stopBtn) return;
      stopBtn.disabled = true;
      const notes = notesInput?.value?.trim() || null;
      try {
        const body: Record<string, unknown> = { endedAt: new Date().toISOString() };
        if (notes) body.notes = notes;
        const res = await fetch("/api/time-entries/" + entry.id, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(body),
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "Failed to stop");
        hide();
        if (typeof (window as any).showNotice === "function") {
          (window as any).showNotice("success", "Timer stopped", "Time entry saved.", 2000);
        }
      } catch (err) {
        if (typeof (window as any).showNotice === "function") {
          (window as any).showNotice("error", "Error", (err as Error).message || "Failed to stop timer", 4000);
        }
      } finally {
        if (stopBtn) stopBtn.disabled = false;
      }
    }

    function init() {
      if (!container || !stopBtn) return;
      load();
      setInterval(load, POLL_MS);
      stopBtn.addEventListener("click", handleStop);

      window.addEventListener("checkInStarted", () => load());
    }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
    else init();
  })();
</script>
