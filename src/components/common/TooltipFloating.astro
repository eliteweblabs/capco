---
// Tooltip component using Floating UI for automatic viewport-aware positioning
export const partial = true;

export interface Props {
  text?: string;
  position?: "top" | "bottom" | "left" | "right";
  className?: string;
  tooltipClass?: string;
  disabled?: boolean;
  open?: boolean;
  dismissable?: boolean;
  mobileClickable?: boolean;
  /** When false, tooltip is disabled on no-hover devices (e.g. touch-only). Default true. */
  touchable?: boolean;
  html?: boolean; // Whether to render text as HTML
}

const {
  text = "",
  position = "top",
  className = "",
  tooltipClass = "",
  disabled = false,
  open = false,
  dismissable = false,
  mobileClickable = false,
  touchable = true,
  html = false,
} = Astro.props;

const wrapperClasses =
  `tooltip-wrapper relative inline-flex items-center justify-center ${mobileClickable ? "mobile-clickable" : ""} ${className}`.trim();
// Flowbite-aligned: absolute z-10, rounded-base (rounded-lg), shadow-xs, transition-opacity duration-300
const contentClasses = [
  "tooltip-content tooltip absolute z-10 inline-block",
  "px-3 py-2 text-sm font-medium text-white dark:text-gray-900 bg-gray-900 dark:bg-gray-100 rounded-lg shadow-lg",
  dismissable ? "opacity-100" : open ? "opacity-100" : "opacity-0",
  dismissable ? "pointer-events-auto" : "pointer-events-none",
  "whitespace-nowrap transition-opacity duration-300",
  tooltipClass,
  disabled ? "hidden" : "",
]
  .filter(Boolean)
  .join(" ");
---

<span class={wrapperClasses} data-tooltip-position={position} data-tooltip-touchable={touchable}>
  <slot />
  <span class={contentClasses} data-dismissable={dismissable ? "true" : "false"} role="tooltip">
    {html ? <span set:html={text} /> : text}
    {
      dismissable && (
        <button
          type="button"
          class="ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full transition-colors hover:bg-white/20 tooltip-close-btn"
          aria-label="Close tooltip"
        >
          <svg
            class="h-3 w-3"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      )
    }
    <span class="tooltip-arrow" data-popper-arrow></span>
  </span>
</span>

<style>
  .tooltip-wrapper {
    background: none;
    line-height: 0; /* size to icon only; no strut/line-height extra height */
  }
  .tooltip-arrow,
  .tooltip-arrow::before {
    position: absolute;
    border: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
    background: inherit !important;
    width: 8px !important;
    height: 8px !important;
  }

  .tooltip-arrow {
    visibility: hidden;
  }

  .tooltip-arrow::before {
    transform: rotate(45deg);
    visibility: visible;
    content: "";
  }

  /* Static arrow position per placement is set in JS (Floating UI arrow middleware + static axis) */
</style>

<script>
  import { computePosition, flip, shift, offset, arrow } from "@floating-ui/dom";

  const initialized = new WeakSet();

  function initTooltips() {
    const wrappers = document.querySelectorAll(".tooltip-wrapper");

    wrappers.forEach((wrapper) => {
      if (initialized.has(wrapper)) return;
      initialized.add(wrapper);

      const trigger = wrapper.firstElementChild as HTMLElement;
      const tooltip = wrapper.querySelector(".tooltip-content") as HTMLElement;
      const arrowElement = tooltip?.querySelector(".tooltip-arrow") as HTMLElement;

      if (!trigger || !tooltip) return;

      const preferredPosition = (wrapper.getAttribute("data-tooltip-position") || "top") as any;
      const isMobileClickable = wrapper.classList.contains("mobile-clickable");
      const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
      const noHover = window.matchMedia("(hover: none)").matches;
      const touchable = wrapper.getAttribute("data-tooltip-touchable") !== "false";

      // On no-hover devices, skip tooltip behavior when touchable is false
      if (noHover && !touchable) return;

      // Update position using Floating UI
      async function updatePosition() {
        if (!tooltip.classList.contains("opacity-100")) return;

        const middleware = [
          offset(8),
          flip({ fallbackAxisSideDirection: "start" }),
          shift({ padding: 8 }),
        ];

        if (arrowElement) {
          middleware.push(arrow({ element: arrowElement }));
        }

        const { x, y, placement, middlewareData } = await computePosition(trigger, tooltip, {
          placement: preferredPosition,
          middleware,
        });

        Object.assign(tooltip.style, { left: `${x}px`, top: `${y}px` });
        tooltip.setAttribute("data-popper-placement", placement);

        // Position arrow (Floating UI sets only one axis per placement; set static axis and clear others per Flowbite/Popper)
        if (arrowElement && middlewareData.arrow) {
          const { x: arrowX, y: arrowY } = middlewareData.arrow;
          const placementSide = placement.split("-")[0];
          const staticSide = { top: "bottom", bottom: "top", left: "right", right: "left" }[
            placementSide
          ];
          const staticValue = "-4px";
          const arrowStyle: Record<string, string> = {
            left: "",
            top: "",
            right: "",
            bottom: "",
          };
          if (arrowX != null) arrowStyle.left = `${arrowX}px`;
          else if (staticSide === "left") arrowStyle.left = staticValue;
          if (arrowY != null) arrowStyle.top = `${arrowY}px`;
          else if (staticSide === "top") arrowStyle.top = staticValue;
          if (staticSide === "right") arrowStyle.right = staticValue;
          if (staticSide === "bottom") arrowStyle.bottom = staticValue;
          Object.assign(arrowElement.style, arrowStyle);
        }
      }

      // Show/hide helpers
      const show = () => {
        tooltip.classList.remove("opacity-0");
        tooltip.classList.add("opacity-100");
        tooltip.style.pointerEvents = "auto";
        updatePosition();
      };

      const hide = () => {
        tooltip.classList.remove("opacity-100");
        tooltip.classList.add("opacity-0");
        tooltip.style.pointerEvents = "none";
      };

      // Event handlers
      if (isTouchDevice && isMobileClickable) {
        // Mobile: click to toggle
        const handleClick = (e: Event) => {
          e.stopPropagation();
          const isVisible = tooltip.classList.contains("opacity-100");

          // Close all other tooltips
          document.querySelectorAll(".tooltip-content.opacity-100").forEach((other) => {
            if (other !== tooltip) {
              other.classList.remove("opacity-100");
              other.classList.add("opacity-0");
            }
          });

          isVisible ? hide() : show();
        };

        const handleOutsideClick = (e: Event) => {
          if (!wrapper.contains(e.target as Node) && tooltip.classList.contains("opacity-100")) {
            hide();
          }
        };

        wrapper.addEventListener("click", handleClick);
        document.addEventListener("click", handleOutsideClick);
      } else {
        // Desktop: hover
        wrapper.addEventListener("mouseenter", show);
        wrapper.addEventListener("mouseleave", hide);
        wrapper.addEventListener("focus", show, true);
        wrapper.addEventListener("blur", hide, true);
      }

      // Update on scroll/resize
      window.addEventListener("scroll", updatePosition, { passive: true });
      window.addEventListener("resize", updatePosition, { passive: true });

      // Close button
      const closeBtn = tooltip.querySelector(".tooltip-close-btn");
      closeBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        hide();
      });
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initTooltips);
  } else {
    initTooltips();
  }
</script>
