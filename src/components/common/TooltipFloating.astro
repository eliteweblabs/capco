---
// Tooltip component using Floating UI for automatic viewport-aware positioning
export const partial = true;

export interface Props {
  text?: string;
  position?: "top" | "bottom" | "left" | "right";
  className?: string;
  tooltipClass?: string;
  disabled?: boolean;
  open?: boolean;
  dismissable?: boolean;
  mobileClickable?: boolean;
  /** When false, tooltip is disabled on no-hover devices (e.g. touch-only). Default true. */
  touchable?: boolean;
  /** When true, hide tooltip popup on screens &lt; 768px (reliable mobile hide vs hover media). Default false. */
  hideOnMobile?: boolean;
  html?: boolean; // Whether to render text as HTML
  /** When false, use flex instead of inline-flex (avoids nav/flex layout issues). Default true for backwards compat. */
  inline?: boolean;
}

const {
  text = "",
  position = "top",
  className = "",
  tooltipClass = "",
  disabled = false,
  open = false,
  dismissable = false,
  mobileClickable = false,
  touchable = true,
  hideOnMobile = false,
  html = false,
  inline = true,
} = Astro.props;

const wrapperClasses =
  `tooltip-wrapper relative ${inline ? "inline-flex" : "flex"} items-center ${mobileClickable ? "mobile-clickable" : ""} ${className}`.trim();
// Flowbite-aligned: absolute z-10, rounded-base (rounded-lg), shadow-xs, transition-opacity duration-300
const contentClasses = [
  "tooltip-content tooltip absolute z-10 inline-block",
  "px-3 py-2 text-sm font-medium text-white dark:text-gray-900 bg-gray-900 dark:bg-gray-100 rounded-lg shadow-lg",
  dismissable ? "opacity-100" : open ? "opacity-100" : "opacity-0",
  dismissable ? "pointer-events-auto" : "pointer-events-none",
  "whitespace-nowrap transition-opacity duration-300",
  hideOnMobile ? "max-md:!hidden" : "",
  tooltipClass,
  disabled ? "hidden" : "",
]
  .filter(Boolean)
  .join(" ");
---

<span class={wrapperClasses} data-tooltip-position={position} data-tooltip-touchable={touchable}>
  <slot />
  <span class={contentClasses} data-dismissable={dismissable ? "true" : "false"} role="tooltip">
    {html ? <span set:html={text} /> : text}
    {
      dismissable && (
        <button
          type="button"
          class="tooltip-close-btn ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full transition-colors hover:bg-white/20"
          aria-label="Close tooltip"
        >
          <svg
            class="h-3 w-3"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      )
    }
    <span class="tooltip-arrow" data-popper-arrow></span>
  </span>
</span>

<style>
  .tooltip-wrapper {
    background: none;
    line-height: 0; /* size to icon only; no strut/line-height extra height */
  }
  .tooltip-arrow,
  .tooltip-arrow::before {
    position: absolute;
    border: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
    background: inherit !important;
    width: 8px !important;
    height: 8px !important;
  }

  .tooltip-arrow {
    visibility: hidden;
  }

  .tooltip-arrow::before {
    transform: rotate(45deg);
    visibility: visible;
    content: "";
  }

  /* Prevent tooltips from causing horizontal overflow on mobile (Safari overscroll) */
  .tooltip-content {
    max-width: 22rem; /* fallback for older Safari that donâ€™t support min() */
    max-width: min(22rem, calc(100vw - 1rem));
  }
  @media (max-width: 480px) {
    .tooltip-content {
      max-width: calc(100vw - 1rem);
      white-space: normal;
    }
  }

  /* ============================================
   DISABLE TOOLTIPS ON TOUCH DEVICES
   ============================================ */

  /* Disable hover tooltips on devices that support touch (mobile/tablets) */
  /* BUT allow tooltips with open=true (opacity-100 class) to still show */
  @media (hover: none) and (pointer: coarse) {
    .group:hover .group-hover\:opacity-100 {
      opacity: 0 !important;
    }

    /* Hide tooltip content ONLY if it relies on hover (opacity-0 base state) */
    .tooltip-content.opacity-0 {
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* Tooltips with open=true (opacity-100) will still display */
    .tooltip-content.opacity-100 {
      visibility: visible !important;
      pointer-events: auto !important;
    }
  }

  /* Alternative: Only enable tooltips on devices with hover capability */
  @media (hover: hover) and (pointer: fine) {
    .tooltip-hover-only {
      display: block;
    }
  }

  /* Static arrow position per placement is set in JS (Floating UI arrow middleware + static axis) */
</style>

<script>
  import { computePosition, flip, shift, offset, arrow } from "@floating-ui/dom";
  import type { Placement } from "@floating-ui/dom";

  const initialized = new WeakSet();

  function initTooltips() {
    const wrappers = document.querySelectorAll(".tooltip-wrapper");

    wrappers.forEach((wrapper) => {
      if (initialized.has(wrapper)) return;
      initialized.add(wrapper);

      const trigger = wrapper.firstElementChild;
      const tooltip = wrapper.querySelector(".tooltip-content");
      const arrowElement = tooltip?.querySelector(".tooltip-arrow");

      if (!trigger || !tooltip) return;

      const preferredPosition = wrapper.getAttribute("data-tooltip-position") || "top";
      const isMobileClickable = wrapper.classList.contains("mobile-clickable");
      const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
      const noHover = window.matchMedia("(hover: none)").matches;
      const touchable = wrapper.getAttribute("data-tooltip-touchable") !== "false";

      // On no-hover devices, skip tooltip behavior when touchable is false
      if (noHover && !touchable) return;

      // Update position using Floating UI
      async function updatePosition() {
        if (!tooltip.classList.contains("opacity-100")) return;

        const middleware = [
          offset(8),
          flip({ fallbackAxisSideDirection: "start" }),
          shift({ padding: 8 }),
        ];

        if (arrowElement) {
          middleware.push(arrow({ element: arrowElement }));
        }

        const { x, y, placement, middlewareData } = await computePosition(trigger as HTMLElement, tooltip as HTMLElement, {
          placement: preferredPosition as Placement,
          middleware,
        });

        Object.assign((tooltip as HTMLElement).style, { left: `${x}px`, top: `${y}px` });
        (tooltip as HTMLElement).setAttribute("data-popper-placement", placement);

        // Position arrow (Floating UI sets only one axis per placement; set static axis and clear others per Flowbite/Popper)
        if (arrowElement && middlewareData.arrow) {
          const { x: arrowX, y: arrowY } = middlewareData.arrow;
          const placementSide = placement.split("-")[0];
          const staticSide = { top: "bottom", bottom: "top", left: "right", right: "left" }[
            placementSide
          ];
          const staticValue = "-4px";
          const arrowStyle: Record<string, string> = {
            left: "",
            top: "",
            right: "",
            bottom: "",
          };
          if (arrowX != null) arrowStyle.left = `${arrowX}px`;
          else if (staticSide === "left") arrowStyle.left = staticValue;
          if (arrowY != null) arrowStyle.top = `${arrowY}px`;
          else if (staticSide === "top") arrowStyle.top = staticValue;
          if (staticSide === "right") arrowStyle.right = staticValue;
          if (staticSide === "bottom") arrowStyle.bottom = staticValue;
          Object.assign((arrowElement as HTMLElement).style, arrowStyle);
        }
      }

      // Show/hide helpers
      const show = () => {
        tooltip.classList.remove("opacity-0");
        tooltip.classList.add("opacity-100");
        (tooltip as HTMLElement).style.pointerEvents = "auto";
        updatePosition();
      };

      const hide = () => {
        tooltip.classList.remove("opacity-100");
        tooltip.classList.add("opacity-0");
        (tooltip as HTMLElement).style.pointerEvents = "none";
      };

      // Event handlers
      if (isTouchDevice && isMobileClickable) {
        // Mobile: click to toggle
        const handleClick = (e: Event) => {
          e.stopPropagation();
          const isVisible = (tooltip as HTMLElement).classList.contains("opacity-100");

          // Close all other tooltips
          document.querySelectorAll(".tooltip-content.opacity-100").forEach((other) => {
            if (other !== (tooltip as HTMLElement)) {
              other.classList.remove("opacity-100");
              other.classList.add("opacity-0");
            }
          });

          isVisible ? hide() : show();
        };

        const handleOutsideClick = (e: Event) => {
          if (!wrapper.contains((e.target as Node)) && (tooltip as HTMLElement).classList.contains("opacity-100")) {
            hide();
          }
        };

        wrapper.addEventListener("click", handleClick);
        document.addEventListener("click", handleOutsideClick);
      } else {
        // Desktop: hover
        wrapper.addEventListener("mouseenter", show);
        wrapper.addEventListener("mouseleave", hide);
        wrapper.addEventListener("focus", show, true);
        wrapper.addEventListener("blur", hide, true);
      }

      // Update on scroll/resize
      window.addEventListener("scroll", updatePosition, { passive: true });
      window.addEventListener("resize", updatePosition, { passive: true });

      // Close button
      const closeBtn = (tooltip as HTMLElement).querySelector(".tooltip-close-btn");
      closeBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        hide();
      });
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initTooltips);
  } else {
    initTooltips();
  }
</script>
