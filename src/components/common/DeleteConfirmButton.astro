---
/**
 * DeleteConfirmButton Component
 * Reusable delete button with 2-step confirmation (no alerts)
 * Uses Button.astro and SimpleIcon for consistency
 *
 * Usage:
 * <DeleteConfirmButton
 *   id="delete-item-123"
 * />
 *
 * Behavior:
 * 1. First click: Shows timer icon for 3 seconds
 * 2. Second click within 3 seconds: Executes delete
 * 3. Auto-reverts to trash icon if not confirmed
 */

import Button from "./Button.astro";

export interface Props {
  id: string;
  class?: string;
  timeout?: number; // milliseconds, default 3000
  size?: "xs" | "sm" | "md" | "lg" | "xl"; // default "sm"
  variant?: "icon" | "button"; // default "icon"
  label?: string; // for button variant
  dataAttributes?: Record<string, string>; // custom data attributes
  itemType?: string; // type of item being deleted (for logging/analytics)
  apiEndpoint?: string; // API endpoint for deletion (for future use)
  deleteMethod?: "POST" | "DELETE"; // HTTP method for API call (default POST)
  deleteQueryParam?: string; // e.g. "slug" -> use button dataset and call DELETE with ?slug=...
  onDeleteCallback?: string; // callback function name (for future use)
  tooltipText?: string; // custom tooltip text
  confirmTitle?: string; // custom confirmation title (for future use)
  confirmMessage?: string; // custom confirmation message (for future use)
}

const {
  id,
  class: className = "",
  timeout = 3000,
  size = "sm",
  variant = "icon",
  label = "Delete",
  dataAttributes = {},
  itemType,
  apiEndpoint,
  deleteMethod = "POST",
  deleteQueryParam,
  onDeleteCallback,
  tooltipText = "Delete",
  confirmTitle,
  confirmMessage,
} = Astro.props;

// Build button variant based on whether it's icon-only or with label
const buttonVariant = "ghost";

// Timer ring SVG size (matches Button icon sizes: xs=24, sm=32, md=40, lg=48, xl=56)
const timerRingSizeMap = { xs: 24, sm: 32, md: 40, lg: 48, xl: 56 } as const;
const timerRingSize = timerRingSizeMap[size] ?? 32;

// Merge custom data attributes with internal ones
const mergedDataAttributes = {
  "data-state": "trash",
  "data-timeout": timeout.toString(),
  ...(itemType && { "data-item-type": itemType }),
  ...(apiEndpoint && { "data-api-endpoint": apiEndpoint }),
  ...(deleteMethod && { "data-delete-method": deleteMethod }),
  ...(deleteQueryParam && { "data-delete-query-param": deleteQueryParam }),
  ...(onDeleteCallback && { "data-callback": onDeleteCallback }),
  ...dataAttributes,
};
---

{
  variant === "icon" ? (
    <div class="delete-confirm-wrapper">
      <Button
        id={id}
        type="button"
        variant={buttonVariant}
        size={size}
        icon="trash"
        iconOnly
        iconClasses="delete-confirm-icon text-red-500 dark:text-red-500"
        class={`delete-confirm-btn ${className}`}
        title={tooltipText}
        dataAttributes={mergedDataAttributes}
      >
        <svg
          width={timerRingSize}
          height={timerRingSize}
          viewBox="0 0 44 44"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          class="timer-ring-overlay absolute left-0 top-0"
        >
          <circle
            cx="22"
            cy="22"
            r="18"
            fill="none"
            stroke="#ef4444"
            stroke-width="3"
            stroke-dasharray="113.1"
            stroke-dashoffset="113.1"
            transform="rotate(-90 22 22)"
            class="timer-icon-test"
          />
        </svg>
      </Button>
    </div>
  ) : (
    <Button
      id={id}
      type="button"
      variant={buttonVariant}
      size={size}
      icon="trash"
      class={`delete-confirm-btn ${className}`}
      title={tooltipText}
      dataAttributes={mergedDataAttributes}
    >
      {label}
    </Button>
  )
}

<style is:global>
  @keyframes draw-ring {
    from {
      stroke-dashoffset: 113.1;
    }
    to {
      stroke-dashoffset: 0;
    }
  }
</style>

<style>
  .delete-confirm-wrapper {
    display: inline-flex;
    position: relative;
  }

  .timer-ring-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .delete-confirm-wrapper:has([data-state="confirm"]) .timer-ring-overlay {
    opacity: 1 !important;
  }

  .delete-confirm-wrapper:has([data-state="confirm"]) .timer-icon-test {
    animation: draw-ring 3000ms linear forwards;
  }

  /* Hide trash icon when in confirm state */
  .delete-confirm-wrapper [data-state="confirm"] .delete-confirm-icon {
    display: none;
  }

  .delete-confirm-btn {
    position: relative;
    cursor: pointer;
    user-select: none;
  }

  .delete-confirm-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>

<script>
  /**
   * Initialize delete confirm buttons
   * Completely self-contained - handles API calls and callbacks
   * Uses a single document-level click listener (bound once) to avoid stacking on SPA navigation.
   */
  const DELETE_CONFIRM_BOUND_KEY = "__deleteConfirmClickBound";
  const ACTIVE_TIMEOUTS_KEY = "__deleteConfirmActiveTimeouts";

  function initDeleteConfirmButtons() {
    // Clear any timeouts from the previous page on SPA navigation so we don't run logic on detached nodes
    const activeTimeouts = (window as any)[ACTIVE_TIMEOUTS_KEY] as Map<string, number> | undefined;
    if (activeTimeouts) {
      activeTimeouts.forEach((id) => clearTimeout(id));
      activeTimeouts.clear();
    }

    // Bind document click listener only once so SPA navigations don't stack listeners
    if (!(window as any)[DELETE_CONFIRM_BOUND_KEY]) {
      (window as any)[DELETE_CONFIRM_BOUND_KEY] = true;
      (window as any)[ACTIVE_TIMEOUTS_KEY] = new Map<string, number>();
      document.addEventListener("click", async (e) => {
        const button = (e.target as HTMLElement).closest(".delete-confirm-btn") as HTMLElement;
        if (!button) return;
        await handleDeleteButtonClick(e, button, (window as any)[ACTIVE_TIMEOUTS_KEY]);
      });
    }
  }

  async function handleDeleteButtonClick(
    e: MouseEvent,
    button: HTMLElement,
    activeTimeouts: Map<string, number>
  ) {
    const buttonId = button.id;
    const timeout = parseInt(button.dataset.timeout || "3000", 10);
    const currentState = button.getAttribute("data-state") || "trash";
    const apiEndpoint = button.dataset.apiEndpoint;
    const callbackName = button.dataset.callback;
    const itemType = button.dataset.itemType;

    if (currentState === "trash") {
      // First click: Show timer ring
      e.stopPropagation();
      const wrapper = button.closest(".delete-confirm-wrapper") as HTMLElement;
      const timerRing = wrapper?.querySelector(".timer-ring-overlay") as HTMLElement;
      const timerCircle = timerRing?.querySelector(".timer-icon-test") as SVGCircleElement;

      if (timerCircle) {
        timerCircle.classList.remove("timer-icon-test");
        void (timerCircle as unknown as HTMLElement).offsetWidth; // Force reflow
        timerCircle.classList.add("timer-icon-test");
      }

      button.setAttribute("data-state", "confirm");
      button.title = "Click again to confirm deletion";

      const iconElement = button.querySelector(".delete-confirm-icon") as SVGElement;
      if (iconElement) {
        iconElement.outerHTML = `<svg class="inline-block stopwatch-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="13" r="8"/>
          <path d="M12 9v4l2 2"/>
          <path d="M10 2h4"/>
        </svg>`;
      }

      if (activeTimeouts.has(buttonId)) {
        clearTimeout(activeTimeouts.get(buttonId)!);
      }

      const timeoutId = window.setTimeout(() => {
        if (button.getAttribute("data-state") === "confirm" && button.isConnected) {
          resetButton(button);
          activeTimeouts.delete(buttonId);
        }
      }, timeout);

      activeTimeouts.set(buttonId, timeoutId);
    } else if (currentState === "confirm") {
      // Second click: Execute deletion
      e.stopPropagation();
      if (activeTimeouts.has(buttonId)) {
        clearTimeout(activeTimeouts.get(buttonId)!);
        activeTimeouts.delete(buttonId);
      }

      resetButton(button);
      button.setAttribute("disabled", "true");

      const deleteMethod = (button.dataset.deleteMethod as "POST" | "DELETE") || "POST";
      const deleteQueryParam = button.dataset.deleteQueryParam;
      const itemId = extractItemId(buttonId, itemType);

      const needsItemId = !(deleteMethod === "DELETE" && deleteQueryParam);
      if (needsItemId && !itemId) {
        console.error("[DeleteConfirmButton] Could not extract item ID from:", buttonId);
        button.removeAttribute("disabled");
        if ((window as any).showNotice) {
          (window as any).showNotice("error", "Delete Failed", "Invalid item ID");
        }
        return;
      }

      if (apiEndpoint) {
        try {
          let url = apiEndpoint;
          const fetchOpts: RequestInit = { credentials: "include" };

          if (deleteMethod === "DELETE" && deleteQueryParam) {
            const paramValue = button.dataset[deleteQueryParam];
            if (paramValue == null || paramValue === "") {
              console.error(
                "[DeleteConfirmButton] DELETE with query param but missing data-" + deleteQueryParam
              );
              button.removeAttribute("disabled");
              if ((window as any).showNotice) {
                (window as any).showNotice("error", "Delete Failed", "Missing " + deleteQueryParam);
              }
              return;
            }
            url = `${apiEndpoint}?${encodeURIComponent(deleteQueryParam)}=${encodeURIComponent(paramValue)}`;
            fetchOpts.method = "DELETE";
          } else {
            fetchOpts.method = "POST";
            fetchOpts.headers = { "Content-Type": "application/json" };
            fetchOpts.body = JSON.stringify({ itemId: itemId!, id: itemId });
          }

          const response = await fetch(url, fetchOpts);

          const data = await response.json();

          const callbackArg =
            deleteMethod === "DELETE" && deleteQueryParam
              ? (button.dataset[deleteQueryParam] ?? itemId)
              : itemId;

          if (data.success || response.ok) {
            if (callbackName && typeof (window as any)[callbackName] === "function") {
              await (window as any)[callbackName](callbackArg);
            } else {
              // Show default success message
              if ((window as any).showSuccess) {
                (window as any).showSuccess(
                  "Deleted",
                  `${itemType || "Item"} deleted successfully`,
                  3000
                );
              }
            }
          } else {
            console.error("[DeleteConfirmButton] API returned error:", data.error);
            if ((window as any).showNotice) {
              (window as any).showNotice(
                "error",
                "Delete Failed",
                data.error || "Failed to delete item"
              );
            }
          }
        } catch (error) {
          console.error("[DeleteConfirmButton] API call failed:", error);
          if ((window as any).showNotice) {
            (window as any).showNotice(
              "error",
              "Delete Failed",
              "An error occurred while deleting"
            );
          }
        } finally {
          button.removeAttribute("disabled");
        }
      } else {
        if (callbackName && typeof (window as any)[callbackName] === "function") {
          try {
            await (window as any)[callbackName](itemId);
          } catch (error) {
            console.error("[DeleteConfirmButton] Callback error:", error);
          }
        }

        button.removeAttribute("disabled");

        // Dispatch event for backward compatibility
        const deleteEvent = new CustomEvent("deleteConfirmed", {
          detail: { buttonId, itemId, itemType },
          bubbles: true,
          cancelable: true,
        });
        button.dispatchEvent(deleteEvent);
      }
    }
  }

  function resetButton(button: HTMLElement) {
    button.setAttribute("data-state", "trash");
    button.title = button.dataset.originalTitle || "Delete";
    const stopwatchIcon = button.querySelector(".stopwatch-icon") as SVGElement;
    if (stopwatchIcon) {
      stopwatchIcon.outerHTML = `<svg class="inline-block delete-confirm-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 6h18"></path>
        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
        <path d="M10 11v6"></path>
        <path d="M14 11v6"></path>
      </svg>`;
    }
  }

  function extractItemId(buttonId: string, itemType?: string): number | null {
    if (itemType) {
      const pattern1 = new RegExp(`delete-${itemType}-(\\d+)`);
      const match1 = buttonId.match(pattern1);
      if (match1) return parseInt(match1[1], 10);
    }
    const pattern2 = /delete-\w+-(\d+)$/;
    const match2 = buttonId.match(pattern2);
    if (match2) return parseInt(match2[1], 10);
    const pattern3 = /(\d+)$/;
    const match3 = buttonId.match(pattern3);
    if (match3) return parseInt(match3[1], 10);
    return null;
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initDeleteConfirmButtons);
  } else {
    initDeleteConfirmButtons();
  }
  // SPA disabled: document.addEventListener("astro:page-load", () => requestAnimationFrame(initDeleteConfirmButtons));
</script>
