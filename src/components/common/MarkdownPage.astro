---
/**
 * MarkdownPage Component
 * Convention-based component loading: <ComponentName /> → tries to load from common locations
 * No registry needed - if file exists, load it; if not, skip it
 */

import { getPageContent } from "../../lib/content";
import { marked } from "marked";
import { parseComponentShortcodes, type ComponentShortcode } from "../../lib/markdown-components";

// Layout imports (these are always needed)
import LayoutDefault from "../layouts/LayoutDefault.astro";
import LayoutFullWidth from "../layouts/LayoutFullWidth.astro";
import LayoutMinimal from "../layouts/LayoutMinimal.astro";
import LayoutCentered from "../layouts/LayoutCentered.astro";
import LayoutFullscreen from "../layouts/LayoutFullscreen.astro";
import LayoutFullForm from "../layouts/LayoutFullForm.astro";

interface Props {
  slug: string;
  currentUser?: any;
  session?: any;
  supabase?: any;
}

const { slug, currentUser, session, supabase } = Astro.props;

const pageContent = await getPageContent(slug);

if (!pageContent) {
  return Astro.redirect("/404");
}

const template = pageContent.template || "default";

const layouts = {
  default: LayoutDefault,
  fullwidth: LayoutFullWidth,
  minimal: LayoutMinimal,
  centered: LayoutCentered,
  fullscreen: LayoutFullscreen,
  fullform: LayoutFullForm,
};

const Layout = layouts[template as keyof typeof layouts] || LayoutDefault;

// Parse component shortcodes from markdown
const components = parseComponentShortcodes(pageContent.content);

console.log(
  "[MarkdownPage] Found components:",
  components.map((c) => c.name)
);

// Fetch shared data once when components need it (avoids duplicate queries)
const needsFeaturedProjects = components.some((c) => c.name === "DynamicProjectsMap");
let featuredProjectsForMap: Array<{
  data: {
    title: string;
    location?: string;
    excerpt?: string;
    coordinates?: { lat: number; lng: number };
  };
}> = [];

if (needsFeaturedProjects) {
  try {
    const baseUrl = Astro.url.origin;
    const response = await fetch(`${baseUrl}/api/projects/get?featured=true`, {
      headers: { Cookie: Astro.request.headers.get("Cookie") || "" },
    });
    if (response.ok) {
      const data = await response.json();
      const projects = (data.projects || []).filter(
        (p: any) => p.featured === true || p.featured === "yes"
      );
      featuredProjectsForMap = projects.map((p: any) => ({
        data: {
          title: p.title || p.address || "Project",
          location: p.address || p.title || "",
          excerpt: p.description || "",
          coordinates:
            p.coordinates ??
            (p.lat != null && p.lng != null ? { lat: p.lat, lng: p.lng } : undefined),
        },
      }));
    }
  } catch (err) {
    console.warn("[MarkdownPage] Could not fetch featured projects for DynamicProjectsMap:", err);
  }
}

// Replace components with inline markers (rendered server-side, no client replacement needed)
const PLACEHOLDER_PREFIX = "__MARKDOWNPAGE_COMPONENT_";
let markdownContent = pageContent.content;
for (let i = 0; i < components.length; i++) {
  markdownContent = markdownContent.replace(
    components[i]!.fullMatch,
    `\n\n<!-- ${PLACEHOLDER_PREFIX}${i}__ -->\n\n`
  );
}

const htmlContent = marked.parse(markdownContent) as string;

// Split HTML by component placeholders and build segments for inline rendering
// Components render in the correct position from the start (no client-side replacement)
const placeholderRegex = new RegExp(`<!-- ${PLACEHOLDER_PREFIX}(\\d+)__ -->`, "g");
const parts = htmlContent.split(placeholderRegex);
// parts: [html0, "0", html1, "1", ...] - alternating HTML and component index
const segments: Array<{ type: "html"; content: string } | { type: "component"; index: number }> =
  [];
for (let i = 0; i < parts.length; i++) {
  if (i % 2 === 0) {
    if (parts[i]) segments.push({ type: "html", content: parts[i] as string });
  } else {
    const idx = parseInt(parts[i] as string, 10);
    if (!Number.isNaN(idx)) segments.push({ type: "component", index: idx });
  }
}

// Component name aliases (e.g. markdown uses ProjectsList but file is ProjectList.astro)
const componentAliases: Record<string, string> = {
  ProjectsList: "ProjectList",
};

// Use import.meta.glob to pre-load all possible components (so Vite processes styles)
// Includes layouts for shortcodes like LandingProductCapco (page wrappers are statically imported above)
const allComponents = import.meta.glob([
  "../layouts/*.astro",
  "../ui/*.astro",
  "../common/*.astro",
  "../profile/*.astro",
  "../project/*.astro",
  "../blocks/*.astro",
  "../../features/*.astro",
  "../../features/*/*.astro",
  "../../features/*/components/*.astro",
]);

// console.log("[MarkdownPage] Available component paths:", Object.keys(allComponents));

// Load only the components used in this page's markdown
const componentModules = await Promise.all(
  components.map(async (component) => {
    const name = component.name;
    const resolvedName = componentAliases[name] ?? name;

    // Find matching component in the glob
    const matchingPath = Object.keys(allComponents).find((path) => {
      const fileName = path.split("/").pop()?.replace(".astro", "");
      return fileName === resolvedName;
    });

    if (!matchingPath) {
      console.warn(`[MarkdownPage] ❌ Component not found: ${name}`);
      return null;
    }

    try {
      // console.log(`[MarkdownPage] ✅ Loading ${name} from ${matchingPath}`);
      const module = (await allComponents[matchingPath]()) as { default: any };
      return { component, Component: module.default };
    } catch (error) {
      console.error(`[MarkdownPage] Failed to load ${name}:`, error);
      return null;
    }
  })
);

// Keep same order as components for segment index lookup (null = failed to load)
---

<Layout
  title={pageContent.title}
  description={pageContent.description || ""}
  lastUpdated={pageContent.lastUpdated}
  {currentUser}
  {session}
  {supabase}
>
  <div class="markdown-page-content">
    {
      segments.map((seg) => {
        if (seg.type === "html") {
          return <Fragment set:html={seg.content} />;
        }
        const mod = componentModules[seg.index];
        if (!mod) return null;
        const { component, Component } = mod;
        const props = { ...component.props };
        if (
          component.name === "DynamicProjectsMap" &&
          !props.projects &&
          featuredProjectsForMap.length > 0
        ) {
          props.projects = featuredProjectsForMap;
        }
        return (
          <div data-component-name={component.name}>
            <Component {...props} />
          </div>
        );
      })
    }
  </div>
</Layout>
