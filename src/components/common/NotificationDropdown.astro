---
export interface Props {
  currentUser?: any;
  class?: string;
}

const { currentUser } = Astro.props;
const currentRole = currentUser?.profile?.role;

import SimpleIcon from "../common/SimpleIcon.astro";

// Return null if no user
if (!currentUser || currentRole === "Client") {
  return null;
}
---

<div
  id="notificationsModal"
  tabindex="-1"
  class="backdrop-blur-lg animate-fade-in fixed inset-0 z-50 hidden transform items-center justify-center transition-all duration-300 ease-in-out"
  aria-hidden="true"
>
  <div
    class="backdrop-blur-sm mx-4 max-h-[96vh] w-full max-w-2xl overflow-y-auto rounded-lg bg-white outer-shadow shadow-xl outer-shadow-white/10 dark:bg-black"
  >
    <!-- Modal content -->
    <div>
      <!-- Modal header -->
      <div
        class="flex items-center justify-between border-b border-gray-200 p-3 md:p-4 lg:p-6 dark:border-gray-700"
      >
        <h3 class="text-xl font-semibold text-gray-900 dark:text-white">Notifications</h3>
        <button
          type="button"
          class="text-gray-400 transition-colors duration-200 hover:text-gray-600 dark:hover:text-gray-300"
          data-modal-toggle="notificationsModal"
        >
          <svg
            class="h-6 w-6"
            aria-hidden="true"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <path
              stroke="currentColor"
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18 18 6m0 12L6 6"></path>
          </svg>
          <span class="sr-only">Close modal</span>
        </button>
      </div>
      <!-- Modal Content -->
      <div class="p-3 md:p-4 lg:p-6">
        <!-- Modal body -->
        <div
          class="align-center flex items-center justify-between rounded-lg bg-gray-100 px-4 py-2 text-sm font-medium text-gray-900 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
        >
          <h3>Notifications</h3>
          <button
            id="mark-all-read"
            class="text-sm text-primary-600 hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300"
          >
            Mark all read
          </button>
        </div>

        <!-- Loading State -->
        <div id="notification-loading" class="p-4 text-center">
          <div class="flex items-center justify-center space-x-2 text-gray-500 dark:text-gray-400">
            <div
              class="h-4 w-4 animate-spin rounded-full border-2 border-gray-300 border-t-primary-600"
            >
            </div>
            <span>Loading notifications...</span>
          </div>
        </div>

        <!-- Empty State -->
        <div id="notification-empty" class="hidden p-6 text-center">
          <svg
            class="mx-auto h-12 w-12 text-gray-400 dark:text-gray-600"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
            ></path>
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-white">
            No recent notifications
          </h3>
          <!-- <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
      No notifications in the last 5 items
    </p> -->
        </div>

        <!-- Notifications List -->
        <div id="notification-list" class="max-h-96 overflow-y-auto scrollbar-hide">
          <!-- Notifications will be populated here -->
        </div>

        <!-- Footer with auto-loading indicator -->
        <div class="border-t border-gray-200 px-4 py-3 dark:border-gray-700">
          <div
            id="loading-indicator"
            class="text-center text-sm text-gray-500 dark:text-gray-400 hidden"
          >
            Loading more notifications...
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  // Global count bubble utility is available via window.updateCountBubble and window.COUNT_BUBBLE_PRESETS

  class NotificationManager {
    isOpen: boolean = false;
    notifications: any[] = [];
    viewedNotifications: Set<number> = new Set();
    pollingInterval: NodeJS.Timeout | null = null;
    isLoadingMore: boolean = false;

    constructor() {
      this.init();
    }

    async init() {
      // Get user ID from global variable or data attribute
      this.bindEvents();
      await this.loadNotifications();
      this.startPolling();
    }

    bindEvents() {
      const modal = document.getElementById("notificationsModal");
      const markAllRead = document.getElementById("mark-all-read");
      const closeButton = modal?.querySelector('[data-modal-toggle="notificationsModal"]');

      // Listen for modal show/hide events (Bootstrap modal events)
      modal?.addEventListener("show.bs.modal", () => {
        this.openDropdown();
      });

      modal?.addEventListener("hide.bs.modal", () => {
        this.closeDropdown();
      });

      // Handle close button click
      closeButton?.addEventListener("click", () => {
        this.closeDropdown();
      });

      // Handle backdrop click to close
      modal?.addEventListener("click", (e) => {
        if (e.target === modal) {
          this.closeDropdown();
        }
      });

      // Mark all as read
      markAllRead?.addEventListener("click", () => {
        this.markAllAsRead();
      });

      // Mark notifications as viewed when scrolling and auto-load more
      const notificationList = document.getElementById("notification-list");
      notificationList?.addEventListener("scroll", () => {
        this.handleScroll();
      });
    }

    openDropdown() {
      const modal = document.getElementById("notificationsModal");
      if (modal) {
        console.log("üîç [NOTIFICATIONS] Opening modal");
        modal.classList.remove("hidden");
        this.isOpen = true;
        this.loadNotifications(); // Refresh notifications when opening
        console.log("üîç [NOTIFICATIONS] Modal opened, isOpen:", this.isOpen);
      }
    }

    closeDropdown() {
      const modal = document.getElementById("notificationsModal");
      if (modal) {
        console.log("üîç [NOTIFICATIONS] Closing modal");
        modal.classList.add("hidden");
        this.isOpen = false;
        this.markViewedNotificationsAsRead();
      }
    }

    async loadNotifications() {
      try {
        this.showLoading();

        // console.log("üîç [NOTIFICATIONS] Fetching notifications from /api/notifications/get?limit=5");
        const response = await fetch("/api/notifications/get?limit=5", {
          credentials: "include",
        });
        // console.log("üîç [NOTIFICATIONS] Response status:", response.status);

        const data = await response.json();
        // console.log("üîç [NOTIFICATIONS] Response data:", data);

        if (data.success) {
          this.notifications = data.notifications || [];
          // console.log("üîç [NOTIFICATIONS] Unread count from API:", data.unreadCount);
          // console.log(
          //   "üîç [NOTIFICATIONS] Notifications received:",
          //   this.notifications.map((n) => ({ id: n.id, title: n.title, viewed: n.viewed }))
          // );
          this.updateBadge(data.unreadCount || 0);
          this.renderNotifications();
          // console.log(
          //   "‚úÖ [NOTIFICATIONS] Successfully loaded",
          //   this.notifications.length,
          //   "notifications"
          // );
        } else if (data.migrationRequired) {
          console.warn("‚ö†Ô∏è [NOTIFICATIONS] Database migration required:", data.error);
          this.showMigrationRequired(data.instructions);
        } else {
          console.error("‚ùå [NOTIFICATIONS] Failed to load notifications:", data.error);
          this.showEmpty();
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error loading notifications:", error);
        this.showEmpty();
      }
    }

    renderNotifications() {
      const list = document.getElementById("notification-list");
      const empty = document.getElementById("notification-empty");
      const loading = document.getElementById("notification-loading");

      // console.log(
      //   "üîç [NOTIFICATIONS] renderNotifications called with",
      //   this.notifications.length,
      //   "notifications"
      // );

      if (!list) {
        console.error("‚ùå [NOTIFICATIONS] notification-list element not found");
        return;
      }

      // Hide loading and empty states
      loading?.classList.add("hidden");
      empty?.classList.add("hidden");

      // Show the list (remove hidden class)
      list?.classList.remove("hidden");

      if (this.notifications.length === 0) {
        empty?.classList.remove("hidden");
        return;
      }

      list.innerHTML = "";

      this.notifications.forEach((notification: any, index: number) => {
        const notificationElement = this.createNotificationElement(notification);

        list.appendChild(notificationElement);
      });

      // Test: Add a simple test element to see if the list is working
    }

    createNotificationElement(notification: any) {
      // console.log("üîç [NOTIFICATIONS] createNotificationElement called with:", notification);
      const div = document.createElement("div");
      div.className = ` overflow-y-auto scrollbar-hide p-4 border-b border-gray-200 dark:border-gray-700 transition-colors ${!notification.viewed ? " dark:bg-primary-900/20" : ""}`;
      div.dataset.notificationId = notification.id;
      // console.log("üîç [NOTIFICATIONS] Created div with className:", div.className);

      const timeAgo = this.formatTimeAgo(notification.createdAt);

      // Use envelope icon for unread, archive icon for read
      const isRead = notification.viewed;
      const iconColor = isRead
        ? "text-gray-400 dark:text-gray-500"
        : "text-primary-600 dark:text-primary-400";
      const iconPath = isRead
        ? "M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"
        : "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z";

      div.innerHTML = `
        <div class="flex items-start space-x-3">
          <div class="flex-shrink-0">
            <svg class="w-5 h-5 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${iconPath}"></path>
            </svg>
          </div>
          <div class="flex-1 min-w-0">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-2">
                <p class="text-sm font-medium text-gray-900 dark:text-white truncate">
                  ${notification.title}
                </p>
              </div>
              <p class="text-xs text-gray-500 dark:text-gray-400 ml-2">${timeAgo}</p>
            </div>
            <p class="mt-1 text-sm text-gray-600 dark:text-gray-300">
              ${notification.message}
            </p>
            ${
              notification.actionUrl
                ? `
              <div class="mt-2">
                <a href="${notification.actionUrl}" class="text-sm text-primary-600 hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300">
                  ${notification.actionText || "View Details"}
                </a>
              </div>
            `
                : ""
            }
          </div>
          <Button
            type="button"
            id="delete-notification-${notification.id}"
            onclick="event.stopPropagation(); window.confirmDeleteNotification(${notification.id})"
            variant="danger"
            size="sm"
            icon="trash"
            title="Delete notification"
            dataAttributes={{
              "data-state": "trash",
              "data-notification-id": notification.id
            }}
            class="delete-btn"
          />
        </div>
      `;

      // Don't automatically mark as viewed when rendered
      // Only mark as viewed when user actually views them (scrolls or clicks)

      // console.log("üîç [NOTIFICATIONS] Final notification element:", div);
      // console.log(
      //   "üîç [NOTIFICATIONS] Final notification innerHTML length:",
      //   div.innerHTML.length
      // );
      return div;
    }

    handleScroll() {
      // Mark visible notifications as viewed
      const list = document.getElementById("notification-list");
      if (!list) return;

      const rect = list.getBoundingClientRect();
      const notifications = list.querySelectorAll("[data-notification-id]");

      notifications.forEach((element) => {
        const elementRect = element.getBoundingClientRect();
        const isVisible = elementRect.top >= rect.top && elementRect.bottom <= rect.bottom;

        if (isVisible) {
          const notificationId = parseInt((element as HTMLElement).dataset.notificationId || "0");
          const notification = this.notifications.find((n) => n.id === notificationId);

          if (notification && !notification.viewed) {
            this.viewedNotifications.add(notificationId);
            // Add visual feedback - mark as read immediately
            this.markNotificationAsRead(notificationId);
          }
        }
      });

      // Check if we're near the bottom for auto-loading
      const scrollTop = list.scrollTop;
      const scrollHeight = list.scrollHeight;
      const clientHeight = list.clientHeight;
      const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;

      // Auto-load more when 80% scrolled
      if (scrollPercentage > 0.8 && this.notifications.length > 0) {
        this.loadMoreNotifications();
      }
    }

    async markNotificationAsRead(notificationId: number) {
      // Update local state immediately for visual feedback
      const notification = this.notifications.find((n) => n.id === notificationId);
      if (notification) {
        notification.viewed = true;
        this.updateNotificationDisplay(notificationId);
      }
    }

    updateNotificationDisplay(notificationId: number) {
      const element = document.querySelector(`[data-notification-id="${notificationId}"]`);
      if (element) {
        // Add visual indication that it's been read
        element.classList.add("opacity-75", "bg-gray-50", "color-background");
        element.classList.remove("bg-white", "dark:bg-gray-900");

        // Add a subtle checkmark or indicator
        const indicator = element.querySelector(".read-indicator");
        if (!indicator) {
          const checkmark = document.createElement("div");
          checkmark.className = "read-indicator absolute top-2 right-2 text-green-500 text-xs";
          checkmark.innerHTML = "‚úì";
          element.appendChild(checkmark);
        }
      }
    }

    async markViewedNotificationsAsRead() {
      if (this.viewedNotifications.size === 0) return;

      try {
        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: Array.from(this.viewedNotifications),
            viewed: true,
          }),
        });

        if (response.ok) {
          // Update badge immediately for better UX
          const unreadCount = this.notifications.filter((n: any) => !n.viewed).length;
          this.updateBadge(unreadCount);
          this.viewedNotifications.clear();
          await this.loadNotifications(); // Refresh to update counts
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error(
            "‚ùå [NOTIFICATIONS] Error marking notifications as read:",
            response.status,
            errorData
          );
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error marking notifications as read:", error);
      }
    }

    async loadMoreNotifications() {
      // Prevent multiple simultaneous loads
      if (this.isLoadingMore) return;
      this.isLoadingMore = true;

      // Show loading indicator
      const loadingIndicator = document.getElementById("loading-indicator");
      if (loadingIndicator) {
        loadingIndicator.classList.remove("hidden");
      }

      try {
        console.log("üîÑ [NOTIFICATIONS] Auto-loading more notifications...");

        const response = await fetch("/api/notifications/get", {
          credentials: "include",
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success && data.notifications) {
          // Append new notifications to existing ones
          this.notifications = [...this.notifications, ...data.notifications];
          this.renderNotifications();
          this.updateBadge(data.unreadCount || 0);

          console.log(`üîÑ [NOTIFICATIONS] Loaded ${data.notifications.length} more notifications`);
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error auto-loading notifications:", error);
      } finally {
        this.isLoadingMore = false;
        // Hide loading indicator
        if (loadingIndicator) {
          loadingIndicator.classList.add("hidden");
        }
      }
    }

    async markAllAsRead() {
      try {
        const unreadIds = this.notifications.filter((n: any) => !n.viewed).map((n: any) => n.id);

        if (unreadIds.length === 0) return;

        const response = await fetch("/api/notifications/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            notificationIds: unreadIds,
            viewed: true,
          }),
        });

        if (response.ok) {
          // Update badge immediately for better UX
          this.updateBadge(0);
          await this.loadNotifications();
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error(
            "‚ùå [NOTIFICATIONS] Error marking all as read:",
            response.status,
            errorData
          );
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error marking all as read:", error);
      }
    }

    confirmDeleteNotification(notificationId: number) {
      // console.log("üîç [NOTIFICATIONS] confirmDeleteNotification called for ID:", notificationId);
      const button = document.getElementById(`delete-notification-${notificationId}`);
      // console.log("üîç [NOTIFICATIONS] Button found:", button);
      if (!button) {
        console.error("‚ùå [NOTIFICATIONS] Delete button not found for ID:", notificationId);
        return;
      }

      const currentState = button.getAttribute("data-state");

      if (currentState === "trash") {
        // First click: Show question mark
        button.innerHTML =
          '<span class="text-lg font-bold w-4 h-4 flex items-center justify-center">?</span>';
        button.setAttribute("data-state", "confirm");
        button.title = "Click again to confirm deletion";
        button.className =
          "flex-shrink-0 p-1 text-gray-100 dark:text-gray-800 hover:text-danger-800 hover:bg-danger-100 rounded transition-colors delete-btn pulse";

        // Auto-revert after 3 seconds
        setTimeout(() => {
          if (button.getAttribute("data-state") === "confirm") {
            this.revertDeleteButton(notificationId);
          }
        }, 3000);
      } else if (currentState === "confirm") {
        // Second click: Actually delete
        this.deleteNotification(notificationId);
      }
    }

    revertDeleteButton(notificationId: number) {
      const button = document.getElementById(`delete-notification-${notificationId}`);
      if (!button) return;

      button.innerHTML = `
        <svg class="w-4 h-4 flex items-center justify-center" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
      `;
      button.setAttribute("data-state", "trash");
      button.title = "Delete notification";
      button.className =
        "flex-shrink-0 p-1 text-gray-100 dark:text-gray-800 hover:text-danger-800 hover:bg-danger-100 rounded transition-colors delete-btn pulse";
    }

    async deleteNotification(notificationId: number) {
      console.log("üîç [NOTIFICATIONS] deleteNotification called for ID:", notificationId);
      try {
        const response = await fetch("/api/notifications/get", {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({ notificationId }),
        });

        console.log("üîç [NOTIFICATIONS] Delete response status:", response.status);
        if (response.ok) {
          console.log("‚úÖ [NOTIFICATIONS] Notification deleted successfully, reloading...");
          await this.loadNotifications();
        } else {
          console.error("‚ùå [NOTIFICATIONS] Delete failed with status:", response.status);
        }
      } catch (error) {
        console.error("‚ùå [NOTIFICATIONS] Error deleting notification:", error);
      }
    }

    updateBadge(count: number) {
      console.log("üîç [NOTIFICATIONS] updateBadge called with count:", count);

      // Use global notification count updater
      if ((window as any).updateNotificationBellCount) {
        (window as any).updateNotificationBellCount(count);
      } else {
        console.warn("üîç [NOTIFICATIONS] Global notification count updater not available");
      }
    }

    showLoading() {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.remove("hidden");
      empty?.classList.add("hidden");
      list?.classList.add("hidden");
    }

    showEmpty() {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.add("hidden");
      empty?.classList.remove("hidden");
      list?.classList.add("hidden");
    }

    showMigrationRequired(instructions: string[]) {
      const loading = document.getElementById("notification-loading") as HTMLElement;
      const empty = document.getElementById("notification-empty");
      const list = document.getElementById("notification-list");

      loading?.classList.add("hidden");
      empty?.classList.add("hidden");
      list?.classList.add("hidden");

      // Create migration required message
      const emptyDiv = document.getElementById("notification-empty") as HTMLElement;
      if (emptyDiv) {
        emptyDiv.innerHTML = `
          <svg class="mx-auto h-12 w-12 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-white">Database Migration Required</h3>
          <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">Notifications table not found.</p>
          <div class="mt-4 text-left">
            <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">Setup instructions:</p>
            <ol class="text-xs text-gray-600 dark:text-gray-400 space-y-1">
              ${instructions.map((instruction: string) => `<li>${instruction}</li>`).join("")}
            </ol>
          </div>
        `;
        emptyDiv.classList.remove("hidden");
      }
    }

    startPolling() {
      // Poll for new notifications every 2 minutes (reduced from 30 seconds)
      this.pollingInterval = setInterval(() => {
        if (!this.isOpen) {
          this.loadNotifications();
        }
      }, 120000);
    }

    formatTimeAgo(dateString: string) {
      const date = new Date(dateString);
      const now = new Date();
      const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));

      if (diffInMinutes < 1) return "Just now";
      if (diffInMinutes < 60) return `${diffInMinutes}m ago`;

      const diffInHours = Math.floor(diffInMinutes / 60);
      if (diffInHours < 24) return `${diffInHours}h ago`;

      const diffInDays = Math.floor(diffInHours / 24);
      if (diffInDays < 7) return `${diffInDays}d ago`;

      return date.toLocaleDateString();
    }
  }

  // Only initialize if user is authenticated

  console.log("üîç [NOTIFICATIONS] Initializing notification manager for authenticated user");
  const notificationManager = new NotificationManager();
  (window as any).notificationManager = notificationManager;

  // Global function for delete confirmation
  (window as any).confirmDeleteNotification = (notificationId: number) => {
    console.log(
      "üîç [NOTIFICATIONS] Global confirmDeleteNotification called for ID:",
      notificationId
    );
    notificationManager.confirmDeleteNotification(notificationId);
  };
</script>

<style>
  /* Custom scrollbar for notification list */
  #notification-list::-webkit-scrollbar {
    width: 4px;
  }

  #notification-list::-webkit-scrollbar-track {
    background: transparent;
  }

  #notification-list::-webkit-scrollbar-thumb {
    background: #d1d5db;
    border-radius: 2px;
  }

  #notification-list::-webkit-scrollbar-thumb:hover {
    background: #9ca3af;
  }
</style>
