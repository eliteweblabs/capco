---
import ProjectNavButton from "./ProjectNavButton.astro";
import { getI18N } from "@/i18n";
import { checkAuth } from "../../lib/auth";

// Para cambiar idioma de textos
const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });

// Get current user for authentication and role
const { isAuth, user, role } = await checkAuth(Astro.cookies);

// Fetch project_statuses from API
let project_statuses: any[] = [];
let projects: any[] = [];
let statusCounts: Record<string, number> = {};

try {
  // Fetch project statuses
  const statusResponse = await fetch(`${Astro.url.origin}/api/get-project-statuses`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  });

  if (statusResponse.ok) {
    const result = await statusResponse.json();
    if (result.success) {
      project_statuses = Object.values(result.statuses || {});
    } else {
      console.error("API returned error:", result.error);
    }
  } else {
    console.error("Failed to fetch project_statuses:", statusResponse.status);
  }

  // Fetch projects to calculate counts (only if user is authenticated)
  if (isAuth && user) {
    const projectsResponse = await fetch(`${Astro.url.origin}/api/get-project`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        user_id: user.id,
        role: role || "Client",
      },
    });

    if (projectsResponse.ok) {
      const projectsResult = await projectsResponse.json();
      if (projectsResult.success) {
        projects = projectsResult.projects || [];

        // Calculate status counts
        statusCounts = {};
        projects.forEach((project) => {
          const status = project.status?.toString() || "10";
          statusCounts[status] = (statusCounts[status] || 0) + 1;
        });
      }
    }
  }
} catch (error) {
  console.error("Error fetching data:", error);
}
---

<nav
  id="sub-nav"
  class="scrollbar-hide relative flex gap-1 overflow-x-auto whitespace-nowrap text-hub-inactive dark:border-hub-border-dark"
>
  <ProjectNavButton
    id="all-statuses"
    label="All Statuses"
    icon="bx bx-list-ul"
    data-count={projects.length.toString()}
  >
    All Statuses
  </ProjectNavButton>

  {
    project_statuses.length > 0
      ? project_statuses
          .filter((status: any) => status.display_in_nav === true)
          .map((status: any) => (
            <ProjectNavButton
              label={status.status_name}
              data-project-status-filter={status.status_code}
              data-count={(statusCounts[status.status_code] || 0).toString()}
            >
              {status.status_name}
            </ProjectNavButton>
          ))
      : ""
  }
</nav>

<script>
  // Project status filtering functionality
  document.addEventListener("DOMContentLoaded", function () {
    const subNav = document.getElementById("sub-nav");
    const projectList = document.getElementById("project-list");

    if (!subNav || !projectList) return;

    // Get all filter buttons
    const filterButtons = subNav.querySelectorAll("[data-project-status-filter]");
    const allStatusesButton = subNav.querySelector("#all-statuses");

    // Get all project items
    const projectItems = projectList.querySelectorAll("[data-project-status]");

    // Add click event listeners to filter buttons
    filterButtons.forEach((button) => {
      button.addEventListener("click", function (this: HTMLButtonElement) {
        const filterValue = this.getAttribute("data-project-status-filter");
        filterProjectsByStatus(filterValue);
        updateActiveButton(this);

        // Center the active button in the navigation
        this.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      });
    });

    // Add click event listener to "All Statuses" button
    if (allStatusesButton) {
      allStatusesButton.addEventListener("click", function (this: HTMLButtonElement) {
        filterProjectsByStatus("all");
        updateActiveButton(this);

        // Center the active button in the navigation
        this.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      });
    }

    // Filter projects based on status
    function filterProjectsByStatus(statusFilter: string | null) {
      projectItems.forEach((item) => {
        const projectStatus = item.getAttribute("data-project-status");

        if (statusFilter === "all" || statusFilter === projectStatus) {
          // Show project (but check if it's hidden by search)
          if (!(item as HTMLElement).classList.contains("hidden")) {
            (item as HTMLElement).style.display = "block";
            (item as HTMLElement).style.opacity = "1";
          }
        } else {
          // Hide project
          (item as HTMLElement).style.display = "none";
          (item as HTMLElement).style.opacity = "0";
        }
      });
    }

    // Update active button styling
    function updateActiveButton(activeButton: Element) {
      if (!subNav) return;

      // Remove active class from all buttons
      const allButtons = subNav.querySelectorAll("button");
      allButtons.forEach((btn) => {
        btn.classList.remove("bg-blue-500", "text-white", "border-blue-500");
        btn.classList.add("text-hub-inactive");
      });

      // Add active class to clicked button
      activeButton.classList.remove("text-hub-inactive");
      activeButton.classList.add("bg-blue-500", "text-white", "border-blue-500");
    }

    // Function to update count bubbles - only changes during search, not status filtering
    function updateCountBubblesForSearch() {
      console.log("üî¢ [ProjectNav] updateCountBubblesForSearch called");
      const projectsList = document.getElementById("project-list");
      if (!projectsList || !subNav) {
        console.log("‚ùå [ProjectNav] Missing projectsList or subNav");
        return;
      }

      // Only count projects that are not hidden by search (ignore status filter)
      const searchVisibleProjects = projectsList.querySelectorAll(
        "[data-project-status]:not(.hidden)"
      );
      console.log("üî¢ [ProjectNav] Found", searchVisibleProjects.length, "search-visible projects");
      const statusCounts: Record<string, number> = {};

      // Count search-visible projects by status
      searchVisibleProjects.forEach((project) => {
        const htmlProject = project as HTMLElement;
        const status = htmlProject.dataset.projectStatus || "10";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });

      // Update each nav button's count
      const navButtons = subNav?.querySelectorAll("button") || [];
      navButtons.forEach((button) => {
        const htmlButton = button as HTMLButtonElement;
        const statusFilter = htmlButton.dataset.projectStatusFilter;
        const isAllStatuses = htmlButton.id === "all-statuses";

        let count = 0;
        if (isAllStatuses) {
          count = searchVisibleProjects.length;
        } else if (statusFilter) {
          count = statusCounts[statusFilter] || 0;
        }

        // Update the count display
        const countSpan = htmlButton.querySelector("span.absolute");
        if (countSpan) {
          countSpan.textContent = count.toString();
          // Hide if count is 0
          if (count === 0) {
            (countSpan as HTMLElement).style.display = "none";
          } else {
            (countSpan as HTMLElement).style.display = "flex";
          }
        }
      });
    }

    // Function to restore original count bubbles (when search is cleared)
    function restoreOriginalCountBubbles() {
      const projectsList = document.getElementById("project-list");
      if (!projectsList || !subNav) return;

      // Count all projects by status (ignore all filters)
      const allProjects = projectsList.querySelectorAll("[data-project-status]");
      const statusCounts: Record<string, number> = {};

      allProjects.forEach((project) => {
        const htmlProject = project as HTMLElement;
        const status = htmlProject.dataset.projectStatus || "10";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });

      // Update each nav button's count back to original values
      const navButtons = subNav?.querySelectorAll("button") || [];
      navButtons.forEach((button) => {
        const htmlButton = button as HTMLButtonElement;
        const statusFilter = htmlButton.dataset.projectStatusFilter;
        const isAllStatuses = htmlButton.id === "all-statuses";

        let count = 0;
        if (isAllStatuses) {
          count = allProjects.length;
        } else if (statusFilter) {
          count = statusCounts[statusFilter] || 0;
        }

        // Update the count display
        const countSpan = htmlButton.querySelector("span.absolute");
        if (countSpan) {
          countSpan.textContent = count.toString();
          // Hide if count is 0
          if (count === 0) {
            (countSpan as HTMLElement).style.display = "none";
          } else {
            (countSpan as HTMLElement).style.display = "flex";
          }
        }
      });
    }

    // Make functions globally available for search component
    if (typeof window !== "undefined") {
      (window as any).updateCountBubblesForSearch = updateCountBubblesForSearch;
      (window as any).restoreOriginalCountBubbles = restoreOriginalCountBubbles;
    }

    // Update counts when page loads
    restoreOriginalCountBubbles();

    // Listen for project list changes to update counts
    const observer = new MutationObserver(() => {
      restoreOriginalCountBubbles();
    });

    const projectsList = document.getElementById("project-list");
    if (projectsList) {
      observer.observe(projectsList, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["style", "class"],
      });
    }

    // Function to handle search state and disable nav when searching
    function handleSearchState() {
      const searchInput = document.getElementById("project-search");
      if (!searchInput || !subNav) return;

      const hasSearchValue = searchInput.value && searchInput.value.trim().length > 0;
      const navButtons = subNav.querySelectorAll("button");

      if (hasSearchValue) {
        // Disable navigation when searching
        navButtons.forEach((button) => {
          button.disabled = true;
          button.style.opacity = "0.5";
          button.style.cursor = "not-allowed";
          button.setAttribute("title", "Status filters are disabled while searching");
        });
      } else {
        // Re-enable navigation when not searching
        navButtons.forEach((button) => {
          button.disabled = false;
          button.style.opacity = "1";
          button.style.cursor = "pointer";
          button.removeAttribute("title");
        });
      }
    }

    // Monitor search input changes
    function setupSearchMonitoring() {
      const searchInput = document.getElementById("project-search");
      if (searchInput) {
        // Check on input change
        searchInput.addEventListener("input", handleSearchState);

        // Check on focus/blur
        searchInput.addEventListener("focus", handleSearchState);
        searchInput.addEventListener("blur", handleSearchState);

        // Initial check
        handleSearchState();
      }

      // Also check periodically in case search is updated by other components
      setInterval(handleSearchState, 500);
    }

    // Handle initial filter on page load
    function handleInitialFilter() {
      if (!subNav) return;

      // Always default to "All Statuses" on page load
      if (allStatusesButton) {
        updateActiveButton(allStatusesButton);
        filterProjectsByStatus("all");
      }
    }

    // Initialize search monitoring
    setupSearchMonitoring();

    // Initialize filter on page load
    handleInitialFilter();
  });
</script>
