---
export interface Props {
  role?: string;
  projects?: any[];
  statuses?: any[];
  stat?: boolean;
}

import ProjectNavButton from "./ProjectNavButton.astro";
import { getI18N } from "@/i18n";

// Para cambiar idioma de textos
const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });

// Get props
const { role, projects = [], statuses = [], stat } = Astro.props;

// Use provided data instead of fetching
let project_statuses: any[] = statuses;
let statusCounts: Record<string, number> = {};

// Calculate status counts from provided projects
if (projects && projects.length > 0) {
  statusCounts = {};
  projects.forEach((project) => {
    const status = project.status?.toString() || "10";
    statusCounts[status] = (statusCounts[status] || 0) + 1;
  });
}

if (!projects || projects.length === 0) return;
---

<nav
  id="project-nav"
  class="scrollbar-hide relative flex gap-1 overflow-x-auto whitespace-nowrap text-hub-inactive dark:border-hub-border-dark"
>
  <ProjectNavButton
    id="all-statuses"
    label="All Projects"
    icon="bx bx-list-ul"
    data-count={projects.length.toString()}
  >
    All Projects
  </ProjectNavButton>

  {
    project_statuses.length > 0
      ? project_statuses
          .filter((status: any) => {
            // Role-based filtering
            if (role === "Admin" || role === "Staff") {
              return status.admin_visible !== false; // Show unless explicitly false
            }
            if (role === "Client") {
              return status.client_visible === true; // Show unless explicitly false
            }
            return true; // Default for other roles
          })
          .map((status: any) => (
            <ProjectNavButton
              label={status.status_name}
              data-project-status-filter={status.status_code}
              data-count={(statusCounts[status.status_code] || 0).toString()}
            >
              {status.status_name}
            </ProjectNavButton>
          ))
      : ""
  }
</nav>

<script>
  // Project status filtering functionality
  document.addEventListener("DOMContentLoaded", function () {
    const subNav = document.getElementById("project-nav");
    const projectList = document.getElementById("project-list");

    if (!subNav || !projectList) return;

    // Check if event listeners are already attached to prevent duplicates
    if (subNav.hasAttribute('data-listeners-attached')) {
      console.log("üîî [ProjectNav] Event listeners already attached, skipping");
      return;
    }
    
    // Mark as having listeners attached
    subNav.setAttribute('data-listeners-attached', 'true');

    // Get all filter buttons
    const filterButtons = subNav.querySelectorAll("[data-project-status-filter]");
    const allStatusesButton = subNav.querySelector("#all-statuses");

    // Get all project items
    const projectItems = projectList.querySelectorAll("[data-project-status]");

    // Add click event listeners to filter buttons
    filterButtons.forEach((button) => {
      button.addEventListener("click", function (this: HTMLButtonElement) {
        const filterValue = this.getAttribute("data-project-status-filter");
        filterProjectsByStatus(filterValue);
        updateActiveButton(this);

        // Center the active button in the navigation
        this.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      });
    });

    // Add click event listener to "All Statuses" button
    if (allStatusesButton) {
      allStatusesButton.addEventListener("click", function (this: HTMLButtonElement) {
        filterProjectsByStatus("all");
        updateActiveButton(this);

        // Center the active button in the navigation
        this.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      });
    }

    // Filter projects based on status
    function filterProjectsByStatus(statusFilter: string | null) {
      let visibleCount = 0;

      projectItems.forEach((item: Element) => {
        const projectStatus = item.getAttribute("data-project-status");

        if (statusFilter === "all" || statusFilter === projectStatus) {
          // Show project (but check if it's hidden by search)
          if (!(item as HTMLElement).classList.contains("hidden")) {
            (item as HTMLElement).style.display = "block";
            (item as HTMLElement).style.opacity = "1";
            visibleCount++;
          }
        } else {
          // Hide project
          (item as HTMLElement).style.display = "none";
          (item as HTMLElement).style.opacity = "0";
        }
      });

      // Show/hide "no projects" message - get fresh references each time
      const noProjectsMessage = document.getElementById("no-projects-message");
      const noProjectsText = document.getElementById("no-projects-text");

      console.log("üîç [ProjectNav] Filtering projects:", {
        statusFilter,
        visibleCount,
        totalProjects: projectItems.length,
        hasNoProjectsMessage: !!noProjectsMessage,
        hasNoProjectsText: !!noProjectsText
      });

      if (noProjectsMessage && noProjectsText) {
        if (visibleCount === 0) {
          // Show "no projects" message with specific status name
          let statusName = "this status";
          if (statusFilter !== "all") {
            // Get status name from the statuses data
            const statusData = project_statuses.find(status => status.status_code.toString() === statusFilter);
            if (statusData) {
              statusName = statusData.status_name;
            } else {
              // Fallback: try to get from button text
              const statusButton = subNav?.querySelector(`[data-project-status-filter="${statusFilter}"]`);
              if (statusButton) {
                statusName = statusButton.textContent?.trim() || "this status";
              }
            }
          }

          const messageText = `No projects currently at ${statusName}.`;
          console.log("üîç [ProjectNav] Setting no projects message:", messageText);
          
          // Force update by clearing and setting text content
          noProjectsText.textContent = "";
          noProjectsText.textContent = messageText;
          
          // Force visibility update
          noProjectsMessage.classList.add("hidden");
          noProjectsMessage.offsetHeight; // Force reflow
          noProjectsMessage.classList.remove("hidden");
        } else {
          // Hide "no projects" message
          console.log("üîç [ProjectNav] Hiding no projects message");
          noProjectsMessage.classList.add("hidden");
        }
      } else {
        console.warn("üîç [ProjectNav] No projects message elements not found:", {
          noProjectsMessage: !!noProjectsMessage,
          noProjectsText: !!noProjectsText
        });
      }
    }

    // Update active button styling
    function updateActiveButton(activeButton: Element) {
      if (!subNav) return;

      // Remove active class from all buttons
      const allButtons = subNav.querySelectorAll("button");
      allButtons.forEach((btn) => {
        btn.classList.remove("bg-blue-500", "text-white", "border-blue-500");
        btn.classList.add("text-hub-inactive");
      });

      // Add active class to clicked button
      activeButton.classList.remove("text-hub-inactive");
      activeButton.classList.add("bg-blue-500", "text-white", "border-blue-500");
    }

    // Function to update count bubbles - only changes during search, not status filtering
    function updateCountBubblesForSearch() {
      console.log("üî¢ [ProjectNav] updateCountBubblesForSearch called");
      const projectsList = document.getElementById("project-list");
      if (!projectsList || !subNav) {
        console.log("‚ùå [ProjectNav] Missing projectsList or subNav");
        return;
      }

      // Only count projects that are not hidden by search (ignore status filter)
      const searchVisibleProjects = projectsList.querySelectorAll(
        "[data-project-status]:not(.hidden)"
      );
      console.log("üî¢ [ProjectNav] Found", searchVisibleProjects.length, "search-visible projects");
      const statusCounts: Record<string, number> = {};

      // Count search-visible projects by status
      searchVisibleProjects.forEach((project: Element) => {
        const htmlProject = project as HTMLElement;
        const status = htmlProject.dataset.projectStatus || "10";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });

      // Update each nav button's count
      const navButtons = subNav?.querySelectorAll("button") || [];
      navButtons.forEach((button) => {
        const htmlButton = button as HTMLButtonElement;
        const statusFilter = htmlButton.dataset.projectStatusFilter;
        const isAllStatuses = htmlButton.id === "all-statuses";

        let count = 0;
        if (isAllStatuses) {
          count = searchVisibleProjects.length;
        } else if (statusFilter) {
          count = statusCounts[statusFilter] || 0;
        }

        // Update the count display
        const countSpan = htmlButton.querySelector("span.absolute");
        if (countSpan) {
          countSpan.textContent = count.toString();
          // Hide if count is 0
          if (count === 0) {
            (countSpan as HTMLElement).style.display = "none";
          } else {
            (countSpan as HTMLElement).style.display = "flex";
          }
        }
      });
    }

    // Function to restore original count bubbles (when search is cleared)
    function restoreOriginalCountBubbles() {
      const projectsList = document.getElementById("project-list");
      if (!projectsList || !subNav) return;

      // Count all projects by status (ignore all filters)
      const allProjects = projectsList.querySelectorAll("[data-project-status]");
      const statusCounts: Record<string, number> = {};

      allProjects.forEach((project: Element) => {
        const htmlProject = project as HTMLElement;
        const status = htmlProject.dataset.projectStatus || "10";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });

      // Update each nav button's count back to original values
      const navButtons = subNav?.querySelectorAll("button") || [];
      navButtons.forEach((button) => {
        const htmlButton = button as HTMLButtonElement;
        const statusFilter = htmlButton.dataset.projectStatusFilter;
        const isAllStatuses = htmlButton.id === "all-statuses";

        let count = 0;
        if (isAllStatuses) {
          count = allProjects.length;
        } else if (statusFilter) {
          count = statusCounts[statusFilter] || 0;
        }

        // Update the count display
        const countSpan = htmlButton.querySelector("span.absolute");
        if (countSpan) {
          countSpan.textContent = count.toString();
          // Hide if count is 0
          if (count === 0) {
            (countSpan as HTMLElement).style.display = "none";
          } else {
            (countSpan as HTMLElement).style.display = "flex";
          }
        }
      });
    }

    // Make functions globally available for search component
    if (typeof window !== "undefined") {
      (window as any).updateCountBubblesForSearch = updateCountBubblesForSearch;
      (window as any).restoreOriginalCountBubbles = restoreOriginalCountBubbles;
    }

    // Update counts when page loads
    restoreOriginalCountBubbles();

    // Listen for project list changes to update counts
    const observer = new MutationObserver(() => {
      restoreOriginalCountBubbles();
    });

    const projectsList = document.getElementById("project-list");
    if (projectsList) {
      observer.observe(projectsList, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["style", "class"],
      });
    }

    // Function to handle search state and disable nav when searching
    function handleSearchState() {
      const searchInput = document.getElementById("project-search");
      if (!searchInput || !subNav) return;

      const hasSearchValue =
        (searchInput as HTMLInputElement).value &&
        (searchInput as HTMLInputElement).value.trim().length > 0;
      const navButtons = subNav.querySelectorAll("button");

      if (hasSearchValue) {
        // Disable navigation when searching
        navButtons.forEach((button) => {
          button.disabled = true;
          button.style.opacity = "0.5";
          button.style.cursor = "not-allowed";
          button.setAttribute("title", "Status filters are disabled while searching");
        });
      } else {
        // Re-enable navigation when not searching
        navButtons.forEach((button) => {
          button.disabled = false;
          button.style.opacity = "1";
          button.style.cursor = "pointer";
          button.removeAttribute("title");
        });
      }
    }

    // Monitor search input changes
    function setupSearchMonitoring() {
      const searchInput = document.getElementById("project-search");
      if (searchInput) {
        // Check on input change
        searchInput.addEventListener("input", handleSearchState);

        // Check on focus/blur
        searchInput.addEventListener("focus", handleSearchState);
        searchInput.addEventListener("blur", handleSearchState);

        // Initial check
        handleSearchState();
      }

      // Also check periodically in case search is updated by other components
      setInterval(handleSearchState, 500);
    }

    // Handle initial filter on page load
    function handleInitialFilter() {
      if (!subNav) return;

      // Always default to "All Statuses" on page load
      if (allStatusesButton) {
        updateActiveButton(allStatusesButton);
        filterProjectsByStatus("all");
      }
    }

    // Initialize search monitoring
    setupSearchMonitoring();

    // Initialize filter on page load
    handleInitialFilter();
  });
</script>
