---
import SimpleIcon from "../common/SimpleIcon.astro";
import CloseButton from "../ui/CloseButton.astro";
import Button from "../common/Button.astro";
import Modal from "../ui/Modal.astro";

interface Props {
  currentUser?: any;
  project: any;
  supabaseUrl?: string;
}

const { currentUser, project, supabaseUrl } = Astro.props;
const id = Astro.params.id;

const currentRole = currentUser?.profile?.role;

if (!project || !project.id || currentRole === "Client") {
  return null;
}

const projectId = project.id;

// console.log("üîç [TabPunchlist] props:", Astro.props);
---

{
  projectId && (
    <a
      type="button"
      id="punchlist-drawer-toggle"
      class="inline-flex items-center rounded-full p-2 text-center text-sm font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-50 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white dark:focus:ring-gray-600"
    >
      <span class="sr-only">View Punchlist</span>

      <SimpleIcon name="menu-check" class="w-6 h-6" />
    </a>
  )
}

<script
  define:vars={{
    projectId,
    currentRole,
    currentUser,
    supabaseUrl,
  }}
  type="module"
  is:inline
>
  // Punchlist functionality
  let punchlistItems = [];
  let currentProjectId = projectId;
  let currentUserId = currentUser?.id;

  async function loadPunchlistItems(projectId) {
    try {
      // Fetch punchlist data directly
      const response = await fetch(`/api/punchlist/get?projectId=${projectId}`, {
        credentials: "include",
      });

      const data = await response.json();

      // console.log("üîç [TabPunchlist] data:", data);
      if (data.success) {
        punchlistItems = data.punchlist;
        renderPunchlistItems();
        updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
      } else {
        console.error("Failed to load punchlist items:", data.error);

        // Show specific error message if table doesn't exist
        if (data.migration_needed || data.error?.includes("does not exist")) {
          showNotice(
            "error",
            "Punchlist Setup Required",
            `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
          );
        } else {
          showNotice(
            "error",
            "Punchlist Error",
            "Failed to load punchlist items: " + (data.details || data.error)
          );
        }
      }
    } catch (error) {
      console.error("Error loading punchlist items:", error);
      showPunchlistError("Failed to load punchlist items");
    }
  }

  // Drawer functions
  function openDrawer() {
    const drawer = document.getElementById("punchlist-drawer");
    const backdrop = document.getElementById("global-backdrop");

    if (drawer && backdrop) {
      backdrop.classList.remove("hidden");
      setTimeout(() => {
        backdrop.classList.add("opacity-100");
        drawer.classList.remove("translate-x-full");
      }, 10);
    }
  }

  function closeDrawer() {
    const drawer = document.getElementById("punchlist-drawer");
    const backdrop = document.getElementById("global-backdrop");

    if (drawer && backdrop) {
      drawer.classList.add("translate-x-full");
      backdrop.classList.remove("opacity-100");
      setTimeout(() => {
        backdrop.classList.add("hidden");
      }, 300);
    }
  }

  // Update incomplete punchlist items count in the punchlist tab
  async function updateIncompletePunchlistItemsCount() {
    const incompleteCount = punchlistItems.filter((item) => !item.markCompleted).length;

    // Update count directly
    const countElement = document.querySelector(".incomplete-punchlist-items-count");
    const tabButton = document.getElementById("punchlist-drawer-toggle");

    if (tabButton) {
      // Update count bubble on tab button

      window.updateCountBubble(
        tabButton,
        incompleteCount,
        window.COUNT_BUBBLE_PRESETS.notification
      );

      // if (incompleteCount > 0) {
      //   tabButton.setAttribute("data-count", incompleteCount.toString());
      //   tabButton.classList.add("has-count");
      // } else {
      //   tabButton.removeAttribute("data-count");
      //   tabButton.classList.remove("has-count");
      // }
    }

    // Also update the old count element if it exists
    if (countElement) {
      if (incompleteCount > 0) {
        countElement.textContent = incompleteCount.toString();
        countElement.classList.remove("hidden");
      } else {
        countElement.classList.add("hidden");
      }
    }

    // console.log("üîç [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
  }

  async function renderPunchlistItems() {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (!punchlistItemsList) return;

    // Separate top-level items and replies
    const topLevelItems = punchlistItems.filter((d) => !d.parentId);
    let html = "";

    // Process items asynchronously
    for (const item of topLevelItems) {
      // Check if user can see this item

      html += await renderPunchlistItem(item, 0);

      // Find and render replies for this item
    }

    punchlistItemsList.innerHTML = html;

    // Load toggles for all items that can be toggled
    punchlistItems.forEach((item) => {
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      if (canToggleCompleted) {
        loadToggleForPunchlistItem(item.id, item.markCompleted, true);
      }
    });
  }

  async function renderPunchlistItem(item, depth = 0) {
    try {
      // Compute all values in the parent component
      const isInternal = item.internal;
      const isAuthor = item.authorId === currentUserId;
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
      const borderLeft = depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

      // Ensure item data is properly encoded to handle Unicode characters
      const itemData = encodeURIComponent(JSON.stringify(item));

      const headers = new Headers({
        "x-comment-data": itemData,
        "x-current-user-role": currentRole,
        "x-current-user-id": currentUserId,
        "x-supabase-url": supabaseUrl,
        "x-comment-depth": depth.toString(),
        "x-is-internal": isInternal.toString(),
        "x-is-author": isAuthor.toString(),
        "x-can-toggle-completed": canToggleCompleted.toString(),
        "x-margin-left": marginLeft,
        "x-border-left": borderLeft,
      });

      const response = await fetch("/partials/punchlist-item", {
        headers: headers,
      });

      if (response.ok) {
        return await response.text();
      } else {
        console.error("Failed to load punchlist item partial:", response.status);
        return `<div class="text-red-500">Failed to load punchlist item</div>`;
      }
    } catch (error) {
      console.error("Error loading punchlist item partial:", error);
      return `<div class="text-red-500">Error loading punchlist item</div>`;
    }
  }

  // Load toggle using SlideToggle partial
  async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
    if (!canToggle) return;

    try {
      // Handle null/undefined isCompleted values
      const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

      const headers = new Headers({
        "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
        // "x-toggle-label": completed ? "Completed" : "Incomplete",
        "x-toggle-label": "",
        // "x-toggle-icon": completed ? "check-circle" : "",
        "x-toggle-color": "primary",
        "x-toggle-checked": completed.toString(),
        "x-toggle-class": "punchlist-completed-toggle",
        "x-toggle-data-discussion-id": itemId.toString(),
      });

      const response = await fetch("/partials/slide-toggle", {
        headers: headers,
      });

      if (response.ok) {
        const toggleHTML = await response.text();
        const container = document.getElementById(`toggle-container-${itemId}`);
        if (container) {
          container.innerHTML = toggleHTML;
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error loading toggle:", error);
    }
  }

  function showPunchlistError(message) {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (punchlistItemsList) {
      punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <SimpleIcon name="alert-circle" class="mx-auto mb-4 text-4xl" />
          <p>${message}</p>
        </div>
      `;
    }
  }

  // Initialize punchlist functionality when punchlist tab is shown
  function initializePunchlist() {
    // Set user role from server-side data (already set via define:vars)
    // User role is already available from component props

    const punchlistContainer = document.getElementById("punchlist-container");
    if (punchlistContainer) {
      currentProjectId = punchlistContainer.dataset.projectId || "";
      if (currentProjectId) {
        loadPunchlistItems(currentProjectId);
      }
    }

    // Add event delegation for completed toggles
    document.addEventListener("change", (e) => {
      const target = e.target;
      if (target.classList.contains("punchlist-completed-toggle")) {
        const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
        const isCompleted = target.checked;
        if (punchlistId) {
          togglePunchlistCompleted(punchlistId, isCompleted);
        }
      }
    });

    console.log("üîî [PUNCHLIST] Event listeners attached");
  }

  // Toggle punchlist item completed status
  async function togglePunchlistCompleted(punchlistId, isCompleted) {
    try {
      console.log("üîî [PUNCHLIST] Toggling completed status:", {
        punchlistId,
        isCompleted,
      });

      const response = await fetch("/api/punchlist/upsert", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({
          punchlistId: punchlistId,
          markCompleted: isCompleted,
        }),
      });

      const data = await response.json();

      if (data.success) {
        console.log("‚úÖ [PUNCHLIST] Punchlist item completed status updated successfully");
        // Update the local punchlist data
        const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
        if (punchlistItem) {
          punchlistItem.markCompleted = isCompleted;
        }

        // Update the incomplete punchlist items count
        updateIncompletePunchlistItemsCount();

        // Show success notification
        if (window.showNotice) {
          window.showNotice(
            "success",
            "Punchlist status updated",
            `Marked as ${isCompleted ? "completed" : "incomplete"}`,
            1500
          );
        }

        // Reload the toggle with the updated state
        loadToggleForPunchlistItem(punchlistId, isCompleted, true);
      } else {
        console.error("‚ùå [PUNCHLIST] Failed to update punchlist status:", data.error);
        // Revert the toggle to previous state
        loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
        // Show error notification
        if (window.showNotice) {
          window.showNotice("error", "Update Failed", "Failed to update punchlist status");
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error updating punchlist status:", error);
      // Revert the toggle to previous state
      loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
      // Show error notification
      if (window.showNotice) {
        window.showNotice("error", "Update Failed", "Error updating punchlist status");
      }
    }
  }

  // Initialize punchlist functionality when component loads
  document.addEventListener("DOMContentLoaded", function () {
    console.log("üîî [PUNCHLIST] Punchlist component loaded, initializing...");
    setTimeout(initializePunchlist, 100);

    // Initialize delete confirm buttons
    initDeleteConfirmButtons();

    // Setup drawer toggle button
    const drawerToggle = document.getElementById("punchlist-drawer-toggle");
    if (drawerToggle) {
      drawerToggle.addEventListener("click", openDrawer);
    }

    // Setup drawer close button
    const drawerClose = document.getElementById("punchlist-drawer-close");
    if (drawerClose) {
      drawerClose.addEventListener("click", closeDrawer);
    }

    // Setup backdrop click to close
    const backdrop = document.getElementById("global-backdrop");
    if (backdrop) {
      backdrop.addEventListener("click", closeDrawer);
    }

    // Close drawer on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        closeDrawer();
      }
    });

    // Swipe to close functionality for punchlist drawer
    const drawer = document.getElementById("punchlist-drawer");
    if (drawer) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      let isDragging = false;
      let currentTranslateX = 0;

      drawer.addEventListener("touchstart", (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isDragging = true;
        drawer.style.transition = "none";
      });

      drawer.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Only respond to horizontal swipes (right, to close)
        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {
          currentTranslateX = deltaX;
          drawer.style.transform = `translateX(${deltaX}px)`;
        }
      });

      drawer.addEventListener("touchend", (e) => {
        if (!isDragging) return;

        isDragging = false;
        drawer.style.transition = "";
        drawer.style.transform = "";

        const swipeThreshold = 100; // minimum swipe distance in pixels

        // If swiped right more than threshold, close drawer
        if (currentTranslateX > swipeThreshold) {
          closeDrawer();
        }

        currentTranslateX = 0;
        touchStartX = 0;
        touchStartY = 0;
        touchEndX = 0;
        touchEndY = 0;
      });
    }

    // Add Punchlist Item functionality (Admin only)
    const addPunchlistBtn = document.getElementById("add-punchlist-item-btn");
    if (addPunchlistBtn && currentRole === "Admin") {
      console.log("üîî [PUNCHLIST] Add button found, attaching event listener");
      addPunchlistBtn.addEventListener("click", async () => {
        console.log("üîî [PUNCHLIST] Add button clicked");
        // Show the editable form by rendering the partial with editable=true
        const punchlistContainer = document.getElementById("punchlist-items-list");
        if (!punchlistContainer) {
          console.error("üîî [PUNCHLIST] punchlist-items-list container not found");
          return;
        }

        // Check if form already exists
        if (document.querySelector(".punchlist-item-new")) {
          console.log("üîî [PUNCHLIST] Form already open");
          return;
        }

        try {
          // Fetch the editable partial
          const response = await fetch("/partials/punchlist-item", {
            method: "GET",
            headers: {
              "Content-Type": "text/html",
              "X-Editable": "true",
              "X-Current-User-Role": currentRole,
            },
          });

          if (!response.ok) {
            throw new Error("Failed to load form");
          }

          const formHtml = await response.text();

          // Insert form at the top of the list
          punchlistContainer.insertAdjacentHTML("afterbegin", formHtml);

          // Attach event listeners to the new form
          attachNewPunchlistFormHandlers();
        } catch (error) {
          console.error("Error loading punchlist form:", error);
          if (window.showError) {
            window.showError(
              "Failed to Load Form",
              "Unable to load punchlist form. Please try again.",
              0
            );
          }
        }
      });
    } else {
      console.log("üîî [PUNCHLIST] Add button not found or user not Admin");
    }
  });

  // Make initializePunchlist globally available for tab switching
  window.initializePunchlist = initializePunchlist;

  // Attach handlers to the new punchlist form
  function attachNewPunchlistFormHandlers() {
    const saveBtn = document.getElementById("save-new-punchlist-btn");
    const cancelBtn = document.getElementById("cancel-new-punchlist-btn");
    const messageInput = document.getElementById("new-punchlist-message");

    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => {
        // Remove the form
        const form = document.querySelector(".punchlist-item-new");
        if (form) form.remove();
      });
    }

    if (saveBtn && messageInput) {
      saveBtn.addEventListener("click", async () => {
        const message = messageInput.value.trim();

        if (!message) {
          if (window.showError) {
            window.showError("Message Required", "Please enter a punchlist item.", 3000);
          }
          messageInput.focus();
          return;
        }

        // Disable button during save
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="loading-spinner"></span> Saving...';

        try {
          const response = await fetch("/api/punchlist/upsert", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              projectId: currentProjectId,
              message: message,
              markCompleted: false,
              internal: false,
            }),
          });

          if (!response.ok) {
            throw new Error("Failed to create punchlist item");
          }

          // Remove the form
          const form = document.querySelector(".punchlist-item-new");
          if (form) form.remove();

          // Reload punchlist items
          await loadPunchlistItems(currentProjectId);
          await renderPunchlistItems();
          await updateIncompletePunchlistItemsCount();

          if (window.showSuccess) {
            window.showSuccess(
              "Punchlist Item Added",
              "Successfully added new punchlist item",
              3000
            );
          }
        } catch (error) {
          console.error("Error adding punchlist item:", error);
          if (window.showError) {
            window.showError(
              "Failed to Add Item",
              "Unable to add punchlist item. Please try again.",
              0
            );
          }
          // Re-enable button
          saveBtn.disabled = false;
          saveBtn.innerHTML = '<i class="bx bx-check"></i> Save Item';
        }
      });
    }
  }

  // Delete callback for punchlist items
  window.handlePunchlistDelete = async (itemId) => {
    try {
      // Remove item from array
      punchlistItems = punchlistItems.filter((item) => item.id !== itemId);

      // Re-render the list
      await renderPunchlistItems();
      await updateIncompletePunchlistItemsCount();

      if (window.showSuccess) {
        window.showSuccess("Item Deleted", "Punchlist item deleted successfully", 3000);
      }
    } catch (error) {
      console.error("Error handling punchlist delete:", error);
      // Reload items to ensure consistency
      await loadPunchlistItems(currentProjectId);
      await renderPunchlistItems();
    }
  };

  // Initialize delete confirm buttons for punchlist
  function initDeleteConfirmButtons() {
    console.log("[PUNCHLIST-DELETE] üöÄ Initializing delete confirm buttons...");

    const activeTimeouts = new Map();

    // Check for existing listener to avoid duplicates
    if (window.__deleteButtonListenerAdded) {
      console.log("[PUNCHLIST-DELETE] Listener already added, skipping");
      return;
    }
    window.__deleteButtonListenerAdded = true;

    // Add click listener
    document.addEventListener("click", async (e) => {
      const target = e.target;
      const button = target.closest(".delete-confirm-btn");

      if (!button) return;

      // Only handle punchlist delete buttons
      if (!button.id || !button.id.includes("delete-punchlist")) {
        console.log("[PUNCHLIST-DELETE] Not a punchlist delete button, ignoring");
        return;
      }

      console.log("[PUNCHLIST-DELETE] ‚úÖ Punchlist delete button clicked:", button.id);

      const buttonId = button.id;
      const timeout = parseInt(button.dataset.timeout || "3000", 10);
      const currentState = button.getAttribute("data-state") || "trash";
      const apiEndpoint = button.dataset.apiEndpoint;
      const callbackName = button.dataset.callback;
      const itemType = button.dataset.itemType;

      console.log("[PUNCHLIST-DELETE] State:", currentState, "API:", apiEndpoint);

      if (currentState === "trash") {
        // First click
        e.stopPropagation();
        console.log("[PUNCHLIST-DELETE] üéØ FIRST CLICK - showing confirm state");

        // Find the wrapper and timer ring
        const wrapper = button.closest(".delete-confirm-wrapper");
        const timerRing = wrapper?.querySelector(".timer-ring-overlay");
        const timerCircle = timerRing?.querySelector(".timer-icon-test");

        if (timerCircle) {
          console.log("[PUNCHLIST-DELETE] Resetting timer animation");
          // Reset animation
          timerCircle.classList.remove("timer-icon-test");
          void timerCircle.offsetWidth; // Force reflow
          timerCircle.classList.add("timer-icon-test");
        }

        button.setAttribute("data-state", "confirm");
        button.title = "Click again to confirm deletion";

        // Change icon to stopwatch
        const iconElement = button.querySelector(".delete-confirm-icon");
        if (iconElement) {
          console.log("[PUNCHLIST-DELETE] Changing icon to stopwatch");
          iconElement.outerHTML = `<svg class="inline-block stopwatch-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="13" r="8"/>
            <path d="M12 9v4l2 2"/>
            <path d="M10 2h4"/>
          </svg>`;
        }

        // Clear any existing timeout
        if (activeTimeouts.has(buttonId)) {
          clearTimeout(activeTimeouts.get(buttonId));
        }

        // Auto-revert after timeout
        const timeoutId = setTimeout(() => {
          if (button.getAttribute("data-state") === "confirm") {
            console.log("[PUNCHLIST-DELETE] ‚è∞ Timeout expired, reverting");
            resetButton(button);
            activeTimeouts.delete(buttonId);
          }
        }, timeout);

        activeTimeouts.set(buttonId, timeoutId);
        console.log("[PUNCHLIST-DELETE] ‚úÖ Waiting for confirmation...");
      } else if (currentState === "confirm") {
        // Second click
        e.stopPropagation();
        console.log("[PUNCHLIST-DELETE] üéØ SECOND CLICK - executing deletion");

        // Clear timeout
        if (activeTimeouts.has(buttonId)) {
          clearTimeout(activeTimeouts.get(buttonId));
          activeTimeouts.delete(buttonId);
        }

        // Reset button immediately
        resetButton(button);

        button.setAttribute("disabled", "true");

        // Extract item ID from button ID (format: delete-punchlist-{id})
        const itemIdMatch = buttonId.match(/delete-punchlist-(\d+)$/);
        const itemId = itemIdMatch ? parseInt(itemIdMatch[1], 10) : null;

        console.log("[PUNCHLIST-DELETE] Extracted item ID:", itemId);

        if (!itemId) {
          console.error("[PUNCHLIST-DELETE] ‚ùå Could not extract item ID from:", buttonId);
          button.removeAttribute("disabled");
          if (window.showNotice) {
            window.showNotice("error", "Delete Failed", "Invalid item ID");
          }
          return;
        }

        if (apiEndpoint) {
          try {
            console.log("[PUNCHLIST-DELETE] üì° Calling API:", apiEndpoint);

            const response = await fetch(apiEndpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              credentials: "include",
              body: JSON.stringify({
                itemId: itemId,
              }),
            });

            const data = await response.json();
            console.log("[PUNCHLIST-DELETE] Response:", data);

            if (data.success || response.ok) {
              console.log("[PUNCHLIST-DELETE] ‚úÖ API call successful");

              // Call callback
              if (callbackName && typeof window[callbackName] === "function") {
                console.log("[PUNCHLIST-DELETE] üìû Calling callback:", callbackName);
                await window[callbackName](itemId);
              }
            } else {
              console.error("[PUNCHLIST-DELETE] ‚ùå API error:", data.error);
              if (window.showNotice) {
                window.showNotice("error", "Delete Failed", data.error || "Failed to delete");
              }
            }
          } catch (error) {
            console.error("[PUNCHLIST-DELETE] ‚ùå Exception:", error);
            if (window.showNotice) {
              window.showNotice("error", "Delete Failed", "An error occurred");
            }
          } finally {
            button.removeAttribute("disabled");
          }
        }
      }
    });

    // Helper function to reset button to initial state
    function resetButton(button) {
      button.setAttribute("data-state", "trash");
      button.title = "Delete punchlist item";

      // Restore trash icon
      const stopwatchIcon = button.querySelector(".stopwatch-icon");
      if (stopwatchIcon) {
        stopwatchIcon.outerHTML = `<svg class="inline-block delete-confirm-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 6h18"></path>
          <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
          <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
          <path d="M10 11v6"></path>
          <path d="M14 11v6"></path>
        </svg>`;
      }
    }

    console.log("[PUNCHLIST-DELETE] ‚úÖ Click listener attached");
  }
</script>
