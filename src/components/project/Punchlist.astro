---
interface Props {
  currentUser?: any;
  project: any;
  supabaseUrl?: string;
}

const { currentUser, project, supabaseUrl } = Astro.props;
const id = Astro.params.id;

const currentRole = currentUser?.profile?.role;

if (!project || !project.id || currentRole === "Client") {
  return null;
}

const projectId = project.id;
import BoxIcon from "../common/BoxIcon.astro";

// console.log("üîç [TabPunchlist] props:", Astro.props);
---

{
  projectId && (
    <div class="relative">
      <button type="button" data-dropdown-toggle="checklist-dropdown" class="relative">
        <span class="sr-only">View Checklist</span>

        <BoxIcon
          name="list-check"
          variant="secondary"
          size="md"
          dataAttributes={{ "data-count": "1" }}
        />
      </button>
      </div>

      <div
        class="z-50 my-4 hidden max-w-96 list-none overflow-hidden rounded-lg bg-gray-100 text-base leading-6 shadow-sm dark:bg-gray-700"
        id="checklist-dropdown"
        data-popper-placement="bottom left"
      >
        <div class="align-center flex justify-between border-b border-gray-200 bg-gray-100 px-4 py-2 text-center font-medium text-gray-900 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
          <h3>Project Checklist</h3>
        </div>

        <div class="grid max-h-[80dvh] gap-4 overflow-y-scroll p-4 dark:bg-gray-800 lg:grid-cols-1">
          <div id="content-punchlist">
            <div>
              <div id="punchlist-container" data-project-id={projectId}>
                <div class="mb-6 flex items-center justify-between overflow-y-scroll">
                  {/* <!-- Punchlist Items List --> */}
                  <div id="punchlist-items-list" class="space-y-4">
                    {/* <!-- Punchlist items will be dynamically loaded here --> */}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
  )
}

<script
  define:vars={{
    projectId,
    currentRole,
    currentUser,
    supabaseUrl,
  }}
  type="module"
>
  // Punchlist functionality
  let punchlistItems = [];
  let currentProjectId = projectId;
  let currentUserId = currentUser?.id;

  async function loadPunchlistItems(projectId) {
    try {
      // Fetch punchlist data directly
      const response = await fetch(`/api/get-punchlist?projectId=${projectId}`, {
        credentials: "include",
      });

      const data = await response.json();

      console.log("üîç [TabPunchlist] data:", data);
      if (data.success) {
        punchlistItems = data.punchlist;
        renderPunchlistItems();
        updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
      } else {
        console.error("Failed to load punchlist items:", data.error);

        // Show specific error message if table doesn't exist
        if (data.migration_needed || data.error?.includes("does not exist")) {
          showModal(
            "error",
            "Punchlist Setup Required",
            `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
          );
        } else {
          showModal(
            "error",
            "Punchlist Error",
            "Failed to load punchlist items: " + (data.details || data.error)
          );
        }
      }
    } catch (error) {
      console.error("Error loading punchlist items:", error);
      showPunchlistError("Failed to load punchlist items");
    }
  }

  // Update incomplete punchlist items count in the punchlist tab
  async function updateIncompletePunchlistItemsCount() {
    const incompleteCount = punchlistItems.filter((item) => !item.markCompleted).length;

    // Update count directly
    const countElement = document.querySelector(".incomplete-punchlist-items-count");
    const tabButton = document.querySelector('[data-dropdown-toggle="checklist-dropdown"]');

    if (tabButton) {
      // Update count bubble on tab button

      window.updateCountBubble(
        tabButton,
        incompleteCount,
        window.COUNT_BUBBLE_PRESETS.notification
      );

      // if (incompleteCount > 0) {
      //   tabButton.setAttribute("data-count", incompleteCount.toString());
      //   tabButton.classList.add("has-count");
      // } else {
      //   tabButton.removeAttribute("data-count");
      //   tabButton.classList.remove("has-count");
      // }
    }

    // Also update the old count element if it exists
    if (countElement) {
      if (incompleteCount > 0) {
        countElement.textContent = incompleteCount.toString();
        countElement.classList.remove("hidden");
      } else {
        countElement.classList.add("hidden");
      }
    }

    // console.log("üîç [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
  }

  async function renderPunchlistItems() {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (!punchlistItemsList) return;

    // Separate top-level items and replies
    const topLevelItems = punchlistItems.filter((d) => !d.parentId);
    let html = "";

    // Process items asynchronously
    for (const item of topLevelItems) {
      // Check if user can see this item

      html += await renderPunchlistItem(item, 0);

      // Find and render replies for this item
    }

    punchlistItemsList.innerHTML = html;

    // Load toggles for all items that can be toggled
    punchlistItems.forEach((item) => {
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      if (canToggleCompleted) {
        loadToggleForPunchlistItem(item.id, item.markCompleted, true);
      }
    });
  }

  async function renderPunchlistItem(item, depth = 0) {
    try {
      // Compute all values in the parent component
      const isInternal = item.internal;
      const isAuthor = item.authorId === currentUserId;
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
      const borderLeft = depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

      // Ensure item data is properly encoded to handle Unicode characters
      const itemData = encodeURIComponent(JSON.stringify(item));

      const headers = new Headers({
        "x-comment-data": itemData,
        "x-current-user-role": currentRole,
        "x-current-user-id": currentUserId,
        "x-supabase-url": supabaseUrl,
        "x-comment-depth": depth.toString(),
        "x-is-internal": isInternal.toString(),
        "x-is-author": isAuthor.toString(),
        "x-can-toggle-completed": canToggleCompleted.toString(),
        "x-margin-left": marginLeft,
        "x-border-left": borderLeft,
      });

      const response = await fetch("/partials/punchlist", {
        headers: headers,
      });

      if (response.ok) {
        return await response.text();
      } else {
        console.error("Failed to load punchlist item partial:", response.status);
        return `<div class="text-red-500">Failed to load punchlist item</div>`;
      }
    } catch (error) {
      console.error("Error loading punchlist item partial:", error);
      return `<div class="text-red-500">Error loading punchlist item</div>`;
    }
  }

  // Load toggle using SlideToggle partial
  async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
    if (!canToggle) return;

    try {
      // Handle null/undefined isCompleted values
      const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

      const headers = new Headers({
        "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
        // "x-toggle-label": completed ? "Completed" : "Incomplete",
        "x-toggle-label": "",
        // "x-toggle-icon": completed ? "bx-check-circle" : "",
        "x-toggle-color": "primary",
        "x-toggle-checked": completed.toString(),
        "x-toggle-class": "punchlist-completed-toggle",
        "x-toggle-data-discussion-id": itemId.toString(),
      });

      const response = await fetch("/partials/slide-toggle", {
        headers: headers,
      });

      if (response.ok) {
        const toggleHTML = await response.text();
        const container = document.getElementById(`toggle-container-${itemId}`);
        if (container) {
          container.innerHTML = toggleHTML;
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error loading toggle:", error);
    }
  }

  function showPunchlistError(message) {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (punchlistItemsList) {
      punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
    }
  }

  // Initialize punchlist functionality when punchlist tab is shown
  function initializePunchlist() {
    // Set user role from server-side data (already set via define:vars)
    // User role is already available from component props

    const punchlistContainer = document.getElementById("punchlist-container");
    if (punchlistContainer) {
      currentProjectId = punchlistContainer.dataset.projectId || "";
      if (currentProjectId) {
        loadPunchlistItems(currentProjectId);
      }
    }

    // Add event delegation for completed toggles
    document.addEventListener("change", (e) => {
      const target = e.target;
      if (target.classList.contains("punchlist-completed-toggle")) {
        const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
        const isCompleted = target.checked;
        if (punchlistId) {
          togglePunchlistCompleted(punchlistId, isCompleted);
        }
      }
    });

    console.log("üîî [PUNCHLIST] Event listeners attached");
  }

  // Toggle punchlist item completed status
  async function togglePunchlistCompleted(punchlistId, isCompleted) {
    try {
      console.log("üîî [PUNCHLIST] Toggling completed status:", {
        punchlistId,
        isCompleted,
      });

      const response = await fetch("/api/update-punchlist-completed", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({
          punchlistId: punchlistId,
          markCompleted: isCompleted,
        }),
      });

      const data = await response.json();

      if (data.success) {
        console.log("‚úÖ [PUNCHLIST] Punchlist item completed status updated successfully");
        // Update the local punchlist data
        const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
        if (punchlistItem) {
          punchlistItem.markCompleted = isCompleted;
        }

        // Update the incomplete punchlist items count
        updateIncompletePunchlistItemsCount();
        // Show success notification
        if (window.showModal) {
          window.showModal(
            "success",
            "Punchlist status updated",
            `Marked as ${isCompleted ? "completed" : "incomplete"}`,
            1500
          );
        }

        // Reload the toggle with the updated state
        loadToggleForPunchlistItem(punchlistId, isCompleted, true);
      } else {
        console.error("‚ùå [PUNCHLIST] Failed to update punchlist status:", data.error);
        // Revert the toggle to previous state
        loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
        // Show error notification
        if (window.showModal) {
          window.showModal("error", "Update Failed", "Failed to update punchlist status");
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error updating punchlist status:", error);
      // Revert the toggle to previous state
      loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
      // Show error notification
      if (window.showModal) {
        window.showModal("error", "Update Failed", "Error updating punchlist status");
      }
    }
  }

  // Initialize punchlist functionality when component loads
  document.addEventListener("DOMContentLoaded", function () {
    console.log("üîî [PUNCHLIST] Punchlist component loaded, initializing...");
    setTimeout(initializePunchlist, 100);
  });

  // Make initializePunchlist globally available for tab switching
  window.initializePunchlist = initializePunchlist;
</script>
