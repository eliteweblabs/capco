---
import SimpleIcon from "../common/SimpleIcon.astro";
import CloseButton from "../ui/CloseButton.astro";

interface Props {
  currentUser?: any;
  project: any;
  supabaseUrl?: string;
}

const { currentUser, project, supabaseUrl } = Astro.props;
const id = Astro.params.id;

const currentRole = currentUser?.profile?.role;

if (!project || !project.id || currentRole === "Client") {
  return null;
}

const projectId = project.id;

// console.log("üîç [TabPunchlist] props:", Astro.props);
---

{
  projectId && (
    <>
      <div class="relative">
        <button
          type="button"
          id="punchlist-drawer-toggle"
          class="inline-flex items-center rounded-full p-2 text-center text-sm font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-50 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white dark:focus:ring-gray-600"
        >
          <span class="sr-only">View Punchlist</span>

          <SimpleIcon name="menu-check" class="w-6 h-6" />
        </button>
      </div>

      {/* Backdrop overlay */}
      <div
        id="punchlist-drawer-backdrop"
        class="fixed inset-0 bg-gray-900/50 dark:bg-gray-900/80 z-40 hidden transition-opacity duration-300"
      />

      {/* Drawer */}
      <div
        id="punchlist-drawer"
        class="fixed top-0 -right-96 z-50 h-screen w-96 max-w-full transition-all duration-300 ease-in-out bg-white dark:bg-gray-800 shadow-xl"
        style="will-change: transform;"
      >
        <div class="flex flex-col h-full">
          {/* Header */}
          <div class="flex items-center justify-between border-b border-gray-200 bg-gray-100 px-4 py-3 dark:border-gray-600 dark:bg-gray-700">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Project Punchlist</h3>
            <CloseButton id="punchlist-drawer-close" tooltipText="Close drawer" position="left" />
          </div>

          {/* Content */}
          <div class="flex-1 overflow-y-auto p-4 color-background">
            <div id="content-punchlist">
              <div>
                <div id="punchlist-container" data-project-id={projectId}>
                  <div class="mb-6">
                    {/* <!-- Punchlist Items List --> */}
                    <div id="punchlist-items-list" class="space-y-4">
                      {/* <!-- Punchlist items will be dynamically loaded here --> */}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  )
}

<script
  define:vars={{
    projectId,
    currentRole,
    currentUser,
    supabaseUrl,
  }}
  type="module"
  is:inline
>
  // Punchlist functionality
  let punchlistItems = [];
  let currentProjectId = projectId;
  let currentUserId = currentUser?.id;

  async function loadPunchlistItems(projectId) {
    try {
      // Fetch punchlist data directly
      const response = await fetch(`/api/punchlist/get?projectId=${projectId}`, {
        credentials: "include",
      });

      const data = await response.json();

      console.log("üîç [TabPunchlist] data:", data);
      if (data.success) {
        punchlistItems = data.punchlist;
        renderPunchlistItems();
        updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
      } else {
        console.error("Failed to load punchlist items:", data.error);

        // Show specific error message if table doesn't exist
        if (data.migration_needed || data.error?.includes("does not exist")) {
          showNotice(
            "error",
            "Punchlist Setup Required",
            `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
          );
        } else {
          showNotice(
            "error",
            "Punchlist Error",
            "Failed to load punchlist items: " + (data.details || data.error)
          );
        }
      }
    } catch (error) {
      console.error("Error loading punchlist items:", error);
      showPunchlistError("Failed to load punchlist items");
    }
  }

  // Drawer functions
  function openDrawer() {
    const drawer = document.getElementById("punchlist-drawer");
    const backdrop = document.getElementById("punchlist-drawer-backdrop");

    if (drawer && backdrop) {
      backdrop.classList.remove("hidden");
      setTimeout(() => {
        backdrop.classList.add("opacity-100");
        drawer.classList.remove("-right-96");
        drawer.classList.add("right-0");
      }, 10);
    }
  }

  function closeDrawer() {
    const drawer = document.getElementById("punchlist-drawer");
    const backdrop = document.getElementById("punchlist-drawer-backdrop");

    if (drawer && backdrop) {
      drawer.classList.remove("right-0");
      drawer.classList.add("-right-96");
      backdrop.classList.remove("opacity-100");
      setTimeout(() => {
        backdrop.classList.add("hidden");
      }, 300);
    }
  }

  // Update incomplete punchlist items count in the punchlist tab
  async function updateIncompletePunchlistItemsCount() {
    const incompleteCount = punchlistItems.filter((item) => !item.markCompleted).length;

    // Update count directly
    const countElement = document.querySelector(".incomplete-punchlist-items-count");
    const tabButton = document.getElementById("punchlist-drawer-toggle");

    if (tabButton) {
      // Update count bubble on tab button

      window.updateCountBubble(
        tabButton,
        incompleteCount,
        window.COUNT_BUBBLE_PRESETS.notification
      );

      // if (incompleteCount > 0) {
      //   tabButton.setAttribute("data-count", incompleteCount.toString());
      //   tabButton.classList.add("has-count");
      // } else {
      //   tabButton.removeAttribute("data-count");
      //   tabButton.classList.remove("has-count");
      // }
    }

    // Also update the old count element if it exists
    if (countElement) {
      if (incompleteCount > 0) {
        countElement.textContent = incompleteCount.toString();
        countElement.classList.remove("hidden");
      } else {
        countElement.classList.add("hidden");
      }
    }

    // console.log("üîç [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
  }

  async function renderPunchlistItems() {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (!punchlistItemsList) return;

    // Separate top-level items and replies
    const topLevelItems = punchlistItems.filter((d) => !d.parentId);
    let html = "";

    // Process items asynchronously
    for (const item of topLevelItems) {
      // Check if user can see this item

      html += await renderPunchlistItem(item, 0);

      // Find and render replies for this item
    }

    punchlistItemsList.innerHTML = html;

    // Load toggles for all items that can be toggled
    punchlistItems.forEach((item) => {
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      if (canToggleCompleted) {
        loadToggleForPunchlistItem(item.id, item.markCompleted, true);
      }
    });
  }

  async function renderPunchlistItem(item, depth = 0) {
    try {
      // Compute all values in the parent component
      const isInternal = item.internal;
      const isAuthor = item.authorId === currentUserId;
      const canToggleCompleted = currentRole === "Admin" || currentRole === "Staff";

      const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
      const borderLeft = depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

      // Ensure item data is properly encoded to handle Unicode characters
      const itemData = encodeURIComponent(JSON.stringify(item));

      const headers = new Headers({
        "x-comment-data": itemData,
        "x-current-user-role": currentRole,
        "x-current-user-id": currentUserId,
        "x-supabase-url": supabaseUrl,
        "x-comment-depth": depth.toString(),
        "x-is-internal": isInternal.toString(),
        "x-is-author": isAuthor.toString(),
        "x-can-toggle-completed": canToggleCompleted.toString(),
        "x-margin-left": marginLeft,
        "x-border-left": borderLeft,
      });

      const response = await fetch("/partials/punchlist", {
        headers: headers,
      });

      if (response.ok) {
        return await response.text();
      } else {
        console.error("Failed to load punchlist item partial:", response.status);
        return `<div class="text-red-500">Failed to load punchlist item</div>`;
      }
    } catch (error) {
      console.error("Error loading punchlist item partial:", error);
      return `<div class="text-red-500">Error loading punchlist item</div>`;
    }
  }

  // Load toggle using SlideToggle partial
  async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
    if (!canToggle) return;

    try {
      // Handle null/undefined isCompleted values
      const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

      const headers = new Headers({
        "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
        // "x-toggle-label": completed ? "Completed" : "Incomplete",
        "x-toggle-label": "",
        // "x-toggle-icon": completed ? "check-circle" : "",
        "x-toggle-color": "primary",
        "x-toggle-checked": completed.toString(),
        "x-toggle-class": "punchlist-completed-toggle",
        "x-toggle-data-discussion-id": itemId.toString(),
      });

      const response = await fetch("/partials/slide-toggle", {
        headers: headers,
      });

      if (response.ok) {
        const toggleHTML = await response.text();
        const container = document.getElementById(`toggle-container-${itemId}`);
        if (container) {
          container.innerHTML = toggleHTML;
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error loading toggle:", error);
    }
  }

  function showPunchlistError(message) {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (punchlistItemsList) {
      punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <SimpleIcon name="alert-circle" class="mx-auto mb-4 text-4xl" />
          <p>${message}</p>
        </div>
      `;
    }
  }

  // Initialize punchlist functionality when punchlist tab is shown
  function initializePunchlist() {
    // Set user role from server-side data (already set via define:vars)
    // User role is already available from component props

    const punchlistContainer = document.getElementById("punchlist-container");
    if (punchlistContainer) {
      currentProjectId = punchlistContainer.dataset.projectId || "";
      if (currentProjectId) {
        loadPunchlistItems(currentProjectId);
      }
    }

    // Add event delegation for completed toggles
    document.addEventListener("change", (e) => {
      const target = e.target;
      if (target.classList.contains("punchlist-completed-toggle")) {
        const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
        const isCompleted = target.checked;
        if (punchlistId) {
          togglePunchlistCompleted(punchlistId, isCompleted);
        }
      }
    });

    console.log("üîî [PUNCHLIST] Event listeners attached");
  }

  // Toggle punchlist item completed status
  async function togglePunchlistCompleted(punchlistId, isCompleted) {
    try {
      console.log("üîî [PUNCHLIST] Toggling completed status:", {
        punchlistId,
        isCompleted,
      });

      const response = await fetch("/api/punchlist/upsert", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({
          punchlistId: punchlistId,
          markCompleted: isCompleted,
        }),
      });

      const data = await response.json();

      if (data.success) {
        console.log("‚úÖ [PUNCHLIST] Punchlist item completed status updated successfully");
        // Update the local punchlist data
        const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
        if (punchlistItem) {
          punchlistItem.markCompleted = isCompleted;
        }

        // Update the incomplete punchlist items count
        updateIncompletePunchlistItemsCount();
        // Show success notification
        if (window.showNotice) {
          window.showNotice(
            "success",
            "Punchlist status updated",
            `Marked as ${isCompleted ? "completed" : "incomplete"}`,
            1500
          );
        }

        // Reload the toggle with the updated state
        loadToggleForPunchlistItem(punchlistId, isCompleted, true);
      } else {
        console.error("‚ùå [PUNCHLIST] Failed to update punchlist status:", data.error);
        // Revert the toggle to previous state
        loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
        // Show error notification
        if (window.showNotice) {
          window.showNotice("error", "Update Failed", "Failed to update punchlist status");
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error updating punchlist status:", error);
      // Revert the toggle to previous state
      loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
      // Show error notification
      if (window.showNotice) {
        window.showNotice("error", "Update Failed", "Error updating punchlist status");
      }
    }
  }

  // Initialize punchlist functionality when component loads
  document.addEventListener("DOMContentLoaded", function () {
    console.log("üîî [PUNCHLIST] Punchlist component loaded, initializing...");
    setTimeout(initializePunchlist, 100);

    // Setup drawer toggle button
    const drawerToggle = document.getElementById("punchlist-drawer-toggle");
    if (drawerToggle) {
      drawerToggle.addEventListener("click", openDrawer);
    }

    // Setup drawer close button
    const drawerClose = document.getElementById("punchlist-drawer-close");
    if (drawerClose) {
      drawerClose.addEventListener("click", closeDrawer);
    }

    // Setup backdrop click to close
    const backdrop = document.getElementById("punchlist-drawer-backdrop");
    if (backdrop) {
      backdrop.addEventListener("click", closeDrawer);
    }

    // Close drawer on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        closeDrawer();
      }
    });

    // Swipe to close functionality for punchlist drawer
    const drawer = document.getElementById("punchlist-drawer");
    if (drawer) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      let isDragging = false;
      let currentTranslateX = 0;

      drawer.addEventListener("touchstart", (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isDragging = true;
        drawer.style.transition = "none";
      });

      drawer.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Only respond to horizontal swipes (right, to close)
        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {
          currentTranslateX = deltaX;
          drawer.style.transform = `translateX(${deltaX}px)`;
        }
      });

      drawer.addEventListener("touchend", (e) => {
        if (!isDragging) return;

        isDragging = false;
        drawer.style.transition = "";
        drawer.style.transform = "";

        const swipeThreshold = 100; // minimum swipe distance in pixels

        // If swiped right more than threshold, close drawer
        if (currentTranslateX > swipeThreshold) {
          closeDrawer();
        }

        currentTranslateX = 0;
        touchStartX = 0;
        touchStartY = 0;
        touchEndX = 0;
        touchEndY = 0;
      });
    }
  });

  // Make initializePunchlist globally available for tab switching
  window.initializePunchlist = initializePunchlist;
</script>
