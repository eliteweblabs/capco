---
interface Props {
  currentUser?: any;
  project: any;
  supabaseUrl?: string;
}

const { currentUser, project, supabaseUrl } = Astro.props;
const id = Astro.params.id;
const isAuth = currentUser ? true : false;

if (!project || !project.id) {
  return null;
}

const projectId = project.id;
const currentRole = currentUser?.role;
import BoxIcon from "../common/BoxIcon.astro";

console.log("üîç [TabPunchlist] props:", Astro.props);
---

{
  isAuth && id && (
    <div class="YRrCJSr_j5nopfm4duUc Q_jg_EPdNf9eDMn1mLI2 WD962RTivt8M5sMg7WrS">
      <div class="YRrCJSr_j5nopfm4duUc Q_jg_EPdNf9eDMn1mLI2 R0X5VtiZIoV7IjvrxBJ_ tS181Wfa_gkJpFt03pqL">
        <button
          type="button"
          data-dropdown-toggle="notification-dropdown"
          class="mveJTCIb2WII7J4sY22F Z4DH5a4vmjReSFRBpPgz PeR2JZ9BZHYIH8Ea3F36 _7KA5gD55t2lxf9Jkj20 ZnBoTVi7VOJdCLSSU62n _q0p_O8QLU1paqtuqmI2 KLtw3_OqL54e_zEQU_yi XIIs8ZOri3wm8Wnj9N_y OPrb_iG5WDy_7F05BDOX dMTOiA3mf3FTjlHu6DqW ICV24pqO8p1LJm4GEOgS"
        >
          <span class="_DVAfiyo21kM68EUVzEQ">View notifications</span>

          <BoxIcon name="checklist" variant="outline" size="md" />
        </button>

        {/* {!id && isBackend && ( */}
        <div
          class="Jq3rRDG6Hsr3eAZ0KJeH aJF41JQLhtfw_MCGt5Th _Vb9igHms0hI1PQcvp_S _SmdlCf6eUKB_V9S5IDj ZhzOGpbwY0R4TKKYr5pG Zy1Pypi71Xu6guex6urN NIAblPiyeuYQ0zW671xb wBVMFkIGfrKshbvi2gS1 mveJTCIb2WII7J4sY22F _Ybd3WwuTVljUT4vEaM3 mfNtySJCsKVaP2xnoGBY PoeKYEQfG4WfmL9xM6vu jqg6J89cvxmDiFpnV56r"
          id="notification-dropdown"
          data-popper-placement="bottom"
        >
          <div id="content-punchlist">
            <div>
              <div id="punchlist-container" data-project-id={projectId}>
                <div class="mb-6 flex items-center justify-between">
                  <h3 class="text-lg font-medium text-gray-900 dark:text-white">
                    Project Checklist
                  </h3>
                </div>

                {/* <!-- Punchlist Items List --> */}
                <div id="punchlist-items-list" class="space-y-4">
                  {/* <!-- Punchlist items will be dynamically loaded here --> */}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

<script
  define:vars={{
    projectId,
    currentRole,
    currentUser,
    supabaseUrl,
  }}
  type="module"
>
  // Punchlist functionality
  let punchlistItems = [];
  let currentProjectId = projectId;
  let currentUserRole = currentRole;
  let currentUserId = currentUser?.id;

  // console.log("üîî [PUNCHLIST] Initial userRole:", currentUserRole);

  // Make user role available globally for reply forms
  window.currentUserRole = currentUserRole;
  window.PROJECT_USER_ROLE = currentUserRole;

  async function loadPunchlistItems(projectId) {
    try {
      const response = await fetch(`/api/get-project-punchlist?projectId=${projectId}`, {
        credentials: "include",
      });
      const data = await response.json();

      console.log("üîç [TabPunchlist] data:", data);
      if (data.success) {
        punchlistItems = data.punchlist;
        renderPunchlistItems();
        updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
      } else {
        console.error("Failed to load punchlist items:", data.error);

        // Show specific error message if table doesn't exist
        if (data.migration_needed || data.error?.includes("does not exist")) {
          showPunchlistError(
            `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
          );
        } else {
          showPunchlistError("Failed to load punchlist items: " + (data.details || data.error));
        }
      }
    } catch (error) {
      console.error("Error loading punchlist items:", error);
      showPunchlistError("Failed to load punchlist items");
    }
  }

  // Update incomplete punchlist items count in the punchlist tab
  function updateIncompletePunchlistItemsCount() {
    const incompleteCount = punchlistItems.filter((item) => !item.mark_completed).length;
    const countElement = document.querySelector(".incomplete-punchlist-items-count");
    const tabButton = document.getElementById("status-punchlist");

    if (tabButton) {
      // Create or update count bubble
      let countBubble = tabButton.querySelector(".punchlist-count-bubble");

      if (incompleteCount > 0) {
        if (!countBubble) {
          // Create count bubble if it doesn't exist
          countBubble = document.createElement("span");
          countBubble.className =
            "punchlist-count-bubble absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full border border-primary-500 bg-white text-xs font-medium text-primary-500 dark:border-primary-400 dark:bg-background-dark dark:text-primary-400";
          tabButton.style.position = "relative";
          tabButton.appendChild(countBubble);
        }
        countBubble.textContent = incompleteCount.toString();
        countBubble.style.display = "flex";
        tabButton.setAttribute("data-count", incompleteCount.toString());
      } else {
        if (countBubble) {
          countBubble.style.display = "none";
        }
        tabButton.setAttribute("data-count", "0");
      }

      // Also update the old count element if it exists
      if (countElement) {
        if (incompleteCount > 0) {
          countElement.textContent = incompleteCount.toString();
          countElement.classList.remove("hidden");
        } else {
          countElement.classList.add("hidden");
        }
      }

      // console.log("üîç [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
    }
  }

  async function renderPunchlistItems() {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (!punchlistItemsList) return;

    // Separate top-level items and replies
    const topLevelItems = punchlistItems.filter((d) => !d.parent_id);
    let html = "";

    // Process items asynchronously
    for (const item of topLevelItems) {
      // Check if user can see this item

      html += await renderPunchlistItem(item, 0);

      // Find and render replies for this item
    }

    punchlistItemsList.innerHTML = html;

    // Load toggles for all items that can be toggled
    punchlistItems.forEach((item) => {
      const canToggleCompleted =
        currentUserRole === "Admin" ||
        currentUserRole === "Staff" ||
        item.author_id === currentUserId;

      if (canToggleCompleted) {
        loadToggleForPunchlistItem(item.id, item.mark_completed, true);
      }
    });
  }

  async function renderPunchlistItem(item, depth = 0) {
    try {
      // Compute all values in the parent component
      const isInternal = item.internal;
      const isAuthor = item.author_id === currentUserId;
      const canToggleCompleted =
        currentUserRole === "Admin" || currentUserRole === "Staff" || isAuthor;

      const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
      const borderLeft = depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

      // Ensure item data is properly encoded to handle Unicode characters
      const itemData = encodeURIComponent(JSON.stringify(item));

      const headers = new Headers({
        "x-comment-data": itemData,
        "x-current-user-role": currentUserRole,
        "x-current-user-id": currentUserId,
        "x-supabase-url": supabaseUrl,
        "x-comment-depth": depth.toString(),
        "x-is-internal": isInternal.toString(),
        "x-is-author": isAuthor.toString(),
        "x-can-toggle-completed": canToggleCompleted.toString(),
        "x-margin-left": marginLeft,
        "x-border-left": borderLeft,
      });

      const response = await fetch("/partials/comment", {
        headers: headers,
      });

      if (response.ok) {
        return await response.text();
      } else {
        console.error("Failed to load punchlist item partial:", response.status);
        return `<div class="text-red-500">Failed to load punchlist item</div>`;
      }
    } catch (error) {
      console.error("Error loading punchlist item partial:", error);
      return `<div class="text-red-500">Error loading punchlist item</div>`;
    }
  }

  // Load toggle using SlideToggle partial
  async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
    if (!canToggle) return;

    try {
      // Handle null/undefined isCompleted values
      const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

      const headers = new Headers({
        "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
        // "x-toggle-label": completed ? "Completed" : "Incomplete",
        "x-toggle-label": "",
        // "x-toggle-icon": completed ? "bx-check-circle" : "",
        "x-toggle-color": "green",
        "x-toggle-checked": completed.toString(),
        "x-toggle-class": "punchlist-completed-toggle",
        "x-toggle-data-discussion-id": itemId.toString(),
      });

      const response = await fetch("/partials/slide-toggle", {
        headers: headers,
      });

      if (response.ok) {
        const toggleHTML = await response.text();
        const container = document.getElementById(`toggle-container-${itemId}`);
        if (container) {
          container.innerHTML = toggleHTML;
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error loading toggle:", error);
    }
  }

  function showPunchlistError(message) {
    const punchlistItemsList = document.getElementById("punchlist-items-list");
    if (punchlistItemsList) {
      punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
    }
  }

  // Initialize punchlist functionality when punchlist tab is shown
  function initializePunchlist() {
    // Set user role from server-side data (already set via define:vars)
    currentUserRole = window.PROJECT_USER_ROLE || "Client";
    console.log("üîî [PUNCHLIST] User role set to:", currentUserRole);

    // Make user role available globally for reply forms
    window.currentUserRole = currentUserRole;

    const punchlistContainer = document.getElementById("punchlist-container");
    if (punchlistContainer) {
      currentProjectId = punchlistContainer.dataset.projectId || "";
      if (currentProjectId) {
        loadPunchlistItems(currentProjectId);
      }
    }

    // Add event delegation for completed toggles
    document.addEventListener("change", (e) => {
      const target = e.target;
      if (target.classList.contains("punchlist-completed-toggle")) {
        const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
        const isCompleted = target.checked;
        if (punchlistId) {
          togglePunchlistCompleted(punchlistId, isCompleted);
        }
      }
    });

    console.log("üîî [PUNCHLIST] Event listeners attached");
  }

  // Toggle punchlist item completed status
  async function togglePunchlistCompleted(punchlistId, isCompleted) {
    try {
      console.log("üîî [PUNCHLIST] Toggling completed status:", {
        punchlistId,
        isCompleted,
      });

      const response = await fetch("/api/update-punchlist-completed", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({
          punchlistId: punchlistId,
          mark_completed: isCompleted,
        }),
      });

      const data = await response.json();

      if (data.success) {
        console.log("‚úÖ [PUNCHLIST] Punchlist item completed status updated successfully");
        // Update the local punchlist data
        const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
        if (punchlistItem) {
          punchlistItem.mark_completed = isCompleted;
        }

        // Update the incomplete punchlist items count
        updateIncompletePunchlistItemsCount();
        // Show success notification
        if (window.showModal) {
          window.showModal(
            "success",
            "Punchlist status updated",
            `Marked as ${isCompleted ? "completed" : "incomplete"}`,
            1500
          );
        }

        // Reload the toggle with the updated state
        loadToggleForPunchlistItem(punchlistId, isCompleted, true);
      } else {
        console.error("‚ùå [PUNCHLIST] Failed to update punchlist status:", data.error);
        // Revert the toggle to previous state
        loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
        // Show error notification
        if (window.showModal) {
          window.showModal("error", "Update Failed", "Failed to update punchlist status");
        }
      }
    } catch (error) {
      console.error("‚ùå [PUNCHLIST] Error updating punchlist status:", error);
      // Revert the toggle to previous state
      loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
      // Show error notification
      if (window.showModal) {
        window.showModal("error", "Update Failed", "Error updating punchlist status");
      }
    }
  }

  // Initialize punchlist functionality when component loads
  document.addEventListener("DOMContentLoaded", function () {
    console.log("üîî [PUNCHLIST] Punchlist component loaded, initializing...");
    setTimeout(initializePunchlist, 100);
  });

  // Make initializePunchlist globally available for tab switching
  window.initializePunchlist = initializePunchlist;
</script>
