---
interface Props {
  currentRole?: string;
  currentUser?: any;
  project: any;
  projectId: string;
  supabaseUrl?: string;
}

const { currentRole, currentUser, supabaseUrl, project } = Astro.props;

const projectId = project.id;
const placeholder =
  currentRole === "Admin" || currentRole === "Staff"
    ? "Write your punchlist item here... (Use @username to mention users)"
    : "Write your punchlist item here...";

// console.log("üîç [TabPunchlist] props:", Astro.props);
---

<div id="content-punchlist">
  <div>
    <div id="punchlist-container" data-project-id={projectId}>
      <div class="mb-6 flex items-center justify-between">
        <h3 class="text-lg font-medium text-gray-900 dark:text-white">Project Punchlist</h3>
      </div>

      <!-- Punchlist Items List -->
      <div id="punchlist-items-list" class="space-y-4">
        <!-- Punchlist items will be dynamically loaded here -->
      </div>
      <div>
        <script
          define:vars={{
            projectId,
            currentRole,
            currentUser,
            supabaseUrl,
          }}
          type="module"
        >
          // Punchlist functionality
          let punchlistItems = [];
          let currentProjectId = projectId;
          let currentUserRole = currentRole;
          let currentUserId = currentUser?.id;

          // console.log("üîî [PUNCHLIST] Initial userRole:", currentUserRole);

          // Make user role available globally for reply forms
          window.currentUserRole = currentUserRole;
          window.PROJECT_USER_ROLE = currentUserRole;

          async function loadPunchlistItems(projectId) {
            try {
              const response = await fetch(`/api/get-project-punchlist?projectId=${projectId}`, {
                credentials: "include",
              });
              const data = await response.json();

              console.log("üîç [TabPunchlist] data:", data);
              if (data.success) {
                punchlistItems = data.punchlist;
                renderPunchlistItems();
                updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
              } else {
                console.error("Failed to load punchlist items:", data.error);

                // Show specific error message if table doesn't exist
                if (data.migration_needed || data.error?.includes("does not exist")) {
                  showPunchlistError(
                    `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
                  );
                } else {
                  showPunchlistError(
                    "Failed to load punchlist items: " + (data.details || data.error)
                  );
                }
              }
            } catch (error) {
              console.error("Error loading punchlist items:", error);
              showPunchlistError("Failed to load punchlist items");
            }
          }

          // Update incomplete punchlist items count in the punchlist tab
          function updateIncompletePunchlistItemsCount() {
            const incompleteCount = punchlistItems.filter((item) => !item.mark_completed).length;
            const countElement = document.querySelector(".incomplete-punchlist-items-count");
            const tabButton = document.getElementById("status-punchlist");

            if (tabButton) {
              // Create or update count bubble
              let countBubble = tabButton.querySelector(".punchlist-count-bubble");

              if (incompleteCount > 0) {
                if (!countBubble) {
                  // Create count bubble if it doesn't exist
                  countBubble = document.createElement("span");
                  countBubble.className =
                    "punchlist-count-bubble absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full border border-primary-500 bg-white text-xs font-medium text-primary-500 dark:border-primary-400 dark:bg-background-dark dark:text-primary-400";
                  tabButton.style.position = "relative";
                  tabButton.appendChild(countBubble);
                }
                countBubble.textContent = incompleteCount.toString();
                countBubble.style.display = "flex";
                tabButton.setAttribute("data-count", incompleteCount.toString());
              } else {
                if (countBubble) {
                  countBubble.style.display = "none";
                }
                tabButton.setAttribute("data-count", "0");
              }

              // Also update the old count element if it exists
              if (countElement) {
                if (incompleteCount > 0) {
                  countElement.textContent = incompleteCount.toString();
                  countElement.classList.remove("hidden");
                } else {
                  countElement.classList.add("hidden");
                }
              }

              // console.log("üîç [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
            }
          }

          async function renderPunchlistItems() {
            const punchlistItemsList = document.getElementById("punchlist-items-list");
            if (!punchlistItemsList) return;

            // Separate top-level items and replies
            const topLevelItems = punchlistItems.filter((d) => !d.parent_id);
            let html = "";

            // Process items asynchronously
            for (const item of topLevelItems) {
              // Check if user can see this item

              html += await renderPunchlistItem(item, 0);

              // Find and render replies for this item
            }

            punchlistItemsList.innerHTML = html;

            // Load toggles for all items that can be toggled
            punchlistItems.forEach((item) => {
              const canToggleCompleted =
                currentUserRole === "Admin" ||
                currentUserRole === "Staff" ||
                item.author_id === currentUserId;

              if (canToggleCompleted) {
                loadToggleForPunchlistItem(item.id, item.mark_completed, true);
              }
            });
          }

          async function renderPunchlistItem(item, depth = 0) {
            try {
              // Compute all values in the parent component
              const isInternal = item.internal;
              const isAuthor = item.author_id === currentUserId;
              const canToggleCompleted =
                currentUserRole === "Admin" || currentUserRole === "Staff" || isAuthor;

              const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
              const borderLeft =
                depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

              // Ensure item data is properly encoded to handle Unicode characters
              const itemData = encodeURIComponent(JSON.stringify(item));

              const headers = new Headers({
                "x-comment-data": itemData,
                "x-current-user-role": currentUserRole,
                "x-current-user-id": currentUserId,
                "x-supabase-url": supabaseUrl,
                "x-comment-depth": depth.toString(),
                "x-is-internal": isInternal.toString(),
                "x-is-author": isAuthor.toString(),
                "x-can-toggle-completed": canToggleCompleted.toString(),

                "x-margin-left": marginLeft,
                "x-border-left": borderLeft,
              });

              const response = await fetch("/partials/comment", {
                headers: headers,
              });

              if (response.ok) {
                return await response.text();
              } else {
                console.error("Failed to load punchlist item partial:", response.status);
                return `<div class="text-red-500">Failed to load punchlist item</div>`;
              }
            } catch (error) {
              console.error("Error loading punchlist item partial:", error);
              return `<div class="text-red-500">Error loading punchlist item</div>`;
            }
          }

          // Load toggle using SlideToggle partial
          async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
            if (!canToggle) return;

            try {
              // Handle null/undefined isCompleted values
              const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

              const headers = new Headers({
                "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
                // "x-toggle-label": completed ? "Completed" : "Incomplete",
                "x-toggle-label": "",
                // "x-toggle-icon": completed ? "bx-check-circle" : "",
                "x-toggle-color": "green",
                "x-toggle-checked": completed.toString(),
                "x-toggle-class": "punchlist-completed-toggle",
                "x-toggle-data-discussion-id": itemId.toString(),
              });

              const response = await fetch("/partials/slide-toggle", {
                headers: headers,
              });

              if (response.ok) {
                const toggleHTML = await response.text();
                const container = document.getElementById(`toggle-container-${itemId}`);
                if (container) {
                  container.innerHTML = toggleHTML;
                }
              }
            } catch (error) {
              console.error("‚ùå [PUNCHLIST] Error loading toggle:", error);
            }
          }

          function showPunchlistError(message) {
            const punchlistItemsList = document.getElementById("punchlist-items-list");
            if (punchlistItemsList) {
              punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
            }
          }

          // Initialize punchlist functionality when punchlist tab is shown
          function initializePunchlist() {
            // Set user role from server-side data (already set via define:vars)
            currentUserRole = window.PROJECT_USER_ROLE || "Client";
            console.log("üîî [PUNCHLIST] User role set to:", currentUserRole);

            // Make user role available globally for reply forms
            window.currentUserRole = currentUserRole;

            const punchlistContainer = document.getElementById("punchlist-container");
            if (punchlistContainer) {
              currentProjectId = punchlistContainer.dataset.projectId || "";
              if (currentProjectId) {
                loadPunchlistItems(currentProjectId);
              }
            }

            // Add event delegation for completed toggles
            document.addEventListener("change", (e) => {
              const target = e.target;
              if (target.classList.contains("punchlist-completed-toggle")) {
                const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
                const isCompleted = target.checked;
                if (punchlistId) {
                  togglePunchlistCompleted(punchlistId, isCompleted);
                }
              }
            });

            console.log("üîî [PUNCHLIST] Event listeners attached");
          }

          // Toggle punchlist item completed status
          async function togglePunchlistCompleted(punchlistId, isCompleted) {
            try {
              console.log("üîî [PUNCHLIST] Toggling completed status:", {
                punchlistId,
                isCompleted,
              });

              const response = await fetch("/api/update-punchlist-completed", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include",
                body: JSON.stringify({
                  punchlistId: punchlistId,
                  mark_completed: isCompleted,
                }),
              });

              const data = await response.json();

              if (data.success) {
                console.log("‚úÖ [PUNCHLIST] Punchlist item completed status updated successfully");
                // Update the local punchlist data
                const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
                if (punchlistItem) {
                  punchlistItem.mark_completed = isCompleted;
                }

                // Update the incomplete punchlist items count
                updateIncompletePunchlistItemsCount();
                // Show success notification
                if (window.showModal) {
                  window.showModal(
                    "success",
                    "Punchlist status updated",
                    `Marked as ${isCompleted ? "completed" : "incomplete"}`,
                    1500
                  );
                }

                // Reload the toggle with the updated state
                loadToggleForPunchlistItem(punchlistId, isCompleted, true);
              } else {
                console.error("‚ùå [PUNCHLIST] Failed to update punchlist status:", data.error);
                // Revert the toggle to previous state
                loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
                // Show error notification
                if (window.showModal) {
                  window.showModal("error", "Update Failed", "Failed to update punchlist status");
                }
              }
            } catch (error) {
              console.error("‚ùå [PUNCHLIST] Error updating punchlist status:", error);
              // Revert the toggle to previous state
              loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
              // Show error notification
              if (window.showModal) {
                window.showModal("error", "Update Failed", "Error updating punchlist status");
              }
            }
          }

          // Initialize punchlist functionality when component loads
          document.addEventListener("DOMContentLoaded", function () {
            console.log("üîî [PUNCHLIST] Punchlist component loaded, initializing...");
            setTimeout(initializePunchlist, 100);
          });

          // Make initializePunchlist globally available for tab switching
          window.initializePunchlist = initializePunchlist;
        </script>
      </div>
    </div>
  </div>
</div>
