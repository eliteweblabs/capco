---
import BoxIcon from "../common/BoxIcon.astro";
import Button from "../common/Button.astro";
import SlideToggle from "../common/SlideToggle.astro";
interface Props {
  authorProfile?: any;
  currentRole?: string;
  project: any;
  projectId: string;
  projectStatus?: number;
  projectStatusLabel?: string;

  fileType?: string;
}

const {
  project,
  currentRole,
  projectId,
  authorProfile,
  projectStatus,
  fileType = "media",
  projectStatusLabel,
} = Astro.props;
---

<div
  id="content-documents"
  class="tab-content hidden"
>
  {
    projectStatus === 10 ||
    projectStatus === 20 ||
    projectStatus === 30 ||
    projectStatus === 40 ||
    projectStatus === 50 ? (
      <>
        <div
          id="upload-dropzone"
          class="hidden cursor-pointer touch-manipulation rounded-lg border-2 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-blue-400 dark:border-gray-600 dark:hover:border-blue-500 md:block"
          style="min-height: 120px; -webkit-tap-highlight-color: transparent;"
        >
          <div class="space-y-4">
            <BoxIcon name="cloud-upload" class="bx-lg mx-auto" />
            <div>
              <p class="font-medium text-gray-600 dark:text-gray-300">
                Drop files here or click to browse
              </p>
              <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
                Upload supports PDF, images, CAD files, and documents (max 10MB each)
              </p>
            </div>
            <Button
              id="browse-files-btn"
              variant="primary"
              size="lg"
              icon="folder-open"
              iconPosition="left"
              class="hidden touch-manipulation md:inline-flex"
            >
              Browse Files
            </Button>
          </div>
        </div>

        <div class="hidden">
          <Button
            id="mobile-browse-files-btn"
            variant="primary"
            size="md"
            icon="folder-open"
            iconPosition="left"
            fullWidth
            class="touch-manipulation"
          >
            Browse Files
          </Button>
        </div>
      </>
    ) : null
  }

  <!-- Hidden file input -->
  <input
    type="file"
    id="file-input"
    multiple
    accept=".pdf,.png,.jpg,.jpeg,.gif,.webp,.dwg,.doc,.docx,.xls,.xlsx,.txt"
    class="hidden"
    capture="environment"
  />

  <!-- Upload Progress -->
  <div id="upload-progress" class="mt-4 hidden">
    <div class="h-2 rounded-lg bg-gray-200 dark:bg-gray-700">
      <div
        id="progress-bar"
        class="h-2 rounded-lg bg-blue-600 transition-all duration-300"
        style="width: 0%"
      >
      </div>
    </div>
    <p id="upload-status" class="mt-2 max-w-full truncate text-sm text-gray-600 dark:text-gray-400">
      Uploading...
    </p>
  </div>

  <!-- File List -->
  <div id="uploaded-files" class="mt-6 hidden">
    <div class="mb-3 hidden items-center justify-between md:flex">
      <h4 class="text-md flex items-center font-medium text-gray-900 dark:text-white">
        <BoxIcon name="file" class="mr-2" />
        Uploaded Files
      </h4>
      <div class="flex items-center space-x-3">
        <Button
          id="download-all-btn"
          variant="ghost"
          size="sm"
          icon="download"
          iconPosition="left"
          class="text-green-600 hover:text-green-800"
        >
          Download All
        </Button>
        <Button
          id="refresh-files-btn"
          variant="ghost"
          size="sm"
          icon="refresh"
          iconPosition="left"
          class="text-blue-600 hover:text-blue-800"
        >
          Refresh
        </Button>
      </div>
    </div>
    <div id="file-list" class="space-y-2"></div>
    <div id="no-files-message" class="hidden">
      <div class="py-8 text-center">
        <BoxIcon name="file" class="bx-lg mx-auto mb-4 h-12 w-12 text-gray-400" />
        <p class="text-sm text-gray-500 dark:text-gray-400">No files have been uploaded yet.</p>
        <p class="mt-1 text-xs text-gray-400 dark:text-gray-500">
          Upload your project documents to get started.
        </p>
      </div>
    </div>

    <!-- File Item Template (hidden, used for cloning) -->
    <template id="file-item-template">
      <div
        class="file-item rounded-lg border border-gray-200 bg-white shadow-sm dark:border-gray-600 dark:bg-gray-800"
      >
        <!-- Accordion Header -->
        <div
          class="accordion-header flex cursor-pointer items-center justify-between p-3 transition-colors hover:bg-gray-100 dark:hover:bg-gray-600"
        >
          <div class="flex min-w-0 flex-1 items-center space-x-3">
            <!-- Expand/Collapse Icon -->
            <div class="hidden flex-shrink-0 md:block">
              <BoxIcon
                name="chevron-right"
                class="accordion-chevron h-5 w-5 text-gray-400 transition-transform"
              />
            </div>

            <!-- File Type Icon Container -->
            <div class="file-icon-container hidden flex-shrink-0 md:block">
              <!-- Icon will be populated by JavaScript -->
            </div>

            <!-- File Info -->
            <div class="min-w-0 flex-1">
              <p class="file-title truncate text-sm font-medium text-gray-900 dark:text-white">
                <!-- Title will be populated by JavaScript -->
              </p>
              <p class="file-metadata text-sm text-gray-500 dark:text-gray-400">
                <!-- Metadata will be populated by JavaScript -->
              </p>
            </div>
          </div>

          <!-- Action Buttons -->
          <div class="ml-3 flex flex-shrink-0 flex-col items-center space-y-1 md:flex-row">
            <!-- View Button -->
            <a
              class="view-button rounded-full p-2 text-blue-600 transition-colors hover:bg-blue-50 hover:text-blue-800 dark:hover:bg-blue-900/20"
              target="_blank"
              title="View file"
            >
              <BoxIcon name="show" class="h-4 w-4" />
            </a>

            <!-- Download Button Container -->
            <div class="download-btn-container"></div>

            <!-- Delete Button -->
            <button
              class="delete-button rounded-full p-2 text-red-600 transition-colors hover:bg-red-50 hover:text-red-800 dark:hover:bg-red-900/20"
              title="Delete file"
            >
              <BoxIcon name="trash" class="h-4 w-4" />
            </button>
          </div>
        </div>

        <!-- Accordion Content -->
        <div class="accordion-content border-t border-gray-200 dark:border-gray-600">
          <div class="space-y-4 p-4">
            <!-- File Metadata Form -->
            <div class="space-y-3">
              <!-- Title Input -->
              <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Title
                </label>
                <input
                  type="text"
                  class="file-title-input mt-1 block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400"
                  placeholder="Enter a descriptive title for this file"
                />
              </div>

              <!-- Comments Textarea -->
              <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Comments
                </label>
                <textarea
                  class="file-comments-input mt-1 block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400"
                  rows="3"
                  placeholder="Add any notes or comments about this file"></textarea>
              </div>

              <!-- Actions Row -->
              <div class="flex items-start justify-between">
                {
                  currentRole === "Admin" || currentRole === "Staff" ? (
                    <div>
                       <!-- Featured Image Toggle -->
                       <div class="featured-image-toggle-container">
                         <SlideToggle
                           id="featured-image-toggle-template"
                           label="Featured Image"
                           icon="star"
                           checked={false}
                           class="featured-image-toggle"
                         />
                      </div>
                      <p class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                        Automatically saves when toggled
                      </p>
                    </div>
                  ) : (
                    <div />
                  )
                }

                <!-- Save Button Container -->
                <div class="save-metadata-btn-container"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </template>
  </div>

  <!-- All Documents Uploaded Button (Clients Only) -->
  {
    projectStatus === 10 ? (
      <div class="mt-6 border-t border-gray-200 pt-6 dark:border-gray-700">
        <div class="text-center">
          <Button
            id="all-documents-uploaded-btn"
            variant="success"
            size="md"
            icon="check"
            iconPosition="right"
            class="focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2"
          >
            Finished Uploading Documents
          </Button>
        </div>
      </div>
    ) : null
  }
</div>

<script define:vars={{ projectId, fileType, authorProfile, currentRole, projectStatus }}>
  class PDFUpload {
    constructor() {
      this.projectId = projectId;
      this.fileType = fileType;
      this.projectStatus = projectStatus;
      this.currentRole = currentRole;
      this.isMobile = window.innerWidth <= 768;
      this.initialized = false;
      this.isFileDialogOpen = false; // Flag to prevent multiple file dialogs
      // console.log("📱 [PDF-UPLOAD] Mobile detection:", this.isMobile);
      this.status = projectStatus;
      this.uploadedFiles = [];
      this.init();
    }

    openFileDialog() {
      // Prevent multiple file dialogs from opening
      if (this.isFileDialogOpen) {
        // console.log("📁 [PDF-UPLOAD] File dialog already open, ignoring click");
        return;
      }

      this.isFileDialogOpen = true;
      // console.log("📁 [PDF-UPLOAD] Opening file dialog");

      // Use setTimeout to ensure the flag is set before opening the dialog
      setTimeout(() => {
        if (this.fileInput) {
          this.fileInput.click();
        } else {
          console.error("📁 [PDF-UPLOAD] File input not found");
          this.isFileDialogOpen = false;
        }
      }, 10);
    }

    init() {
      if (this.initialized) {
        console.log("📱 [PDF-UPLOAD] Already initialized, skipping...");
        return;
      }

      // console.log(
      //   "📁 [PDF-UPLOAD] Initializing with projectId:",
      //   this.projectId,
      //   "status:",
      //   this.status
      // );
      this.setupElements();
      this.setupEventListeners();
      this.setupAccordionListeners();
      this.loadExistingFiles();
      this.initialized = true;
      // console.log("📱 [PDF-UPLOAD] Initialization complete");
    }

    setupElements() {
      this.dropzone = document.getElementById("upload-dropzone");
      this.fileInput = document.getElementById("file-input");
      this.browseBtn = document.getElementById("browse-files-btn");
      this.mobileBrowseBtn = document.getElementById("mobile-browse-files-btn");
      this.progressContainer = document.getElementById("upload-progress");
      this.progressBar = document.getElementById("progress-bar");
      this.uploadStatus = document.getElementById("upload-status");
      this.filesContainer = document.getElementById("uploaded-files");
      this.fileList = document.getElementById("file-list");
      this.noFilesMessage = document.getElementById("no-files-message");
      this.refreshBtn = document.getElementById("refresh-files-btn");
      this.downloadAllBtn = document.getElementById("download-all-btn");
      this.extractedText = document.getElementById("extracted-text");
      this.allDocumentsUploadedBtn = document.getElementById("all-documents-uploaded-btn");
    }

    createMobileFileInput() {
      // Remove any existing mobile file input first
      const existingMobileInput = document.getElementById("mobile-file-input");
      if (existingMobileInput) {
        existingMobileInput.remove();
      }

      // Create a visible file input for mobile devices
      const mobileFileInput = document.createElement("input");
      mobileFileInput.id = "mobile-file-input";
      mobileFileInput.type = "file";
      mobileFileInput.multiple = true;
      mobileFileInput.accept = ".pdf,.png,.jpg,.jpeg,.gif,.webp,.dwg,.doc,.docx,.xls,.xlsx,.txt";
      mobileFileInput.className =
        "block w-full text-sm text-transparent file:mr-4 file:py-3 file:px-6 file:rounded-full file:border-0 file:text-sm file:font-medium file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:transition-colors file:cursor-pointer";
      mobileFileInput.style.marginTop = "1rem";
      // Make the "No file chosen" text transparent
      mobileFileInput.style.color = "transparent";

      mobileFileInput.addEventListener("change", (e) => {
        console.log("📱 [PDF-UPLOAD] Mobile file input change event triggered");
        this.handleFiles(e.target.files);
      });

      // Insert after the dropzone
      this.dropzone.parentNode.insertBefore(mobileFileInput, this.dropzone.nextSibling);
    }

    setupEventListeners() {
      // Check if event listeners are already attached
      if (this.fileInput._hasEventListeners) {
        console.log("📱 [PDF-UPLOAD] Event listeners already attached, skipping...");
        return;
      }

      // File input change
      this.fileInput.addEventListener("change", (e) => {
        // console.log("📁 [PDF-UPLOAD] File input change event triggered:", e.target.files);
        this.isFileDialogOpen = false; // Reset flag when files are selected
        this.handleFiles(e.target.files);
      });

      // File input cancel (when user cancels the file dialog)
      this.fileInput.addEventListener("cancel", () => {
        // console.log("📁 [PDF-UPLOAD] File dialog cancelled");
        this.isFileDialogOpen = false;
      });

      // Mobile-specific file input handling
      if (this.isMobile) {
        // Add additional mobile-specific event listeners
        this.fileInput.addEventListener("input", (e) => {
          // console.log("📱 [PDF-UPLOAD] File input input event triggered (mobile)");
          this.handleFiles(e.target.files);
        });

        // Create a visible file input for mobile as fallback (only if it doesn't exist)
        if (!document.getElementById("mobile-file-input")) {
          this.createMobileFileInput();
        }
      }

      // Mark that event listeners have been attached
      this.fileInput._hasEventListeners = true;

      // Add cleanup method to window for debugging
      window.cleanupPDFUpload = () => {
        this.initialized = false;
        this.fileInput._hasEventListeners = false;
        const mobileInput = document.getElementById("mobile-file-input");
        if (mobileInput) {
          mobileInput.remove();
        }
        console.log("📱 [PDF-UPLOAD] Cleanup completed");
      };

      // Browse button click (only if it exists)
      if (this.browseBtn) {
        this.browseBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });

        // Mobile touch events for browse button
        this.browseBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });
      }

      // Mobile browse button click (only if it exists)
      if (this.mobileBrowseBtn) {
        this.mobileBrowseBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });

        // Mobile touch events for mobile browse button
        this.mobileBrowseBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });
      }

      // Dropzone events (only if it exists)
      if (this.dropzone) {
        this.dropzone.addEventListener("click", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });

        // Mobile touch events for dropzone
        this.dropzone.addEventListener("touchstart", (e) => {
          e.preventDefault();
          this.openFileDialog();
        });
      }

      if (this.dropzone) {
        this.dropzone.addEventListener("dragover", (e) => {
          e.preventDefault();
          this.dropzone.classList.add("border-blue-400", "bg-blue-50", "dark:bg-blue-900/20");
        });

        this.dropzone.addEventListener("dragleave", (e) => {
          e.preventDefault();
          this.dropzone.classList.remove("border-blue-400", "bg-blue-50", "dark:bg-blue-900/20");
        });

        this.dropzone.addEventListener("drop", (e) => {
          e.preventDefault();
          this.dropzone.classList.remove("border-blue-400", "bg-blue-50", "dark:bg-blue-900/20");
          this.handleFiles(e.dataTransfer.files);
        });
      }

      // Refresh button click (only if it exists)
      if (this.refreshBtn) {
        this.refreshBtn.addEventListener("click", () => {
          this.refreshFileList();
        });
      }

      // Download all button click (only if it exists)
      if (this.downloadAllBtn) {
        this.downloadAllBtn.addEventListener("click", () => {
          this.downloadAllFiles();
        });
      }

      // All documents uploaded button click
      if (this.allDocumentsUploadedBtn) {
        this.allDocumentsUploadedBtn.addEventListener("click", () => {
          this.markAllDocumentsUploaded();
        });
      }

      // Event delegation for download buttons and view links
      this.fileList.addEventListener("click", async (e) => {
        if (e.target.closest(".download-btn")) {
          e.stopPropagation(); // Prevent accordion from opening/closing
          const downloadBtn = e.target.closest(".download-btn");
          const filePath = downloadBtn.getAttribute("data-file-path");
          const fileName = downloadBtn.getAttribute("data-file-name");
          if (filePath && fileName) {
            this.downloadFile(filePath, fileName);
          }
        }

        // Also prevent accordion triggering for view links
        if (e.target.closest("a[href]")) {
          e.stopPropagation(); // Prevent accordion from opening/closing
        }
      });

      // Event delegation for featured image toggles
      this.fileList.addEventListener("change", (e) => {
        console.log("📁 [PDF-UPLOAD] Change event triggered on:", e.target);
        console.log("📁 [PDF-UPLOAD] Target classes:", e.target.classList.toString());

        if (e.target.classList.contains("featured-image-toggle")) {
          console.log("📁 [PDF-UPLOAD] Featured image toggle detected!");
          e.stopPropagation(); // Prevent accordion from opening/closing
          const toggle = e.target;
          const fileId = toggle.getAttribute("data-file-id");
          const isChecked = toggle.checked;
          console.log("📁 [PDF-UPLOAD] Featured image toggle data:", {
            fileId,
            isChecked,
          });
          if (fileId) {
            this.updateFeaturedImage(fileId, isChecked);
          }
        } else {
          console.log("📁 [PDF-UPLOAD] Not a featured image toggle, ignoring");
        }
      });
    }

    setupAccordionListeners() {
      // Event delegation for accordion functionality
      this.fileList.addEventListener("click", (e) => {
        // Handle accordion header clicks - but exclude download buttons and view links
        if (
          e.target.closest(".accordion-header") &&
          !e.target.closest(".download-btn") &&
          !e.target.closest("a[href]")
        ) {
          const header = e.target.closest(".accordion-header");
          const fileItem = header.closest(".file-item");
          const content = fileItem.querySelector(".accordion-content");
          const chevron = header.querySelector("svg");

          // Toggle accordion
          if (content.classList.contains("hidden")) {
            content.classList.remove("hidden");
            chevron.style.transform = "rotate(0deg)";
            fileItem.classList.add("accordion-open");
          } else {
            content.classList.add("hidden");
            chevron.style.transform = "rotate(90deg)";
            fileItem.classList.remove("accordion-open");
          }
        }

        // Handle save metadata button clicks
        if (e.target.closest(".save-metadata-btn")) {
          const saveBtn = e.target.closest(".save-metadata-btn");
          const fileItem = saveBtn.closest(".file-item");
          const fileId = saveBtn.getAttribute("data-file-id");
          const titleInput = fileItem.querySelector(".file-title-input");
          const commentsInput = fileItem.querySelector(".file-comments-input");

          this.saveFileMetadata(fileId, titleInput.value, commentsInput.value, fileItem);
        }
      });
    }

    async handleFiles(files) {
      console.log("🐛 [DEBUG] handleFiles called with:", files);
      console.log("🐛 [DEBUG] Files length:", files?.length);
      console.log("🐛 [DEBUG] Mobile device:", this.isMobile);
      console.log("🐛 [DEBUG] Project ID:", this.projectId);
      console.log("🐛 [DEBUG] Current user:", this.currentUser);

      if (!files || files.length === 0) {
        console.log("🐛 [DEBUG] No files provided - STOPPING");
        return;
      }

      const fileArray = Array.from(files);
      console.log("🐛 [DEBUG] File array details:", 
        fileArray.map((f) => ({ 
          name: f.name, 
          size: f.size, 
          type: f.type,
          lastModified: f.lastModified 
        }))
      );
      this.showProgress();

      for (let i = 0; i < fileArray.length; i++) {
        const file = fileArray[i];
        try {
          await this.uploadFile(file, i + 1, fileArray.length);
        } catch (error) {
          console.error(`📁 [PDF-UPLOAD] Error uploading ${file.name}:`, error);
          this.showError(`Failed to upload ${file.name}: ${error.message}`);
        }
      }

      this.hideProgress();
    }

    async uploadFile(file, index, total) {
      console.log("🐛 [DEBUG] uploadFile called with full details:", {
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        index,
        total,
        projectId: this.projectId,
        timestamp: new Date().toISOString()
      });

      // Add metadata if available
      const titleInput = document.getElementById("file-title");
      const commentsInput = document.getElementById("file-comments");

      const title = titleInput && titleInput.value.trim() ? titleInput.value.trim() : file.name;
      const description =
        commentsInput && commentsInput.value.trim() ? commentsInput.value.trim() : null;

      console.log("🐛 [DEBUG] Upload metadata:", { title, description });

      this.updateProgress((index / total) * 100, `Uploading ${file.name}...`);

      try {
        console.log("🐛 [DEBUG] Starting file conversion to base64...");
        // Convert file to base64
        const reader = new FileReader();
        const fileData = await new Promise((resolve, reject) => {
          reader.onload = () => {
            console.log("🐛 [DEBUG] File converted to base64, length:", reader.result?.length);
            resolve(reader.result);
          };
          reader.onerror = (error) => {
            console.error("🐛 [DEBUG] FileReader error:", error);
            reject(error);
          };
          reader.readAsDataURL(file);
        });

        const requestPayload = {
          mediaData: fileData,
          fileName: file.name,
          fileType: file.type,
          projectId: this.projectId,
          targetLocation: "project",
          title: title,
          description: description,
        };

        console.log("🐛 [DEBUG] Request payload (without mediaData):", {
          ...requestPayload,
          mediaData: `[BASE64 DATA - ${fileData?.length} chars]`
        });

        console.log("🐛 [DEBUG] Using unified media system...");
        // Call the unified media API directly
        const response = await fetch("/api/media", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            ...requestPayload,
            targetLocation: "documents", // Always documents for this tab
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Upload failed");
        }

        const uploadResult = await response.json();
        const uploadedFile = uploadResult.file; 

        console.log("🐛 [DEBUG] Upload successful:", uploadedFile);

        // Add to uploaded files list
        this.uploadedFiles.push(uploadedFile);
        console.log("🐛 [DEBUG] Added to uploadedFiles, total count:", this.uploadedFiles.length);

      // Refresh the file list to show all files
        console.log("🐛 [DEBUG] Calling refreshFileList...");
      this.refreshFileList();
      } catch (error) {
        console.error("🐛 [DEBUG] Complete error in uploadFile:", {
          message: error.message,
          stack: error.stack,
          fileName: file.name
        });
        throw new Error(`Failed to process ${file.name}: ${error.message}`);
      }
    }

    // Helper function to create buttons using Button partial
    async createButtonPartial(config) {
      try {
        const headers = new Headers();
        Object.entries(config).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            headers.set(`x-button-${key}`, value.toString());
          }
        });

        const response = await fetch("/partials/button", {
          headers: headers,
        });

        if (response.ok) {
          return await response.text();
        } else {
          console.error("Failed to fetch button partial:", response.status);
          return null;
        }
      } catch (error) {
        console.error("Error creating button partial:", error);
        return null;
      }
    }

    async populateFileTemplate(
      fileItem,
      { file, fileTitle, fileName, fileType, fileSize, uploadedAt, fileComments, hasCustomTitle }
    ) {
      // Populate file title
      const fileTitleElement = fileItem.querySelector(".file-title");
      if (fileTitleElement) {
        fileTitleElement.textContent = fileTitle;
        fileTitleElement.title = fileTitle;
      }

      // Populate file metadata
      const fileMetadataElement = fileItem.querySelector(".file-metadata");
      if (fileMetadataElement) {
        fileMetadataElement.textContent = `${this.formatFileSize(fileSize)} • ${fileType}${uploadedAt ? ` • ${uploadedAt}` : ""}`;
      }

      // Populate file icon
      const fileIconContainer = fileItem.querySelector(".file-icon-container");
      if (fileIconContainer) {
        fileIconContainer.innerHTML = this.getFileIcon(fileType);
      }

      // Set up view button
      const viewButton = fileItem.querySelector(".view-button");
      if (viewButton && file.public_url) {
        viewButton.href = file.public_url;
        viewButton.classList.remove("hidden");
      } else if (viewButton) {
        viewButton.style.display = "none";
      }

      // Set up delete button
      const deleteButton = fileItem.querySelector(".delete-button");
      if (deleteButton) {
        deleteButton.onclick = () => this.deleteFile(file.id, fileItem);
      }

      // Populate form fields
      const titleInput = fileItem.querySelector(".file-title-input");
      if (titleInput) {
        titleInput.value = hasCustomTitle ? fileTitle : "";
      }

      const commentsInput = fileItem.querySelector(".file-comments-input");
      if (commentsInput) {
        commentsInput.value = fileComments || "";
      }

      // Set up accordion functionality - ALWAYS open by default like the original
      const accordionContent = fileItem.querySelector(".accordion-content");
      const chevron = fileItem.querySelector(".accordion-chevron");

      if (accordionContent && chevron) {
        // Always show content by default (like the original behavior)
        accordionContent.classList.remove("hidden");
        chevron.style.transform = "rotate(90deg)"; // Pointing down when open (chevron-right rotated 90deg)
        fileItem.classList.add("accordion-open");
      }

      // Set up featured image toggle
      const toggleContainer = fileItem.querySelector(".featured-image-toggle-container");
      const toggleInput = fileItem.querySelector("input.featured-image-toggle");
      if (toggleContainer && toggleInput) {
        // Set unique ID for this toggle
        const uniqueId = `featured-image-toggle-${file.id}`;
        toggleInput.id = uniqueId;
        
        // Set data attributes
        toggleContainer.setAttribute("data-file-id", file.id);
        toggleInput.setAttribute("data-file-id", file.id);
        
        // Set the checked state
        toggleInput.checked = file.is_featured || false;
        console.log("📁 [PDF-UPLOAD] Set toggle state for file:", file.id, "is_featured:", file.is_featured, "checked:", toggleInput.checked);
      } else {
        console.warn("📁 [PDF-UPLOAD] Could not find toggle input for file:", file.id);
      }
    }

    async addFileToList(file) {
      console.log("📁 [PDF-UPLOAD] Adding file to list:", file.id, file.file_name);
      this.filesContainer.classList.remove("hidden");

      // Clone the template
      const template = document.getElementById("file-item-template");
      const fileItem = template.content.cloneNode(true).querySelector(".file-item");
      fileItem.setAttribute("data-file-id", file.id);

      // Add the original classes that were in the createElement version
      fileItem.className =
        "file-item bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600 accordion-open";

      // Use file_name from database or fallback to name
      const fileName = file.fileName || file.file_name || file.name;
      const fileTitle = file.title || fileName;
      const fileSize = file.fileSize || file.file_size || file.size;
      const fileType = file.fileType || file.file_type || file.type;
      const uploadedAt = file.uploaded_at ? new Date(file.uploaded_at).toLocaleDateString() : "";
      const fileComments = file.comments;
      const hasCustomTitle = fileTitle && fileTitle !== fileName;

      // Populate the template with file data
      this.populateFileTemplate(fileItem, {
        file,
        fileTitle,
        fileName,
        fileType,
        fileSize,
        uploadedAt,
        fileComments,
        hasCustomTitle,
      });

      this.fileList.appendChild(fileItem);

      // Load buttons using Button partial
      await this.loadFileItemButtons(fileItem, file, fileName);
    }

    async loadFileItemButtons(fileItem, file, fileName) {
      try {
        // Load download button if file has public URL
        const downloadContainer = fileItem.querySelector(".download-btn-container");
        if (downloadContainer && file.public_url) {
          const downloadButtonHtml = await this.createButtonPartial({
            variant: "ghost",
            size: "sm",
            icon: "download",
            class:
              "download-btn p-2 text-green-600 hover:text-green-800 hover:bg-green-50 dark:hover:bg-green-900/20 rounded-full",
            title: "Download file",
            "data-file-path": file.file_path,
            "data-file-name": fileName,
          });
          if (downloadButtonHtml) {
            downloadContainer.innerHTML = downloadButtonHtml;
          }
        }

        // Load save metadata button
        const saveContainer = fileItem.querySelector(".save-metadata-btn-container");
        if (saveContainer) {
          const saveButtonHtml = await this.createButtonPartial({
            variant: "primary",
            size: "sm",
            icon: "check",
            text: "Save Title & Comments",
            class: "save-metadata-btn",
            "data-file-id": file.id.toString(),
          });
          if (saveButtonHtml) {
            saveContainer.innerHTML = saveButtonHtml;
          }
        }
      } catch (error) {
        console.error("Error loading file item buttons:", error);
      }
    }

    async saveFileMetadata(fileId, title, comments, fileItem) {
      try {
        const response = await fetch("/api/update-file-metadata", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            fileId: fileId,
            title: title.trim(),
            comments: comments.trim(),
          }),
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to save metadata");
        }

        const result = await response.json();

        if (result.success) {
          // Update the display title in the accordion header
          const headerTitle = fileItem.querySelector(".accordion-header p");
          if (headerTitle) {
            headerTitle.textContent = title.trim() || "Untitled";
          }

          // Show success feedback
          const saveBtn = fileItem.querySelector(".save-metadata-btn");
          const originalText = saveBtn.innerHTML;
          saveBtn.innerHTML = `
            <svg class="h-4 w-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
            </svg>
            Saved!
          `;
          saveBtn.classList.remove("bg-blue-600", "hover:bg-blue-700");
          saveBtn.classList.add("bg-green-600", "hover:bg-green-700");

          // Reset button after 2 seconds and close accordion
          setTimeout(() => {
            saveBtn.innerHTML = originalText;
            saveBtn.classList.remove("bg-green-600", "hover:bg-green-700");
            saveBtn.classList.add("bg-blue-600", "hover:bg-blue-700");

            // Close the accordion
            const accordionContent = fileItem.querySelector(".accordion-content");
            const chevron = fileItem.querySelector(".accordion-header svg");
            if (accordionContent && chevron) {
              accordionContent.classList.add("hidden");
              chevron.style.transform = "rotate(0deg)";
              fileItem.classList.remove("accordion-open");
            }
          }, 2000);
        }
      } catch (error) {
        console.error("Error saving file metadata:", error);
        this.showError(`Failed to save metadata: ${error.message}`);
      }
    }

    async updateFeaturedImage(fileId, isFeatured) {
      try {
        console.log("⭐ [FEATURED-IMAGE] Updating featured image:", { fileId, isFeatured });

        const response = await fetch("/api/media", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            projectId: this.projectId,
            fileId: fileId,
            mediaType: "featured_image",
            isActive: isFeatured,
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Failed to update featured image");
        }

        const updateResult = await response.json();

        if (!updateResult.success) {
          throw new Error(updateResult.message || "Failed to update featured image");
        }

        console.log("⭐ [FEATURED-IMAGE] Successfully updated featured image");

        // Update all other featured image toggles to be unchecked
        if (isFeatured) {
          const allToggles = document.querySelectorAll(".featured-image-toggle");
          allToggles.forEach((toggle) => {
            if (toggle.getAttribute("data-file-id") !== fileId) {
              toggle.checked = false;
            }
          });
        }

      // Show success feedback
        if (typeof window !== "undefined" && window.showModal) {
          console.log("🔔 [PDF-UPLOAD] Calling window.showModal");
          window.showModal("success", "Success", `Featured image ${isFeatured ? "set" : "removed"} successfully`, 1500);
        } else {
          console.log("✅ Success:", message);
        }
        
      } catch (error) {
        console.error("⭐ [FEATURED-IMAGE] Error updating featured image:", error);
        this.showError(`Failed to update featured image: ${error.message}`, 111500);

        // Revert the toggle state
        const toggle = document.querySelector(`.featured-image-toggle[data-file-id="${fileId}"]`);
        if (toggle) {
          toggle.checked = !isFeatured;
        }
      }
    }

    async loadExistingFiles() {
      await this.refreshFileList();
    }

    async refreshFileList() {
      console.log("📁 [PDF-UPLOAD] refreshFileList called for project:", this.projectId);

      // Clear existing file list
      this.fileList.innerHTML = "";

      try {
        console.log("📁 [PDF-UPLOAD] Fetching files for project:", this.projectId);

        const response = await fetch(`/api/media?projectId=${this.projectId}&targetLocation=documents`, {
          method: "GET",
          credentials: "include",
        });

        if (!response.ok) {
          throw new Error(`Failed to load files: ${response.statusText}`);
        }

        const result = await response.json();

        console.log("📁 [PDF-UPLOAD] Files result:", result);
        console.log("📁 [PDF-UPLOAD] Files count:", result.media?.length || 0);

        if (result.success && result.media && result.media.length > 0) {
          for (const file of result.media) {
            // Convert get-media response format to match expected file format
            const formattedFile = {
              id: file.id,
              file_name: file.fileName,
              file_path: file.filePath,
              file_type: file.fileType,
              file_size: file.fileSize || 0,
              title: file.title,
              comments: file.comments,
              uploaded_at: file.uploadedAt,
              public_url: file.publicUrl,
              bucket_name: file.bucketName,
              is_featured: file.is_featured || false,
            };
            await this.addFileToList(formattedFile);
          }
            this.filesContainer.classList.remove("hidden");
            this.noFilesMessage.classList.add("hidden");
            console.log("📁 [PDF-UPLOAD] Showing file list, hiding no-files message");
          } else {
            this.filesContainer.classList.remove("hidden");
            this.noFilesMessage.classList.remove("hidden");
            console.log("📁 [PDF-UPLOAD] Showing no-files message, hiding file list");
        }
      } catch (error) {
        console.error("Error loading existing files:", error);
      }
    }


    async markAllDocumentsUploaded() {
      try {
        // Disable button and show loading state
        this.allDocumentsUploadedBtn.disabled = true;
        this.allDocumentsUploadedBtn.innerHTML = `
          <svg class="animate-spin mr-2 h-5 w-5" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Updating Status...
        `;

        // Call the update-status API to change status
        console.log("🔔 [PDF-UPLOAD] Debug projectId:", {
          projectIdProp: projectId,
          thisProjectId: this.projectId,
          typeof: typeof this.projectId,
          stringified: JSON.stringify(this.projectId),
        });

        console.log("🔔 [PDF-UPLOAD] Calling /api/update-status with:", {
          projectId: this.projectId,
          status: 20,
          currentUserId: this.currentUser?.id,
          oldStatus: this.projectStatus,
        });

        const response = await fetch("/api/update-status", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include", // Include cookies for authentication
          body: JSON.stringify({
            projectId: this.projectId,
            status: 20, // Status 20 - All Documents Uploaded
            currentUserId: this.currentUser?.id, // Add current user ID for logging
            oldStatus: this.projectStatus, // Add old status for logging
          }),
        });

        console.log("🔔 [PDF-UPLOAD] API response status:", response.status);

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to update project status");
        }

        const result = await response.json();

        if (result.success) {
          console.log("📊 [PDF-UPLOAD] Status updated successfully:", result);

          // Show success notification using notificationData from API
          window.handleUpdateStatusNotification(result, "PDF-UPLOAD");

          const uploadStatus = document.getElementById("upload-status");
          if (uploadStatus) {
            uploadStatus.innerHTML = ``;
          }
          this.dropzone.classList.add("hidden");
          // Update button to show completion
          this.allDocumentsUploadedBtn.innerHTML = `
            <svg class="mr-2 h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
            </svg>
            Documents Submitted ✓
          `;
          this.allDocumentsUploadedBtn.classList.remove("bg-green-600", "hover:bg-green-700");
          this.allDocumentsUploadedBtn.classList.add("bg-gray-600", "cursor-not-allowed");
          this.allDocumentsUploadedBtn.disabled = true;

          // window.location.href = `/project/${this.projectId}?tab=proposal`;
        }
      } catch (error) {
        console.error("Error updating project status:", error);
        this.showError(`Failed to update project status: ${error.message}`);

        // Reset button to original state
        this.allDocumentsUploadedBtn.disabled = false;
        this.allDocumentsUploadedBtn.innerHTML = `
          <svg class="mr-2 h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
          </svg>
          All Documents Uploaded
        `;
      }
    }


    async downloadAllFiles() {
      try {
        const response = await fetch("/api/get-project-files", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ projectId: this.projectId }),
        });

        if (response.ok) {
          const result = await response.json();
          if (result.files && result.files.length > 0) {
            // Download each file with a slight delay to avoid browser blocking
            for (let i = 0; i < result.files.length; i++) {
              const file = result.files[i];
              if (file.file_path) {
                setTimeout(() => {
                  this.downloadFile(file.file_path, file.file_name || file.name || `file-${i + 1}`);
                }, i * 500); // 500ms delay between downloads
              }
            }
          } else {
            this.showError("No files available to download");
          }
        }
      } catch (error) {
        console.error("Error downloading files:", error);
        this.showError("Failed to download files");
      }
    }

    showProgress() {
      this.progressContainer.classList.remove("hidden");
    }

    hideProgress() {
      setTimeout(() => {
        this.progressContainer.classList.add("hidden");
        this.progressBar.style.width = "0%";
      }, 1000);
    }

    updateProgress(percent, statusVal) {
      this.progressBar.style.width = `${percent}%`;

      // Truncate long filenames to prevent screen jumping on mobile
      let displayStatus = statusVal;
      if (statusVal.includes("Uploading") && statusVal.length > 50) {
        // Extract filename from "Uploading filename.ext..."
        const match = statusVal.match(/Uploading (.+?)\.\.\./);
        if (match) {
          const filename = match[1];
          const extension = filename.split(".").pop();
          const nameWithoutExt = filename.substring(0, filename.lastIndexOf("."));

          // Truncate to 30 characters + extension
          if (nameWithoutExt.length > 30) {
            const truncatedName = nameWithoutExt.substring(0, 30) + "...";
            displayStatus = `Uploading ${truncatedName}.${extension}...`;
          }
        }
      }

      this.uploadStatus.textContent = displayStatus;

      // Add title attribute for full filename on hover
      if (statusVal !== displayStatus) {
        this.uploadStatus.title = statusVal;
      } else {
        this.uploadStatus.title = "";
      }
    }

    showError(message) {
      // Use centralized notification system
      if (typeof window !== "undefined" && window.showModal) {
        window.showModal("error", "Upload Error", message);
      } else {
        console.error("❌ Error:", message);
      }
    }

    formatFileSize(bytes) {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    getFileIcon(fileType) {
      const type = fileType.toLowerCase();

      // PDF files
      if (type.includes("pdf")) {
        return `<svg class="h-6 w-6 text-red-500" fill="currentColor" viewBox="0 0 24 24">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1v5h5v10H6V3h7z"/>
          <path d="M9 12h6v2H9zm0 4h6v2H9z"/>
        </svg>`;
      }

      // Image files
      if (
        type.includes("image") ||
        type.includes("png") ||
        type.includes("jpg") ||
        type.includes("jpeg") ||
        type.includes("gif") ||
        type.includes("webp")
      ) {
        return `<svg class="h-6 w-6 text-blue-500" fill="currentColor" viewBox="0 0 24 24">
          <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
        </svg>`;
      }

      // CAD files
      if (type.includes("dwg") || type.includes("dxf") || type.includes("cad")) {
        return `<svg class="h-6 w-6 text-green-500" fill="currentColor" viewBox="0 0 24 24">
          <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
        </svg>`;
      }

      // Document files
      if (
        type.includes("doc") ||
        type.includes("docx") ||
        type.includes("txt") ||
        type.includes("rtf")
      ) {
        return `<svg class="h-6 w-6 text-blue-600" fill="currentColor" viewBox="0 0 24 24">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1v5h5v10H6V3h7z"/>
          <path d="M9 12h6v2H9zm0 4h6v2H9z"/>
        </svg>`;
      }

      // Spreadsheet files
      if (type.includes("xls") || type.includes("xlsx") || type.includes("csv")) {
        return `<svg class="h-6 w-6 text-green-600" fill="currentColor" viewBox="0 0 24 24">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1v5h5v10H6V3h7z"/>
          <path d="M8 12h8v2H8zm0 4h8v2H8z"/>
        </svg>`;
      }

      // Archive files
      if (
        type.includes("zip") ||
        type.includes("rar") ||
        type.includes("7z") ||
        type.includes("tar") ||
        type.includes("gz")
      ) {
        return `<svg class="h-6 w-6 text-orange-500" fill="currentColor" viewBox="0 0 24 24">
          <path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/>
          <path d="M12 10l-2 2 2 2 2-2-2-2z"/>
        </svg>`;
      }

      // Default file icon
      return `<svg class="h-6 w-6 text-gray-500" fill="currentColor" viewBox="0 0 24 24">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1v5h5v10H6V3h7z"/>
      </svg>`;
    }

    async downloadFile(filePath, fileName) {
      try {
        const response = await fetch("/api/download-file", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filePath, fileName, projectId: this.projectId }),
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Download failed");
        }

        // Create blob from response and download
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
      } catch (error) {
        console.error("Error downloading file:", error);
        this.showError(`Failed to download ${fileName}: ${error.message}`);
      }
    }
  }


  // Initialize the PDF upload component
  document.addEventListener("DOMContentLoaded", () => {
    console.log("📁 [PDF-UPLOAD] DOMContentLoaded event fired");

    // Check if already initialized
    if (window.pdfUploadDocuments && window.pdfUploadDocuments.initialized) {
      console.log("📁 [PDF-UPLOAD] PDFUpload already initialized, skipping");
      return;
    }

    console.log("📁 [PDF-UPLOAD] Initializing PDFUpload component for Documents");
    window.pdfUploadDocuments = new PDFUpload();
  });
</script>
