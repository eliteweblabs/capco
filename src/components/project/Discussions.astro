---
interface Props {
  authorProfile?: any;
  currentRole?: string;
  project: any;
  projectId: string;
  projectStatus?: number;
  projectStatusLabel?: string;
}

import BoxIcon from "../common/BoxIcon.astro";

const { projectId, authorProfile, projectStatus, currentRole, projectStatusLabel } = Astro.props;

const placeholder =
  currentRole === "Admin" || currentRole === "Staff"
    ? "Write your comment here... (Use @username to mention users)"
    : "Write your comment here...";
---

<div
  id="content-discussion"
  class="tab-content hidden rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
>
  <div id="discussion-container" data-project-id={projectId}>
    <div class="mb-6 flex items-center justify-between">
      <h3 class="text-lg font-medium text-gray-900 dark:text-white">Project Discussion</h3>
      <button
        id="new-comment-btn"
        class="inline-flex items-center rounded-lg bg-red-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-red-700 whitespace-nowrap min-w-[120px] justify-center"
      >
        <BoxIcon name="plus" class="mr-2 bx-sm" />
        New Comment
      </button>
    </div>

    <!-- Comment Form (hidden by default) -->
    <div
      id="comment-form"
      class="mb-6 hidden rounded-lg border border-gray-200 p-4 dark:border-gray-700"
    >
      <div class="relative">
        <textarea
          id="comment-message"
          placeholder={placeholder}
          class="w-full resize-none rounded-lg border border-gray-300 p-3 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
          rows="4"></textarea>
        <div
          id="mention-dropdown"
          class="absolute z-50 mt-1 hidden w-full max-h-48 overflow-y-auto rounded-lg border border-gray-300 bg-white shadow-lg dark:border-gray-600 dark:bg-gray-700"
        >
        </div>
      </div>

      {/* Admin/Staff Only Toggles */}
      {
        (currentRole === "Admin" || currentRole === "Staff") && (
          <div class="mt-3 flex flex-wrap gap-6 border-t border-gray-200 pt-3 dark:border-gray-600">
            {/* Internal Only Toggle */}
            <label class="flex items-center gap-3 cursor-pointer">
              <div class="relative">
                <input type="checkbox" id="internal-toggle" class="sr-only peer" />
                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600" />
              </div>
              <span class="text-sm text-gray-700 dark:text-gray-300">
                <BoxIcon name="lock" class="mr-1" />
                Internal Only
              </span>
            </label>
          </div>
        )
      }

      {/* Form Actions */}
      <div class="mt-4 flex items-center justify-end">
        <button
          id="submit-comment-btn"
          class="inline-flex items-center rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-blue-700"
        >
          <BoxIcon name="send" class="mr-2 h-4 w-4" />
          Post Comment
        </button>
      </div>
    </div>
    <!-- Comments List -->
    <div id="comments-list" class="space-y-4">
      <!-- Comments will be dynamically loaded here -->
    </div>
  </div>

  <script define:vars={{ projectId, authorProfile, currentRole }}>
    // Discussion functionality
    let discussions = [];
    let currentProjectId = projectId;
    let currentUserRole = currentRole;
    let currentUserId = authorProfile.id;
    let currentUserName = authorProfile.company_name;
    let mentionableUsers = [];
    let currentMentionStart = -1;

    // console.log("üîî [DISCUSSION] Initial userRole:", currentUserRole);

    // Make user role available globally for reply forms
    window.currentUserRole = currentUserRole;
    window.PROJECT_USER_ROLE = currentUserRole;

    async function loadDiscussions(projectId) {
      try {
        const response = await fetch(`/api/get-project-discussions?projectId=${projectId}`);
        const data = await response.json();

        if (data.success) {
          discussions = data.discussions;
          //       console.log("üîç [DISCUSSIONS] Loaded discussions data:", discussions.map(d => ({
          //         // id: d.id,
          //         // author_id: d.author_id,
          //         // company_name: d.company_name,
          //         // hasProfiles: !!d.profiles,
          //         // profileData: d.profiles ? {
          //         //   display_name: d.profiles.display_name,
          //         //   company_name: d.profiles.company_name,
          //         //   first_name: d.profiles.first_name,
          //         //   last_name: d.profiles.last_name
          //         // } : null
          //       }
          //     )
          //   )
          // );
          renderDiscussions();
          updateIncompleteCommentsCount(); // Update count after loading discussions
        } else {
          console.error("Failed to load discussions:", data.error);
          showDiscussionError("Failed to load discussions");
        }
      } catch (error) {
        console.error("Error loading discussions:", error);
        showDiscussionError("Failed to load discussions");
      }
    }

    // Update incomplete comments count in the discussion tab
    function updateIncompleteCommentsCount() {
      const incompleteCount = discussions.filter((discussion) => !discussion.mark_completed).length;
      const countElement = document.querySelector(".incomplete-comments-count");
      const tabButton = document.getElementById("tab-discussion");

      if (countElement && tabButton) {
        if (incompleteCount > 0) {
          countElement.textContent = incompleteCount.toString();
          countElement.classList.remove("hidden");
          tabButton.setAttribute("data-count", incompleteCount.toString());
        } else {
          countElement.classList.add("hidden");
          tabButton.setAttribute("data-count", "0");
        }

        // console.log("üîç [DISCUSSION] Incomplete comments count updated:", incompleteCount);
      }
    }

    function renderDiscussions() {
      const commentsList = document.getElementById("comments-list");
      if (!commentsList) return;

      // console.log("üîç [DEBUG] renderDiscussions called with:", {
      //   userRole: currentUserRole,
      //   discussionsCount: discussions.length,
      //   discussions: discussions.map(d => ({ id: d.id, internal: d.internal, author_id: d.author_id, parent_id: d.parent_id }))
      // });

      if (discussions.length === 0) {
        commentsList.innerHTML = `
        <div class="text-center py-8 text-gray-500 dark:text-gray-400">
          <i class="bx bx-message-rounded-dots mx-auto mb-4 text-4xl"></i>
          <p>No comments yet. Be the first to start the discussion!</p>
        </div>
      `;
        return;
      }

      // Separate top-level comments and replies
      const topLevelComments = discussions.filter((d) => !d.parent_id);
      const replies = discussions.filter((d) => d.parent_id);

      // console.log("üîç [DEBUG] Threading:", {
      //   topLevel: topLevelComments.length,
      //   replies: replies.length,
      //   topLevelIds: topLevelComments.map(c => c.id),
      //   replyParents: replies.map(r => r.parent_id)
      // });

      // Debug the first few replies to see their structure
      if (replies.length > 0) {
        // console.log("üîç [DEBUG] First reply structure:", replies[0]);
      }

      let html = "";

      topLevelComments.forEach((comment) => {
        // Check if user can see this comment
        const canSeeComment =
          !comment.internal ||
          currentUserRole === "Admin" ||
          currentUserRole === "Staff" ||
          comment.author_id === currentUserId;

        if (!canSeeComment) {
          console.log("üîç [DEBUG] Hiding internal comment from user:", comment.id);
          return;
        }

        html += renderComment(comment, 0);

        // Find and render replies for this comment
        const commentReplies = replies.filter((reply) => reply.parent_id === comment.id);
        commentReplies.forEach((reply) => {
          const canSeeReply =
            !reply.internal ||
            currentUserRole === "Admin" ||
            currentUserRole === "Staff" ||
            reply.author_id === currentUserId;
          if (canSeeReply) {
            html += renderComment(reply, 1);
          }
        });
      });

      commentsList.innerHTML = html;
    }

    function highlightMentions(text) {
      // Highlight @mentions with a blue background and white text
      // Pattern for formatted mentions (spaces converted to underscores on save)
      return text.replace(
        /@([a-zA-Z0-9_]+)/g,
        '<span class="inline-flex items-center rounded-full bg-blue-100 px-2 py-1 text-xs font-medium text-blue-800 dark:bg-blue-900 dark:text-blue-200">@$1</span>'
      );
    }

    // Make highlightMentions available globally for other components
    window.highlightMentions = highlightMentions;

    function renderComment(comment, depth = 0) {
      const isInternal = comment.internal;
      const isAuthor = comment.author_id === currentUserId;
      const canToggleCompleted =
        currentUserRole === "Admin" || currentUserRole === "Staff" || isAuthor;
      const canReply =
        currentUserRole === "Admin" || currentUserRole === "Staff" || currentUserRole === "Client";

      const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
      const borderLeft = depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

      return `
      <div class="comment-item ${marginLeft} ${borderLeft}" data-discussion-id="${comment.id}">
        <div class="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
          <div class="flex items-start justify-between">
            <div class="flex items-center space-x-3">
              <div class="flex h-8 w-8 items-center justify-center rounded-full bg-gray-200 dark:bg-gray-600">
                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
                  ${comment.company_name ? comment.company_name.charAt(0).toUpperCase() : "U"}
                </span>
              </div>
              <div>
                <p class="text-sm font-medium text-gray-900 dark:text-white">
                  ${comment.company_name || "Unknown User"}
                  ${isInternal ? '<span class="ml-2 inline-flex items-center rounded-full bg-red-100 px-2 py-1 text-xs font-medium text-red-800 dark:bg-red-900 dark:text-red-200"><i class="bx bx-lock mr-1"></i>Internal</span>' : ""}
                </p>
                <p class="text-xs text-gray-500 dark:text-gray-400">
                  ${new Date(comment.created_at).toLocaleString()}
                </p>
              </div>
            </div>
            
            ${
              canToggleCompleted
                ? `
              <div class="flex items-center space-x-2">
                <label class="flex items-center gap-2 cursor-pointer">
                  <div class="relative">
                    <input
                      type="checkbox"
                      class="sr-only peer completed-toggle"
                      data-discussion-id="${comment.id}"
                      ${comment.mark_completed ? "checked" : ""}
                    />
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 dark:peer-focus:ring-green-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                  </div>
                  <span class="text-xs text-gray-600 dark:text-gray-400">
                    ${comment.mark_completed ? "Completed" : "Mark Complete"}
                  </span>
                </label>
              </div>
            `
                : ""
            }
          </div>
          
          <div class="mt-3">
            <p class="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap">${highlightMentions(comment.message)}</p>
          </div>
          
          ${
            canReply
              ? `
            <div class="mt-3 flex items-center justify-between">
              <button
                class="reply-button text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200"
                data-discussion-id="${comment.id}"
              >
                <i class="bx bx-reply mr-1"></i>
                Reply
              </button>
            </div>
          `
              : ""
          }
        </div>
      </div>
    `;
    }

    function showDiscussionError(message) {
      const commentsList = document.getElementById("comments-list");
      if (commentsList) {
        commentsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
      }
    }

    function toggleCommentForm() {
      console.log("üîî [DISCUSSION] toggleCommentForm called");
      const commentForm = document.getElementById("comment-form");
      const newCommentBtn = document.getElementById("new-comment-btn");

      if (commentForm && newCommentBtn) {
        const isHidden = commentForm.classList.contains("hidden");

        if (isHidden) {
          commentForm.classList.remove("hidden");
          newCommentBtn.innerHTML = `
          <i class="bx bx-x mr-2 bx-sm"></i>
          Cancel
        `;
          newCommentBtn.classList.remove("bg-red-600", "hover:bg-red-700");
          newCommentBtn.classList.add("bg-gray-600", "hover:bg-gray-700");

          // Focus on textarea
          const textarea = document.getElementById("comment-message");
          if (textarea) {
            textarea.focus();
          }
        } else {
          commentForm.classList.add("hidden");
          newCommentBtn.innerHTML = `
          <i class="bx bx-plus bx-sm"></i>
          New Comment
        `;
          newCommentBtn.classList.remove("bg-gray-600", "hover:bg-gray-700");
          newCommentBtn.classList.add("bg-red-600", "hover:bg-red-700");

          // Clear form
          const textarea = document.getElementById("comment-message");
          const internalToggle = document.getElementById("internal-toggle");
          if (textarea) textarea.value = "";
          if (internalToggle) internalToggle.checked = false;
        }
      }
    }

    // Cancel reply form
    function cancelReply(parentCommentId) {
      console.log("üîî [DISCUSSION] Canceling reply for comment:", parentCommentId);

      const replyForm = document.querySelector(
        `[data-discussion-id="${parentCommentId}"]`
      )?.nextElementSibling;
      if (replyForm && replyForm.classList.contains("inline-reply-form")) {
        replyForm.remove();
      }

      // Clear the current reply target
      window.currentReplyTo = null;
    }

    // Submit reply
    async function submitReply(parentCommentId) {
      console.log("üîî [DISCUSSION] Submitting reply for comment:", parentCommentId);

      const replyForm = document.querySelector(
        `[data-discussion-id="${parentCommentId}"]`
      )?.nextElementSibling;
      if (!replyForm) {
        console.error("Reply form not found");
        return;
      }

      const messageInput = replyForm.querySelector(".reply-message-input");
      const internalToggle = replyForm.querySelector(".reply-internal-toggle");
      const submitBtn = replyForm.querySelector(".submit-reply-btn");

      const message = messageInput?.value?.trim();
      const isInternal = internalToggle?.checked || false;

      if (!message) {
        alert("Please enter a reply message");
        return;
      }

      // Set loading state
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = `
        <svg class="animate-spin mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Posting...
      `;
      }

      try {
        const response = await fetch("/api/add-discussion", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: currentProjectId,
            message: message,
            parentId: parentCommentId,
            internal: isInternal,
          }),
        });

        const data = await response.json();

        if (data.success) {
          console.log("‚úÖ Reply submitted successfully");
          // Remove the reply form
          replyForm.remove();
          // Reload discussions
          await loadDiscussions(currentProjectId);
          // Show success message
          if (window.showModal) {
            window.showModal(
              "success",
              "Reply posted",
              "Your reply has been added to the discussion"
            );
          }
        } else {
          console.error("Failed to submit reply:", data.error);
          alert("Failed to submit reply: " + data.error);
        }
      } catch (error) {
        console.error("Error submitting reply:", error);
        alert("Error submitting reply");
      } finally {
        // Reset loading state
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = `
          <i class="bx bx-send mr-2"></i>
          Post Reply
        `;
        }
      }
    }

    // Make functions globally available
    window.toggleCommentForm = toggleCommentForm;
    window.cancelReply = cancelReply;
    window.submitReply = submitReply;

    async function submitComment() {
      const messageInput = document.getElementById("comment-message");
      const message = messageInput?.value?.trim();
      const internalToggle = document.getElementById("internal-toggle");
      const isInternal = internalToggle?.checked || false;
      const submitBtn = document.getElementById("submit-comment-btn");

      if (!message) {
        alert("Please enter a comment message");
        return;
      }

      // Set loading state
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = `
        <svg class="animate-spin mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Posting...
      `;
      }

      try {
        const response = await fetch("/api/add-discussion", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: currentProjectId,
            message: message,
            internal: isInternal,
          }),
        });

        const data = await response.json();

        if (data.success) {
          console.log("‚úÖ Comment submitted successfully");
          // Clear form and hide it
          messageInput.value = "";
          if (internalToggle) internalToggle.checked = false;
          toggleCommentForm();
          // Reload discussions
          await loadDiscussions(currentProjectId);
          // Show success message
          if (window.showModal) {
            window.showModal(
              "success",
              "Comment posted",
              "Your comment has been added to the discussion"
            );
          }
        } else {
          console.error("Failed to submit comment:", data.error);
          alert("Failed to submit comment: " + data.error);
        }
      } catch (error) {
        console.error("Error submitting comment:", error);
        alert("Error submitting comment");
      } finally {
        // Reset loading state
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = `
          <i class="bx bx-send mr-2 h-4 w-4"></i>
          Post Comment
        `;
        }
      }
    }

    // Load mentionable users
    async function loadMentionableUsers() {
      if (!currentProjectId) return;

      // console.log("üìã [DISCUSSION] Loading mentionable users with authorProfile");

      try {
        const response = await fetch(`/api/get-mentionable-users?projectId=${currentProjectId}`);
        const data = await response.json();

        if (data.success) {
          mentionableUsers = data.users;

          // Add project author to mentionable users if not already included
          if (authorProfile && !mentionableUsers.find((user) => user.id === authorProfile.id)) {
            const authorUser = {
              id: authorProfile.id,
              name:
                authorProfile.first_name && authorProfile.last_name
                  ? `${authorProfile.first_name} ${authorProfile.last_name}`
                  : authorProfile.company_name || "Unknown User",
              role: authorProfile.role || "Client",
              email: authorProfile.email || "",
            };
            mentionableUsers.unshift(authorUser); // Add to beginning of list
            // console.log("üìã [DISCUSSION] Added project author to mentionable users");
          }

          // console.log("üìã [DISCUSSION] Loaded mentionable users:", mentionableUsers.length);
        } else {
          console.error("Failed to load mentionable users:", data.error);
        }
      } catch (error) {
        console.error("Error loading mentionable users:", error);
      }
    }

    // Show mention dropdown
    function showMentionDropdown(query, position) {
      const dropdown = document.getElementById("mention-dropdown");
      const textarea = document.getElementById("comment-message");

      if (!dropdown || !textarea) return;

      const filteredUsers = mentionableUsers.filter(
        (user) =>
          user.name.toLowerCase().includes(query.toLowerCase()) ||
          user.email.toLowerCase().includes(query.toLowerCase())
      );

      if (filteredUsers.length === 0) {
        hideMentionDropdown();
        return;
      }

      // Separate project author from other users
      const projectAuthor = filteredUsers.find((user) => user.id === authorProfile?.id);
      const otherUsers = filteredUsers.filter((user) => user.id !== authorProfile?.id);

      let html = "";
      let itemIndex = 0;

      // Add project author first with special styling
      if (projectAuthor) {
        html += `
        <div class="mention-item px-3 py-2 cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 ${itemIndex === 0 ? "bg-blue-50 dark:bg-blue-900/20" : ""} border-b border-gray-200 dark:border-gray-600" 
             data-index="${itemIndex}" 
             data-user-name="${projectAuthor.name}">
          <div class="flex items-center gap-2">
            <i class="bx bx-user-circle text-blue-600 dark:text-blue-400 text-lg"></i>
            <div>
              <div class="font-medium text-blue-900 dark:text-blue-100">${projectAuthor.name}</div>
              <div class="text-sm text-blue-600 dark:text-blue-400">Project Author</div>
            </div>
          </div>
        </div>
      `;
        itemIndex++;
      }

      // Add other users
      html += otherUsers
        .map(
          (user, index) => `
      <div class="mention-item px-3 py-2 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-600 ${itemIndex === 0 ? "bg-gray-50 dark:bg-gray-600" : ""}" 
           data-index="${itemIndex}" 
           data-user-name="${user.name}">
        <div class="flex items-center gap-2">
          <i class="bx bx-user text-gray-500 dark:text-gray-400 text-lg"></i>
          <div>
            <div class="font-medium text-gray-900 dark:text-white">${user.name}</div>
            <div class="text-sm text-gray-500 dark:text-gray-400">${user.email}</div>
          </div>
        </div>
      </div>
    `
        )
        .join("");

      dropdown.innerHTML = html;
      dropdown.classList.remove("hidden");

      // Add click handlers
      dropdown.querySelectorAll(".mention-item").forEach((item) => {
        item.addEventListener("click", () => {
          const userName = item.getAttribute("data-user-name");
          if (userName) insertMention(userName);
        });
      });
    }

    // Hide mention dropdown
    function hideMentionDropdown() {
      const dropdown = document.getElementById("mention-dropdown");
      if (dropdown) {
        dropdown.classList.add("hidden");
      }
      currentMentionStart = -1;
    }

    // Insert mention into textarea
    function insertMention(userName) {
      const textarea = document.getElementById("comment-message");
      if (!textarea || currentMentionStart === -1) return;

      // Format the username to replace spaces with underscores
      const formattedUserName = userName.replace(/\s+/g, "_");

      const beforeMention = textarea.value.substring(0, currentMentionStart);
      const afterMention = textarea.value.substring(textarea.selectionStart);
      const mentionText = `@${formattedUserName} `;

      textarea.value = beforeMention + mentionText + afterMention;

      // Set cursor position after mention
      const newPosition = beforeMention.length + mentionText.length;
      textarea.setSelectionRange(newPosition, newPosition);
      textarea.focus();

      hideMentionDropdown();
    }

    // Handle mention input
    function handleMentionInput() {
      const textarea = document.getElementById("comment-message");
      if (!textarea) return;

      const cursorPos = textarea.selectionStart;
      const textBeforeCursor = textarea.value.substring(0, cursorPos);

      // Look for @ symbol
      const atIndex = textBeforeCursor.lastIndexOf("@");
      if (atIndex === -1) {
        hideMentionDropdown();
        return;
      }

      // Check if there's a space after @ (not a mention)
      const textAfterAt = textBeforeCursor.substring(atIndex + 1);
      if (textAfterAt.includes(" ")) {
        hideMentionDropdown();
        return;
      }

      // Show dropdown with filtered users
      currentMentionStart = atIndex;
      showMentionDropdown(textAfterAt, atIndex);
    }

    // Initialize discussion functionality when discussion tab is shown
    function initializeDiscussion() {
      // Set user role from server-side data (already set via define:vars)
      currentUserRole = window.PROJECT_USER_ROLE || "Client";
      console.log("üîî [DISCUSSION] User role set to:", currentUserRole);

      // Make user role available globally for reply forms
      window.currentUserRole = currentUserRole;

      const discussionContainer = document.getElementById("discussion-container");
      if (discussionContainer) {
        currentProjectId = discussionContainer.dataset.projectId || "";
        if (currentProjectId) {
          loadDiscussions(currentProjectId);
          loadMentionableUsers();
        }
      }

      // Remove existing event listeners to prevent duplicates
      const newCommentBtn = document.getElementById("new-comment-btn");
      const submitCommentBtn = document.getElementById("submit-comment-btn");
      const commentTextarea = document.getElementById("comment-message");

      if (newCommentBtn) {
        // Remove all existing event listeners by cloning the node
        const newBtn = newCommentBtn.cloneNode(true);
        newCommentBtn.parentNode?.replaceChild(newBtn, newCommentBtn);

        // Add single clean event listener
        newBtn.addEventListener("click", function (e) {
          e.preventDefault();
          e.stopPropagation();
          console.log("üîî [DISCUSSION] New comment button clicked!");
          toggleCommentForm();
        });
      }

      if (submitCommentBtn) {
        submitCommentBtn.removeEventListener("click", submitComment);
        submitCommentBtn.addEventListener("click", submitComment);
      }

      // Add mention functionality to textarea
      if (commentTextarea) {
        commentTextarea.addEventListener("input", handleMentionInput);
        commentTextarea.addEventListener("keydown", (e) => {
          const dropdown = document.getElementById("mention-dropdown");
          if (!dropdown || dropdown.classList.contains("hidden")) return;

          const items = dropdown.querySelectorAll(".mention-item");
          const selected = dropdown.querySelector(
            ".mention-item.bg-gray-50, .mention-item.dark\\:bg-gray-600"
          );
          let selectedIndex = 0;

          if (selected) {
            selectedIndex = parseInt(selected.getAttribute("data-index") || "0");
          }

          if (e.key === "ArrowDown") {
            e.preventDefault();
            const nextIndex = Math.min(selectedIndex + 1, items.length - 1);
            items.forEach((item, i) => {
              item.classList.toggle("bg-gray-50", i === nextIndex);
              item.classList.toggle("dark:bg-gray-600", i === nextIndex);
            });
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            const prevIndex = Math.max(selectedIndex - 1, 0);
            items.forEach((item, i) => {
              item.classList.toggle("bg-gray-50", i === prevIndex);
              item.classList.toggle("dark:bg-gray-600", i === prevIndex);
            });
          } else if (e.key === "Enter" || e.key === "Tab") {
            e.preventDefault();
            const selectedItem = items[selectedIndex];
            if (selectedItem) {
              const userName = selectedItem.getAttribute("data-user-name");
              if (userName) insertMention(userName);
            }
          } else if (e.key === "Escape") {
            e.preventDefault();
            hideMentionDropdown();
          }
        });

        // Hide dropdown when clicking outside
        document.addEventListener("click", (e) => {
          const dropdown = document.getElementById("mention-dropdown");
          const textarea = document.getElementById("comment-message");
          if (dropdown && !dropdown.contains(e.target) && e.target !== textarea) {
            hideMentionDropdown();
          }
        });
      }

      // Add event delegation for completed toggles
      document.addEventListener("change", (e) => {
        const target = e.target;
        if (target.classList.contains("completed-toggle")) {
          const discussionId = parseInt(target.getAttribute("data-discussion-id") || "0");
          const isCompleted = target.checked;
          if (discussionId) {
            toggleDiscussionCompleted(discussionId, isCompleted);
          }
        }
      });

      // Add event delegation for reply buttons
      document.addEventListener("click", (e) => {
        const target = e.target;

        // Only log clicks on buttons or elements that might be reply-related
        // if (target.tagName === 'BUTTON' || target.closest('button') || target.classList.contains('reply-button')) {
        //   console.log("üîî [DISCUSSION] Click event on:", target.tagName, target.className, target.textContent?.trim());
        // }

        if (target.classList.contains("reply-button") || target.closest(".reply-button")) {
          // console.log("üîî [DISCUSSION] Reply button clicked!");
          const button = target.classList.contains("reply-button")
            ? target
            : target.closest(".reply-button");
          if (button) {
            const discussionId = parseInt(button.getAttribute("data-discussion-id") || "0");
            // console.log("üîî [DISCUSSION] Discussion ID from button:", discussionId);
            if (discussionId) {
              showReplyForm(discussionId);
            }
          }
        }
      });

      // console.log("üîî [DISCUSSION] Event listeners attached");
    }

    // Show reply form for a specific comment
    function showReplyForm(parentCommentId) {
      // console.log("üîî [DISCUSSION] showReplyForm called with:", parentCommentId);

      // First, hide any existing inline reply forms
      const existingReplyForms = document.querySelectorAll(".inline-reply-form");
      existingReplyForms.forEach((form) => form.remove());

      // Find the comment element to reply to
      const commentElement = document.querySelector(`[data-discussion-id="${parentCommentId}"]`);
      if (!commentElement) {
        console.error("üîî [DISCUSSION] Comment element not found for ID:", parentCommentId);
        return;
      }

      // Create inline reply form
      const replyFormHTML = `
      <div class="inline-reply-form mt-3 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-600">
        <!-- Textarea -->
        <div class="relative">
          <textarea
            class="reply-message-input w-full resize-none rounded-lg border border-gray-300 p-3 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            placeholder="Type your reply here..."
            rows="3"
          ></textarea>
        </div>
        
        <!-- Admin/Staff Only Toggles for Reply -->
        ${(() => {
          const userRole = window.currentUserRole || "Client";
          return userRole === "Admin" || userRole === "Staff"
            ? `
            <div class="mt-3 flex flex-wrap gap-6 border-t border-gray-200 pt-3 dark:border-gray-600">
              <!-- Internal Only Toggle -->
              <label class="flex items-center gap-3 cursor-pointer">
                <div class="relative">
                  <input
                    type="checkbox"
                    class="reply-internal-toggle sr-only peer"
                  />
                  <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                </div>
                <span class="text-sm text-gray-700 dark:text-gray-300">
                  <i class="bx bx-lock mr-1"></i>
                  Internal Only
                </span>
              </label>
            </div>
          `
            : "";
        })()}
        
        <!-- Buttons Row -->
        <div class="mt-3 flex items-center justify-between">
          <button
            class="cancel-reply-btn px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
            onclick="window.cancelReply(${parentCommentId})"
          >
            Cancel
          </button>
          <button
            class="submit-reply-btn rounded-lg bg-blue-600 px-4 py-2 text-white transition-colors hover:bg-blue-700"
            onclick="window.submitReply(${parentCommentId})"
          >
            <i class="bx bx-send mr-2"></i>
            Post Reply
          </button>
        </div>
      </div>
    `;

      // Insert the reply form after the comment
      commentElement.insertAdjacentHTML("afterend", replyFormHTML);

      // Set the parent comment ID for the reply
      window.currentReplyTo = parentCommentId;

      // Focus on the reply textarea
      const replyTextarea = document.querySelector(".reply-message-input");
      if (replyTextarea) {
        replyTextarea.focus();
      }

      // console.log("üîî [DISCUSSION] Inline reply form created for comment:", parentCommentId);
      // console.log("üîî [DISCUSSION] currentReplyTo set to:", window.currentReplyTo);
    }

    // Toggle discussion completed status
    async function toggleDiscussionCompleted(discussionId, isCompleted) {
      try {
        // console.log("üîî [DISCUSSION] Toggling completed status:", { discussionId, isCompleted });

        const response = await fetch("/api/update-discussion-completed", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            discussionId: discussionId,
            mark_completed: isCompleted,
          }),
        });

        const data = await response.json();

        if (data.success) {
          // console.log("‚úÖ [DISCUSSION] Discussion completed status updated successfully");
          // Update the local discussion data
          const discussion = discussions.find((d) => d.id === discussionId);
          if (discussion) {
            discussion.mark_completed = isCompleted;
          }
          // Update the incomplete comments count
          updateIncompleteCommentsCount();
          // Show success notification
          if (window.showModal) {
            window.showModal(
              "success",
              "Discussion status updated",
              `Marked as ${isCompleted ? "completed" : "incomplete"}`
            );
          }
        } else {
          console.error("‚ùå [DISCUSSION] Failed to update discussion status:", data.error);
          // Revert the toggle if the API call failed
          const toggle = document.getElementById(`completed-toggle-${discussionId}`);
          if (toggle) {
            toggle.checked = !isCompleted;
          }
          // Show error notification
          if (window.showError) {
            window.showError("Update Failed", "Failed to update discussion status");
          }
        }
      } catch (error) {
        console.error("‚ùå [DISCUSSION] Error updating discussion status:", error);
        // Revert the toggle if there was an error
        const toggle = document.getElementById(`completed-toggle-${discussionId}`);
        if (toggle) {
          toggle.checked = !isCompleted;
        }
        // Show error notification
        if (window.showError) {
          window.showError("Update Failed", "Error updating discussion status");
        }
      }
    }

    // Initialize discussion functionality when component loads
    document.addEventListener("DOMContentLoaded", function () {
      console.log("üîî [DISCUSSION] Discussions component loaded, initializing...");
      setTimeout(initializeDiscussion, 100);
    });

    // Make initializeDiscussion globally available for tab switching
    window.initializeDiscussion = initializeDiscussion;
  </script>
</div>
