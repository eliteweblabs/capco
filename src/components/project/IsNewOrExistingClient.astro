---
// This component handles the toggle between new client and existing client
// All toggle logic is contained here, and form data is handled by the parent component
import SlotMachineModal from "../form/SlotMachineModal.astro";
import { supabase } from "../../lib/supabase";

interface Props {
  userRole?: string;
}

// const { currentRole = "Client" } = Astro.props;

// Fetch existing clients for the slot machine - try global data first, fallback to database
let existingClients: any[] = [];
let clientError = null;

// Try to get client profiles from global data first (loaded at dashboard level)
if (typeof window !== "undefined" && (window as any).globalClientProfiles) {
  const globalProfiles = (window as any).globalClientProfiles;
  // console.log(`ðŸ“‹ [IsNewOrExistingClient] Using global client profiles: ${globalProfiles.length}`);

  existingClients = globalProfiles.map((profile: any) => ({
    value: profile.id,
    label: profile.company_name || `Client ${profile.id}`,
  }));
} else {
  // Fallback to database call if global data not available
  // console.log(
  //   "ðŸ“‹ [IsNewOrExistingClient] Global client profiles not available, falling back to database call"
  // );

  if (supabase) {
    try {
      // Get all client profiles
      const { data: profiles, error: profilesError } = await supabase
        .from("profiles")
        .select("id, company_name, role")
        .eq("role", "Client")
        .order("company_name");

      if (profilesError) {
        console.error("Error fetching client profiles:", profilesError);
        clientError = profilesError.message;
      } else if (profiles) {
        // console.log(
        //   `ðŸ“‹ [IsNewOrExistingClient] Loaded ${profiles.length} client profiles from database`
        // );

        // Format clients for slot machine
        existingClients = profiles.map((profile) => ({
          value: profile.id,
          label: profile.company_name || `Client ${profile.id}`,
        }));
      }
    } catch (err) {
      console.error("Exception fetching clients:", err);
      clientError = err instanceof Error ? err.message : "Unknown error";
    }
  } else {
    clientError = "Supabase not configured";
  }
}
---

<div class="space-y-4">
  <div id="existing-client-select-container">
    <SlotMachineModal
      id="existing-client-select"
      name="author_id"
      icon="user-circle"
      title="Select Existing Client"
      options={[]}
      selectedValue=""
      placeholder="Choose an existing client..."
      showCloseButton={true}
      showCancelButton={true}
      buttonText="Select Client"
      buttonVariant="outline"
      searchText="Search Client"
      searchPlaceholder="Type to search clients..."
      apiEndpoint="/api/clients"
      apiParams={{
        role: "Client",
      }}
      valueField="id"
      labelField="company_name"
      fetchOnLoad={true}
      skipSaveToAPI={true}
    />
  </div>

  <div class="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
    <div id="new-client-fields" class="grid grid-cols-1 gap-4 md:grid-cols-2">
      <div>
        <label
          for="first-name"
          class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
        >
          First Name *
        </label>
        <input
          type="text"
          id="first-name"
          name="first_name"
          required
          class="w-full rounded-lg border border-gray-300 bg-background-card px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-background-card-dark dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400"
          placeholder="Enter first name"
        />
      </div>

      <div>
        <label
          for="last-name"
          class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
        >
          Last Name *
        </label>
        <input
          type="text"
          id="last-name"
          name="last_name"
          required
          class="w-full rounded-lg border border-gray-300 bg-background-card px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-background-card-dark dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400"
          placeholder="Enter last name"
        />
      </div>

      <div>
        <label
          for="company-name"
          class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
        >
          Company Name
        </label>
        <input
          type="text"
          id="company-name"
          name="company_name"
          class="w-full rounded-lg border border-gray-300 bg-background-card px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-background-card-dark dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400"
          placeholder="Enter company name"
        />
      </div>

      <div>
        <label for="email" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Email *
        </label>
        <input
          type="email"
          id="email"
          name="email"
          required
          class="w-full rounded-lg border border-gray-300 bg-background-card px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-background-card-dark dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400"
          placeholder="Enter email address"
        />
      </div>
    </div>
  </div>
</div>

<!-- Using proper Flowbite toggle structure - no custom CSS needed -->

<script>
  // Initialize form fields and watch for client selection changes
  document.addEventListener("DOMContentLoaded", function () {
    const newClientFields = document.getElementById("new-client-fields") as HTMLDivElement;

    if (newClientFields) {
      // Set required attributes on new client fields
      const initialNewFields = newClientFields.querySelectorAll("input");
      initialNewFields.forEach((field) => {
        if (field.name === "first_name" || field.name === "last_name" || field.name === "email") {
          field.setAttribute("required", "required");
        }
      });
    }

    // Watch for changes on the author_id hidden input
    const authorIdInput = document.getElementById(
      "existing-client-select-value"
    ) as HTMLInputElement;

    if (authorIdInput) {
      // Create a mutation observer to watch for value changes
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "value") {
            const clientId = authorIdInput.value;
            if (clientId && clientId.trim() !== "") {
              console.log(`ðŸ‘¤ [CLIENT-WATCHER] Author ID changed to: ${clientId}`);
              populateClientFields(clientId);
            }
          }
        });
      });

      // Start observing the input for attribute changes
      observer.observe(authorIdInput, { attributes: true, attributeFilter: ["value"] });

      // Also watch for direct value changes (for browsers that don't trigger attribute mutations)
      let lastValue = authorIdInput.value;
      setInterval(() => {
        if (authorIdInput.value !== lastValue) {
          lastValue = authorIdInput.value;
          if (lastValue && lastValue.trim() !== "") {
            console.log(`ðŸ‘¤ [CLIENT-WATCHER] Author ID changed to: ${lastValue}`);
            populateClientFields(lastValue);
          }
        }
      }, 100); // Check every 100ms
    }
  });

  // Function to populate client fields
  function populateClientFields(clientId: string) {
    console.log(`ðŸ‘¤ [CLIENT-POPULATE] Fetching client data for ID: ${clientId}`);

    fetch(`/api/clients?role=Client&id=${clientId}`)
      .then((response) => response.json())
      .then((data) => {
        if (data.success && data.clients && data.clients.length > 0) {
          const selectedClient = data.clients[0]; // Should only be one client when filtering by ID

          console.log(`ðŸ‘¤ [CLIENT-POPULATE] Found client data:`, selectedClient);

          // Populate the form fields
          const firstNameField = document.getElementById("first-name") as HTMLInputElement;
          const lastNameField = document.getElementById("last-name") as HTMLInputElement;
          const companyNameField = document.getElementById("company-name") as HTMLInputElement;
          const emailField = document.getElementById("email") as HTMLInputElement;

          if (firstNameField) firstNameField.value = selectedClient.first_name || "";
          if (lastNameField) lastNameField.value = selectedClient.last_name || "";
          if (companyNameField) companyNameField.value = selectedClient.company_name || "";
          if (emailField) emailField.value = selectedClient.email || "";

          console.log(`ðŸ‘¤ [CLIENT-POPULATE] Form fields populated successfully`);
        } else {
          console.error(`ðŸ‘¤ [CLIENT-POPULATE] Client not found in API response`);
        }
      })
      .catch((error) => {
        console.error(`ðŸ‘¤ [CLIENT-POPULATE] Error fetching client data:`, error);
      });
  }
</script>
