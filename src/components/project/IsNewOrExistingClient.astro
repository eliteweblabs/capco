---
// This component handles the toggle between new client and existing client
// All toggle logic is contained here, and form data is handled by the parent component

interface Props {
  // userRole?: string;
  globalInputClasses?: string;
  globalSecondaryTextClasses?: string;
  globalPrimaryTextClasses?: string;
  globalCompanyName?: string;
  globalCompanySlogan?: string;
  year?: string;
}
const {
  globalInputClasses,
  globalSecondaryTextClasses,
  globalPrimaryTextClasses,
  globalCompanyName,
  globalCompanySlogan,
  year,
} = Astro.props;

import BoxIcon from "../common/BoxIcon.astro";
import { supabase } from "../../lib/supabase";
import SlotMachineModal from "../form/SlotMachineModal.astro";

// const { currentRole = "Client" } = Astro.props;

// Fetch existing clients for the slot machine - try global data first, fallback to database
let existingClients: any[] = [];
let clientError = null;

// Try to get client profiles from global data first (loaded at dashboard level)
if (typeof window !== "undefined" && (window as any).globalClientProfiles) {
  const globalProfiles = (window as any).globalClientProfiles;
  // console.log(`ðŸ“‹ [IsNewOrExistingClient] Using global client profiles: ${globalProfiles.length}`);

  existingClients = globalProfiles.map((profile: any) => ({
    value: profile.id,
    label: profile.company_name || `Client ${profile.id}`,
  }));
} else {
  // Fallback to database call if global data not available
  // console.log(
  //   "ðŸ“‹ [IsNewOrExistingClient] Global client profiles not available, falling back to database call"
  // );

  if (supabase) {
    try {
      // Get all client profiles
      const { data: profiles, error: profilesError } = await supabase
        .from("profiles")
        .select("id, company_name, role")
        .eq("role", "Client")
        .order("company_name");

      if (profilesError) {
        console.error("Error fetching client profiles:", profilesError);
        clientError = profilesError.message;
      } else if (profiles) {
        // console.log(
        //   `ðŸ“‹ [IsNewOrExistingClient] Loaded ${profiles.length} client profiles from database`
        // );

        // Format clients for slot machine
        existingClients = profiles.map((profile) => ({
          value: profile.id,
          label: profile.company_name || `Client ${profile.id}`,
        }));
      }
    } catch (err) {
      console.error("Exception fetching clients:", err);
      clientError = err instanceof Error ? err.message : "Unknown error";
    }
  } else {
    clientError = "Supabase not configured";
  }
}
---

<div id="existing-client-select-container" class="col-span-6 mb-4">
  <SlotMachineModal
    id="existing-client-select"
    name="author_id"
    icon="user-circle"
    title="Select Existing Client"
    options={existingClients}
    selectedValue=""
    placeholder="Choose an existing client..."
    showCloseButton={true}
    showCancelButton={true}
    buttonText="Select Client"
    buttonVariant="outline"
    buttonClass="w-full"
    searchText="Search Client"
    searchPlaceholder="Type to search clients..."
    valueField="id"
    labelField="company_name"
    fetchOnLoad={false}
    skipSaveToAPI={true}
  />
</div>

<div id="new-client-fields" class="grid grid-cols-1 gap-4 md:grid-cols-2">
  <div>
    <label for="first-name" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
      First Name *
    </label>
    <input
      type="text"
      id="first-name"
      name="first_name"
      required
      class=`${globalInputClasses}`
      placeholder="Enter first name"
    />
  </div>

  <div>
    <label for="last-name" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
      Last Name *
    </label>
    <input
      type="text"
      id="last-name"
      name="last_name"
      required
      class=`${globalInputClasses}`
      placeholder="Enter last name"
    />
  </div>

  <div>
    <label
      for="company-name"
      class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
    >
      Company Name
    </label>
    <input
      type="text"
      id="company-name"
      name="company_name"
      class=`${globalInputClasses}`
      placeholder="Enter company name"
    />
  </div>

  <div>
    <label for="email" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
      Email *
    </label>
    <div class="relative">
      <input
        type="email"
        id="email"
        name="email"
        required
        class=`${globalInputClasses}`
        placeholder="Enter email address"
      />
      <BoxIcon
        id="email-lock-icon"
        variant="primary"
        size="sm"
        name="lock"
        class="invisible absolute right-3 top-1/2 -translate-y-1/2"
      />
    </div>
  </div>
</div>

<!-- Using proper Flowbite toggle structure - no custom CSS needed -->

<script>
  // Initialize form fields and watch for client selection changes
  document.addEventListener("DOMContentLoaded", function () {
    // if (newClientFields) {
    //   // Set required attributes on new client fields
    //   const initialNewFields = newClientFields.querySelectorAll("input");
    //   initialNewFields.forEach((field) => {
    //     if (field.name === "first_name" || field.name === "last_name" || field.name === "email") {
    //       field.setAttribute("required", "required");
    //     }
    //   });
    // }

    // Watch for changes on the author_id hidden input
    const authorIdInput = document.getElementById(
      "existing-client-select-value"
    ) as HTMLInputElement;

    if (authorIdInput) {
      // Create a mutation observer to watch for value changes
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "value") {
            const clientId = authorIdInput.value;
            if (clientId && clientId.trim() !== "") {
              console.log(`ðŸ‘¤ [CLIENT-WATCHER] Author ID changed to: ${clientId}`);
              populateClientFields(clientId);
            }
          }
        });
      });

      // Start observing the input for attribute changes
      observer.observe(authorIdInput, { attributes: true, attributeFilter: ["value"] });

      // Also watch for direct value changes (for browsers that don't trigger attribute mutations)
      let lastValue = authorIdInput.value;
      setInterval(() => {
        if (authorIdInput.value !== lastValue) {
          lastValue = authorIdInput.value;
          if (lastValue && lastValue.trim() !== "") {
            console.log(`ðŸ‘¤ [CLIENT-WATCHER] Author ID changed to: ${lastValue}`);
            populateClientFields(lastValue);
          }
        }
      }, 100); // Check every 100ms
    }
  });

  // Function to populate client fields
  function populateClientFields(clientId: string) {
    console.log(`ðŸ‘¤ [CLIENT-POPULATE] Fetching client data for ID: ${clientId}`);

    fetch(`/api/clients?role=Client&id=${clientId}`)
      .then((response) => response.json())
      .then((data) => {
        if (data.success && data.clients && data.clients.length > 0) {
          const selectedClient = data.clients[0]; // Should only be one client when filtering by ID

          console.log(`ðŸ‘¤ [CLIENT-POPULATE] Found client data:`, selectedClient);

          // Populate the form fields
          const firstNameField = document.getElementById("first-name") as HTMLInputElement;
          const lastNameField = document.getElementById("last-name") as HTMLInputElement;
          const companyNameField = document.getElementById("company-name") as HTMLInputElement;
          const emailField = document.getElementById("email") as HTMLInputElement;
          const emailLockIcon = document.getElementById("email-lock-icon") as HTMLDivElement;
          emailField.setAttribute("readonly", "readonly");
          emailField.classList.add("cursor-not-allowed");
          emailLockIcon.classList.remove("invisible");

          const newClientFields = document.getElementById("new-client-fields") as HTMLDivElement;

          // Get all input fields as an array with their corresponding values
          const inputFields = Array.from(
            newClientFields.querySelectorAll("input")
          ) as HTMLInputElement[];

          // Create a mapping of field IDs to their values
          const fieldValues: { [key: string]: string } = {
            "first-name": selectedClient.first_name || "",
            "last-name": selectedClient.last_name || "",
            "company-name": selectedClient.company_name || "",
            email: selectedClient.email || "",
          };

          // Animate each field with a cascading delay and set values during animation
          inputFields.forEach((field: HTMLInputElement, index: number) => {
            const delay = index * 250; // 250ms delay between each field

            setTimeout(() => {
              // Set the field value during animation
              const fieldId = field.id;
              if (fieldValues[fieldId]) {
                field.value = fieldValues[fieldId];
              }

              // Add animation classes
              field.classList.add("animate-pulse");
              field.classList.add("ring-2");
              field.classList.add("ring-primary-500");
              field.classList.add("dark:ring-primary-400");
              field.classList.add("border-primary-400");
              field.classList.add("dark:border-primary-dark-400");

              // Remove animation classes after 2 seconds
              setTimeout(() => {
                field.classList.remove("animate-pulse");
                field.classList.remove("ring-2");
                field.classList.remove("ring-primary-500");
                field.classList.remove("dark:ring-primary-400");
                field.classList.remove("border-primary-400");
                field.classList.remove("dark:border-primary-dark-400");
              }, 2000);
            }, delay);
          });
          // if (firstNameField) setInterval(() => (firstNameField.focus(), 500));
          // if (lastNameField) setInterval(() => (lastNameField.focus(), 1000));
          // if (companyNameField) setInterval(() => (companyNameField.focus(), 1500));

          console.log(`ðŸ‘¤ [CLIENT-POPULATE] Form fields populated successfully`);
        } else {
          console.error(`ðŸ‘¤ [CLIENT-POPULATE] Client not found in API response`);
        }
      })
      .catch((error) => {
        console.error(`ðŸ‘¤ [CLIENT-POPULATE] Error fetching client data:`, error);
      });
  }
</script>
