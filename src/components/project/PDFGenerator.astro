---
import BoxIcon from "../common/BoxIcon.astro";

interface Props {
  projectId?: string;
  projectData?: {
    title?: string;
    address?: string;
    owner?: string;
    architect?: string;
    description?: string;
    sq_ft?: number;
    status?: string;
  };
  templateType?: "project-agreement" | "proposal" | "invoice";
  buttonText?: string;
  buttonClass?: string;
}

const {
  projectId,
  projectData = {},
  templateType = "project-agreement",
  buttonText = "Generate PDF Agreement",
  buttonClass = "px-4 py-2 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 transition-colors",
} = Astro.props;
---

<div class="pdf-generator-container">
  <button
    type="button"
    class={`pdf-generate-btn ${buttonClass}`}
    data-project-id={projectId}
    data-template-type={templateType}
    data-project-data={JSON.stringify(projectData)}
  >
    <BoxIcon name="file-pdf" class="mr-2" />
    {buttonText}
  </button>

  <!-- PDF Generation Status -->
  <div class="pdf-status mt-2 hidden text-sm">
    <div class="pdf-generating hidden text-blue-600">
      <BoxIcon name="loader-alt" class="mr-1 animate-spin" />
      Generating PDF...
    </div>
    <div class="pdf-success hidden text-green-600">
      <BoxIcon name="check" class="mr-1" />
      PDF generated successfully
    </div>
    <div class="pdf-error hidden text-red-600">
      <BoxIcon name="error" class="mr-1" />
      Failed to generate PDF
    </div>
  </div>

  <!-- Generated PDFs List -->
  <div class="generated-pdfs mt-4 hidden">
    <h4 class="mb-2 font-medium text-gray-900 dark:text-white">Generated Documents</h4>
    <div class="pdf-list space-y-2"></div>
  </div>
</div>

<script type="module">
  class PDFGeneratorManager {
    constructor() {
      this.setupEventListeners();
      this.loadExistingPDFs();
    }

    setupEventListeners() {
      document.addEventListener("click", (event) => {
        const btn = event.target.closest(".pdf-generate-btn");
        if (btn) {
          this.handlePDFGeneration(btn);
        }
      });
    }

    async handlePDFGeneration(button) {
      const projectId = button.dataset.projectId;
      const templateType = button.dataset.templateType || "project-agreement";
      const projectData = JSON.parse(button.dataset.projectData || "{}");

      const container = button.closest(".pdf-generator-container");
      const statusDiv = container?.querySelector(".pdf-status");
      const generatingDiv = statusDiv?.querySelector(".pdf-generating");
      const successDiv = statusDiv?.querySelector(".pdf-success");
      const errorDiv = statusDiv?.querySelector(".pdf-error");

      try {
        // Show generating status
        this.showStatus(statusDiv, generatingDiv);
        button.disabled = true;

        // First, open the template page for user to sign
        const templateUrl = this.buildTemplateUrl(templateType, projectId, projectData);

        // Open in new window for signature collection
        const signatureWindow = window.open(
          templateUrl,
          "pdf-signature",
          "width=1200,height=800,scrollbars=yes,resizable=yes"
        );

        if (!signatureWindow) {
          throw new Error("Please allow popups to generate PDF documents");
        }

        // Wait for signatures to be completed in the popup
        const checkForCompletion = () => {
          return new Promise((resolve, reject) => {
            const checkInterval = setInterval(() => {
              try {
                if (signatureWindow.closed) {
                  clearInterval(checkInterval);
                  reject(new Error("Signature window was closed"));
                  return;
                }

                // Check if signatures are completed
                if (signatureWindow.digitalSignatureManager) {
                  const signatures = signatureWindow.digitalSignatureManager.getAllSignatures();
                  const hasSignatures = Object.values(signatures).some((sig) => sig !== null);

                  if (hasSignatures) {
                    clearInterval(checkInterval);
                    resolve(signatures);
                  }
                }
              } catch (error) {
                // Window might not be accessible due to CORS
                // Continue checking until user closes or completes
              }
            }, 1000);

            // Timeout after 5 minutes
            setTimeout(() => {
              clearInterval(checkInterval);
              reject(new Error("Signature collection timed out"));
            }, 300000);
          });
        };

        // Alternative: Skip signature collection for now and generate PDF directly
        // This can be enhanced later to properly handle signature collection

        await this.generatePDF(templateUrl, {}, projectData);

        // Show success
        this.showStatus(statusDiv, successDiv);
        this.loadExistingPDFs();

        // if (window.showSuccess) {
        //   window.showSuccess(
        //     "PDF Generated",
        //     "Project agreement PDF has been generated successfully.",
        //     5000
        //   );
        // } else {
        //   console.log("ðŸ”” [PDF Generated] Project agreement PDF has been generated successfully.");
        // }
      } catch (error) {
        console.error("PDF generation error:", error);
        this.showStatus(statusDiv, errorDiv);

        if (window.showError) {
          window.showError(
            "PDF Generation Failed",
            error.message || "There was an error generating the PDF.",
            0
          );
        } else {
          console.error(
            "ðŸ”” [PDF Generation Failed]",
            error.message || "There was an error generating the PDF."
          );
        }
      } finally {
        button.disabled = false;

        // Hide status after delay
        setTimeout(() => {
          this.hideStatus(statusDiv);
        }, 5000);
      }
    }

    buildTemplateUrl(templateType, projectId, projectData) {
      const baseUrl = new URL(`/pdf/${templateType}`, window.location.origin);

      if (projectId) {
        baseUrl.searchParams.set("projectId", projectId);
      }

      // Add project data as URL parameters
      Object.entries(projectData).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          baseUrl.searchParams.set(key, String(value));
        }
      });

      return baseUrl.toString();
    }

    async generatePDF(templateUrl, signatures = {}, projectData = {}) {
      const pdfTemplateUrl = templateUrl + (templateUrl.includes("?") ? "&" : "?") + "mode=pdf";

      const response = await fetch("/api/generate-pdf", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          templateUrl: pdfTemplateUrl,
          signatures: signatures,
          projectData: projectData,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
      }

      // Download the PDF
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `project-agreement-${projectData.projectId || "document"}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }

    async loadExistingPDFs() {
      try {
        // Get project IDs from current page
        const projectElements = document.querySelectorAll("[data-project-id]");
        const projectIds = Array.from(projectElements)
          .map((el) => el.dataset.projectId)
          .filter(Boolean);

        if (projectIds.length === 0) return;

        // Fetch existing PDFs for these projects
        const response = await fetch("/api/get-pdf-documents", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ projectIds }),
        });

        if (response.ok) {
          const { pdfs } = await response.json();
          this.displayExistingPDFs(pdfs);
        }
      } catch (error) {
        console.error("Error loading existing PDFs:", error);
      }
    }

    displayExistingPDFs(pdfs) {
      const containers = document.querySelectorAll(".pdf-generator-container");

      containers.forEach((container) => {
        const button = container.querySelector(".pdf-generate-btn");
        const projectId = button?.dataset.projectId;

        if (!projectId) return;

        const projectPDFs = pdfs.filter((pdf) => pdf.project_id === projectId);

        if (projectPDFs.length > 0) {
          const generatedDiv = container.querySelector(".generated-pdfs");
          const pdfList = generatedDiv?.querySelector(".pdf-list");

          if (generatedDiv && pdfList) {
            pdfList.innerHTML = projectPDFs
              .map(
                (pdf) => `
              <div class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded border">
                <div class="flex items-center flex-1 min-w-0">
                  <i class="bx bx-file-pdf text-red-500 mr-2"></i>
                  <span class="text-sm font-medium truncate" title="${pdf.file_name}">${pdf.file_name}</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="text-xs text-gray-500">
                    ${new Date(pdf.created_at).toLocaleDateString()}
                  </span>
                  <button 
                    class="text-xs px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
                    onclick="window.open('/api/download-pdf/${pdf.id}', '_blank')"
                  >
                    Download
                  </button>
                </div>
              </div>
            `
              )
              .join("");

            generatedDiv.classList.remove("hidden");
          }
        }
      });
    }

    showStatus(statusDiv, activeDiv) {
      if (!statusDiv || !activeDiv) return;

      // Hide all status divs
      statusDiv.querySelectorAll("div").forEach((div) => div.classList.add("hidden"));

      // Show the active one
      statusDiv.classList.remove("hidden");
      activeDiv.classList.remove("hidden");
    }

    hideStatus(statusDiv) {
      if (statusDiv) {
        statusDiv.classList.add("hidden");
        statusDiv.querySelectorAll("div").forEach((div) => div.classList.add("hidden"));
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener("DOMContentLoaded", () => {
    if (!window.pdfGeneratorManager) {
      window.pdfGeneratorManager = new PDFGeneratorManager();
    }
  });

  // Make manager globally accessible
  // Note: TypeScript interface declaration would go in a .d.ts file
</script>
