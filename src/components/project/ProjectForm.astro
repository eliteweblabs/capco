---
import { getProjectFormConfig } from "../../lib/forms/form-config-from-site";
import {
  getFilteredUnifiedFormElements,
  isFormElementReadOnly,
} from "../../lib/project-form-config";
import { getColumnClasses, globalClasses } from "../../pages/api/global/global-classes";
import { checkAuth } from "../../lib/auth";
import FormFieldRenderer from "../../features/forms/components/FormFieldRenderer.astro";

import ToggleButtonGroup from "../form/ToggleButtonGroup.astro";
import UnitSlider from "../form/UnitSlider.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";
import Button from "../common/Button.astro";
import StickyActions from "./StickyActions.astro";

interface Props {
  project?: any;
  isNewProject?: boolean;
  projectStatus?: number | null;
  globalInputClasses?: string;
  secondaryTextClasses?: string;
  primaryTextClasses?: string;
}

const { currentUser } = await checkAuth(Astro.cookies);
const {
  project = {},
  isNewProject = true,
  projectStatus = null,
  globalInputClasses,
  secondaryTextClasses,
  primaryTextClasses,
} = Astro.props;

const currentRole = currentUser?.profile?.role;
const projectId = project?.id;
const globalClassesResult = globalClasses();
const globalFormClasses = globalClassesResult.globalFormClasses;
const themeInputClasses = globalClassesResult.globalInputClasses;
// Generate a temporary ID for new projects
const formId = isNewProject ? `${Date.now()}` : projectId || "";

// Prefer FormConfig from form-config-from-site (same pattern as ProfileTabForm, ContactForm, etc.)
const projectFormConfig = await getProjectFormConfig(currentRole, isNewProject, projectStatus);
const useFormConfig = projectFormConfig != null && projectFormConfig.steps?.length > 0;

// Legacy path: when no projectForm in site config, use unified form elements from project-form-config
const formElements = useFormConfig
  ? []
  : await getFilteredUnifiedFormElements(currentRole, isNewProject, projectStatus);

const formFields = useFormConfig ? projectFormConfig!.steps[0].fields ?? [] : [];
const formButtons = useFormConfig ? projectFormConfig!.steps[0].buttons ?? [] : [];

/** Enrich field for FormFieldRenderer: readOnly from readOnlyAtStatus, projectId + value for UnitSlider, options‚Üíbuttons for button-group */
function fieldForRenderer(
  field: any,
  projectStatusVal: number | null,
  formIdVal: string,
  projectData: Record<string, any>
) {
  const readOnly =
    field.readOnlyAtStatus?.length && projectStatusVal != null
      ? field.readOnlyAtStatus.includes(projectStatusVal)
      : false;
  let componentProps = { ...(field.componentProps || {}), readOnly };
  if (field.component === "UnitSlider") {
    componentProps = { ...componentProps, projectId: formIdVal };
  }
  let out = { ...field, componentProps };
  if (field.component === "UnitSlider" && projectData?.[field.name] !== undefined && projectData[field.name] !== "") {
    out = { ...out, value: projectData[field.name] };
  }
  if (field.type === "button-group" && (field.options?.length ?? 0) > 0 && !(field.buttons?.length)) {
    out = {
      ...out,
      buttons: field.options.map((o: { value: string; label: string }) => ({
        type: "choice" as const,
        label: o.label,
        dataValue: o.value,
      })),
    };
  }
  return out;
}

---

<div id="project-form-wrapper">
  <div id="project-form-wrapper">
    <form
      class={`${globalFormClasses} w-full`}
      data-project-id={formId}
      data-is-new-project={isNewProject}
      data-current-role={currentRole}
      data-project-data={JSON.stringify(project || {})}
      autocomplete="off"
    >
      <!-- Form: FormConfig-driven (form-config-from-site) or legacy unified elements -->
      <div id="project-form-elements-grid" class="grid grid-cols-6 md:grid-cols-12 gap-4">
        {useFormConfig ? (
          <>
            {formFields.map((field: any) => {
              const isAddress =
                field.id === "address-input" || field.component === "GoogleAddressAutocomplete";
              if (isAddress) {
                const columnClass = getColumnClasses(field.columns);
                return (
                  <div class={`relative ${columnClass}`}>
                    {isNewProject ? (
                      <div class="col-span-12 md:col-span-6 ">
                        <SlotMachineModal
                          id="address"
                          icon="map-pin"
                          title="Select Address"
                          options={[]}
                          selectedValue={project?.address || ""}
                          placeholder="Search for an address..."
                          showCloseButton={true}
                          showCancelButton={true}
                          buttonText="Select Address *"
                          buttonClass="w-full mb-4"
                          buttonVariant="primary"
                          searchText="Search Address"
                          searchPlaceholder="Type to search addresses..."
                          fetchApiEndpoint="/api/google/places-autocomplete"
                          apiParams={{
                            types: "address",
                            components: "country:us",
                            locationBias: "circle:100@42.3601,-71.0589",
                          }}
                          valueField="description"
                          noResultsText="Type to search addresses..."
                          currentUser={currentUser}
                          project={project}
                          globalInputClasses={globalInputClasses ?? themeInputClasses}
                          currentLocation={true}
                        />
                      </div>
                    ) : (
                      <input
                        type="text"
                        id="address"
                        name="address"
                        value={project?.address || ""}
                        readonly={true}
                        data-scrap="true"
                      />
                    )}
                    {isNewProject && (currentRole === "Admin" || currentRole === "Staff") && (
                      <IsNewOrExistingClient
                        globalInputClasses={globalInputClasses ?? themeInputClasses}
                        secondaryTextClasses={secondaryTextClasses}
                        primaryTextClasses={primaryTextClasses}
                      />
                    )}
                  </div>
                );
              }
              const enrichedField = fieldForRenderer(field, projectStatus, formId, project);
              return (
                <FormFieldRenderer
                  field={enrichedField}
                  context="standard"
                  inputClasses={globalInputClasses ?? themeInputClasses}
                  initialData={project}
                  wrapperClass={`relative ${getColumnClasses(field.columns)}`}
                  buttonDefaults={projectFormConfig!.buttonDefaults ?? {}}
                />
              );
            })}
          </>
        ) : (
          formElements.map((element) => {
            const isReadOnly = isFormElementReadOnly(element, projectStatus);

            if (element.id === "address-input") {
              const columnClass = getColumnClasses(element.columns);

              return (
                <div class={`relative ${columnClass}`}>
                  {isNewProject ? (
                    <div class="col-span-12 md:col-span-6 ">
                      <SlotMachineModal
                        id="address"
                        icon="map-pin"
                        title="Select Address"
                        options={[]}
                        selectedValue={project?.address || ""}
                        placeholder="Search for an address..."
                        showCloseButton={true}
                        showCancelButton={true}
                        buttonText="Select Address *"
                        buttonClass="w-full mb-4"
                        buttonVariant="primary"
                        searchText="Search Address"
                        searchPlaceholder="Type to search addresses..."
                        fetchApiEndpoint="/api/google/places-autocomplete"
                        apiParams={{
                          types: "address",
                          components: "country:us",
                          locationBias: "circle:100@42.3601,-71.0589",
                        }}
                        valueField="description"
                        noResultsText="Type to search addresses..."
                        currentUser={currentUser}
                        project={project}
                        globalInputClasses={globalInputClasses}
                        currentLocation={true}
                      />
                    </div>
                  ) : (
                    <input
                      type="text"
                      id="address"
                      name="address"
                      value={project?.address || ""}
                      readonly={true}
                      data-scrap="true"
                    />
                  )}
                  {isNewProject && (currentRole === "Admin" || currentRole === "Staff") && (
                    <IsNewOrExistingClient
                      globalInputClasses={globalInputClasses}
                      secondaryTextClasses={secondaryTextClasses}
                      primaryTextClasses={primaryTextClasses}
                    />
                  )}
                </div>
              );
            }

            if (element.type === "field") {
              if (element.elementType === "text" || element.elementType === "number") {
                const columnClass = getColumnClasses(element.columns);

                return (
                  <div class={`relative ${columnClass}`}>
                    <label
                      for={`${element.id}`}
                      class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                    >
                      {element.label}
                      {element.required ? " *" : ""}
                    </label>
                    <input
                      type={element.elementType === "number" ? "number" : "text"}
                      id={`${element.id}`}
                      name={element.name}
                      value={
                        project?.[element.name] && project[element.name] !== ""
                          ? project[element.name]
                          : element.value || ""
                      }
                      class={`${globalInputClasses} ${
                        isReadOnly ? "cursor-not-allowed bg-gray-100 color-background" : ""
                      }`}
                      autocomplete={
                        element.name === "architect"
                          ? "organization"
                          : element.name === "title"
                            ? "off"
                            : element.name === "description"
                              ? "off"
                              : element.name === "nfpaVersion"
                                ? "off"
                                : element.name === "hazardousMaterial"
                                  ? "off"
                                  : element.name === "hpsCommodities"
                                    ? "off"
                                    : element.name === "siteAccess"
                                      ? "off"
                                      : element.name === "exteriorBeacon"
                                        ? "off"
                                        : element.name === "fireSprinklerInstallation"
                                          ? "off"
                                          : element.name === "commencementOfConstruction"
                                            ? "off"
                                            : element.name === "suppressionDetectionSystems"
                                              ? "off"
                                              : "off"
                      }
                      placeholder={element.placeholder || ""}
                      required={element.required}
                      min={element.min}
                      max={element.max}
                      step={element.step}
                      readonly={isReadOnly}
                      data-field={element.dataField}
                      data-scrap={element.dataScrap ? "true" : undefined}
                    />
                  </div>
                );
              }

              if (element.elementType === "textarea") {
                const columnClass = getColumnClasses(element.columns);

                return (
                  <div class={`relative ${columnClass}`}>
                    <label
                      for={`${element.id}`}
                      class="block text-sm font-medium text-gray-700 dark:text-gray-300"
                    >
                      {element.label}
                    </label>

                    <textarea
                      id={`${element.id}`}
                      name={element.name}
                      rows="3"
                      class={globalInputClasses}
                      placeholder={element.placeholder || ""}
                      readonly={isReadOnly}
                    > {project?.[element.name] && project[element.name] !== "" ? project[element.name] : element.value || ""}</textarea>
                  </div>
                );
              }

              if (element.elementType === "checkbox") {
                const columnClass = getColumnClasses(element.columns);

                const isChecked =
                  project?.[element.name] === true ||
                  project?.[element.name] === "true" ||
                  project?.[element.name] === 1 ||
                  project?.[element.name] === "1";
                return (
                  <div class={`relative ${columnClass}`}>
                    <label
                      class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                    >
                      <input
                        type="checkbox"
                        id={`${element.id}`}
                        name={element.name}
                        checked={isChecked}
                        disabled={isReadOnly}
                        class="peer sr-only"
                      />
                      <div
                        class={`peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-gray-100 after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-300 dark:border-gray-600 dark:peer-focus:ring-primary-800 rtl:peer-checked:after:-translate-x-full ${
                          isReadOnly
                            ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                            : "bg-gray-200 peer-checked:bg-primary-600 dark:bg-gray-700 dark:peer-checked:bg-primary-600"
                        }`}
                      />
                      <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                        {element.label}
                      </span>
                    </label>
                  </div>
                );
              }

              if (element.elementType === "component" && element.component === "UnitSlider") {
                const columnClass = getColumnClasses(element.columns);

                return (
                  <div class={`relative ${columnClass}`}>
                    <UnitSlider
                      projectId={formId}
                      value={
                        project?.[element.name] && project[element.name] !== ""
                          ? project[element.name]
                          : element.value || 1
                      }
                      readOnly={isReadOnly}
                      name={element.name}
                      label={element.label}
                      min={element.min}
                      max={element.max}
                      step={element.step}
                    />
                  </div>
                );
              }
            }

            // Handle button groups (use ToggleButtonGroup; config uses options or buttons)
            if (element.type === "button-group") {
              const columnClass = getColumnClasses(element.columns);

              // Parse selected values from project data
              let selectedValues: string[] = [];
              if (project?.[element.name]) {
                if (Array.isArray(project[element.name])) {
                  selectedValues = project[element.name];
                } else if (typeof project[element.name] === "string") {
                  try {
                    const parsed = JSON.parse(project[element.name]);
                    selectedValues = Array.isArray(parsed) ? parsed : [project[element.name]];
                  } catch {
                    selectedValues = project[element.name]
                      .split(",")
                      .map((s: string) => s.trim())
                      .filter(Boolean);
                  }
                } else {
                  selectedValues = [String(project[element.name])];
                }
              }

              const rawOptions = element.options ?? element.buttons ?? [];
              const groupButtons = rawOptions.map((opt: any) => {
                if (typeof opt === "string") return { label: opt, value: opt };
                const value = opt.dataValue ?? opt.value ?? opt.label;
                const label = opt.label ?? value;
                return { label, value, selected: opt.selected };
              });

              return (
                <div class={`mt-5 space-y-3 ${columnClass}`}>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                    {element.label}
                  </label>
                  <ToggleButtonGroup
                    name={element.name}
                    buttons={groupButtons}
                    toggleType={element.groupType ?? "radio"}
                    initialValues={selectedValues}
                    disabled={isReadOnly}
                    class={`mb-4 flex flex-wrap gap-2 ${isReadOnly ? "cursor-not-allowed opacity-75" : ""} ${element.cssClass ?? ""}`.trim()}
                  />
                </div>
              );
            }

            // Skip actions in main loop - they're handled separately
            if (element.type === "action") {
              return null;
            }

            return null;
          })
        )}
      </div>

      {/* <!-- Form Actions Container: FormConfig buttons or legacy action elements --> */}
      {useFormConfig ? (
        formButtons.length > 0 ? (
          <StickyActions columns={formButtons.length.toString()}>
            {formButtons.map((btn: any) => (
              <Button
                type={btn.type === "submit" ? "submit" : "button"}
                variant={btn.variant === "info" ? "secondary" : btn.variant || "secondary"}
                size="lg"
                icon={btn.icon}
                iconPosition="left"
                class={btn.classes || ""}
                id={btn.id}
                dataAttributes={{
                  "data-action": btn.action || "",
                  "data-tab": btn.tab || "",
                }}
              >
                <span set:html={btn.label ?? ""} />
              </Button>
            ))}
          </StickyActions>
        ) : null
      ) : (
        (() => {
          const actionElements = formElements.filter((element) => element.type === "action");
          const buttonCount = actionElements.length;
          if (buttonCount === 0) return null;
          return (
            <StickyActions columns={buttonCount.toString()}>
              {actionElements.map((element) => {
                const isReadOnly = isFormElementReadOnly(element, projectStatus);
                return (
                  <Button
                    type={element.elementType === "submit" ? "submit" : "button"}
                    variant={
                      element.variant === "info" ? "secondary" : element.variant || "secondary"
                    }
                    size="lg"
                    icon={element.icon}
                    iconPosition="left"
                    class={element.cssClass || ""}
                    id={element.id}
                    dataAttributes={{
                      "data-action": element.action || "",
                      "data-tab": element.tab || "",
                    }}
                  >
                    <span set:html={element.label} />
                  </Button>
                );
              })}
            </StickyActions>
          );
        })()
      )}
    </form>
  </div>
</div>


<script>
  // Initialize project form
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector("form[data-project-id]");
    if (!form) return;
    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";
    const currentRole = form.getAttribute("data-current-role");

    // Form submission handler
    async function handleFormSubmit(event: Event) {
      const form = event.target as HTMLFormElement;

      // Check form validity before preventing default
      if (!form.checkValidity()) {
        // Let the browser show validation messages
        return;
      }

      event.preventDefault();

      // console.log("üìù [ProjectForm] Form submission started");
      const formData = new FormData(form);
      const projectData: any = {};

      // Convert FormData to object
      console.log("üìù [ProjectForm] FormData entries:");
      for (const [key, value] of formData.entries()) {
        console.log(`üìù [ProjectForm] FormData entry: ${key} = ${value}`);
        if (key.includes("[]")) {
          // Handle array fields (like multi-select button groups)
          const fieldName = key.replace("[]", "");
          if (!projectData[fieldName]) {
            projectData[fieldName] = [];
          }
          projectData[fieldName].push(value);
        } else {
          // Check if this is a button group field that contains JSON arrays
          const buttonGroupFields = ["building", "project", "service", "requestedDocs"];
          if (buttonGroupFields.includes(key) && value && typeof value === "string") {
            console.log(`üìù [ProjectForm] Processing button group field: ${key} = ${value}`);
            try {
              // Parse as JSON array (all button groups now use consistent array format)
              const parsed = JSON.parse(value);
              projectData[key] = Array.isArray(parsed) ? parsed : [];
              console.log(`üìù [ProjectForm] Parsed button group ${key}:`, projectData[key]);
            } catch (error) {
              console.log(`üìù [ProjectForm] Failed to parse button group ${key}:`, error);
              // If parsing fails, default to empty array
              projectData[key] = [];
            }
          } else {
            projectData[key] = value;
          }
        }
      }

      try {
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = true;
          const loaderIcon =
            window.SimpleIcons?.getIcon("loader-2", {
              className: "animate-spin mr-1 inline-block w-4 h-4",
            }) || "";
          submitBtn.innerHTML = `${loaderIcon}Saving...`;
        }

        window.showNotice("info", "Verifying project data...", projectData["address"], 10000);

        let response;
        if (isNewProject) {
          // Create new project
          // console.log("üìù [ProjectForm] Creating new project");
          response = await fetch("/api/projects/upsert", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        } else {
          // Update existing project
          console.log("üìù [ProjectForm] Updating existing project:", projectId, projectData);

          // Include the project ID in the body for the PUT handler
          response = await fetch(`/api/projects/upsert`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ ...projectData, id: projectId }),
          });
        }

        // Check if response is JSON before parsing
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const textResponse = await response.text();
          console.error("üìù [ProjectForm] Non-JSON response received:", {
            status: response.status,
            contentType,
            body: textResponse.substring(0, 200) + "...",
          });
          throw new Error(
            `API returned non-JSON response (${response.status}): ${textResponse.substring(0, 100)}`
          );
        }

        const result = await response.json();

        if (result.success) {
          if (isNewProject) {
            // For new projects, update status to 1 (Under Review) to trigger database-driven notifications

            try {
              console.log("üìù [ProjectForm] Making fetch call now...");

              const project = result.project;
              const nextStatus = 10;

              window.updateStatus(project, nextStatus, undefined).then((data) => {
                if (data.success) {
                  // debugger;
                  if (window.handleNewStatusModalAndEmail && typeof window.handleNewStatusModalAndEmail === "function") {
                    window.handleNewStatusModalAndEmail(data, "PROPOSAL-VIEW");
                  } else {
                    console.warn("‚ö†Ô∏è [PROPOSAL-VIEW] handleNewStatusModalAndEmail not available yet");
                  }
                  // Redirect to project page after successful status update
                  window.location.href = `/project/${data.project.id}?status=discussion`;
                } else {
                  console.error("‚ùå [PROPOSAL-VIEW] Failed to update status:", data.error);
                  // Fallback: redirect even if status update failed (project was created successfully)
                  window.location.href = `/project/${project.id}`;
                }
              }).catch((error: any) => {
                console.error("‚ùå [PROPOSAL-VIEW] Status update error:", error);
                // Fallback: redirect even if status update errored (project was created successfully)
                window.location.href = `/project/${project.id}`;
              });

              // const statusResult = await window.updateStatus(result.project, nextStatus, undefined);
              // window.handleNewStatusModalAndEmail(statusResult, "PROJECT-FORM");
            } catch (statusError) {
              console.error("üìù [ProjectForm] Status update failed:", statusError);
              console.error("üìù [ProjectForm] Status update error details:", statusError);

              // Store error in localStorage for debugging
              localStorage.setItem(
                "projectFormError",
                JSON.stringify({
                  error: (statusError as any)?.message || statusError,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Fallback: just refresh the page
              window.location.reload();
            }
          } else {
            // For existing projects, just show success and refresh
            if (window.showNotice) {
              window.showNotice(
                "success",
                "Project Updated",
                "Project has been updated successfully!"
              );
            }
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          }
        } else {
          console.error("üìù [ProjectForm] API returned success: false");
          console.error("üìù [ProjectForm] Error details:", result.error);
          console.error("üìù [ProjectForm] Full result:", result);
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("üìù [ProjectForm] Error saving project:", error);
        if (window.showNotice) {
          window.showNotice(
            "Error",
            error instanceof Error ? error.message : "Failed to save project",
            "error"
          );
        }
      } finally {
        // Reset button state
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = false;
          const saveIcon =
            window.SimpleIcons?.getIcon("save", {
              className: "mr-1 inline-block w-4 h-4",
            }) || "";
          submitBtn.innerHTML = `Save<span class="hidden md:inline"> Project</span> ${saveIcon}`;
        }
      }
    }

    // Add form submission handler
    form.addEventListener("submit", handleFormSubmit);

    // Note: Delete button is handled by the action button system below
    if (!isNewProject) {
      const deleteBtn = document.getElementById("delete-project");
      deleteBtn?.addEventListener("click", () => {
        window.deleteProject(projectId);
      });
    }

  });

  // Handle different form actions
  function handleAction(action: any, projectId: any, isNewProject: any) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          window.deleteProject(projectId);
        }
        break;
      case "buildProposal":
        // Navigate to proposal tab
        if (typeof window !== "undefined" && window.switchTab) {
          window.switchTab("proposal");
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("üßπ [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons - let ToggleButton component handle its own state
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("selected");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      // console.log("üßπ [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("üßπ [ProjectForm] Auto-resetting new project form");
      // resetForm();
    }
    // Make resetForm globally available
    window.resetForm = resetForm;

    // Square footage numeric filtering
    const sqFtInputs = document.querySelectorAll('input[name="sqFt"]');

    sqFtInputs.forEach((input) => {
      // Prevent non-numeric characters on keypress
      input.addEventListener("keypress", (e) => {
        if (!/[0-9]/.test((e as KeyboardEvent).key)) {
          e.preventDefault();
        }
      });

      // Handle paste events to filter out non-numeric characters
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        const paste = ((e as ClipboardEvent).clipboardData || window.clipboardData).getData("text");
        const numericOnly = paste.replace(/[^0-9]/g, "");
        (input as HTMLInputElement).value = numericOnly;
      });

      // Handle input events to remove any non-numeric characters
      input.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          target.value = target.value.replace(/[^0-9]/g, "");
        }
      });
    });
  });
</script>
