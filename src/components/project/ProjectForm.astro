---
import {
  // BUTTON_GROUPS,
  // PROJECT_FORM_FIELDS,
  getFilteredFormFields,
  getFilteredButtonGroups,
  getFilteredFormActions,
  isFieldReadOnly,
  isButtonGroupReadOnly,
} from "../../lib/project-form-config";
import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import StaffSelect from "./StaffSelectDropdown.astro";
import GoogleAddressAutocomplete from "../form/GoogleAddressAutocomplete.astro";
// import DeleteProject from "../form/DeleteProject.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";

interface Props {
  project?: any;
  projectId?: string | null;
  authorProfile?: any;
  currentRole?: string | null; // Add role prop to control field visibility
  isNewProject?: boolean; // Add flag to indicate if this is a new project
  projectStatus?: number | null; // Add project status for status-based field visibility
}

const {
  project = {},
  projectId = "",
  authorProfile,
  currentRole,
  isNewProject = true,
  projectStatus = null,
} = Astro.props;

// Generate a temporary ID for new projects
const formId = isNewProject ? `new-project-${Date.now()}` : projectId || "";

// Use currentRole prop if provided, otherwise use authenticated role
const effectiveRole = currentRole || currentRole;

// Filter fields based on user role and project status
const formFields = getFilteredFormFields(effectiveRole, isNewProject, projectStatus);

// Get filtered button groups based on user role and project status
const buttonGroups = getFilteredButtonGroups(effectiveRole, isNewProject, projectStatus);

// Get filtered form actions based on user role and project status
const formActions = getFilteredFormActions(effectiveRole, isNewProject, projectStatus);

// Debug logging
// console.log("üìù [ProjectForm] Debug info:", {
//   role,
//   isNewProject,
//   projectStatus,
//   formFieldsCount: formFields.length,
//   buttonGroupsCount: buttonGroups.length,
//   formActionsCount: formActions.length,
//   formFields: formFields.map((f) => ({
//     id: f.id,
//     name: f.name,
//     allow: f.allow,
//   })),
//   buttonGroups: buttonGroups.map((g) => ({
//     id: g.id,
//     name: g.name,
//     allow: g.allow,
//   })),
//   formActions: formActions.map((a) => ({
//     id: a.id,
//     label: a.label,
//     allow: a.allow,
//   })),
// });

// Check specifically for the existing client select field
const existingClientField = formFields.find((f) => f.id === "existing-client-select");
// console.log(
//   existingClientField
//     ? "‚ö†Ô∏è [ProjectForm] Found existing-client-select field"
//     : "‚úÖ [ProjectForm] existing-client-select field correctly filtered out"
// );

// Debug new client fields specifically
// const newClientFieldsInForm = formFields.filter(
//   (field) =>
//     field.name === "first_name" ||
//     field.name === "last_name" ||
//     field.name === "company_name" ||
//     field.name === "email"
// );
// console.log("New client fields found:", newClientFieldsInForm.length, newClientFieldsInForm);
---

<form
  class="w-full space-y-4"
  data-project-id={formId}
  data-project-data={JSON.stringify(project || {})}
  data-is-new-project={isNewProject}
  autocomplete="off"
  novalidate
>
  <!-- New Client Toggle (Top of Form) -->
  {
    isNewProject && (effectiveRole === "Admin" || effectiveRole === "Staff") ? (
      <IsNewOrExistingClient />
    ) : (
      ""
    )
  }

  <!-- Google Address Autocomplete Field -->
  {
    formFields
      .filter(
        (field) => field.type === "component" && field.component === "GoogleAddressAutocomplete"
      )
      .map((field) => (
        <div class="relative">
          <GoogleAddressAutocomplete
            id={`${field.id}`}
            name={field.name}
            label={field.label}
            value={project?.[field.name] || ""}
            placeholder={field.componentProps?.placeholder || "Enter address..."}
            required={field.componentProps?.required || field.required || false}
          />
        </div>
      ))
  }

  <!-- Other Core Fields Grid -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    {
      formFields
        .filter(
          (field) =>
            field.name !== "address" &&
            field.name !== "first_name" &&
            field.name !== "last_name" &&
            field.name !== "company_name" &&
            field.name !== "email" &&
            (field.type === "text" || field.type === "number")
        )
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <div class="relative">
              <label
                for={`${field.id}`}
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {field.label}
                {field.required ? " *" : ""}
              </label>
              <input
                type={field.type === "number" ? "number" : "text"}
                id={`${field.id}`}
                name={field.name}
                value={project?.[field.name] || ""}
                class={`w-full rounded-md border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                  isReadOnly
                    ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                    : "bg-white dark:bg-gray-700"
                }`}
                placeholder={field.placeholder || ""}
                required={field.required}
                min={field.min}
                max={field.max}
                step={field.step}
                readonly={isReadOnly}
                data-field={field.dataField}
                data-project-id={formId}
                data-project-data={JSON.stringify(project || {})}
              />
            </div>
          );
        })
    }
  </div>

  <!-- Description Field -->
  {
    formFields
      .filter((field) => field.type === "textarea")
      .map((field) => {
        const isReadOnly = isFieldReadOnly(field, projectStatus);
        return (
          <div class="relative">
            <label
              for={`${field.id}`}
              class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              {field.label}
            </label>
            {/* prettier-ignore */}
            <textarea id={`${field.id}`} name={field.name} rows="3" class={`w-full rounded-md border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                isReadOnly
                  ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                  : "bg-white dark:bg-gray-700"
              }`} placeholder={field.placeholder || ""} readonly={isReadOnly} data-project-id={formId} data-project-data={JSON.stringify(project || {})}>{project?.[field.name] || ""}</textarea>
            {/* prettier-ignore */}
          </div>
        );
      })
  }

  <!-- Staff Assignment Field (Admin Only) -->
  {
    formFields
      .filter((field) => field.type === "component" && field.component === "StaffSelect")
      .map((field) => {
        // console.log("üßë‚Äçüíº [ProjectForm] Rendering StaffSelect field:", field);
        return (
          <div class="relative">
            <StaffSelect
              id={`${field.id}`}
              label={field.label}
              value={project?.[field.name] || ""}
              projectId={project?.id?.toString() || ""}
              autoSave={true}
              currentRole={currentRole || ""}
            />
          </div>
        );
      })
  }

  <!-- Construction Type & Units Row -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    <!-- Construction Type -->
    <div>
      <label class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
        >Construction Type</label
      >
      <div class="flex gap-4">
        {
          formFields
            .filter((field) => field.type === "checkbox" && field.name !== "new_client")
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              const isChecked =
                project?.[field.name] === true ||
                project?.[field.name] === "true" ||
                project?.[field.name] === 1 ||
                project?.[field.name] === "1";
              return (
                <label
                  class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                >
                  <input
                    type="checkbox"
                    id={`${field.id}`}
                    name={field.name}
                    checked={isChecked}
                    disabled={isReadOnly}
                    class="peer sr-only"
                    data-project-id={formId}
                    data-project-data={JSON.stringify(project || {})}
                  />
                  <div
                    class={`peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-white after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:border-gray-600 dark:peer-focus:ring-blue-800 rtl:peer-checked:after:-translate-x-full ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                        : "bg-gray-200 peer-checked:bg-blue-600 dark:bg-gray-700 dark:peer-checked:bg-blue-600"
                    }`}
                  />
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                    {field.label}
                  </span>
                </label>
              );
            })
        }
      </div>
    </div>

    <!-- Units Slider -->
    {
      formFields
        .filter((field) => field.type === "component" && field.component === "UnitSlider")
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <UnitSlider projectId={formId} value={project?.units || 1} readOnly={isReadOnly} />
          );
        })
    }
  </div>

  <!-- Button Groups -->
  {
    buttonGroups.map((group) => {
      const isReadOnly = isButtonGroupReadOnly(group, projectStatus);
      // Parse selected values from project data
      let selectedValues: string[] = [];
      if (project?.[group.name]) {
        if (Array.isArray(project[group.name])) {
          selectedValues = project[group.name];
        } else if (typeof project[group.name] === "string") {
          try {
            const parsed = JSON.parse(project[group.name]);
            selectedValues = Array.isArray(parsed) ? parsed : [project[group.name]];
          } catch {
            selectedValues = project[group.name]
              .split(",")
              .map((s: string) => s.trim())
              .filter((s: string) => s);
          }
        } else {
          selectedValues = [project[group.name]];
        }
      }

      return (
        <div class="space-y-3" data-project-data={JSON.stringify(project)}>
          <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
            {group.label}
          </label>
          <div class={`flex flex-wrap gap-2 ${isReadOnly ? "pointer-events-none opacity-75" : ""}`}>
            {group.options.map((option) => {
              const isSelected = selectedValues.includes(option.value);
              return (
                <ToggleButton
                  value={option.value}
                  group={group.name}
                  type={group.type}
                  disabled={isReadOnly}
                  class={`${group.cssClass} ${isSelected ? "border-blue-500 bg-blue-500 text-white" : ""} ${
                    isReadOnly ? "cursor-not-allowed" : ""
                  }`}
                >
                  {option.label}
                </ToggleButton>
              );
            })}
          </div>
        </div>
      );
    })
  }

  <!-- Form Actions -->
  <div class="flex gap-2 border-t border-gray-200 pt-4 dark:border-gray-600">
    {
      formActions.map((action) => (
        <button
          type={action.type}
          class={action.cssClass}
          id={action.id}
          data-project-id={formId}
          data-action={action.action}
          data-tab={action.tab}
        >
          {action.icon && <i class={`bx ${action.icon} mr-1`} />}
          {action.label}
        </button>
      ))
    }
  </div>
</form>

<script>
  // Extend Window interface for toast manager
  declare global {
    interface Window {
      toastAlertManager?: any;
      currentProjectData?: any;
    }
  }

  // Initialize project form
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector("form[data-project-id]");
    if (!form) return;

    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    // Make project data available globally
    const projectDataAttr = form.getAttribute("data-project-data");
    if (projectDataAttr) {
      try {
        const projectData = JSON.parse(projectDataAttr);
        // Make project data available globally
        (window as any).currentProjectData = projectData;
        // console.log("Project data loaded:", projectData);
      } catch (error) {
        console.error("Error parsing project data:", error);
      }
    }

    // Add event listeners for action buttons

    // Add form submission handler
    form.addEventListener("submit", handleFormSubmit);

    // Form submission handler
    async function handleFormSubmit(event: Event) {
      event.preventDefault();
      // console.log("üìù [ProjectForm] Form submission started");

      const form = event.target as HTMLFormElement;
      const formData = new FormData(form);
      const projectData: any = {};

      // Convert FormData to object
      for (const [key, value] of formData.entries()) {
        if (key.includes("[]")) {
          // Handle array fields (like multi-select button groups)
          const fieldName = key.replace("[]", "");
          if (!projectData[fieldName]) {
            projectData[fieldName] = [];
          }
          projectData[fieldName].push(value);
        } else {
          // Check if this is a button group field that contains JSON arrays
          const buttonGroupFields = ["building", "project", "service", "requested_docs"];
          if (buttonGroupFields.includes(key) && value && typeof value === "string") {
            try {
              // Parse as JSON array (all button groups now use consistent array format)
              const parsed = JSON.parse(value);
              projectData[key] = Array.isArray(parsed) ? parsed : [];
            } catch {
              // If parsing fails, default to empty array
              projectData[key] = [];
            }
          } else {
            projectData[key] = value;
          }
        }
      }

      // console.log("üìù [ProjectForm] Form data:", projectData);

      try {
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="bx bx-loader-alt animate-spin mr-1"></i>Saving...';
        }

        let response;
        if (isNewProject) {
          // Create new project
          // console.log("üìù [ProjectForm] Creating new project");
          response = await fetch("/api/create-project", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        } else {
          // Update existing project
          // console.log("üìù [ProjectForm] Updating existing project:", projectId);
          response = await fetch(`/api/update-project/${projectId}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        }

        const result = await response.json();
        // console.log("üìù [ProjectForm] API response:", result);
        // console.log("üìù [ProjectForm] Response status:", response.status);
        // console.log("üìù [ProjectForm] Response ok:", response.ok);

        if (result.success) {
          if (isNewProject) {
            // For new projects, update status to 10 (Project Created) to trigger database-driven notifications
            // console.log("üìù [ProjectForm] Updating status to 10 for new project");
            // console.log("üìù [ProjectForm] About to make fetch call to test endpoint");
            try {
              // console.log("üìù [ProjectForm] Making fetch call now...");
              const statusResponse = await fetch("/api/update-status", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include", // Include cookies for authentication
                body: JSON.stringify({
                  projectId: result.project.id,
                  status: 10, // Project Created
                }),
              });

              // console.log("üìù [ProjectForm] Fetch call completed, status:", statusResponse.status);
              const statusResult = await statusResponse.json();
              // console.log("üìù [ProjectForm] Response parsed successfully");
              // console.log("üìù [ProjectForm] Status update response:", statusResult);
              // console.log("üìù [ProjectForm] Status update response status:", statusResponse.status);
              // console.log("üìù [ProjectForm] Status update response ok:", statusResponse.ok);

              // Store response in localStorage for debugging
              localStorage.setItem(
                "projectFormStatusResponse",
                JSON.stringify({
                  response: statusResult,
                  status: statusResponse.status,
                  ok: statusResponse.ok,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              if (statusResult.success && statusResult.statusConfig?.redirect_url) {
                // Use database-driven redirect
                const delay = statusResult.statusConfig.redirect_delay || 0;
                const showCountdown = statusResult.statusConfig.redirect_show_countdown !== false;

                if (delay > 0 && showCountdown) {
                  // Show countdown and redirect after delay
                  if ((window as any).showNotification) {
                    (window as any).showNotification({
                      type: "success",
                      title: "Project Created",
                      message:
                        statusResult.message ||
                        "Project created successfully! Redirecting in {{COUNTDOWN}} seconds...",
                      redirect: {
                        url: statusResult.statusConfig.redirect_url,
                        delay: delay,
                        showCountdown: true,
                      },
                    });
                  } else {
                    // Fallback: redirect after delay
                    setTimeout(() => {
                      window.location.href = statusResult.statusConfig.redirect_url;
                    }, delay * 1000);
                  }
                } else {
                  // Immediate redirect
                  window.location.href = statusResult.statusConfig.redirect_url;
                }
              } else {
                // No redirect configured, just refresh
                window.location.reload();
              }
            } catch (statusError: any) {
              console.error("üìù [ProjectForm] Status update failed:", statusError);
              console.error("üìù [ProjectForm] Status update error details:", statusError);

              // Store error in localStorage for debugging
              localStorage.setItem(
                "projectFormError",
                JSON.stringify({
                  error: statusError?.message || statusError,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Fallback: just refresh the page
              window.location.reload();
            }
          } else {
            // For existing projects, just show success and refresh
            if ((window as any).showSuccess) {
              (window as any).showSuccess(
                "Project Updated",
                "Project has been updated successfully!"
              );
            }
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          }
        } else {
          console.error("üìù [ProjectForm] API returned success: false");
          console.error("üìù [ProjectForm] Error details:", result.error);
          console.error("üìù [ProjectForm] Full result:", result);
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("üìù [ProjectForm] Error saving project:", error);
        if ((window as any).showError) {
          (window as any).showError(
            "Error",
            error instanceof Error ? error.message : "Failed to save project"
          );
        }
      } finally {
        // Reset button state
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = '<i class="bx bx-save mr-1"></i>Save Project';
        }
      }
    }

    // Handle delete button (only for existing projects)
    // Note: Delete button is handled by the action button system below
    if (!isNewProject) {
      const deleteBtn = document.getElementById("delete-project");
      // console.log("Delete button setup:", {
      //   deleteBtn: !!deleteBtn,
      //   projectId,
      //   isNewProject,
      //   formId: form.getAttribute("data-project-id"),
      // });
    }

    // Handle other action buttons
    const actionButtons = document.querySelectorAll("[data-action]");
    actionButtons.forEach((button) => {
      const action = button.getAttribute("data-action");
      const tab = button.getAttribute("data-tab");

      if (projectId) {
        button.addEventListener("click", function () {
          // If button has a tab property, navigate to that tab
          if (tab && typeof window !== "undefined" && (window as any).switchTab) {
            (window as any).switchTab(tab);
          } else if (action) {
            // Otherwise handle the action normally
            handleAction(action, projectId, isNewProject);
          }
        });
      }
    });

    // Setup new client toggle functionality (only for new projects and admin/staff users)
    if (isNewProject) {
      // New client toggle is now handled by the NewOrExistingClient component
    }
  });

  // Delete project function
  let isDeleting = false; // Flag to prevent multiple delete operations

  function deleteProject(projectId: string) {
    // console.log("deleteProject called with projectId:", projectId, "type:", typeof projectId);

    // Prevent multiple delete operations
    if (isDeleting) {
      console.log("Delete operation already in progress, ignoring request");
      return;
    }

    // Validate project ID
    if (!projectId || projectId.startsWith("new-project-")) {
      console.error("Invalid project ID for deletion:", projectId);
      if ((window as any).toastAlertManager) {
        (window as any).toastAlertManager.show({
          type: "error",
          title: "Delete Failed",
          message: "Cannot delete a new project that hasn't been saved yet.",
          duration: 5000,
        });
      }
      return;
    }

    // Show confirmation toast with action buttons
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type: "warning",
        title: "Delete Project",
        message: "Are you sure you want to delete this project? This action cannot be undone.",
        duration: 0, // Don't auto-dismiss
        actions: [
          {
            label: "Cancel",
            action: () => {
              // Just close the toast, do nothing
            },
          },
          {
            label: "Delete",
            action: () => {
              // Set deleting flag to prevent multiple operations
              isDeleting = true;

              // Show loading state
              const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
              if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
              }

              // Make API call to delete project
              console.log("Sending delete request for project:", projectId);
              fetch(`/api/delete-project`, {
                method: "DELETE",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ projectId }),
              })
                .then(async (response) => {
                  console.log("Delete response status:", response.status);
                  const data = await response.json();
                  console.log("Delete response data:", data);

                  if (!response.ok) {
                    throw new Error(data.error || "Failed to delete project");
                  }

                  // Show success toast
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "success",
                      title: "Project Deleted!",
                      message: data.message || "Project has been deleted successfully.",
                      duration: 3000,
                    });
                  }

                  // Reset deleting flag
                  isDeleting = false;

                  // Redirect to dashboard after a short delay
                  setTimeout(() => {
                    window.location.href = "/dashboard";
                  }, 1500);
                })
                .catch((error) => {
                  console.error("Error deleting project:", error);

                  // Show error toast with specific error message
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "error",
                      title: "Delete Failed",
                      message: error.message || "Failed to delete project. Please try again.",
                      duration: 5000,
                    });
                  }

                  // Reset deleting flag and button state
                  isDeleting = false;
                  if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                  }
                });
            },
          },
        ],
      });
    }
  }

  // Show toast notification
  function showToast(
    type: "success" | "error" | "warning" | "info",
    title: string,
    message: string,
    duration: number = 4000
  ) {
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type,
        title,
        message,
        duration,
      });
    }
  }

  // Handle different form actions
  function handleAction(action: string, projectId: string, isNewProject: boolean) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          deleteProject(projectId);
        }
        break;
      case "buildProposal":
        // Navigate to proposal tab
        if (typeof window !== "undefined" && (window as any).switchTab) {
          (window as any).switchTab("proposal");
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form submission handler
  function handleFormSubmit(event: Event) {
    event.preventDefault();
    console.log("Form submission started");

    // Remove required attribute and disable hidden fields to prevent validation errors
    const form = event.target as HTMLFormElement;

    // Find all hidden fields (by style, class, or parent visibility)
    const hiddenFields = form.querySelectorAll(`
      input[style*="display: none"], 
      input[style*="display:none"], 
      .hidden input,
      input[disabled],
      input[type="hidden"]
    `);

    // Also check for fields in hidden containers
    const hiddenContainers = form.querySelectorAll(
      '[style*="display: none"], [style*="display:none"], .hidden'
    );
    hiddenContainers.forEach((container) => {
      const containerInputs = container.querySelectorAll("input, textarea, select");
      containerInputs.forEach((field) => {
        if (
          field instanceof HTMLInputElement ||
          field instanceof HTMLTextAreaElement ||
          field instanceof HTMLSelectElement
        ) {
          field.removeAttribute("required");
          field.disabled = true;
        }
      });
    });

    hiddenFields.forEach((field) => {
      if (
        field instanceof HTMLInputElement ||
        field instanceof HTMLTextAreaElement ||
        field instanceof HTMLSelectElement
      ) {
        field.removeAttribute("required");
        field.disabled = true;
      }
    });
    const formData = new FormData(form);
    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    console.log("Form data:", { projectId, isNewProject });

    // Collect form data
    const formValues: any = {};
    for (const [key, value] of formData.entries()) {
      formValues[key] = value;
    }

    // console.log("üìù [ProjectForm] Raw form data collected:", formValues);
    // console.log("üìù [ProjectForm] assigned_to_id value:", formValues.assigned_to_id);
    // console.log("üìù [ProjectForm] All form field names:", Object.keys(formValues));

    // The API will handle author_id logic based on user role
    // For admin/staff: author_id comes from form (new client or existing client select)
    // For clients: author_id will be set to their own ID

    // Collect toggle button values
    const toggleButtons = form.querySelectorAll(".toggle-button.bg-blue-500");
    // console.log("üìù [ProjectForm] Found toggle buttons:", toggleButtons.length);
    toggleButtons.forEach((button) => {
      const group = button.getAttribute("data-group");
      const value = button.getAttribute("data-value");
      const type = button.getAttribute("data-type");

      // console.log("üìù [ProjectForm] Toggle button:", { group, value, type });

      if (group && value) {
        if (type === "multi-select") {
          if (!formValues[group]) {
            formValues[group] = [];
          }
          if (Array.isArray(formValues[group])) {
            formValues[group].push(value);
          } else {
            formValues[group] = [formValues[group], value];
          }
        } else {
          formValues[group] = value;
        }
      }
    });

    // Get units value from slider
    const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
    if (unitsSlider) {
      const unitsOptions = unitsSlider.getAttribute("data-values")?.split(",") || [];
      const sliderValue = parseInt(unitsSlider.value);
      formValues.units = unitsOptions[sliderValue] || "1";
      // console.log("üìù [ProjectForm] Units slider value:", {
      //   sliderValue,
      //   unitsValue: formValues.units,
      // });
    } else {
      console.log("üìù [ProjectForm] Units slider not found");
    }

    // console.log("Form data:", formValues);

    // Determine API endpoint based on new/existing project
    const endpoint = isNewProject ? "/api/create-project" : `/api/update-project/${projectId}`;
    const method = isNewProject ? "POST" : "PUT";

    // Show loading state
    const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;

    if (!submitBtn) {
      console.error("Submit button not found");
      return;
    }

    const originalText = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Saving...';

    // Submit form data
    fetch(endpoint, {
      method: method,
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formValues),
    })
      .then(async (response) => {
        const result = await response.json();

        if (!response.ok) {
          // Handle different error types from API response
          let errorTitle = "Save Failed";
          let errorMessage = "Failed to save project. Please try again.";
          let errorDuration = 5000;

          // Check for specific error types
          if (result.error) {
            errorMessage = result.error;
          }

          if (result.details) {
            // Use the detailed error message for more specific feedback
            errorMessage = result.details;
          }

          // Handle specific error cases
          if (result.error && result.error.includes("validation")) {
            errorTitle = "Validation Error";
            errorMessage = "Please check your input and try again.";
          } else if (result.error && result.error.includes("authentication")) {
            errorTitle = "Authentication Error";
            errorMessage = "Please log in again and try saving the project.";
          } else if (result.error && result.error.includes("permission")) {
            errorTitle = "Permission Denied";
            errorMessage = "You don't have permission to save this project.";
          } else if (result.error && result.error.includes("not found")) {
            errorTitle = "Project Not Found";
            errorMessage = "The project you're trying to update could not be found.";
          } else if (result.error && result.error.includes("required")) {
            errorTitle = "Missing Information";
            errorMessage = "Please fill in all required fields.";
          }

          // Show error toast using centralized system
          if ((window as any).showError) {
            (window as any).showError(errorTitle, errorMessage, errorDuration);
          }

          throw new Error(errorMessage);
        }

        console.log("Project saved successfully:", result);

        // Success is indicated by the redirect and project save
        // No need for hardcoded toast messages - let the database-driven system handle notifications

        // For new projects, set initial status to 10 and trigger email notifications
        if (isNewProject && result.id) {
          console.log("üîç [ProjectForm] New project created, setting initial status to 10...");

          try {
            // console.log("üîç [ProjectForm] About to call update-status API...");
            // console.log("üîç [ProjectForm] Project ID:", result.id);

            // Call update-status API to set initial status and trigger notifications
            const statusResponse = await fetch("/api/update-status", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              credentials: "include", // Include cookies for authentication
              body: JSON.stringify({
                projectId: result.id,
                status: 10, // Fixed: API expects 'status', not 'newStatus'
              }),
            });

            if (statusResponse.ok) {
              const statusResult = await statusResponse.json();
              // console.log("üîç [ProjectForm] Status update successful:", statusResult);
            } else {
              const errorText = await statusResponse.text();
              console.error("üîç [ProjectForm] Status update failed:", errorText);
            }
          } catch (statusError) {
            console.error("üîç [ProjectForm] Error calling update-status API:", statusError);
          }

          // The update-status API call above should trigger database-driven toast messages
          // No need for hardcoded notifications - let the status system handle it
        }

        return result;
      })
      .catch((error) => {
        console.error("Error saving project:", error);

        // Only show generic error if we haven't already shown a specific error
        if ((window as any).showError && !error.message.includes("Failed to save project")) {
          (window as any).showError(
            "Network Error",
            "Network error. Please check your connection and try again.",
            5000
          );
        }
      })
      .finally(() => {
        // Reset button state
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
      });
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("üßπ [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("bg-blue-500", "text-white", "border-blue-500");
        button.classList.add("bg-white", "dark:bg-gray-700", "text-gray-700", "dark:text-gray-300");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      console.log("üßπ [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("üßπ [ProjectForm] Auto-resetting new project form");
      resetForm();
    }
  });

  // Make resetForm globally available
  (window as any).resetForm = resetForm;
</script>
