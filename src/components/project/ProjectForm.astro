---
import {
  // BUTTON_GROUPS,
  // PROJECT_FORM_FIELDS,
  getFilteredFormFields,
  getFilteredButtonGroups,
  getFilteredFormActions,
  isFieldReadOnly,
  isButtonGroupReadOnly,
} from "../../lib/project-form-config";
import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import ClientSelect from "../form/ClientSelect.astro";
import StaffSelect from "../form/StaffSelect.astro";
import GoogleAddressAutocomplete from "../form/GoogleAddressAutocomplete.astro";
// import DeleteProject from "../form/DeleteProject.astro";

interface Props {
  project?: any;
  projectId?: string | null;
  userRole?: string | null; // Add userRole prop to control field visibility
  isNewProject?: boolean; // Add flag to indicate if this is a new project
  projectStatus?: number | null; // Add project status for status-based field visibility
}

const {
  project = {},
  projectId = "",
  userRole,
  isNewProject = false,
  projectStatus = null,
} = Astro.props;

// Generate a temporary ID for new projects
const formId = isNewProject ? `new-project-${Date.now()}` : projectId || "";

// Filter fields based on user role and project status
const formFields = getFilteredFormFields(userRole, isNewProject, projectStatus);

// Get filtered button groups based on user role and project status
const buttonGroups = getFilteredButtonGroups(userRole, isNewProject, projectStatus);

// Get filtered form actions based on user role and project status
const formActions = getFilteredFormActions(userRole, isNewProject, projectStatus);

// Debug logging
console.log("üìù [ProjectForm] Debug info:", {
  userRole,
  isNewProject,
  projectStatus,
  formFieldsCount: formFields.length,
  buttonGroupsCount: buttonGroups.length,
  formActionsCount: formActions.length,
  formFields: formFields.map((f) => ({
    id: f.id,
    name: f.name,
    allow: f.allow,
  })),
  buttonGroups: buttonGroups.map((g) => ({
    id: g.id,
    name: g.name,
    allow: g.allow,
  })),
  formActions: formActions.map((a) => ({
    id: a.id,
    label: a.label,
    allow: a.allow,
  })),
});

// Check specifically for the existing client select field
const existingClientField = formFields.find(f => f.id === "existing-client-select");
console.log(existingClientField ? "‚ö†Ô∏è [ProjectForm] Found existing-client-select field" : "‚úÖ [ProjectForm] existing-client-select field correctly filtered out");

// Debug new client fields specifically
const newClientFieldsInForm = formFields.filter(
  (field) => field.name === "first_name" || field.name === "last_name" || field.name === "company_name" || field.name === "email"
);
console.log("New client fields found:", newClientFieldsInForm.length, newClientFieldsInForm);
---


<form
  class="space-y-4 w-full"
  data-project-id={formId}
  data-project-data={JSON.stringify(project || {})}
  data-is-new-project={isNewProject}
  onsubmit="handleFormSubmit(event)"
>
  <!-- New Client Toggle (Top of Form) -->
  {
    formFields
      .filter((field) => field.name === "new_client")
      .map((field) => {
        const isChecked =
          project?.[field.name] === true ||
          project?.[field.name] === "true" ||
          project?.[field.name] === 1 ||
          project?.[field.name] === "1";
        return (
          <div class="relative">
            <label class="inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                id={`${field.id}`}
                name={field.name}
                checked={isChecked}
                class="sr-only peer"
                data-project-id={formId}
                data-project-data={JSON.stringify(project || {})}
              />
              <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600" />
              <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                {field.label}
              </span>
            </label>
          </div>
        );
      })
  }

  <!-- Client Fields (First Name, Last Name, Company Name for new client, or Existing Client dropdown) -->
  <div class="space-y-4">
    <!-- New Client Fields (First Name, Last Name, Company Name) - Only shown when new client toggle is on -->
    {isNewProject && (
      <div id="new-client-fields-container" class="space-y-4">
        <!-- First Name and Last Name Row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          {
            formFields
              .filter((field) => field.name === "first_name" || field.name === "last_name")
              .map((field) => {
                const isReadOnly = isFieldReadOnly(field, projectStatus);
                return (
                  <div class="relative">
                    <label
                      for={`${field.id}`}
                      class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                    >
                      {field.label}
                      {field.required ? " *" : ""}
                    </label>
                    <input
                      type="text"
                      id={`${field.id}`}
                      name={field.name}
                      value={project?.[field.name] || ""}
                      class={`w-full py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 rounded-md text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 ${
                        isReadOnly 
                          ? "bg-gray-100 dark:bg-gray-800 cursor-not-allowed" 
                          : "bg-white dark:bg-gray-700"
                      }`}
                      placeholder={field.placeholder || ""}
                      required={field.required}
                      readonly={isReadOnly}
                      data-field={field.dataField}
                      data-project-id={formId}
                      data-project-data={JSON.stringify(project || {})}
                    />
                  </div>
                );
              })
          }
        </div>

        <!-- Company Name Field (Full Width) -->
        {
          formFields
            .filter((field) => field.name === "company_name")
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              return (
                <div class="relative">
                  <label
                    for={`${field.id}`}
                    class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    {field.label}
                    {field.required ? " *" : ""}
                  </label>
                  <input
                    type="text"
                    id={`${field.id}`}
                    name={field.name}
                    value={project?.[field.name] || ""}
                    class={`w-full py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 rounded-md text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 ${
                      isReadOnly 
                        ? "bg-gray-100 dark:bg-gray-800 cursor-not-allowed" 
                        : "bg-white dark:bg-gray-700"
                    }`}
                    placeholder={field.placeholder || ""}
                    required={field.required}
                    readonly={isReadOnly}
                    data-field={field.dataField}
                    data-project-id={formId}
                    data-project-data={JSON.stringify(project || {})}
                  />
                </div>
              );
            })
        }

        <!-- Email Field (for new client) -->
        {
          formFields
            .filter((field) => field.name === "email")
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              return (
                <div class="relative">
                  <label
                    for={`${field.id}`}
                    class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                  >
                    {field.label}
                    {field.required ? " *" : ""}
                  </label>
                  <input
                    type="email"
                    id={`${field.id}`}
                    name={field.name}
                    value={project?.[field.name] || ""}
                    class={`w-full py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 rounded-md text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 ${
                      isReadOnly 
                        ? "bg-gray-100 dark:bg-gray-800 cursor-not-allowed" 
                        : "bg-white dark:bg-gray-700"
                    }`}
                    placeholder={field.placeholder || ""}
                    required={field.required}
                    readonly={isReadOnly}
                    data-field={field.dataField}
                    data-project-id={formId}
                    data-project-data={JSON.stringify(project || {})}
                  />
                </div>
              );
            })
        }
      </div>
    )}

    <!-- Existing Client Selection (filtered by role) -->
    {
      formFields
        .filter((field) => field.name === "author_id" && field.type === "select")
        .map((field) => (
            <div id="existing-client-container" class="relative">
              <ClientSelect
                selectedUserId={project?.author_id || ""}
                name="author_id"
                id="existing-client-select"
                label="Select Existing Client"
                role="Client"
                required={false}
                class="w-full"
              />
            </div>
        ))
    }
  </div>

  <!-- Google Address Autocomplete Field -->
  {
    formFields
      .filter((field) => field.type === "component" && field.component === "GoogleAddressAutocomplete")
      .map((field) => (
        <div class="relative">
          <GoogleAddressAutocomplete
            id={`${field.id}`}
            name={field.name}
            label={field.label}
            value={project?.[field.name] || ""}
            placeholder={field.componentProps?.placeholder || "Enter address..."}
            required={field.componentProps?.required || field.required || false}
          />
        </div>
      ))
  }

  <!-- Other Core Fields Grid -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
    {
      formFields
        .filter(
          (field) =>
            field.name !== "address" &&
            field.name !== "first_name" &&
            field.name !== "last_name" &&
            field.name !== "company_name" &&
            field.name !== "email" &&
            (field.type === "text" || field.type === "number")
        )
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <div class="relative">
              <label
                for={`${field.id}`}
                class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                {field.label}
                {field.required ? " *" : ""}
              </label>
              <input
                type={field.type === "number" ? "number" : "text"}
                id={`${field.id}`}
                name={field.name}
                value={project?.[field.name] || ""}
                class={`w-full py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 rounded-md text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 ${
                  isReadOnly 
                    ? "bg-gray-100 dark:bg-gray-800 cursor-not-allowed" 
                    : "bg-white dark:bg-gray-700"
                }`}
                placeholder={field.placeholder || ""}
                required={field.required}
                min={field.min}
                max={field.max}
                step={field.step}
                readonly={isReadOnly}
                data-field={field.dataField}
                data-project-id={formId}
                data-project-data={JSON.stringify(project || {})}
              />
            </div>
          );
        })
    }
  </div>

  <!-- Description Field -->
  {
    formFields
      .filter((field) => field.type === "textarea")
      .map((field) => {
        const isReadOnly = isFieldReadOnly(field, projectStatus);
        return (
          <div class="relative">
            <label
              for={`${field.id}`}
              class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              {field.label}
            </label>
            <textarea
              id={`${field.id}`}
              name={field.name}
              rows="3"
              class={`w-full py-2 px-3 text-sm border border-gray-300 dark:border-gray-600 rounded-md text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 ${
                isReadOnly 
                  ? "bg-gray-100 dark:bg-gray-800 cursor-not-allowed" 
                  : "bg-white dark:bg-gray-700"
              }`}
              placeholder={field.placeholder || ""}
              readonly={isReadOnly}
              data-project-id={formId}
              data-project-data={JSON.stringify(project || {})}
            >{project?.[field.name] || ""}</textarea>
          </div>
        );
      })
  }

  <!-- Staff Assignment Field (Admin Only) -->
  {
    formFields
      .filter((field) => field.type === "component" && field.component === "StaffSelect")
      .map((field) => (
        <div class="relative">
          <StaffSelect
            id={`${field.id}`}
            name={field.name}
            label={field.label}
            value={project?.[field.name] || ""}
          />
        </div>
      ))
  }

  <!-- Construction Type & Units Row -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
    <!-- Construction Type -->
    <div>
      <label
        class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
        >Construction Type</label
      >
      <div class="flex gap-4">
        {
          formFields
            .filter(
              (field) =>
                field.type === "checkbox" && field.name !== "new_client"
            )
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              const isChecked =
                project?.[field.name] === true ||
                project?.[field.name] === "true" ||
                project?.[field.name] === 1 ||
                project?.[field.name] === "1";
              return (
                <label class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}>
                  <input
                    type="checkbox"
                    id={`${field.id}`}
                    name={field.name}
                    checked={isChecked}
                    disabled={isReadOnly}
                    class="sr-only peer"
                    data-project-id={formId}
                    data-project-data={JSON.stringify(project || {})}
                  />
                  <div class={`relative w-11 h-6 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 ${
                    isReadOnly 
                      ? "bg-gray-300 dark:bg-gray-600 cursor-not-allowed" 
                      : "bg-gray-200 dark:bg-gray-700 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"
                  }`} />
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                    {field.label}
                  </span>
                </label>
              );
            })
        }
      </div>
    </div>

    <!-- Units Slider -->
    <UnitSlider projectId={formId} value={project?.units || 1} />
  </div>

  <!-- Button Groups -->
  {
    buttonGroups.map((group) => {
      const isReadOnly = isButtonGroupReadOnly(group, projectStatus);
      // Parse selected values from project data
      let selectedValues: string[] = [];
      if (project?.[group.name]) {
        if (Array.isArray(project[group.name])) {
          selectedValues = project[group.name];
        } else if (typeof project[group.name] === "string") {
          try {
            const parsed = JSON.parse(project[group.name]);
            selectedValues = Array.isArray(parsed)
              ? parsed
              : [project[group.name]];
          } catch {
            selectedValues = project[group.name]
              .split(",")
              .map((s: string) => s.trim())
              .filter((s: string) => s);
          }
        } else {
          selectedValues = [project[group.name]];
        }
      }

      return (
        <div class="space-y-3" data-project-data={JSON.stringify(project)}>
          <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
            {group.label}
          </label>
          <div class={`flex flex-wrap gap-2 ${isReadOnly ? "pointer-events-none opacity-75" : ""}`}>
            {group.options.map((option) => {
              const isSelected = selectedValues.includes(option.value);
              return (
                <ToggleButton
                  value={option.value}
                  group={group.name}
                  type={group.type}
                  disabled={isReadOnly}
                  class={`${group.cssClass} ${isSelected ? "bg-blue-500 text-white border-blue-500" : ""} ${
                    isReadOnly ? "cursor-not-allowed" : ""
                  }`}
                >
                  {option.label}
                </ToggleButton>
              );
            })}
          </div>
        </div>
      );
    })
  }

  <!-- Form Actions -->
  <div class="flex gap-2 pt-4 border-t border-gray-200 dark:border-gray-600">
    {
      formActions.map((action) => (
        <button
          type={action.type}
          class={action.cssClass}
          id={action.id}
          data-project-id={formId}
          data-action={action.action}
        >
          {action.icon && <i class={`bx ${action.icon} mr-1`} />}
          {action.label}
        </button>
      ))
    }
  </div>
</form>

<script>
  // Extend Window interface for toast manager
  declare global {
    interface Window {
      toastAlertManager?: any;
      currentProjectData?: any;
    }
  }

  // Make project data available globally
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector("form[data-project-id]");
    if (form) {
      const projectId = form.getAttribute("data-project-id");
      const projectDataAttr = form.getAttribute("data-project-data");
      if (projectDataAttr) {
        try {
          const projectData = JSON.parse(projectDataAttr);
          // Make project data available globally
          (window as any).currentProjectData = projectData;
          console.log("Project data loaded:", projectData);
        } catch (error) {
          console.error("Error parsing project data:", error);
        }
      }
    }
  });

  // Add event listeners for action buttons
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector("form[data-project-id]");
    if (form) {
      const projectId = form.getAttribute("data-project-id");
      const isNewProject = form.getAttribute("data-is-new-project") === "true";

      // Add form submission handler
      form.addEventListener("submit", handleFormSubmit);

      // Handle delete button (only for existing projects)
      // Note: Delete button is handled by the action button system below
      if (!isNewProject) {
        const deleteBtn = document.getElementById("delete-project");
        console.log("Delete button setup:", {
          deleteBtn: !!deleteBtn,
          projectId,
          isNewProject,
          formId: form.getAttribute("data-project-id")
        });
      }

      // Handle other action buttons
      const actionButtons = document.querySelectorAll("[data-action]");
      actionButtons.forEach((button) => {
        const action = button.getAttribute("data-action");
        if (action && projectId) {
          button.addEventListener("click", function () {
            handleAction(action, projectId, isNewProject);
          });
        }
      });

      // Setup new client toggle functionality (only for new projects and admin/staff users)
      if (isNewProject) {
        // Check if the new client toggle exists (only for admin/staff users)
        const newClientToggleExists = document.getElementById('new-client-toggle');
        if (newClientToggleExists) {
          setupNewClientToggle();
        } else {
          console.log("‚ÑπÔ∏è New client toggle not available for this user role - skipping setup");
        }
      }
    }
  });

  // Setup new client toggle functionality
  function setupNewClientToggle() {
    // Get the form to extract the formId
    const form = document.querySelector(
      "form[data-project-id]"
    ) as HTMLFormElement;
    if (!form) {
      console.error("Project form not found");
      return;
    }

    const formId = form.getAttribute("data-project-id");
    if (!formId) {
      console.error("Form ID not found");
      return;
    }

    // Find the new client toggle using the correct ID
    const newClientToggle = document.getElementById(
      `new-client-toggle`
    ) as HTMLInputElement;
    const existingClientContainer = document.getElementById(
      "existing-client-container"
    ) as HTMLElement;
    
 
    if (!newClientToggle) {
      console.log("‚ÑπÔ∏è New client toggle not found - this is expected for client users");
      return;
    }

    // Handle toggle change
    newClientToggle.addEventListener("change", function () {
      const isNewClient = this.checked;
      
      // Find the new client fields container using the specific ID
      const newClientFieldsContainer = document.getElementById('new-client-fields-container') as HTMLElement;
      
      console.log("üîÑ Toggle changed:", {
        isNewClient,
        newClientFieldsContainer: !!newClientFieldsContainer,
        existingClientContainer: !!existingClientContainer,
      });

      if (isNewClient) {
        // Show new client fields (first name, last name, company name, email), hide existing client dropdown
        console.log("üìù Showing new client fields, hiding client dropdown");
        
        if (newClientFieldsContainer) {
          newClientFieldsContainer.style.display = "block";
          console.log("‚úÖ New client fields shown");
        }
        
        if (existingClientContainer) {
          existingClientContainer.style.display = "none";
          console.log("‚úÖ Client dropdown hidden");
        }
      } else {
        // Hide new client fields, show existing client dropdown
        console.log("üîΩ Hiding new client fields, showing client dropdown");

        if (newClientFieldsContainer) {
          newClientFieldsContainer.style.display = "none";
          console.log("‚úÖ New client fields hidden");
        }
        
        if (existingClientContainer) {
          existingClientContainer.style.display = "block";
          console.log("‚úÖ Client dropdown shown");
        }
      }
    });

    // Set initial state
    newClientToggle.dispatchEvent(new Event("change"));

    // Listen for client selection events from ClientSelect component
    document.addEventListener("clientSelected", function (e) {
      const customEvent = e as CustomEvent;
      console.log("üîî [ProjectForm] Client selected:", customEvent.detail);

      // The form will automatically pick up the value since the component uses the correct name attribute
      // This is just for logging/debugging purposes
    });
  }

  // Delete project function
  function deleteProject(projectId: string) {
    console.log("deleteProject called with projectId:", projectId, "type:", typeof projectId);
    
    // Validate project ID
    if (!projectId || projectId.startsWith("new-project-")) {
      console.error("Invalid project ID for deletion:", projectId);
      if ((window as any).toastAlertManager) {
        (window as any).toastAlertManager.show({
          type: "error",
          title: "Delete Failed",
          message: "Cannot delete a new project that hasn't been saved yet.",
          duration: 5000,
        });
      }
      return;
    }
    
    // Show confirmation toast with action buttons
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type: "warning",
        title: "Delete Project",
        message:
          "Are you sure you want to delete this project? This action cannot be undone.",
        duration: 0, // Don't auto-dismiss
        actions: [
          {
            label: "Cancel",
            action: () => {
              // Just close the toast, do nothing
            },
          },
          {
            label: "Delete",
            action: () => {
              // Show loading state
              const deleteBtn = document.getElementById(
                "delete-project"
              ) as HTMLButtonElement;
              if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.innerHTML =
                  '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
              }

              // Make API call to delete project
              console.log("Sending delete request for project:", projectId);
              fetch(`/api/delete-project`, {
                method: "DELETE",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ projectId }),
              })
                .then(async (response) => {
                  console.log("Delete response status:", response.status);
                  const data = await response.json();
                  console.log("Delete response data:", data);
                  
                  if (!response.ok) {
                    throw new Error(data.error || "Failed to delete project");
                  }
                  
                  // Show success toast
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "success",
                      title: "Project Deleted!",
                      message: data.message || "Project has been deleted successfully.",
                      duration: 3000,
                    });
                  }

                  // Redirect to dashboard after a short delay
                  setTimeout(() => {
                    window.location.href = "/dashboard";
                  }, 1500);
                })
                .catch((error) => {
                  console.error("Error deleting project:", error);

                  // Show error toast
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "error",
                      title: "Delete Failed",
                      message: "Failed to delete project. Please try again.",
                      duration: 5000,
                    });
                  }

                  // Reset button state
                  if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML =
                      '<i class="bx bx-trash mr-1"></i>Delete Project';
                  }
                });
            },
          },
        ],
      });
    }
  }

  // Show toast notification
  function showToast(
    type: "success" | "error" | "warning" | "info",
    title: string,
    message: string,
    duration: number = 4000
  ) {
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type,
        title,
        message,
        duration,
      });
    }
  }

  // Handle different form actions
  function handleAction(
    action: string,
    projectId: string,
    isNewProject: boolean
  ) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          deleteProject(projectId);
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

 
 

  // Form submission handler
  function handleFormSubmit(event: Event) {
    event.preventDefault();
    console.log("Form submission started");

    // Remove required attribute from hidden fields to prevent validation errors
    const form = event.target as HTMLFormElement;
    const hiddenFields = form.querySelectorAll('input[style*="display: none"], input[style*="display:none"], .hidden input');
    hiddenFields.forEach((field) => {
      if (field instanceof HTMLInputElement) {
        field.removeAttribute('required');
      }
    });
    const formData = new FormData(form);
    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    console.log("Form data:", { projectId, isNewProject });

    // Collect form data
    const formValues: any = {};
    for (const [key, value] of formData.entries()) {
      formValues[key] = value;
    }

    console.log("üìù [ProjectForm] Raw form data collected:", formValues);

    // Handle client data based on new client toggle
    const isNewClient = formValues.new_client === "on";
    if (isNewClient) {
      // For new client, use email
      formValues.client_type = "new";
      formValues.client_name = `${formValues.first_name} ${formValues.last_name}`.trim();
      formValues.client_email = formValues.email;
    } else {
      // For existing client, use the selected client ID
      formValues.client_type = "existing";
      formValues.client_id = formValues.author_id;
    }

    // Collect toggle button values
    const toggleButtons = form.querySelectorAll(".toggle-button.bg-blue-500");
    console.log("üìù [ProjectForm] Found toggle buttons:", toggleButtons.length);
    toggleButtons.forEach((button) => {
      const group = button.getAttribute("data-group");
      const value = button.getAttribute("data-value");
      const type = button.getAttribute("data-type");

      console.log("üìù [ProjectForm] Toggle button:", { group, value, type });

      if (group && value) {
        if (type === "multi-select") {
          if (!formValues[group]) {
            formValues[group] = [];
          }
          if (Array.isArray(formValues[group])) {
            formValues[group].push(value);
          } else {
            formValues[group] = [formValues[group], value];
          }
        } else {
          formValues[group] = value;
        }
      }
    });

    // Get units value from slider
    const unitsSlider = form.querySelector(
      'input[name="units"]'
    ) as HTMLInputElement;
    if (unitsSlider) {
      const unitsOptions =
        unitsSlider.getAttribute("data-values")?.split(",") || [];
      const sliderValue = parseInt(unitsSlider.value);
      formValues.units = unitsOptions[sliderValue] || "1";
      console.log("üìù [ProjectForm] Units slider value:", { sliderValue, unitsValue: formValues.units });
    } else {
      console.log("üìù [ProjectForm] Units slider not found");
    }

    console.log("Form data:", formValues);

    // Determine API endpoint based on new/existing project
    const endpoint = isNewProject
      ? "/api/create-project"
      : `/api/update-project/${projectId}`;
    const method = isNewProject ? "POST" : "PUT";

    // Show loading state
    const submitBtn = form.querySelector(
      'button[type="submit"]'
    ) as HTMLButtonElement;

    if (!submitBtn) {
      console.error("Submit button not found");
      return;
    }

    const originalText = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML =
      '<i class="bx bx-loader-alt bx-spin mr-1"></i>Saving...';

    // Submit form data
    fetch(endpoint, {
      method: method,
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formValues),
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error("Failed to save project");
        }
        return response.json();
      })
      .then((data) => {
        console.log("Project saved successfully:", data);

        // Show success toast
        if ((window as any).toastAlertManager) {
          (window as any).toastAlertManager.show({
            type: "success",
            title: isNewProject ? "Project Created!" : "Project Updated!",
            message: isNewProject
              ? "Your new project has been created successfully. Please upload your project files by clicking the 'Documents' tab."
              : "Your project has been updated successfully.",
            duration: isNewProject ? 10000 : 4000,
          });
        }

        // Redirect to project page if it's a new project
        if (isNewProject && data.id) {
          setTimeout(() => {
            window.location.href = `/project/${data.id}`;
          }, 1500); // Small delay to show the toast
        }
      })
      .catch((error) => {
        console.error("Error saving project:", error);

        // Show error toast
        if ((window as any).toastAlertManager) {
          (window as any).toastAlertManager.show({
            type: "error",
            title: "Save Failed",
            message: "Failed to save project. Please try again.",
            duration: 5000,
          });
        }
      })
      .finally(() => {
        // Reset button state
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
      });
  }
</script>
