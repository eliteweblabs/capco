---
import {
  // BUTTON_GROUPS,
  // PROJECT_FORM_FIELDS,
  getFilteredFormFields,
  getFilteredButtonGroups,
  getFilteredFormActions,
  isFieldReadOnly,
  isButtonGroupReadOnly,
} from "../../lib/project-form-config";
import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
// import GooglePlacesSlotmachine from "../form/GooglePlacesSlotmachine.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";
import Button from "../common/Button.astro";

interface Props {
  project?: any;
  currentUser?: any;
  isNewProject?: boolean;
  projectStatus?: number | null;
}

const {
  project = {},
  currentUser = {},
  isNewProject = true,
  projectStatus = null,
} = Astro.props;

const currentRole = currentUser?.profile?.role;
const projectId = project?.id;
// Generate a temporary ID for new projects
const formId = isNewProject ? `new-project-${Date.now()}` : projectId || "";
// Filter fields based on user role and project status
const formFields = getFilteredFormFields(currentRole, isNewProject, projectStatus);
// Get filtered button groups based on user role and project status
const buttonGroups = getFilteredButtonGroups(currentRole, isNewProject, projectStatus);
// Get filtered form actions based on user role and project status
const formActions = getFilteredFormActions(currentRole, isNewProject, projectStatus);



---

<form
  class="w-full space-y-4"
  data-project-id={formId}
  data-is-new-project={isNewProject}
  data-current-role={currentRole}
  data-project-data={JSON.stringify(project || {})}
  autocomplete="off"
>

<!-- Address Input -->
<div class="grid grid-cols-1 gap-4 lg:grid-cols-1">

  {
    isNewProject && (
      <SlotMachineModal
        id="address"
        icon="map-pin"
        title="Select Address"
        options={[]}
        selectedValue={project?.address || ""}
        placeholder="Search for an address..."
        showCloseButton={true}
        showCancelButton={true}
        fetchOnLoad={false}
        buttonText="Select Address *"
        buttonClass="w-full"
        searchText="Search Address"
        searchPlaceholder="Type to search addresses..."
        apiEndpoint="/api/places-autocomplete"
        apiParams={{
          types: "address",
          components: "country:us",
          locationBias: "circle:100@42.3601,-71.0589",
        }}
        valueField="description"
        showImages={true}
        imageField=""
        noResultsText="Type to search addresses..."
        skipSaveToAPI={true}
        currentUser={currentUser}
        project={project}
      />
    )
  }
  <!-- Client Information (Admin/Staff Only) -->
  {
    isNewProject && (currentRole === "Admin" || currentRole === "Staff") && (
      <IsNewOrExistingClient />
    )
  }
</div>

  <!-- Other Core Fields Grid -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    {
      formFields
        .filter(
          (field) =>
            field.name !== "address" &&
            field.name !== "first_name" &&
            field.name !== "last_name" &&
            field.name !== "company_name" &&
            field.name !== "email" &&
            (field.type === "text" || field.type === "number")
        )
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <div class="relative">
              <label
                for={`${field.id}`}
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {field.label}
                {field.required ? " *" : ""}
              </label>
              {field.name === "sq_ft" ? (
                <div class="relative">
                  <input
                    type="text"
                    id={`${field.id}`}
                    name={field.name}
                    value={project?.[field.name] || ""}
                    class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 pr-12 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400 ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                        : "bg-background-card _1jTZ8KXRZul60S6czNi"
                    }`}
                    placeholder={field.placeholder || ""}
                    required={field.required}
                    readonly={isReadOnly}
                    data-field={field.dataField}
                    data-project-id={formId}
                    inputmode="numeric"
                    pattern="[0-9]*"
                  />
                  <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                    <span class="text-sm text-gray-500 dark:text-gray-400">ftÂ²</span>
                  </div>
                </div>
              ) : (
                <input
                  type={field.type === "number" ? "number" : "text"}
                  id={`${field.id}`}
                  name={field.name}
                  value={project?.[field.name] || ""}
                  class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400 ${
                    isReadOnly
                      ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                      : "bg-background-card _1jTZ8KXRZul60S6czNi"
                  }`}
                  placeholder={field.placeholder || ""}
                  required={field.required}
                  min={field.min}
                  max={field.max}
                  step={field.step}
                  readonly={isReadOnly}
                  data-field={field.dataField}
                />
              )}
            </div>
          );
        })
    }
  </div>

  <!-- Description Field -->
  {
    formFields
      .filter((field) => field.type === "textarea")
      .map((field) => {
        const isReadOnly = isFieldReadOnly(field, projectStatus);
        return (
          <div class="grid grid-cols-1 gap-4 lg:grid-cols-1">
            <div class="relative">
              <label
                for={`${field.id}`}
                class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {field.label}
              </label>
              <!-- @ts-ignore -->
              <textarea id={`${field.id}`} name={field.name} rows="3" class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:text-white dark:focus:border-primary-400 dark:focus:ring-primary-400 ${isReadOnly ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800" : "bg-background-card _1jTZ8KXRZul60S6czNi" }`} placeholder={field.placeholder || ""} readonly={isReadOnly}>{project?.[field.name] || ""}</textarea>
            </div>
          </div>
        );
      })
  }

  <!-- Construction Type & Units Row -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    <!-- Construction Type -->
    <div>
      <label class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Construction Type</label>
      <div class="flex gap-4">
        {
          formFields
            .filter((field) => field.type === "checkbox" && field.name !== "new_client")
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              const isChecked =
                project?.[field.name] === true ||
                project?.[field.name] === "true" ||
                project?.[field.name] === 1 ||
                project?.[field.name] === "1";
              return (
                <label
                  class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                >
                  <input
                    type="checkbox"
                    id={`${field.id}`}
                    name={field.name}
                    checked={isChecked}
                    disabled={isReadOnly}
                    class="peer sr-only"
                  />
                  <div
                    class={`peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-white after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-300 dark:border-gray-600 dark:peer-focus:ring-primary-800 rtl:peer-checked:after:-translate-x-full ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                        : "bg-gray-200 peer-checked:bg-primary-600 dark:bg-gray-700 dark:peer-checked:bg-primary-600"
                    }`}
                  />
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                    {field.label}
                  </span>
                </label>
              );
            })
        }
      </div>
    </div>

    <!-- Units Slider -->
    {
      formFields
        .filter((field) => field.type === "component" && field.component === "UnitSlider")
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <UnitSlider projectId={formId} value={project?.units || 1} readOnly={isReadOnly} />
          );
        })
    }
  </div>

  <!-- Button Groups -->
  {
    buttonGroups.map((group) => {
      const isReadOnly = isButtonGroupReadOnly(group, projectStatus);
      // Parse selected values from project data
      let selectedValues = [] as any;
      if (project?.[group.name]) {
        if (Array.isArray(project[group.name])) {
          selectedValues = project[group.name];
        } else if (typeof project[group.name] === "string") {
          try {
            const parsed = JSON.parse(project[group.name]);
            selectedValues = Array.isArray(parsed) ? parsed : [project[group.name]];
          } catch {
            selectedValues = project[group.name]
              .split(",")
              .map((s: any) => s.trim())
              .filter((s: any) => s);
          }
        } else {
          selectedValues = [project[group.name]];
        }
      }

      return (
        <div class="mt-5 space-y-3">
          <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
            {group.label}
          </label>
          <div
            class={`mb-4 flex flex-wrap gap-2 ${isReadOnly ? "pointer-events-none opacity-75" : ""}`}
          >
            {group.options.map((option) => {
              const isSelected = selectedValues.includes(option.value);
              return (
                <ToggleButton
                  value={option.value}
                  group={group.name}
                  type={group.type}
                  disabled={isReadOnly}
                  class={`${group.cssClass} ${isSelected ? "toggle-button dark:bg-primary-dark selected bg-primary text-white" : ""} ${
                    isReadOnly ? "cursor-not-allowed" : ""
                  }`}
                >
                  {option.label}
                </ToggleButton>
              );
            })}
          </div>
        </div>
      );
    })
  }
  <!-- Form Actions -->
  <div class="flex gap-2 pt-4 dark:border-gray-600">
    {
      formActions.map((action: any) => (
        <Button
          type={action.type}
          variant={action.variant === "info" ? "primary" : action.variant || "primary"}
          size="md"
          icon={action.icon}
          iconPosition="left"
          class={action.cssClass}
          id={action.id}
          dataAttributes={{
            "data-action": action.action,
            "data-tab": action.tab,
          }}
        >
          {action.label}
        </Button>
      ))
    }
  </div>
</form>

<script>
  // Extend Window interface for notification manager
  declare global {
    interface Window {
      showModal?: any;
      hideNotification?: any;
      currentProjectData?: any;
      handleUpdateStatusNotification?: any;
      showSuccess?: any;
      switchTab?: any;
      resetForm?: any;
      clipboardData?: any;
    }
  }

  // Window properties

  // Initialize project form
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector("form[data-project-id]");
    if (!form) return;

    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    // Make project data available globally
    // const projectDataAttr = form.getAttribute("data-project-data");
    // if (projectDataAttr) {
    //   try {
    //     const projectData = JSON.parse(projectDataAttr);
    //     window.currentProjectData = projectData;
    //     // console.log("Project data loaded:", projectData);
    //   } catch (error) {
    //     console.error("Error parsing project data:", error);
    //   }
    // }

    // Add event listeners for action buttons

    // Add form submission handler
    form.addEventListener("submit", handleFormSubmit);

    // Form submission handler
    async function handleFormSubmit(event: Event) {
      const form = event.target as HTMLFormElement;

      // Check form validity before preventing default
      if (!form.checkValidity()) {
        // Let the browser show validation messages
        return;
      }

      event.preventDefault();
      // console.log("ð [ProjectForm] Form submission started");
      const formData = new FormData(form);
      const projectData: any = {};

      // Convert FormData to object
      for (const [key, value] of formData.entries()) {
        if (key.includes("[]")) {
          // Handle array fields (like multi-select button groups)
          const fieldName = key.replace("[]", "");
          if (!projectData[fieldName]) {
            projectData[fieldName] = [];
          }
          projectData[fieldName].push(value);
        } else {
          // Check if this is a button group field that contains JSON arrays
          const buttonGroupFields = ["building", "project", "service", "requested_docs"];
          if (buttonGroupFields.includes(key) && value && typeof value === "string") {
            try {
              // Parse as JSON array (all button groups now use consistent array format)
              const parsed = JSON.parse(value);
              projectData[key] = Array.isArray(parsed) ? parsed : [];
            } catch {
              // If parsing fails, default to empty array
              projectData[key] = [];
            }
          } else {
            projectData[key] = value;
          }
        }
      }

      // console.log("ð [ProjectForm] Form data:", projectData);
      // console.log("ð [ProjectForm] Button group data:", {
      //   building: projectData.building,
      //   project: projectData.project,
      //   service: projectData.service,
      //   requested_docs: projectData.requested_docs,
      // });

      try {
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="bx bx-loader-alt animate-spin mr-1"></i>Saving...';
        }

        let response;
        if (isNewProject) {
          // Create new project
          // console.log("ð [ProjectForm] Creating new project");
          response = await fetch("/api/create-project", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        } else {
          // Update existing project
          // console.log("ð [ProjectForm] Updating existing project:", projectId);
          const updateData = {
            ...projectData,
            projectId: projectId
          };
          response = await fetch(`/api/update-project`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(updateData),
          });
        }

        // Check if response is JSON before parsing
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const textResponse = await response.text();
          console.error("ð [ProjectForm] Non-JSON response received:", {
            status: response.status,
            contentType,
            body: textResponse.substring(0, 200) + "..."
          });
          throw new Error(`API returned non-JSON response (${response.status}): ${textResponse.substring(0, 100)}`);
        }

        const result = await response.json();
        // console.log("ð [ProjectForm] API response:", result);
        // console.log("ð [ProjectForm] Response status:", response.status);
        // console.log("ð [ProjectForm] Response ok:", response.ok);

        if (result.success) {
          if (isNewProject) {
            // For new projects, update status to 10 (Project Created) to trigger database-driven notifications
            // console.log("ð [ProjectForm] Updating status to 10 for new project");
            // console.log("ð [ProjectForm] About to make fetch call to test endpoint");
            try {
              // console.log("ð [ProjectForm] Making fetch call now...");
              const statusResponse = await fetch("/api/update-status", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include", // Include cookies for authentication
                body: JSON.stringify({
                  projectId: result.project.id,
                  status: 10, // Project Created
                  oldStatus: 0,
                }),
              });

              // console.log("ð [ProjectForm] Fetch call completed, status:", statusResponse.status);
              const statusResult = await statusResponse.json();
              // console.log("ð [ProjectForm] Response parsed successfully");
              // console.log("ð [ProjectForm] Status update response:", statusResult);
              // console.log("ð [ProjectForm] Status update response status:", statusResponse.status);
              // console.log("ð [ProjectForm] Status update response ok:", statusResponse.ok);

              // Store response in localStorage for debugging
              localStorage.setItem(
                "projectFormStatusResponse",
                JSON.stringify({
                  response: statusResult,
                  status: statusResponse.status,
                  ok: statusResponse.ok,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Show notification using new modal system
              window.handleUpdateStatusNotification(statusResult, "PROJECT-FORM");
            } catch (statusError) {
              console.error("ð [ProjectForm] Status update failed:", statusError);
              console.error("ð [ProjectForm] Status update error details:", statusError);

              // Store error in localStorage for debugging
              localStorage.setItem(
                "projectFormError",
                JSON.stringify({
                  error: (statusError as any)?.message || statusError,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Fallback: just refresh the page
              window.location.reload();
            }
          } else {
            // For existing projects, just show success and refresh
            if (window.showSuccess) {
              window.showSuccess("Project Updated", "Project has been updated successfully!");
            }
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          }
        } else {
          console.error("ð [ProjectForm] API returned success: false");
          console.error("ð [ProjectForm] Error details:", result.error);
          console.error("ð [ProjectForm] Full result:", result);
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("ð [ProjectForm] Error saving project:", error);
        if (window.showModal) {
          window.showModal(
            "Error",
            error instanceof Error ? error.message : "Failed to save project",
            "error"
          );
        }
      } finally {
        // Reset button state
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = '<i class="bx bx-save mr-1"></i>Save Project';
        }
      }
    }

    // Handle delete button (only for existing projects)
    // Note: Delete button is handled by the action button system below
    if (!isNewProject) {
      const deleteBtn = document.getElementById("delete-project");
      deleteBtn?.addEventListener("click", () => {
        deleteProject(projectId);
      });
      // console.log("Delete button setup:", {
      //   deleteBtn: !!deleteBtn,
      //   projectId,
      //   isNewProject,
      //   formId: form.getAttribute("data-project-id"),
      // });
    }

    // Handle other action buttons
    const actionButtons = document.querySelectorAll("[data-action]");
    actionButtons.forEach((button) => {
      const action = button.getAttribute("data-action");
      const tab = button.getAttribute("data-tab");

      if (projectId) {
        button.addEventListener("click", function () {
          // If button has a tab property, navigate to that tab
          if (tab && typeof window !== "undefined" && window.switchTab) {
            window.switchTab(tab);
          } else if (action) {
            // Otherwise handle the action normally
            handleAction(action, projectId, isNewProject);
          }
        });
      }
    });
  });

  // Delete project function
  let isDeleting = false; // Flag to prevent multiple delete operations

  function deleteProject(projectId: any) {
    // console.log("deleteProject called with projectId:", projectId, "type:", typeof projectId);

    // Prevent multiple delete operations
    if (isDeleting) {
      console.log("Delete operation already in progress, ignoring request");
      return;
    }

    // Validate project ID
    if (!projectId || projectId.startsWith("new-project-")) {
      // console.error("Invalid project ID for deletion:", projectId);
      if (window.showModal) {
        window.showModal(
          "error",
          "Delete Failed",
          "Cannot delete a new project that hasn't been saved yet.",
          5000
        );
      }
      return;
    }

    // Show confirmation modal with action buttons
    if (window.showModal) {
      window.showModal(
        "warning",
        "Delete Project",
        "Are you sure you want to delete this project? This action cannot be undone.",
        6000000, // 6000 seconds timeout
        [
          {
            label: "Cancel",
            action: () => {},
          },
          {
            label: "Delete",
            action: () => {
              // Set deleting flag to prevent multiple operations
              isDeleting = true;

              // Show loading state
              const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
              deleteBtn?.setAttribute("data-loading", "true");
              if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
              }

              // Make API call to delete project
              console.log("Sending delete request for project:", projectId);
              fetch(`/api/delete-project`, {
                method: "DELETE",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ projectId }),
              })
                .then(async (response) => {
                  // console.log("Delete response status:", response.status);
                  const data = await response.json();
                  // console.log("Delete response data:", data);

                  if (!response.ok) {
                    throw new Error(data.error || "Failed to delete project");
                  }

                  // Show success modal
                  if (window.showModal) {
                    window.showModal(
                      "success",
                      "Project Deleted!",
                      data.message || "Project has been deleted successfully.",
                      1500 // 6000 seconds timeout
                    );
                  }

                  // Reset deleting flag
                  isDeleting = false;

                  // Redirect to dashboard after a short delay
                  setTimeout(() => {
                    window.location.href = "/dashboard";
                  }, 1500);
                })
                .catch((error) => {
                  console.error("Error deleting project:", error);

                  // Show error modal with specific error message
                  if (window.showModal) {
                    window.showModal(
                      "error",
                      "Delete Failed",
                      error.message || "Failed to delete project. Please try again.",
                      6000000 // 6000 seconds timeout
                    );
                  }

                  // Reset deleting flag and button state
                  isDeleting = false;
                  if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                  }
                });
            },
          },
        ]
      );
    }
  }

  // Handle different form actions
  function handleAction(action: any, projectId: any, isNewProject: any) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          deleteProject(projectId);
        }
        break;
      case "buildProposal":
        // Navigate to proposal tab
        if (typeof window !== "undefined" && window.switchTab) {
          window.switchTab("proposal");
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("ð§¹ [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons - let ToggleButton component handle its own state
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("selected");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      // console.log("ð§¹ [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("ð§¹ [ProjectForm] Auto-resetting new project form");
      resetForm();
    }
    // Make resetForm globally available
    window.resetForm = resetForm;

    // Square footage numeric filtering
    const sqFtInputs = document.querySelectorAll('input[name="sq_ft"]');

    sqFtInputs.forEach((input) => {
      // Prevent non-numeric characters on keypress
      input.addEventListener("keypress", (e) => {
        if (!/[0-9]/.test((e as KeyboardEvent).key)) {
          e.preventDefault();
        }
      });

      // Handle paste events to filter out non-numeric characters
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        const paste = ((e as ClipboardEvent).clipboardData || window.clipboardData).getData("text");
        const numericOnly = paste.replace(/[^0-9]/g, "");
        (input as HTMLInputElement).value = numericOnly;
      });

      // Handle input events to remove any non-numeric characters
      input.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          target.value = target.value.replace(/[^0-9]/g, "");
        }
      });
    });
  });
</script>
