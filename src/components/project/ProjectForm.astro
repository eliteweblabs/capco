---
import {
  // BUTTON_GROUPS,
  // PROJECT_FORM_FIELDS,
  getFilteredFormFields,
  getFilteredButtonGroups,
  getFilteredFormActions,
  isFieldReadOnly,
  isButtonGroupReadOnly,
} from "../../lib/project-form-config";
import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import GooglePlacesSlotmachine from "../form/GooglePlacesSlotmachine.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";

interface Props {
  project?: any;
  projectId?: string | null;
  currentUser?: any;
  currentRole?: string | null;
  isNewProject?: boolean;
  projectStatus?: number | null;
}

const {
  project = {},
  projectId = "",
  currentUser = {},
  currentRole,
  isNewProject = true,
  projectStatus = null,
} = Astro.props;

// Generate a temporary ID for new projects
const formId = isNewProject ? `new-project-${Date.now()}` : projectId || "";

// Use currentRole prop if provided, otherwise use authenticated role

// Filter fields based on user role and project status
const formFields = getFilteredFormFields(currentRole, isNewProject, projectStatus);

// Get filtered button groups based on user role and project status
const buttonGroups = getFilteredButtonGroups(currentRole, isNewProject, projectStatus);

// Get filtered form actions based on user role and project status
const formActions = getFilteredFormActions(currentRole, isNewProject, projectStatus);

// Debug logging
// console.log("üìù [ProjectForm] Debug info:", {
//   isNewProject,
//   projectStatus,
//   formFieldsCount: formFields.length,
//   buttonGroupsCount: buttonGroups.length,
//   formActionsCount: formActions.length,
//   formFields: formFields.map((f) => ({
//     id: f.id,
//     name: f.name,
//     allow: f.allow,
//   })),
//   buttonGroups: buttonGroups.map((g) => ({
//     id: g.id,
//     name: g.name,
//     allow: g.allow,
//   })),
//   formActions: formActions.map((a) => ({
//     id: a.id,
//     label: a.label,
//     allow: a.allow,
//   })),
// });

// Check specifically for the existing client select field
// const existingClientField = formFields.find((f) => f.id === "existing-client-select");
// console.log(
//   existingClientField
//     ? "‚ö†Ô∏è [ProjectForm] Found existing-client-select field"
//     : "‚úÖ [ProjectForm] existing-client-select field correctly filtered out"
// );

// Debug new client fields specifically
// const newClientFieldsInForm = formFields.filter(
//   (field) =>
//     field.name === "first_name" ||
//     field.name === "last_name" ||
//     field.name === "company_name" ||
//     field.name === "email"
// );
// console.log("New client fields found:", newClientFieldsInForm.length, newClientFieldsInForm);
---

<form
  class="w-full space-y-4"
  data-project-id={formId}
  data-is-new-project={isNewProject}
  data-current-role={currentRole}
  data-project-data={JSON.stringify(project || {})}
  autocomplete="off"
>
  {
    isNewProject && (
      <GooglePlacesSlotmachine
        id="address"
        name="address"
        label="Address"
        value={project?.address || ""}
        placeholder="Enter address"
        required={true}
        projectStatus={projectStatus || 0}
        class="w-full"
      />
    )
  }
  <!-- Client Information (Admin/Staff Only) -->
  {
    isNewProject && (currentRole === "Admin" || currentRole === "Staff") ? (
      <div class="space-y-4">
        <div class="rounded-lg border border-gray-200 bg-gray-50 p-4 dark:border-gray-700 dark:bg-gray-800">
          <label class="mb-2 block text-sm font-medium text-gray-900 dark:text-white">
            Select Existing Client (Optional)
          </label>
          <p class="mb-3 text-xs text-gray-500 dark:text-gray-400">
            Choose an existing client to auto-fill the form, or fill in the fields below manually
          </p>

          <div id="existing-client-select-container">
            <SlotMachineModal
              id="existing-client-select"
              name="author_id"
              title="Select Existing Client"
              options={[]}
              selectedValue=""
              placeholder="Choose an existing client..."
              theme="blue"
              showCloseButton={true}
              showCancelButton={true}
              buttonText="Select Client"
              skipSaveToAPI={true}
              onSelect="handleExistingClientSelect"
            />
          </div>
        </div>

        <div class="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
          <h3 class="mb-4 text-lg font-medium text-gray-900 dark:text-white">Client Information</h3>

          <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
            <div>
              <label
                for="first_name"
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                First Name *
              </label>
              <input
                type="text"
                id="first_name"
                name="first_name"
                required
                class="w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                placeholder="Enter first name"
              />
            </div>

            <div>
              <label
                for="last_name"
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Last Name *
              </label>
              <input
                type="text"
                id="last_name"
                name="last_name"
                required
                class="w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                placeholder="Enter last name"
              />
            </div>

            <div>
              <label
                for="company_name"
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Company Name
              </label>
              <input
                type="text"
                id="company_name"
                name="company_name"
                class="w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                placeholder="Enter company name"
              />
            </div>

            <div>
              <label
                for="email"
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Email *
              </label>
              <input
                type="email"
                id="email"
                name="email"
                required
                class="w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400"
                placeholder="Enter email address"
              />
            </div>
          </div>
        </div>
      </div>
    ) : null
  }

  <!-- Other Core Fields Grid -->
  <div class="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
    <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
      {
        formFields
          .filter(
            (field) =>
              field.name !== "address" &&
              field.name !== "first_name" &&
              field.name !== "last_name" &&
              field.name !== "company_name" &&
              field.name !== "email" &&
              (field.type === "text" || field.type === "number")
          )
          .map((field) => {
            const isReadOnly = isFieldReadOnly(field, projectStatus);
            return (
              <div class="relative">
                <label
                  for={`${field.id}`}
                  class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {field.label}
                  {field.required ? " *" : ""}
                </label>
                {field.name === "sq_ft" ? (
                  <div class="relative">
                    <input
                      type="text"
                      id={`${field.id}`}
                      name={field.name}
                      value={project?.[field.name] || ""}
                      class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 pr-12 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                        isReadOnly
                          ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                          : "bg-white dark:bg-gray-700"
                      }`}
                      placeholder={field.placeholder || ""}
                      required={field.required}
                      readonly={isReadOnly}
                      data-field={field.dataField}
                      data-project-id={formId}
                      inputmode="numeric"
                      pattern="[0-9]*"
                    />
                    <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                      <span class="text-gray-500 dark:text-gray-400 text-sm">ft¬≤</span>
                    </div>
                  </div>
                ) : (
                  <input
                    type={field.type === "number" ? "number" : "text"}
                    id={`${field.id}`}
                    name={field.name}
                    value={project?.[field.name] || ""}
                    class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                        : "bg-white dark:bg-gray-700"
                    }`}
                    placeholder={field.placeholder || ""}
                    required={field.required}
                    min={field.min}
                    max={field.max}
                    step={field.step}
                    readonly={isReadOnly}
                    data-field={field.dataField}
                  />
                )}
              </div>
            );
          })
      }
    </div>

    <!-- Description Field -->
    {
      formFields
        .filter((field) => field.type === "textarea")
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <div class="relative">
              <label
                for={`${field.id}`}
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {field.label}
              </label>
              <textarea
                id={`${field.id}`}
                name={field.name}
                rows="3"
                class={`w-full rounded-lg border border-gray-300 px-3 py-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                  isReadOnly
                    ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                    : "bg-white dark:bg-gray-700"
                }`}
                placeholder={field.placeholder || ""}
                readonly={isReadOnly}
              >
                {project?.[field.name] || ""}
              </textarea>
            </div>
          );
        })
    }

    <!-- Construction Type & Units Row -->
    <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
      <!-- Construction Type -->
      <div>
        <label class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
          >Construction Type</label
        >
        <div class="flex gap-4">
          {
            formFields
              .filter((field) => field.type === "checkbox" && field.name !== "new_client")
              .map((field) => {
                const isReadOnly = isFieldReadOnly(field, projectStatus);
                const isChecked =
                  project?.[field.name] === true ||
                  project?.[field.name] === "true" ||
                  project?.[field.name] === 1 ||
                  project?.[field.name] === "1";
                return (
                  <label
                    class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                  >
                    <input
                      type="checkbox"
                      id={`${field.id}`}
                      name={field.name}
                      checked={isChecked}
                      disabled={isReadOnly}
                      class="peer sr-only"
                    />
                    <div
                      class={`peer relative h-6 w-11 rounded-lg after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-lg after:border after:border-gray-300 after:bg-white after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:border-gray-600 dark:peer-focus:ring-blue-800 rtl:peer-checked:after:-translate-x-full ${
                        isReadOnly
                          ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                          : "bg-gray-200 peer-checked:bg-blue-600 dark:bg-gray-700 dark:peer-checked:bg-blue-600"
                      }`}
                    />
                    <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                      {field.label}
                    </span>
                  </label>
                );
              })
          }
        </div>
      </div>

      <!-- Units Slider -->
      {
        formFields
          .filter((field) => field.type === "component" && field.component === "UnitSlider")
          .map((field) => {
            const isReadOnly = isFieldReadOnly(field, projectStatus);
            return (
              <UnitSlider projectId={formId} value={project?.units || 1} readOnly={isReadOnly} />
            );
          })
      }
    </div>

    <!-- Button Groups -->
    {
      buttonGroups.map((group) => {
        const isReadOnly = isButtonGroupReadOnly(group, projectStatus);
        // Parse selected values from project data
        let selectedValues = [] as any;
        if (project?.[group.name]) {
          if (Array.isArray(project[group.name])) {
            selectedValues = project[group.name];
          } else if (typeof project[group.name] === "string") {
            try {
              const parsed = JSON.parse(project[group.name]);
              selectedValues = Array.isArray(parsed) ? parsed : [project[group.name]];
            } catch {
              selectedValues = project[group.name]
                .split(",")
                .map((s: any) => s.trim())
                .filter((s: any) => s);
            }
          } else {
            selectedValues = [project[group.name]];
          }
        }

        return (
          <div class="space-y-3">
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
              {group.label}
            </label>
            <div
              class={`flex flex-wrap gap-2 mb-4 ${isReadOnly ? "pointer-events-none opacity-75" : ""}`}
            >
              {group.options.map((option) => {
                const isSelected = selectedValues.includes(option.value);
                return (
                  <ToggleButton
                    value={option.value}
                    group={group.name}
                    type={group.type}
                    disabled={isReadOnly}
                    class={`${group.cssClass} ${isSelected ? "border-blue-500 bg-blue-500 text-white" : ""} ${
                      isReadOnly ? "cursor-not-allowed" : ""
                    }`}
                  >
                    {option.label}
                  </ToggleButton>
                );
              })}
            </div>
          </div>
        );
      })
    }
  </div>
  <!-- Form Actions -->
  <div class="flex gap-2 pt-4 dark:border-gray-600 flex-col lg:flex-row">
    {
      formActions.map((action) => (
        <button
          type={action.type}
          class={action.cssClass}
          id={action.id}
          data-action={action.action}
          data-tab={action.tab}
        >
          {action.icon && <i class={`bx ${action.icon} mr-1`} />}
          {action.label}
        </button>
      ))
    }
  </div>
</form>

<script>
  // Extend Window interface for notification manager
  declare global {
    interface Window {
      showModal?: any;
      hideNotification?: any;
      currentProjectData?: any;
      handleUpdateStatusNotification?: any;
      showSuccess?: any;
      switchTab?: any;
      resetForm?: any;
      updateSlotMachineOptions?: any;
      handleExistingClientSelect?: any;
      clipboardData?: any;
    }
  }

  // Window properties
  const windowWithProps = window;

  // Initialize project form
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector("form[data-project-id]");
    if (!form) return;

    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    // Make project data available globally
    const projectDataAttr = form.getAttribute("data-project-data");
    if (projectDataAttr) {
      try {
        const projectData = JSON.parse(projectDataAttr);
        windowWithProps.currentProjectData = projectData;
        // console.log("Project data loaded:", projectData);
      } catch (error) {
        console.error("Error parsing project data:", error);
      }
    }

    // Add event listeners for action buttons

    // Add form submission handler
    form.addEventListener("submit", handleFormSubmit);

    // Form submission handler
    async function handleFormSubmit(event: Event) {
      const form = event.target as HTMLFormElement;

      // Check form validity before preventing default
      if (!form.checkValidity()) {
        // Let the browser show validation messages
        return;
      }

      event.preventDefault();
      // console.log("üìù [ProjectForm] Form submission started");
      const formData = new FormData(form);
      const projectData: any = {};

      // Convert FormData to object
      for (const [key, value] of formData.entries()) {
        if (key.includes("[]")) {
          // Handle array fields (like multi-select button groups)
          const fieldName = key.replace("[]", "");
          if (!projectData[fieldName]) {
            projectData[fieldName] = [];
          }
          projectData[fieldName].push(value);
        } else {
          // Check if this is a button group field that contains JSON arrays
          const buttonGroupFields = ["building", "project", "service", "requested_docs"];
          if (buttonGroupFields.includes(key) && value && typeof value === "string") {
            try {
              // Parse as JSON array (all button groups now use consistent array format)
              const parsed = JSON.parse(value);
              projectData[key] = Array.isArray(parsed) ? parsed : [];
            } catch {
              // If parsing fails, default to empty array
              projectData[key] = [];
            }
          } else {
            projectData[key] = value;
          }
        }
      }

      // console.log("üìù [ProjectForm] Form data:", projectData);

      try {
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="bx bx-loader-alt animate-spin mr-1"></i>Saving...';
        }

        let response;
        if (isNewProject) {
          // Create new project
          // console.log("üìù [ProjectForm] Creating new project");
          response = await fetch("/api/create-project", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        } else {
          // Update existing project
          // console.log("üìù [ProjectForm] Updating existing project:", projectId);
          response = await fetch(`/api/update-project/${projectId}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        }

        const result = await response.json();
        // console.log("üìù [ProjectForm] API response:", result);
        // console.log("üìù [ProjectForm] Response status:", response.status);
        // console.log("üìù [ProjectForm] Response ok:", response.ok);

        if (result.success) {
          if (isNewProject) {
            // For new projects, update status to 10 (Project Created) to trigger database-driven notifications
            // console.log("üìù [ProjectForm] Updating status to 10 for new project");
            // console.log("üìù [ProjectForm] About to make fetch call to test endpoint");
            try {
              // console.log("üìù [ProjectForm] Making fetch call now...");
              const statusResponse = await fetch("/api/update-status", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include", // Include cookies for authentication
                body: JSON.stringify({
                  projectId: result.project.id,
                  status: 10, // Project Created
                  oldStatus: projectData.status,
                }),
              });

              // console.log("üìù [ProjectForm] Fetch call completed, status:", statusResponse.status);
              const statusResult = await statusResponse.json();
              // console.log("üìù [ProjectForm] Response parsed successfully");
              // console.log("üìù [ProjectForm] Status update response:", statusResult);
              // console.log("üìù [ProjectForm] Status update response status:", statusResponse.status);
              // console.log("üìù [ProjectForm] Status update response ok:", statusResponse.ok);

              // Store response in localStorage for debugging
              localStorage.setItem(
                "projectFormStatusResponse",
                JSON.stringify({
                  response: statusResult,
                  status: statusResponse.status,
                  ok: statusResponse.ok,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Show notification using new modal system
              windowWithProps.handleUpdateStatusNotification(statusResult, "PROJECT-FORM");
            } catch (statusError) {
              console.error("üìù [ProjectForm] Status update failed:", statusError);
              console.error("üìù [ProjectForm] Status update error details:", statusError);

              // Store error in localStorage for debugging
              localStorage.setItem(
                "projectFormError",
                JSON.stringify({
                  error: (statusError as any)?.message || statusError,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Fallback: just refresh the page
              windowWithProps.location.reload();
            }
          } else {
            // For existing projects, just show success and refresh
            if (windowWithProps.showSuccess) {
              windowWithProps.showSuccess(
                "Project Updated",
                "Project has been updated successfully!"
              );
            }
            setTimeout(() => {
              windowWithProps.location.reload();
            }, 1000);
          }
        } else {
          console.error("üìù [ProjectForm] API returned success: false");
          console.error("üìù [ProjectForm] Error details:", result.error);
          console.error("üìù [ProjectForm] Full result:", result);
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("üìù [ProjectForm] Error saving project:", error);
        if (windowWithProps.showModal) {
          windowWithProps.showModal(
            "Error",
            error instanceof Error ? error.message : "Failed to save project",
            "error"
          );
        }
      } finally {
        // Reset button state
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = '<i class="bx bx-save mr-1"></i>Save Project';
        }
      }
    }

    // Handle delete button (only for existing projects)
    // Note: Delete button is handled by the action button system below
    if (!isNewProject) {
      const deleteBtn = document.getElementById("delete-project");
      // console.log("Delete button setup:", {
      //   deleteBtn: !!deleteBtn,
      //   projectId,
      //   isNewProject,
      //   formId: form.getAttribute("data-project-id"),
      // });
    }

    // Handle other action buttons
    const actionButtons = document.querySelectorAll("[data-action]");
    actionButtons.forEach((button) => {
      const action = button.getAttribute("data-action");
      const tab = button.getAttribute("data-tab");

      if (projectId) {
        button.addEventListener("click", function () {
          // If button has a tab property, navigate to that tab
          if (tab && typeof window !== "undefined" && windowWithProps.switchTab) {
            windowWithProps.switchTab(tab);
          } else if (action) {
            // Otherwise handle the action normally
            handleAction(action, projectId, isNewProject);
          }
        });
      }
    });

    // Setup new client toggle functionality (only for new projects and admin/staff users)
    if (isNewProject) {
      // New client toggle is now handled by the NewOrExistingClient component
    }
  });

  // Delete project function
  let isDeleting = false; // Flag to prevent multiple delete operations

  function deleteProject(projectId: any) {
    // console.log("deleteProject called with projectId:", projectId, "type:", typeof projectId);

    // Prevent multiple delete operations
    if (isDeleting) {
      console.log("Delete operation already in progress, ignoring request");
      return;
    }

    // Validate project ID
    if (!projectId || projectId.startsWith("new-project-")) {
      // console.error("Invalid project ID for deletion:", projectId);
      if (windowWithProps.showModal) {
        windowWithProps.showModal(
          "error",
          "Delete Failed",
          "Cannot delete a new project that hasn't been saved yet.",
          5000
        );
      }
      return;
    }

    // Show confirmation modal with action buttons
    if (windowWithProps.showModal) {
      windowWithProps.showModal(
        "warning",
        "Delete Project",
        "Are you sure you want to delete this project? This action cannot be undone.",
        6000000, // 6000 seconds timeout
        [
          {
            label: "Cancel",
            action: () => {},
          },
          {
            label: "Delete",
            action: () => {
              // Set deleting flag to prevent multiple operations
              isDeleting = true;

              // Show loading state
              const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
              if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
              }

              // Make API call to delete project
              // console.log("Sending delete request for project:", projectId);
              fetch(`/api/delete-project`, {
                method: "DELETE",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ projectId }),
              })
                .then(async (response) => {
                  // console.log("Delete response status:", response.status);
                  const data = await response.json();
                  // console.log("Delete response data:", data);

                  if (!response.ok) {
                    throw new Error(data.error || "Failed to delete project");
                  }

                  // Show success modal
                  if (windowWithProps.showModal) {
                    windowWithProps.showModal(
                      "success",
                      "Project Deleted!",
                      data.message || "Project has been deleted successfully.",
                      1500 // 6000 seconds timeout
                    );
                  }

                  // Reset deleting flag
                  isDeleting = false;

                  // Redirect to dashboard after a short delay
                  setTimeout(() => {
                    windowWithProps.location.href = "/dashboard";
                  }, 1500);
                })
                .catch((error) => {
                  console.error("Error deleting project:", error);

                  // Show error modal with specific error message
                  if (windowWithProps.showModal) {
                    windowWithProps.showModal(
                      "error",
                      "Delete Failed",
                      error.message || "Failed to delete project. Please try again.",
                      6000000 // 6000 seconds timeout
                    );
                  }

                  // Reset deleting flag and button state
                  isDeleting = false;
                  if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                  }
                });
            },
          },
        ]
      );
    }
  }

  // Handle different form actions
  function handleAction(action: any, projectId: any, isNewProject: any) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          deleteProject(projectId);
        }
        break;
      case "buildProposal":
        // Navigate to proposal tab
        if (typeof window !== "undefined" && windowWithProps.switchTab) {
          windowWithProps.switchTab("proposal");
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("üßπ [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("bg-blue-500", "text-white", "border-blue-500");
        button.classList.add("bg-white", "dark:bg-gray-700", "text-gray-700", "dark:text-gray-300");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      console.log("üßπ [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("üßπ [ProjectForm] Auto-resetting new project form");
      resetForm();
    }
    // Make resetForm globally available
    windowWithProps.resetForm = resetForm;

    // Square footage numeric filtering
    const sqFtInputs = document.querySelectorAll('input[name="sq_ft"]');

    sqFtInputs.forEach((input) => {
      // Prevent non-numeric characters on keypress
      input.addEventListener("keypress", (e) => {
        if (!/[0-9]/.test((e as KeyboardEvent).key)) {
          e.preventDefault();
        }
      });

      // Handle paste events to filter out non-numeric characters
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        const paste = (
          (e as ClipboardEvent).clipboardData || windowWithProps.clipboardData
        ).getData("text");
        const numericOnly = paste.replace(/[^0-9]/g, "");
        (input as HTMLInputElement).value = numericOnly;
      });

      // Handle input events to remove any non-numeric characters
      input.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          target.value = target.value.replace(/[^0-9]/g, "");
        }
      });
    });

    // Load existing clients for the slot machine (Admin/Staff only)
    if (form) {
      const currentRole = form.getAttribute("data-current-role");
      const isNewProject = form.getAttribute("data-is-new-project") === "true";
      if (isNewProject && (currentRole === "Admin" || currentRole === "Staff")) {
        try {
          const response = await fetch("/api/get-clients");
          const data = await response.json();

          if (data.success && data.clients) {
            const clientOptions = data.clients.map((client: any) => ({
              value: client.id,
              label: client.company_name || `${client.first_name} ${client.last_name}`,
              disabled: false,
            }));

            // Update the slot machine options
            if (windowWithProps.updateSlotMachineOptions) {
              windowWithProps.updateSlotMachineOptions("existing-client-select", clientOptions);
            }
          }
        } catch (error) {
          console.error("Failed to load existing clients:", error);
        }

        // Set up existing client selection handler
        windowWithProps.handleExistingClientSelect = function (
          value: any,
          label: any,
          componentId: any
        ) {
          // console.log("üë§ [ProjectForm] Existing client selected:", { value, label, componentId });

          // Fetch client details and populate form fields
          fetch(`/api/get-user-profile?userId=${value}`)
            .then((response) => response.json())
            .then((data) => {
              if (data.success && data.profile) {
                const profile = data.profile;

                // Populate form fields with micro-interaction
                const firstNameField = document.getElementById("first_name") as HTMLInputElement;
                const lastNameField = document.getElementById("last_name") as HTMLInputElement;
                const companyField = document.getElementById("company_name") as HTMLInputElement;
                const emailField = document.getElementById("email") as HTMLInputElement;

                // Helper function to add micro-interaction effect
                const addMicroInteraction = (field: HTMLInputElement, value: string) => {
                  if (field) {
                    // Always update the field value (even if empty)
                    field.value = value || "";
                    // Add animation classes
                    field.classList.add(
                      "animate-pulse",
                      "ring-2",
                      "ring-blue-800",
                      "ring-opacity-50"
                    );
                    // Remove animation classes after animation completes
                    setTimeout(() => {
                      field.classList.remove(
                        "animate-pulse",
                        "ring-2",
                        "ring-blue-800",
                        "ring-opacity-50"
                      );
                    }, 1000);
                  }
                };

                addMicroInteraction(firstNameField, profile.first_name || "");
                addMicroInteraction(lastNameField, profile.last_name || "");
                addMicroInteraction(companyField, profile.company_name || "");
                addMicroInteraction(emailField, profile.email || "");

                // console.log("üë§ [ProjectForm] Form fields populated with client data:", {
                //   first_name: profile.first_name,
                //   last_name: profile.last_name,
                //   company_name: profile.company_name,
                //   email: profile.email
                // });
              } else {
                console.error("üë§ [ProjectForm] Failed to fetch client profile:", data);
              }
            })
            .catch((error) => {
              console.error("üë§ [ProjectForm] Error fetching client profile:", error);
            });
        };
      }
    }
  });
</script>
