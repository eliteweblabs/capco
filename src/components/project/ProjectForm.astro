---
import {
  // BUTTON_GROUPS,
  // PROJECT_FORM_FIELDS,
  getFilteredFormFields,
  getFilteredButtonGroups,
  getFilteredFormActions,
  isFieldReadOnly,
  isButtonGroupReadOnly,
} from "../../lib/project-form-config";
import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import ClientSelect from "../form/ClientSelect.astro";
import StaffSelect from "../form/StaffSelect.astro";
import GoogleAddressAutocomplete from "../form/GoogleAddressAutocomplete.astro";
// import DeleteProject from "../form/DeleteProject.astro";
import NewOrExistingClient from "../form/newOrExistingClient.astro";

interface Props {
  project?: any;
  projectId?: string | null;
  userRole?: string | null; // Add userRole prop to control field visibility
  isNewProject?: boolean; // Add flag to indicate if this is a new project
  projectStatus?: number | null; // Add project status for status-based field visibility
}

const {
  project = {},
  projectId = "",
  userRole,
  isNewProject = false,
  projectStatus = null,
} = Astro.props;

// Generate a temporary ID for new projects
const formId = isNewProject ? `new-project-${Date.now()}` : projectId || "";

// Filter fields based on user role and project status
const formFields = getFilteredFormFields(userRole, isNewProject, projectStatus);

// Get filtered button groups based on user role and project status
const buttonGroups = getFilteredButtonGroups(userRole, isNewProject, projectStatus);

// Get filtered form actions based on user role and project status
const formActions = getFilteredFormActions(userRole, isNewProject, projectStatus);

// Debug logging
console.log("📝 [ProjectForm] Debug info:", {
  userRole,
  isNewProject,
  projectStatus,
  formFieldsCount: formFields.length,
  buttonGroupsCount: buttonGroups.length,
  formActionsCount: formActions.length,
  formFields: formFields.map((f) => ({
    id: f.id,
    name: f.name,
    allow: f.allow,
  })),
  buttonGroups: buttonGroups.map((g) => ({
    id: g.id,
    name: g.name,
    allow: g.allow,
  })),
  formActions: formActions.map((a) => ({
    id: a.id,
    label: a.label,
    allow: a.allow,
  })),
});

// Check specifically for the existing client select field
const existingClientField = formFields.find((f) => f.id === "existing-client-select");
console.log(
  existingClientField
    ? "⚠️ [ProjectForm] Found existing-client-select field"
    : "✅ [ProjectForm] existing-client-select field correctly filtered out"
);

// Debug new client fields specifically
const newClientFieldsInForm = formFields.filter(
  (field) =>
    field.name === "first_name" ||
    field.name === "last_name" ||
    field.name === "company_name" ||
    field.name === "email"
);
console.log("New client fields found:", newClientFieldsInForm.length, newClientFieldsInForm);
---

<form
  class="w-full space-y-4"
  data-project-id={formId}
  data-project-data={JSON.stringify(project || {})}
  data-is-new-project={isNewProject}
  onsubmit="handleFormSubmit(event)"
  autocomplete="off"
  novalidate
>
  <!-- New Client Toggle (Top of Form) -->
  {isNewProject ? <NewOrExistingClient /> : ""}

  <!-- Google Address Autocomplete Field -->
  {
    formFields
      .filter(
        (field) => field.type === "component" && field.component === "GoogleAddressAutocomplete"
      )
      .map((field) => (
        <div class="relative">
          <GoogleAddressAutocomplete
            id={`${field.id}`}
            name={field.name}
            label={field.label}
            value={project?.[field.name] || ""}
            placeholder={field.componentProps?.placeholder || "Enter address..."}
            required={field.componentProps?.required || field.required || false}
          />
        </div>
      ))
  }

  <!-- Other Core Fields Grid -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    {
      formFields
        .filter(
          (field) =>
            field.name !== "address" &&
            field.name !== "first_name" &&
            field.name !== "last_name" &&
            field.name !== "company_name" &&
            field.name !== "email" &&
            (field.type === "text" || field.type === "number")
        )
        .map((field) => {
          const isReadOnly = isFieldReadOnly(field, projectStatus);
          return (
            <div class="relative">
              <label
                for={`${field.id}`}
                class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {field.label}
                {field.required ? " *" : ""}
              </label>
              <input
                type={field.type === "number" ? "number" : "text"}
                id={`${field.id}`}
                name={field.name}
                value={project?.[field.name] || ""}
                class={`w-full rounded-md border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                  isReadOnly
                    ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                    : "bg-white dark:bg-gray-700"
                }`}
                placeholder={field.placeholder || ""}
                required={field.required}
                min={field.min}
                max={field.max}
                step={field.step}
                readonly={isReadOnly}
                data-field={field.dataField}
                data-project-id={formId}
                data-project-data={JSON.stringify(project || {})}
              />
            </div>
          );
        })
    }
  </div>

  <!-- Description Field -->
  {
    formFields
      .filter((field) => field.type === "textarea")
      .map((field) => {
        const isReadOnly = isFieldReadOnly(field, projectStatus);
        return (
          <div class="relative">
            <label
              for={`${field.id}`}
              class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              {field.label}
            </label>
            <textarea
              id={`${field.id}`}
              name={field.name}
              rows="3"
              class={`w-full rounded-md border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400 ${
                isReadOnly
                  ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800"
                  : "bg-white dark:bg-gray-700"
              }`}
              placeholder={field.placeholder || ""}
              readonly={isReadOnly}
              data-project-id={formId}
              data-project-data={JSON.stringify(project || {})}
            >
              {project?.[field.name] || ""}
            </textarea>
          </div>
        );
      })
  }

  <!-- Staff Assignment Field (Admin Only) -->
  {
    formFields
      .filter((field) => field.type === "component" && field.component === "StaffSelect")
      .map((field) => (
        <div class="relative">
          <StaffSelect
            id={`${field.id}`}
            name={field.name}
            label={field.label}
            value={project?.[field.name] || ""}
          />
        </div>
      ))
  }

  <!-- Construction Type & Units Row -->
  <div class="grid grid-cols-1 gap-4 lg:grid-cols-2">
    <!-- Construction Type -->
    <div>
      <label class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
        >Construction Type</label
      >
      <div class="flex gap-4">
        {
          formFields
            .filter((field) => field.type === "checkbox" && field.name !== "new_client")
            .map((field) => {
              const isReadOnly = isFieldReadOnly(field, projectStatus);
              const isChecked =
                project?.[field.name] === true ||
                project?.[field.name] === "true" ||
                project?.[field.name] === 1 ||
                project?.[field.name] === "1";
              return (
                <label
                  class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                >
                  <input
                    type="checkbox"
                    id={`${field.id}`}
                    name={field.name}
                    checked={isChecked}
                    disabled={isReadOnly}
                    class="peer sr-only"
                    data-project-id={formId}
                    data-project-data={JSON.stringify(project || {})}
                  />
                  <div
                    class={`peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-white after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:border-gray-600 dark:peer-focus:ring-blue-800 rtl:peer-checked:after:-translate-x-full ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                        : "bg-gray-200 peer-checked:bg-blue-600 dark:bg-gray-700 dark:peer-checked:bg-blue-600"
                    }`}
                  />
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                    {field.label}
                  </span>
                </label>
              );
            })
        }
      </div>
    </div>

    <!-- Units Slider -->
    <UnitSlider projectId={formId} value={project?.units || 1} />
  </div>

  <!-- Button Groups -->
  {
    buttonGroups.map((group) => {
      const isReadOnly = isButtonGroupReadOnly(group, projectStatus);
      // Parse selected values from project data
      let selectedValues: string[] = [];
      if (project?.[group.name]) {
        if (Array.isArray(project[group.name])) {
          selectedValues = project[group.name];
        } else if (typeof project[group.name] === "string") {
          try {
            const parsed = JSON.parse(project[group.name]);
            selectedValues = Array.isArray(parsed) ? parsed : [project[group.name]];
          } catch {
            selectedValues = project[group.name]
              .split(",")
              .map((s: string) => s.trim())
              .filter((s: string) => s);
          }
        } else {
          selectedValues = [project[group.name]];
        }
      }

      return (
        <div class="space-y-3" data-project-data={JSON.stringify(project)}>
          <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
            {group.label}
          </label>
          <div class={`flex flex-wrap gap-2 ${isReadOnly ? "pointer-events-none opacity-75" : ""}`}>
            {group.options.map((option) => {
              const isSelected = selectedValues.includes(option.value);
              return (
                <ToggleButton
                  value={option.value}
                  group={group.name}
                  type={group.type}
                  disabled={isReadOnly}
                  class={`${group.cssClass} ${isSelected ? "border-blue-500 bg-blue-500 text-white" : ""} ${
                    isReadOnly ? "cursor-not-allowed" : ""
                  }`}
                >
                  {option.label}
                </ToggleButton>
              );
            })}
          </div>
        </div>
      );
    })
  }

  <!-- Form Actions -->
  <div class="flex gap-2 border-t border-gray-200 pt-4 dark:border-gray-600">
    {
      formActions.map((action) => (
        <button
          type={action.type}
          class={action.cssClass}
          id={action.id}
          data-project-id={formId}
          data-action={action.action}
        >
          {action.icon && <i class={`bx ${action.icon} mr-1`} />}
          {action.label}
        </button>
      ))
    }
  </div>
</form>

<script>
  // Extend Window interface for toast manager
  declare global {
    interface Window {
      toastAlertManager?: any;
      currentProjectData?: any;
    }
  }

  // Make project data available globally
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector("form[data-project-id]");
    if (form) {
      const projectId = form.getAttribute("data-project-id");
      const projectDataAttr = form.getAttribute("data-project-data");
      if (projectDataAttr) {
        try {
          const projectData = JSON.parse(projectDataAttr);
          // Make project data available globally
          (window as any).currentProjectData = projectData;
          console.log("Project data loaded:", projectData);
        } catch (error) {
          console.error("Error parsing project data:", error);
        }
      }
    }
  });

  // Add event listeners for action buttons
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector("form[data-project-id]");
    if (form) {
      const projectId = form.getAttribute("data-project-id");
      const isNewProject = form.getAttribute("data-is-new-project") === "true";

      // Add form submission handler
      form.addEventListener("submit", handleFormSubmit);

      // Handle delete button (only for existing projects)
      // Note: Delete button is handled by the action button system below
      if (!isNewProject) {
        const deleteBtn = document.getElementById("delete-project");
        console.log("Delete button setup:", {
          deleteBtn: !!deleteBtn,
          projectId,
          isNewProject,
          formId: form.getAttribute("data-project-id"),
        });
      }

      // Handle other action buttons
      const actionButtons = document.querySelectorAll("[data-action]");
      actionButtons.forEach((button) => {
        const action = button.getAttribute("data-action");
        if (action && projectId) {
          button.addEventListener("click", function () {
            handleAction(action, projectId, isNewProject);
          });
        }
      });

      // Setup new client toggle functionality (only for new projects and admin/staff users)
      if (isNewProject) {
        // New client toggle is now handled by the NewOrExistingClient component
      }
    }
  });

  // Delete project function
  function deleteProject(projectId: string) {
    console.log("deleteProject called with projectId:", projectId, "type:", typeof projectId);

    // Validate project ID
    if (!projectId || projectId.startsWith("new-project-")) {
      console.error("Invalid project ID for deletion:", projectId);
      if ((window as any).toastAlertManager) {
        (window as any).toastAlertManager.show({
          type: "error",
          title: "Delete Failed",
          message: "Cannot delete a new project that hasn't been saved yet.",
          duration: 5000,
        });
      }
      return;
    }

    // Show confirmation toast with action buttons
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type: "warning",
        title: "Delete Project",
        message: "Are you sure you want to delete this project? This action cannot be undone.",
        duration: 0, // Don't auto-dismiss
        actions: [
          {
            label: "Cancel",
            action: () => {
              // Just close the toast, do nothing
            },
          },
          {
            label: "Delete",
            action: () => {
              // Show loading state
              const deleteBtn = document.getElementById("delete-project") as HTMLButtonElement;
              if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
              }

              // Make API call to delete project
              console.log("Sending delete request for project:", projectId);
              fetch(`/api/delete-project`, {
                method: "DELETE",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ projectId }),
              })
                .then(async (response) => {
                  console.log("Delete response status:", response.status);
                  const data = await response.json();
                  console.log("Delete response data:", data);

                  if (!response.ok) {
                    throw new Error(data.error || "Failed to delete project");
                  }

                  // Show success toast
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "success",
                      title: "Project Deleted!",
                      message: data.message || "Project has been deleted successfully.",
                      duration: 3000,
                    });
                  }

                  // Redirect to dashboard after a short delay
                  setTimeout(() => {
                    window.location.href = "/dashboard";
                  }, 1500);
                })
                .catch((error) => {
                  console.error("Error deleting project:", error);

                  // Show error toast
                  if ((window as any).toastAlertManager) {
                    (window as any).toastAlertManager.show({
                      type: "error",
                      title: "Delete Failed",
                      message: "Failed to delete project. Please try again.",
                      duration: 5000,
                    });
                  }

                  // Reset button state
                  if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete Project';
                  }
                });
            },
          },
        ],
      });
    }
  }

  // Show toast notification
  function showToast(
    type: "success" | "error" | "warning" | "info",
    title: string,
    message: string,
    duration: number = 4000
  ) {
    if ((window as any).toastAlertManager) {
      (window as any).toastAlertManager.show({
        type,
        title,
        message,
        duration,
      });
    }
  }

  // Handle different form actions
  function handleAction(action: string, projectId: string, isNewProject: boolean) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          deleteProject(projectId);
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form submission handler
  function handleFormSubmit(event: Event) {
    event.preventDefault();
    console.log("Form submission started");

    // Remove required attribute and disable hidden fields to prevent validation errors
    const form = event.target as HTMLFormElement;

    // Find all hidden fields (by style, class, or parent visibility)
    const hiddenFields = form.querySelectorAll(`
      input[style*="display: none"], 
      input[style*="display:none"], 
      .hidden input,
      input[disabled],
      input[type="hidden"]
    `);

    // Also check for fields in hidden containers
    const hiddenContainers = form.querySelectorAll(
      '[style*="display: none"], [style*="display:none"], .hidden'
    );
    hiddenContainers.forEach((container) => {
      const containerInputs = container.querySelectorAll("input, textarea, select");
      containerInputs.forEach((field) => {
        if (
          field instanceof HTMLInputElement ||
          field instanceof HTMLTextAreaElement ||
          field instanceof HTMLSelectElement
        ) {
          field.removeAttribute("required");
          field.disabled = true;
        }
      });
    });

    hiddenFields.forEach((field) => {
      if (
        field instanceof HTMLInputElement ||
        field instanceof HTMLTextAreaElement ||
        field instanceof HTMLSelectElement
      ) {
        field.removeAttribute("required");
        field.disabled = true;
      }
    });
    const formData = new FormData(form);
    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";

    console.log("Form data:", { projectId, isNewProject });

    // Collect form data
    const formValues: any = {};
    for (const [key, value] of formData.entries()) {
      formValues[key] = value;
    }

    console.log("📝 [ProjectForm] Raw form data collected:", formValues);

    // Handle client data based on new client toggle (now handled by NewOrExistingClient component)
    const isNewClient = formValues.new_client === "on";
    if (isNewClient) {
      // For new client, use email
      formValues.client_type = "new";
      formValues.client_name = `${formValues.first_name} ${formValues.last_name}`.trim();
      formValues.client_email = formValues.email;
    } else {
      // For existing client, use the selected client ID
      formValues.client_type = "existing";
      formValues.client_id = formValues.author_id;
    }

    // Collect toggle button values
    const toggleButtons = form.querySelectorAll(".toggle-button.bg-blue-500");
    console.log("📝 [ProjectForm] Found toggle buttons:", toggleButtons.length);
    toggleButtons.forEach((button) => {
      const group = button.getAttribute("data-group");
      const value = button.getAttribute("data-value");
      const type = button.getAttribute("data-type");

      console.log("📝 [ProjectForm] Toggle button:", { group, value, type });

      if (group && value) {
        if (type === "multi-select") {
          if (!formValues[group]) {
            formValues[group] = [];
          }
          if (Array.isArray(formValues[group])) {
            formValues[group].push(value);
          } else {
            formValues[group] = [formValues[group], value];
          }
        } else {
          formValues[group] = value;
        }
      }
    });

    // Get units value from slider
    const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
    if (unitsSlider) {
      const unitsOptions = unitsSlider.getAttribute("data-values")?.split(",") || [];
      const sliderValue = parseInt(unitsSlider.value);
      formValues.units = unitsOptions[sliderValue] || "1";
      console.log("📝 [ProjectForm] Units slider value:", {
        sliderValue,
        unitsValue: formValues.units,
      });
    } else {
      console.log("📝 [ProjectForm] Units slider not found");
    }

    console.log("Form data:", formValues);

    // Determine API endpoint based on new/existing project
    const endpoint = isNewProject ? "/api/create-project" : `/api/update-project/${projectId}`;
    const method = isNewProject ? "POST" : "PUT";

    // Show loading state
    const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;

    if (!submitBtn) {
      console.error("Submit button not found");
      return;
    }

    const originalText = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="bx bx-loader-alt bx-spin mr-1"></i>Saving...';

    // Submit form data
    fetch(endpoint, {
      method: method,
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formValues),
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error("Failed to save project");
        }
        return response.json();
      })
      .then((data) => {
        console.log("Project saved successfully:", data);

        // Show success toast
        if ((window as any).toastAlertManager) {
          (window as any).toastAlertManager.show({
            type: "success",
            title: isNewProject ? "Project Created!" : "Project Updated!",
            message: isNewProject
              ? "Your new project has been created successfully. Please upload your project files by clicking the 'Documents' tab."
              : "Your project has been updated successfully.",
            duration: isNewProject ? 10000 : 4000,
          });
        }

        // Redirect to project page if it's a new project
        if (isNewProject && data.id) {
          setTimeout(() => {
            window.location.href = `/project/${data.id}`;
          }, 1500); // Small delay to show the toast
        }
      })
      .catch((error) => {
        console.error("Error saving project:", error);

        // Show error toast
        if ((window as any).toastAlertManager) {
          (window as any).toastAlertManager.show({
            type: "error",
            title: "Save Failed",
            message: "Failed to save project. Please try again.",
            duration: 5000,
          });
        }
      })
      .finally(() => {
        // Reset button state
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
      });
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("🧹 [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("bg-blue-500", "text-white", "border-blue-500");
        button.classList.add("bg-white", "dark:bg-gray-700", "text-gray-700", "dark:text-gray-300");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      console.log("🧹 [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      console.log("🧹 [ProjectForm] Auto-resetting new project form");
      resetForm();
    }
  });

  // Make resetForm globally available
  (window as any).resetForm = resetForm;
</script>
