---
import {
  getFilteredUnifiedFormElements,
  isFormElementReadOnly,
} from "../../lib/project-form-config";
import { getColumnClasses } from "../../pages/api/global-classes";

import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";
import Button from "../common/Button.astro";

interface Props {
  project?: any;
  currentUser?: any;
  isNewProject?: boolean;
  projectStatus?: number | null;
  globalInputClasses?: string;
  globalSecondaryTextClasses?: string;
  globalPrimaryTextClasses?: string;
}

const {
  project = {},
  currentUser = {},
  isNewProject = true,
  projectStatus = null,
  globalInputClasses,
  globalSecondaryTextClasses,
  globalPrimaryTextClasses,
} = Astro.props;

const currentRole = currentUser?.profile?.role;
const projectId = project?.id;
// Generate a temporary ID for new projects
const formId = isNewProject ? `${Date.now()}` : projectId || "";
// Get unified form elements based on user role and project status
const formElements = getFilteredUnifiedFormElements(currentRole, isNewProject, projectStatus);
---

<form
  class="w-full space-y-4"
  data-project-id={formId}
  data-is-new-project={isNewProject}
  data-current-role={currentRole}
  data-project-data={JSON.stringify(project || {})}
  autocomplete="off"
>
  <!-- Unified Form Elements Loop -->
  <div class="grid grid-cols-6 md:grid-cols-12 gap-4">
    {
      formElements.map((element) => {
        const isReadOnly = isFormElementReadOnly(element, projectStatus);

        // Handle special cases first
        if (element.id === "address-input") {
          // Determine column class for address field
          const columnClass = getColumnClasses(element.columns);

          return (
            <div class={`relative ${columnClass}`}>
              {isNewProject ? (
                <SlotMachineModal
                  id="address"
                  icon="map-pin"
                  title="Select Address"
                  options={[]}
                  selectedValue={project?.address || ""}
                  placeholder="Search for an address..."
                  showCloseButton={true}
                  showCancelButton={true}
                  fetchOnLoad={false}
                  buttonText="Select Address *"
                  buttonClass="w-full"
                  buttonVariant="outline"
                  searchText="Search Address"
                  searchPlaceholder="Type to search addresses..."
                  fetchApiEndpoint="/api/places-autocomplete"
                  apiParams={{
                    types: "address",
                    components: "country:us",
                    locationBias: "circle:100@42.3601,-71.0589",
                  }}
                  valueField="description"
                  showImages={true}
                  imageField=""
                  noResultsText="Type to search addresses..."
                  skipSaveToAPI={true}
                  currentUser={currentUser}
                  project={project}
                  globalInputClasses={globalInputClasses}
                />
              ) : (
                <input
                  type="text"
                  id="address"
                  name="address"
                  value={project?.address || ""}
                  class="hidden"
                />
              )}

              {isNewProject && (currentRole === "Admin" || currentRole === "Staff") && (
                <IsNewOrExistingClient
                  globalInputClasses={globalInputClasses}
                  globalSecondaryTextClasses={globalSecondaryTextClasses}
                  globalPrimaryTextClasses={globalPrimaryTextClasses}
                />
              )}
            </div>
          );
        }

        // Handle form fields
        if (element.type === "field") {
          if (element.elementType === "text" || element.elementType === "number") {
            const columnClass = getColumnClasses(element.columns);

            return (
              <div class={`relative ${columnClass}`}>
                <label
                  for={`${element.id}`}
                  class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {element.label}
                  {element.required ? " *" : ""}
                </label>
                <input
                  type={element.elementType === "number" ? "number" : "text"}
                  id={`${element.id}`}
                  name={element.name}
                  value={
                    project?.[element.name] && project[element.name] !== ""
                      ? project[element.name]
                      : element.value || ""
                  }
                  class={`${globalInputClasses} ${
                    isReadOnly ? "cursor-not-allowed bg-gray-100 dark:bg-gray-800" : ""
                  }`}
                  autocomplete={
                    element.name === "architect"
                      ? "organization"
                      : element.name === "title"
                        ? "off"
                        : element.name === "description"
                          ? "off"
                          : element.name === "nfpaVersion"
                            ? "off"
                            : element.name === "hazardousMaterial"
                              ? "off"
                              : element.name === "hpsCommodities"
                                ? "off"
                                : element.name === "siteAccess"
                                  ? "off"
                                  : element.name === "exteriorBeacon"
                                    ? "off"
                                    : element.name === "fireSprinklerInstallation"
                                      ? "off"
                                      : element.name === "commencementOfConstruction"
                                        ? "off"
                                        : element.name === "suppressionDetectionSystems"
                                          ? "off"
                                          : "off"
                  }
                  placeholder={element.placeholder || ""}
                  required={element.required}
                  min={element.min}
                  max={element.max}
                  step={element.step}
                  readonly={isReadOnly}
                  data-field={element.dataField}
                />
              </div>
            );
          }

          if (element.elementType === "textarea") {
            const columnClass = getColumnClasses(element.columns);

            return (
              <div class={`relative ${columnClass}`}>
                <label
                  for={`${element.id}`}
                  class="block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {element.label}
                </label>
                <textarea
                  id={`${element.id}`}
                  name={element.name}
                  rows="3"
                  class={globalInputClasses}
                  placeholder={element.placeholder || ""}
                  readonly={isReadOnly}
                >
                  {project?.[element.name] && project[element.name] !== ""
                    ? project[element.name]
                    : element.value || ""}
                </textarea>
              </div>
            );
          }

          if (element.elementType === "checkbox") {
            const columnClass = getColumnClasses(element.columns);

            const isChecked =
              project?.[element.name] === true ||
              project?.[element.name] === "true" ||
              project?.[element.name] === 1 ||
              project?.[element.name] === "1";
            return (
              <div class={`relative ${columnClass}`}>
                <label
                  class={`inline-flex items-center ${isReadOnly ? "cursor-not-allowed" : "cursor-pointer"}`}
                >
                  <input
                    type="checkbox"
                    id={`${element.id}`}
                    name={element.name}
                    checked={isChecked}
                    disabled={isReadOnly}
                    class="peer sr-only"
                  />
                  <div
                    class={`peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-gray-100 after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-300 dark:border-gray-600 dark:peer-focus:ring-primary-800 rtl:peer-checked:after:-translate-x-full ${
                      isReadOnly
                        ? "cursor-not-allowed bg-gray-300 dark:bg-gray-600"
                        : "bg-gray-200 peer-checked:bg-primary-600 dark:bg-gray-700 dark:peer-checked:bg-primary-600"
                    }`}
                  />
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">
                    {element.label}
                  </span>
                </label>
              </div>
            );
          }

          if (element.elementType === "component" && element.component === "UnitSlider") {
            const columnClass = getColumnClasses(element.columns);

            return (
              <div class={`relative ${columnClass}`}>
                <UnitSlider
                  projectId={formId}
                  value={
                    project?.[element.name] && project[element.name] !== ""
                      ? project[element.name]
                      : element.value || 1
                  }
                  readOnly={isReadOnly}
                  name={element.name}
                  label={element.label}
                  min={element.min}
                  max={element.max}
                  step={element.step}
                />
              </div>
            );
          }
        }

        // Handle button groups
        if (element.type === "button-group") {
          const columnClass = getColumnClasses(element.columns);

          // Parse selected values from project data
          let selectedValues = [] as any;
          // console.log(`üîç [PROJECT-FORM] Processing group: ${element.name}, Project data:`, project?.[element.name]);
          if (project?.[element.name]) {
            if (Array.isArray(project[element.name])) {
              selectedValues = project[element.name];
            } else if (typeof project[element.name] === "string") {
              try {
                const parsed = JSON.parse(project[element.name]);
                selectedValues = Array.isArray(parsed) ? parsed : [project[element.name]];
              } catch {
                selectedValues = project[element.name]
                  .split(",")
                  .map((s: any) => s.trim())
                  .filter((s: any) => s);
              }
            } else {
              selectedValues = [project[element.name]];
            }
          }

          return (
            <div class={`mt-5 space-y-3 ${columnClass}`}>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                {element.label}
              </label>
              <div
                class={`mb-4 flex flex-wrap gap-2 ${isReadOnly ? "cursor-not-allowed opacity-75" : ""}`}
              >
                {element.options?.map((option) => {
                  const optionValue = typeof option === "string" ? option : option.value;
                  const optionLabel = typeof option === "string" ? option : option.label;
                  const isSelected =
                    selectedValues.includes(optionValue) ||
                    (typeof option === "object" && option.selected === true);
                  return (
                    <ToggleButton
                      value={optionValue}
                      group={element.name}
                      type={element.groupType}
                      disabled={isReadOnly}
                      class={`${element.cssClass || ""} ${isSelected ? "toggle-button selected" : "toggle-button"} ${
                        isReadOnly ? "pointer-events-none" : ""
                      }`}
                    >
                      {optionLabel}
                    </ToggleButton>
                  );
                })}
              </div>
            </div>
          );
        }

        // Skip actions in main loop - they're handled separately
        if (element.type === "action") {
          return null;
        }

        return null;
      })
    }
  </div>

  <!-- Form Actions Container -->
  <div class="flex gap-2 pt-4 dark:border-gray-600">
    {
      formElements
        .filter((element) => element.type === "action")
        .map((element) => {
          const isReadOnly = isFormElementReadOnly(element, projectStatus);
          return (
            <Button
              type={element.elementType === "submit" ? "submit" : "button"}
              variant={element.variant === "info" ? "primary" : element.variant || "primary"}
              size="xl"
              icon={element.icon}
              iconPosition="left"
              class={element.cssClass || ""}
              id={element.id}
              dataAttributes={{
                "data-action": element.action || "",
                "data-tab": element.tab || "",
              }}
            >
              {element.label}
            </Button>
          );
        })
    }
  </div>
</form>

<script>
  // Initialize project form
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector("form[data-project-id]");
    if (!form) return;
    const projectId = form.getAttribute("data-project-id");
    const isNewProject = form.getAttribute("data-is-new-project") === "true";
    // Add form submission handler
    form.addEventListener("submit", handleFormSubmit);
    // Form submission handler
    async function handleFormSubmit(event: Event) {
      const form = event.target as HTMLFormElement;

      // Check form validity before preventing default
      if (!form.checkValidity()) {
        // Let the browser show validation messages
        return;
      }

      event.preventDefault();
      // console.log("üìù [ProjectForm] Form submission started");
      const formData = new FormData(form);
      const projectData: any = {};

      // Convert FormData to object
      console.log("üìù [ProjectForm] FormData entries:");
      for (const [key, value] of formData.entries()) {
        console.log(`üìù [ProjectForm] FormData entry: ${key} = ${value}`);
        if (key.includes("[]")) {
          // Handle array fields (like multi-select button groups)
          const fieldName = key.replace("[]", "");
          if (!projectData[fieldName]) {
            projectData[fieldName] = [];
          }
          projectData[fieldName].push(value);
        } else {
          // Check if this is a button group field that contains JSON arrays
          const buttonGroupFields = ["building", "project", "service", "requestedDocs"];
          if (buttonGroupFields.includes(key) && value && typeof value === "string") {
            console.log(`üìù [ProjectForm] Processing button group field: ${key} = ${value}`);
            try {
              // Parse as JSON array (all button groups now use consistent array format)
              const parsed = JSON.parse(value);
              projectData[key] = Array.isArray(parsed) ? parsed : [];
              console.log(`üìù [ProjectForm] Parsed button group ${key}:`, projectData[key]);
            } catch (error) {
              console.log(`üìù [ProjectForm] Failed to parse button group ${key}:`, error);
              // If parsing fails, default to empty array
              projectData[key] = [];
            }
          } else {
            projectData[key] = value;
          }
        }
      }

      try {
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="bx bx-loader-alt animate-spin mr-1"></i>Saving...';
        }

        window.showModal("info", "Verifying project data...", projectData["address"], 10000);

        let response;
        if (isNewProject) {
          // Create new project
          // console.log("üìù [ProjectForm] Creating new project");
          response = await fetch("/api/create-project", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        } else {
          // Update existing project
          console.log("üìù [ProjectForm] Updating existing project:", projectId, projectData);

          response = await fetch(`/api/update-project/${projectId}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(projectData),
          });
        }

        // Check if response is JSON before parsing
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const textResponse = await response.text();
          console.error("üìù [ProjectForm] Non-JSON response received:", {
            status: response.status,
            contentType,
            body: textResponse.substring(0, 200) + "...",
          });
          throw new Error(
            `API returned non-JSON response (${response.status}): ${textResponse.substring(0, 100)}`
          );
        }

        const result = await response.json();

        if (result.success) {
          if (isNewProject) {
            // For new projects, update status to 1 (Under Review) to trigger database-driven notifications

            try {
              console.log("üìù [ProjectForm] Making fetch call now...");

              const project = result.project;
              const nextStatus = 10;

              (window as any).updateStatus(project, nextStatus, undefined).then((data: any) => {
                if (data.success) {
                  // debugger;
                  window.handleNewStatusModalAndEmail(data, "PROPOSAL-VIEW");
                  // window.location.href = `/project/${data.project.id}?status=discussion`;
                } else {
                  console.error("‚ùå [PROPOSAL-VIEW] Failed to update status:", data.error);
                }
              });

              // const statusResult = await (window as any).updateStatus(result.project, nextStatus, undefined);
              // window.handleNewStatusModalAndEmail(statusResult, "PROJECT-FORM");
            } catch (statusError) {
              console.error("üìù [ProjectForm] Status update failed:", statusError);
              console.error("üìù [ProjectForm] Status update error details:", statusError);

              // Store error in localStorage for debugging
              localStorage.setItem(
                "projectFormError",
                JSON.stringify({
                  error: (statusError as any)?.message || statusError,
                  timestamp: new Date().toISOString(),
                  projectId: result.project.id,
                })
              );

              // Fallback: just refresh the page
              window.location.reload();
            }
          } else {
            // For existing projects, just show success and refresh
            if ((window as any).showModal) {
              (window as any).showModal(
                "success",
                "Project Updated",
                "Project has been updated successfully!"
              );
            }
            setTimeout(() => {
              window.location.reload();
            }, 1000);
          }
        } else {
          console.error("üìù [ProjectForm] API returned success: false");
          console.error("üìù [ProjectForm] Error details:", result.error);
          console.error("üìù [ProjectForm] Full result:", result);
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("üìù [ProjectForm] Error saving project:", error);
        if (window.showModal) {
          window.showModal(
            "Error",
            error instanceof Error ? error.message : "Failed to save project",
            "error"
          );
        }
      } finally {
        // Reset button state
        const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement;
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = '<i class="bx bx-save mr-1"></i>Save Project';
        }
      }
    }
    // Note: Delete button is handled by the action button system below
    if (!isNewProject) {
      const deleteBtn = document.getElementById("delete-project");
      deleteBtn?.addEventListener("click", () => {
        (window as any).deleteProject(projectId);
      });
    }
  });

  // Handle different form actions
  function handleAction(action: any, projectId: any, isNewProject: any) {
    switch (action) {
      case "deleteProject":
        if (!isNewProject) {
          (window as any).deleteProject(projectId);
        }
        break;
      case "buildProposal":
        // Navigate to proposal tab
        if (typeof window !== "undefined" && window.switchTab) {
          window.switchTab("proposal");
        }
        break;
      default:
        console.log(`Action ${action} not implemented`);
    }
  }

  // Form reset function to clear cached values
  function resetForm() {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("üßπ [ProjectForm] Resetting form to clear cached values");

      // Reset all form inputs
      const inputs = form.querySelectorAll("input, textarea, select");
      inputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          if (input.type === "checkbox" || input.type === "radio") {
            input.checked = false;
          } else {
            input.value = "";
          }
        } else if (input instanceof HTMLTextAreaElement) {
          input.value = "";
        } else if (input instanceof HTMLSelectElement) {
          input.selectedIndex = 0;
        }
      });

      // Reset toggle buttons - let ToggleButton component handle its own state
      const toggleButtons = form.querySelectorAll(".toggle-button");
      toggleButtons.forEach((button) => {
        button.classList.remove("selected");
      });

      // Reset units slider to default
      const unitsSlider = form.querySelector('input[name="units"]') as HTMLInputElement;
      if (unitsSlider) {
        unitsSlider.value = "0"; // Default to first option
        const valueDisplay = form.querySelector('[id^="units-value-"]') as HTMLElement;
        if (valueDisplay) {
          valueDisplay.textContent = "1";
        }
      }

      // New client toggle reset is now handled by the NewOrExistingClient component

      // console.log("üßπ [ProjectForm] Form reset completed");
    }
  }

  // Auto-reset form on page load for new projects
  document.addEventListener("DOMContentLoaded", async function () {
    const form = document.querySelector('form[data-is-new-project="true"]');
    if (form) {
      // console.log("üßπ [ProjectForm] Auto-resetting new project form");
      // resetForm();
    }
    // Make resetForm globally available
    window.resetForm = resetForm;

    // Square footage numeric filtering
    const sqFtInputs = document.querySelectorAll('input[name="sqFt"]');

    sqFtInputs.forEach((input) => {
      // Prevent non-numeric characters on keypress
      input.addEventListener("keypress", (e) => {
        if (!/[0-9]/.test((e as KeyboardEvent).key)) {
          e.preventDefault();
        }
      });

      // Handle paste events to filter out non-numeric characters
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        const paste = ((e as ClipboardEvent).clipboardData || window.clipboardData).getData("text");
        const numericOnly = paste.replace(/[^0-9]/g, "");
        (input as HTMLInputElement).value = numericOnly;
      });

      // Handle input events to remove any non-numeric characters
      input.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (target) {
          target.value = target.value.replace(/[^0-9]/g, "");
        }
      });
    });
  });
</script>
