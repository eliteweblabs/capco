---
interface Props {
  authorProfile?: any;
  currentRole?: string;
  currentUser?: any;
  project: any;
  projectId: string;
  projectStatus?: number;
  projectStatusLabel?: string;
  supabaseUrl?: string;
}

import BoxIcon from "../common/BoxIcon.astro";
import Button from "../common/Button.astro";
import SlideToggle from "../common/SlideToggle.astro";

const {
  projectId,
  authorProfile,
  projectStatus,
  currentRole,
  currentUser,
  projectStatusLabel,
  supabaseUrl,
} = Astro.props;

const placeholder =
  currentRole === "Admin" || currentRole === "Staff"
    ? "Write your punchlist item here... (Use @username to mention users)"
    : "Write your punchlist item here...";
---

<div
  id="content-punchlist"
  class="tab-content hidden rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
>
  <div>
    <div id="punchlist-container" data-project-id={projectId}>
      <div class="mb-6 flex items-center justify-between">
        <h3 class="text-lg font-medium text-gray-900 dark:text-white">Project Punchlist</h3>

        <Button
          id="new-punchlist-item-btn"
          variant="primary"
          size="sm"
          icon="plus"
          iconPosition="left"
          class="min-w-[120px] whitespace-nowrap"
        >
          New Item
        </Button>
      </div>

      <p class="mb-4 text-sm text-gray-500 dark:text-gray-400">
        <b>Placeholders: </b>
        &#123;&#123; PROJECT_ADDRESS &#125;&#125;, &#123;&#123; CLIENT_NAME &#125;&#125;, &#123;&#123;
        CLIENT_EMAIL &#125;&#125;, &#123;&#123; EST_TIME &#125;&#125;, &#123;&#123; STATUS_NAME &#125;&#125;,
        &#123;&#123; CONTRACT_URL &#125;&#125;
      </p>
      <!-- Punchlist Item Form (hidden by default) -->
      <div
        id="punchlist-item-form"
        class="mb-6 hidden rounded-lg border border-gray-200 p-4 dark:border-gray-700"
      >
        <div class="relative">
          <textarea
            id="punchlist-item-message"
            placeholder={placeholder}
            class="w-full resize-none rounded-lg border border-gray-300 p-3 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            rows="4"
            required></textarea>
          <div
            id="punchlist-mention-dropdown"
            class="absolute z-50 mt-1 hidden max-h-48 w-full overflow-y-auto rounded-lg border border-gray-300 bg-white shadow-lg dark:border-gray-600 dark:bg-gray-700"
          >
          </div>
        </div>

        {/* Image Upload Section */}
        <div class="mt-3">
          <div class="flex items-center justify-between">
            <label
              class="flex cursor-pointer items-center gap-2 text-sm text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
            >
              <BoxIcon name="paperclip" class="h-4 w-4" />
              <span>Add Files</span>
              <input
                type="file"
                id="punchlist-item-images"
                accept="image/*,application/pdf,.dwg,.dxf,.dwt,.dws,.dwf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.csv"
                multiple
                class="hidden"
              />
            </label>

            <Button
              type="button"
              id="clear-punchlist-images-btn"
              variant="ghost"
              size="xs"
              class="hidden text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-200"
            >
              Clear All
            </Button>
          </div>

          {/* Image Preview Area */}
          <div id="punchlist-image-preview-container" class="mt-2 hidden">
            <div id="punchlist-image-previews" class="flex flex-wrap gap-2">
              <!-- Image previews will be added here -->
            </div>
          </div>
        </div>

        {/* Admin/Staff Only Toggles */}
        {
          (currentRole === "Admin" || currentRole === "Staff") && (
            <div class="mt-3 flex flex-wrap gap-6 border-t border-gray-200 pt-3 dark:border-gray-600">
              {/* Internal Only Toggle */}
              <SlideToggle id="punchlist-internal-toggle" label="Internal Only" checked={true} />
            </div>
          )
        }

        {/* Form Actions */}
        <div class="mt-4 flex items-center justify-end">
          <Button
            id="submit-punchlist-item-btn"
            variant="primary"
            size="sm"
            icon="send"
            iconPosition="left"
          >
            Post
          </Button>
        </div>
      </div>
      <!-- Punchlist Items List -->
      <div id="punchlist-items-list" class="space-y-4">
        <!-- Punchlist items will be dynamically loaded here -->
      </div>
      <div>
        <script
          define:vars={{
            projectId,
            authorProfile,
            currentRole,
            currentUser,
            supabaseUrl,
          }}
          type="module"
        >
          // Punchlist functionality
          let punchlistItems = [];
          let currentProjectId = projectId;
          let currentUserRole = currentRole;
          let currentUserId = currentUser?.id || authorProfile.id;
          let mentionableUsers = [];
          let currentMentionStart = -1;
          let selectedPunchlistImages = [];

          // console.log("🔔 [PUNCHLIST] Initial userRole:", currentUserRole);

          // Make user role available globally for reply forms
          window.currentUserRole = currentUserRole;
          window.PROJECT_USER_ROLE = currentUserRole;

          async function loadPunchlistItems(projectId) {
            try {
              const response = await fetch(`/api/get-project-punchlist?projectId=${projectId}`, {
                credentials: "include",
              });
              const data = await response.json();

              if (data.success) {
                punchlistItems = data.punchlist;
                renderPunchlistItems();
                updateIncompletePunchlistItemsCount(); // Update count after loading punchlist items
              } else {
                console.error("Failed to load punchlist items:", data.error);

                // Show specific error message if table doesn't exist
                if (data.migration_needed || data.error?.includes("does not exist")) {
                  showPunchlistError(
                    `Punchlist feature setup required<br><br>
                    <strong>Admin Action Needed:</strong><br>
                    Please run the SQL script:<br>
                    <code>sql-queriers/create-punchlist-table.sql</code><br>
                    in your Supabase SQL Editor to enable punchlist functionality.`
                  );
                } else {
                  showPunchlistError(
                    "Failed to load punchlist items: " + (data.details || data.error)
                  );
                }
              }
            } catch (error) {
              console.error("Error loading punchlist items:", error);
              showPunchlistError("Failed to load punchlist items");
            }
          }

          // Update incomplete punchlist items count in the punchlist tab
          function updateIncompletePunchlistItemsCount() {
            const incompleteCount = punchlistItems.filter((item) => !item.mark_completed).length;
            const countElement = document.querySelector(".incomplete-punchlist-items-count");
            const tabButton = document.getElementById("status-punchlist");

            if (tabButton) {
              // Create or update count bubble
              let countBubble = tabButton.querySelector(".punchlist-count-bubble");

              if (incompleteCount > 0) {
                if (!countBubble) {
                  // Create count bubble if it doesn't exist
                  countBubble = document.createElement("span");
                  countBubble.className =
                    "punchlist-count-bubble absolute right-0 top-0 flex h-5 w-5 items-center justify-center rounded-full border border-primary-500 bg-white text-xs font-medium text-primary-500 dark:border-primary-400 dark:bg-background-dark dark:text-primary-400";
                  tabButton.style.position = "relative";
                  tabButton.appendChild(countBubble);
                }
                countBubble.textContent = incompleteCount.toString();
                countBubble.style.display = "flex";
                tabButton.setAttribute("data-count", incompleteCount.toString());
              } else {
                if (countBubble) {
                  countBubble.style.display = "none";
                }
                tabButton.setAttribute("data-count", "0");
              }

              // Also update the old count element if it exists
              if (countElement) {
                if (incompleteCount > 0) {
                  countElement.textContent = incompleteCount.toString();
                  countElement.classList.remove("hidden");
                } else {
                  countElement.classList.add("hidden");
                }
              }

              // console.log("🔍 [PUNCHLIST] Incomplete punchlist items count updated:", incompleteCount);
            }
          }

          async function renderPunchlistItems() {
            const punchlistItemsList = document.getElementById("punchlist-items-list");
            if (!punchlistItemsList) return;

            // Separate top-level items and replies
            const topLevelItems = punchlistItems.filter((d) => !d.parent_id);
            const replies = punchlistItems.filter((d) => d.parent_id);

            let html = "";

            // Process items asynchronously
            for (const item of topLevelItems) {
              // Check if user can see this item
              const canSeeItem =
                !item.internal ||
                currentUserRole === "Admin" ||
                currentUserRole === "Staff" ||
                item.author_id === currentUserId;

              if (!canSeeItem) {
                console.log("🔍 [DEBUG] Hiding internal punchlist item from user:", item.id);
                continue;
              }

              html += await renderPunchlistItem(item, 0);

              // Find and render replies for this item
              const itemReplies = replies.filter((reply) => reply.parent_id === item.id);
              for (const reply of itemReplies) {
                const canSeeReply =
                  !reply.internal ||
                  currentUserRole === "Admin" ||
                  currentUserRole === "Staff" ||
                  reply.author_id === currentUserId;
                if (canSeeReply) {
                  html += await renderPunchlistItem(reply, 1);
                }
              }
            }

            punchlistItemsList.innerHTML = html;

            // Load toggles for all items that can be toggled
            punchlistItems.forEach((item) => {
              const canToggleCompleted =
                currentUserRole === "Admin" ||
                currentUserRole === "Staff" ||
                item.author_id === currentUserId;

              if (canToggleCompleted) {
                loadToggleForPunchlistItem(item.id, item.mark_completed, true);
              }
            });
          }

          function highlightMentions(text) {
            // Highlight @mentions with a blue background and white text
            // Pattern for formatted mentions (spaces converted to underscores on save)
            return text.replace(
              /@([a-zA-Z0-9_]+)/g,
              '<span class="inline-flex items-center rounded-lg bg-blue-100 px-2 py-1 text-xs font-medium text-blue-800 dark:bg-blue-900 dark:text-blue-200">@$1</span>'
            );
          }

          // Make highlightMentions available globally for other components
          window.highlightMentions = highlightMentions;

          async function renderPunchlistItem(item, depth = 0) {
            try {
              // Compute all values in the parent component
              const isInternal = item.internal;
              const isAuthor = item.author_id === currentUserId;
              const canToggleCompleted =
                currentUserRole === "Admin" || currentUserRole === "Staff" || isAuthor;
              const canReply =
                currentUserRole === "Admin" ||
                currentUserRole === "Staff" ||
                currentUserRole === "Client";
              const marginLeft = depth > 0 ? `ml-${Math.min(depth * 8, 32)}` : "";
              const borderLeft =
                depth > 0 ? "border-l-2 border-gray-200 dark:border-gray-600 pl-4" : "";

              // Ensure item data is properly encoded to handle Unicode characters
              const itemData = encodeURIComponent(JSON.stringify(item));

              const headers = new Headers({
                "x-comment-data": itemData,
                "x-current-user-role": currentUserRole,
                "x-current-user-id": currentUserId,
                "x-supabase-url": supabaseUrl,
                "x-comment-depth": depth.toString(),
                "x-is-internal": isInternal.toString(),
                "x-is-author": isAuthor.toString(),
                "x-can-toggle-completed": canToggleCompleted.toString(),
                "x-can-reply": canReply.toString(),
                "x-margin-left": marginLeft,
                "x-border-left": borderLeft,
              });

              // Load images for this punchlist item using unified media API
              try {
                const imageResponse = await fetch(
                  `/api/media?targetLocation=punchlist&targetId=${item.id}&projectId=${currentProjectId}`,
                  {
                    credentials: "include",
                  }
                );

                if (imageResponse.ok) {
                  const imageData = await imageResponse.json();
                  if (imageData.success && imageData.media && imageData.media.length > 0) {
                    imageData.media.forEach((mediaFile, index) => {
                      headers.set(`x-image-url-${index}`, mediaFile.publicUrl);
                      headers.set(`x-image-name-${index}`, mediaFile.fileName);
                    });
                    headers.set(`x-image-count`, imageData.media.length.toString());
                  }
                }
              } catch (error) {
                console.warn("Failed to load images for punchlist item:", item.id, error);
              }

              const response = await fetch("/partials/comment", {
                headers: headers,
              });

              if (response.ok) {
                return await response.text();
              } else {
                console.error("Failed to load punchlist item partial:", response.status);
                return `<div class="text-red-500">Failed to load punchlist item</div>`;
              }
            } catch (error) {
              console.error("Error loading punchlist item partial:", error);
              return `<div class="text-red-500">Error loading punchlist item</div>`;
            }
          }

          // Load toggle using SlideToggle partial
          async function loadToggleForPunchlistItem(itemId, isCompleted, canToggle) {
            if (!canToggle) return;

            try {
              // Handle null/undefined isCompleted values
              const completed = isCompleted === true || isCompleted === "true" || isCompleted === 1;

              const headers = new Headers({
                "x-toggle-id": `punchlist-completed-toggle-${itemId}`,
                "x-toggle-label": completed ? "Completed" : "Incomplete",
                "x-toggle-icon": completed ? "bx-check-circle" : "",
                "x-toggle-color": "green",
                "x-toggle-checked": completed.toString(),
                "x-toggle-class": "punchlist-completed-toggle",
                "x-toggle-data-discussion-id": itemId.toString(),
              });

              const response = await fetch("/partials/slide-toggle", {
                headers: headers,
              });

              if (response.ok) {
                const toggleHTML = await response.text();
                const container = document.getElementById(`toggle-container-${itemId}`);
                if (container) {
                  container.innerHTML = toggleHTML;
                }
              }
            } catch (error) {
              console.error("❌ [PUNCHLIST] Error loading toggle:", error);
            }
          }

          function showPunchlistError(message) {
            const punchlistItemsList = document.getElementById("punchlist-items-list");
            if (punchlistItemsList) {
              punchlistItemsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
            }
          }

          function togglePunchlistItemForm() {
            console.log("🔔 [PUNCHLIST] togglePunchlistItemForm called");
            const punchlistItemForm = document.getElementById("punchlist-item-form");
            const newPunchlistItemBtn = document.getElementById("new-punchlist-item-btn");

            if (punchlistItemForm && newPunchlistItemBtn) {
              const isHidden = punchlistItemForm.classList.contains("hidden");

              if (isHidden) {
                punchlistItemForm.classList.remove("hidden");
                newPunchlistItemBtn.innerHTML = `
          <i class="bx bx-x mr-2 bx-sm"></i>
          Cancel
        `;
                newPunchlistItemBtn.classList.remove("bg-red-600", "hover:bg-red-700");
                newPunchlistItemBtn.classList.add("bg-gray-600", "hover:bg-gray-700");

                // Focus on textarea
                const textarea = document.getElementById("punchlist-item-message");
                if (textarea) {
                  textarea.focus();
                }
              } else {
                punchlistItemForm.classList.add("hidden");
                newPunchlistItemBtn.innerHTML = `
          <i class="bx bx-plus bx-sm"></i>
          New Item
        `;
                newPunchlistItemBtn.classList.remove("bg-gray-600", "hover:bg-gray-700");
                newPunchlistItemBtn.classList.add("bg-red-600", "hover:bg-red-700");

                // Clear form
                const textarea = document.getElementById("punchlist-item-message");
                const internalToggle = document.getElementById("punchlist-internal-toggle");
                if (textarea) textarea.value = "";
                if (internalToggle) internalToggle.checked = false;
                clearAllPunchlistImages();
              }
            }
          }

          // Cancel reply form
          function cancelPunchlistReply(parentItemId) {
            console.log("🔔 [PUNCHLIST] Canceling reply for punchlist item:", parentItemId);

            const replyForm = document.querySelector(
              `[data-punchlist-id="${parentItemId}"]`
            )?.nextElementSibling;
            if (replyForm && replyForm.classList.contains("inline-reply-form")) {
              replyForm.remove();
            }

            // Clear the current reply target
            window.currentPunchlistReplyTo = null;
          }

          // Submit reply
          async function submitPunchlistReply(parentItemId) {
            console.log("🔔 [PUNCHLIST] Submitting reply for punchlist item:", parentItemId);

            const replyForm = document.querySelector(
              `[data-punchlist-id="${parentItemId}"]`
            )?.nextElementSibling;
            if (!replyForm) {
              console.error("Reply form not found");
              return;
            }

            const messageInput = replyForm.querySelector(".reply-message-input");
            const internalToggle = replyForm.querySelector(".reply-internal-toggle");
            const submitBtn = replyForm.querySelector(".submit-reply-btn");

            const message = messageInput?.value?.trim();
            const isInternal = internalToggle?.checked || false;

            if (!message) {
              alert("Please enter a reply message");
              return;
            }

            // Set loading state
            if (submitBtn) {
              submitBtn.disabled = true;
              submitBtn.innerHTML = `
        <svg class="animate-spin mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Posting...
      `;
            }

            try {
              const response = await fetch("/api/add-punchlist", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include",
                body: JSON.stringify({
                  projectId: currentProjectId,
                  message: message,
                  parentId: parentItemId,
                  internal: isInternal,
                }),
              });

              const data = await response.json();

              if (data.success) {
                console.log("✅ Reply submitted successfully");
                // Remove the reply form
                replyForm.remove();
                // Reload punchlist items
                await loadPunchlistItems(currentProjectId);
                // Show success message
                if (window.showModal) {
                  window.showModal(
                    "success",
                    "Reply posted",
                    "Your reply has been added to the punchlist"
                  );
                }
              } else {
                console.error("Failed to submit reply:", data.error);
                alert("Failed to submit reply: " + data.error);
              }
            } catch (error) {
              console.error("Error submitting reply:", error);
              alert("Error submitting reply");
            } finally {
              // Reset loading state
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = `
          <i class="bx bx-send mr-2"></i>
          Post Reply
        `;
              }
            }
          }

          // Image upload functionality (using new save-media API)
          async function handlePunchlistImageUpload(event) {
            const files = Array.from(event.target.files);
            const maxFiles = 5;
            const maxSize = 50 * 1024 * 1024; // 50MB per file (increased for CAD files)

            // Define allowed file types
            const allowedTypes = [
              // Images
              "image/jpeg",
              "image/jpg",
              "image/png",
              "image/gif",
              "image/webp",
              "image/bmp",
              "image/tiff",
              "image/svg+xml",
              // Documents
              "application/pdf",
              "application/msword",
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              "application/vnd.ms-excel",
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              "application/vnd.ms-powerpoint",
              "application/vnd.openxmlformats-officedocument.presentationml.presentation",
              "text/plain",
              "text/csv",
              // AutoCAD files
              "application/acad",
              "application/x-acad",
              "application/autocad",
              "application/x-autocad",
              "application/dwg",
              "application/x-dwg",
              "image/vnd.dwg",
              "drawing/dwg",
              "application/dxf",
              "application/x-dxf",
              "image/vnd.dxf",
              "drawing/dxf",
              "application/dwt",
              "application/x-dwt",
              "application/dws",
              "application/x-dws",
              "application/dwf",
              "application/x-dwf",
              "model/vnd.dwf",
              // Generic binary for CAD files
              "application/octet-stream",
            ];

            // Validate files
            const validFiles = files.filter((file) => {
              // Check file type (including extension fallback for octet-stream)
              const isAllowedType =
                allowedTypes.includes(file.type) ||
                (file.type === "application/octet-stream" &&
                  /\.(dwg|dxf|dwt|dws|dwf)$/i.test(file.name));

              if (!isAllowedType) {
                console.warn("Skipping unsupported file type:", file.name, "Type:", file.type);
                if (window.showModal) {
                  window.showModal(
                    "warning",
                    "Unsupported File Type",
                    `${file.name} is not a supported file type. Please upload images, PDFs, documents, or CAD files.`
                  );
                }
                return false;
              }

              if (file.size > maxSize) {
                console.warn("Skipping large file:", file.name, "Size:", file.size);
                if (window.showModal) {
                  window.showModal(
                    "warning",
                    "File Too Large",
                    `${file.name} is too large. Maximum size is 50MB.`
                  );
                }
                return false;
              }
              return true;
            });

            // Check total file limit
            if (selectedPunchlistImages.length + validFiles.length > maxFiles) {
              if (window.showModal) {
                window.showModal("warning", "Too Many Files", `Maximum ${maxFiles} files allowed.`);
              }
              return;
            }

            // Add valid files to selected images for preview
            validFiles.forEach((file) => {
              selectedPunchlistImages.push(file);
            });

            updatePunchlistImagePreviews();
          }

          function updatePunchlistImagePreviews() {
            const container = document.getElementById("punchlist-image-preview-container");
            const previews = document.getElementById("punchlist-image-previews");
            const clearBtn = document.getElementById("clear-punchlist-images-btn");

            if (!container || !previews) return;

            if (selectedPunchlistImages.length === 0) {
              container.classList.add("hidden");
              if (clearBtn) clearBtn.classList.add("hidden");
              return;
            }

            container.classList.remove("hidden");
            if (clearBtn) clearBtn.classList.remove("hidden");

            previews.innerHTML = selectedPunchlistImages
              .map(
                (file, index) => `
        <div class="relative group">
          <img 
            src="${URL.createObjectURL(file)}" 
            alt="${file.name}"
            class="w-20 h-20 object-cover rounded-lg border border-gray-300 dark:border-gray-600"
          />
          <button
            type="button"
            onclick="removePunchlistImage(${index})"
            class="absolute -top-2 -right-2 w-6 h-6 bg-red-500 text-white rounded-lg flex items-center justify-center text-xs hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
          >
            ×
          </button>
          <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-50 text-white text-xs p-1 rounded-b-lg truncate">
            ${file.name}
          </div>
        </div>
      `
              )
              .join("");
          }

          function removePunchlistImage(index) {
            selectedPunchlistImages.splice(index, 1);
            updatePunchlistImagePreviews();
          }

          function clearAllPunchlistImages() {
            selectedPunchlistImages = [];
            updatePunchlistImagePreviews();
            const fileInput = document.getElementById("punchlist-item-images");
            if (fileInput) fileInput.value = "";
          }

          // Image modal functionality
          function openImageModal(imageUrl) {
            console.log("🖼️ [PUNCHLIST] openImageModal called with:", imageUrl);

            // Create modal overlay
            const modal = document.createElement("div");
            modal.className =
              "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50";
            modal.innerHTML = `
        <div class="relative max-w-4xl max-h-full p-4">
          <button 
            onclick="this.closest('.fixed').remove()"
            class="absolute top-2 right-2 text-white text-2xl hover:text-gray-300 z-10"
          >
            ×
          </button>
          <img 
            src="${imageUrl}" 
            alt="Punchlist image"
            class="max-w-full max-h-full object-contain rounded-lg"
          />
        </div>
      `;

            // Close on background click
            modal.addEventListener("click", (e) => {
              if (e.target === modal) {
                modal.remove();
              }
            });

            // Close on escape key
            const handleEscape = (e) => {
              if (e.key === "Escape") {
                modal.remove();
                document.removeEventListener("keydown", handleEscape);
              }
            };
            document.addEventListener("keydown", handleEscape);

            document.body.appendChild(modal);
          }

          // Make image functions globally available
          window.removePunchlistImage = removePunchlistImage;
          window.clearAllPunchlistImages = clearAllPunchlistImages;
          window.openImageModal = openImageModal;

          // Make functions globally available
          window.togglePunchlistItemForm = togglePunchlistItemForm;
          window.cancelPunchlistReply = cancelPunchlistReply;
          window.submitPunchlistReply = submitPunchlistReply;

          async function submitPunchlistItem() {
            const messageInput = document.getElementById("punchlist-item-message");
            const message = messageInput?.value?.trim();
            const internalToggle = document.getElementById("punchlist-internal-toggle");
            const isInternal = internalToggle?.checked || false;
            const submitBtn = document.getElementById("submit-punchlist-item-btn");

            if (!message) {
              if (window.showModal) {
                window.showModal("error", "Please enter a message", "", 5000);
              }
              messageInput?.focus();
              return;
            }

            // Set loading state
            if (submitBtn) {
              submitBtn.disabled = true;
              submitBtn.innerHTML = `
        <svg class="animate-spin mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        ${selectedPunchlistImages.length > 0 ? "Uploading..." : "Posting..."}
      `;
            }

            try {
              // First, submit the punchlist item without images
              const response = await fetch("/api/add-punchlist", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include",
                body: JSON.stringify({
                  projectId: currentProjectId,
                  message: message || "",
                  internal: isInternal,
                }),
              });

              const data = await response.json();

              if (data.success) {
                const punchlistId = data.punchlist.id;

                // Upload images using save-media API if any were selected
                let uploadedImageCount = 0;
                let uploadErrors = [];

                if (selectedPunchlistImages.length > 0) {
                  console.log(
                    "📸 Uploading",
                    selectedPunchlistImages.length,
                    "images for punchlist item",
                    punchlistId
                  );

                  for (let i = 0; i < selectedPunchlistImages.length; i++) {
                    const file = selectedPunchlistImages[i];

                    try {
                      // Convert file to base64
                      const reader = new FileReader();
                      const fileData = await new Promise((resolve, reject) => {
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                      });

                      // Upload using unified media API
                      const response = await fetch("/api/media", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        credentials: "include",
                        body: JSON.stringify({
                          mediaData: fileData,
                          fileName: file.name,
                          fileType: file.type,
                          projectId: currentProjectId,
                          targetLocation: "punchlist",
                          targetId: punchlistId,
                          title: `Punchlist file - ${file.name}`,
                          description: `File attached to punchlist item`,
                        }),
                      });

                      if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || "Upload failed");
                      }

                      const uploadResult = await response.json();
                      const uploadedFile = uploadResult.file;

                      uploadedImageCount++;
                      console.log("✅ File uploaded:", uploadedFile.fileName);
                    } catch (error) {
                      console.error("❌ Upload error for", file.name, ":", error);
                      uploadErrors.push(`Failed to upload ${file.name}: ${error.message}`);
                    }
                  }

                  // Show upload errors if any
                  if (uploadErrors.length > 0) {
                    console.warn("⚠️ Upload errors:", uploadErrors);
                    if (window.showModal) {
                      window.showModal(
                        "warning",
                        "Upload Warnings",
                        `Some images failed to upload:\n${uploadErrors.join("\n")}`
                      );
                    }
                  }
                }

                console.log("✅ Punchlist item submitted successfully");

                // Clear form and hide it
                messageInput.value = "";
                if (internalToggle) internalToggle.checked = false;
                clearAllPunchlistImages();
                togglePunchlistItemForm();
                // Reload punchlist items
                await loadPunchlistItems(currentProjectId);
                // Show success message
                if (window.showModal) {
                  window.showModal(
                    "success",
                    "Punchlist item posted",
                    `Your punchlist item has been added${uploadedImageCount > 0 ? ` with ${uploadedImageCount} image(s)` : ""}`
                  );
                }
              } else {
                console.error("Failed to submit punchlist item:", data.error);
                if (window.showModal) {
                  window.showModal(
                    "error",
                    "Punchlist Item Failed",
                    `Failed to submit punchlist item: ${data.error}`
                  );
                } else {
                  alert("Failed to submit punchlist item: " + data.error);
                }
              }
            } catch (error) {
              console.error("Error submitting punchlist item:", error);
              if (window.showModal) {
                window.showModal(
                  "error",
                  "Punchlist Item Error",
                  `Error submitting punchlist item: ${error.message}`
                );
              } else {
                alert("Error submitting punchlist item: " + error.message);
              }
            } finally {
              // Reset loading state
              if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = `
          <i class="bx bx-send mr-2 h-4 w-4"></i>
          Post Item
        `;
              }
            }
          }

          // Load mentionable users
          async function loadMentionableUsers() {
            if (!currentProjectId) return;

            try {
              const response = await fetch(
                `/api/get-mentionable-users?projectId=${currentProjectId}`
              );
              const data = await response.json();

              if (data.success) {
                mentionableUsers = data.users;

                // Add project author to mentionable users if not already included
                if (
                  authorProfile &&
                  !mentionableUsers.find((user) => user.id === authorProfile.id)
                ) {
                  const authorUser = {
                    id: authorProfile.id,
                    name:
                      authorProfile.first_name && authorProfile.last_name
                        ? `${authorProfile.first_name} ${authorProfile.last_name}`
                        : authorProfile.company_name || "Unknown User",
                    role: authorProfile.role || "Client",
                    email: authorProfile.email || "",
                  };
                  mentionableUsers.unshift(authorUser); // Add to beginning of list
                }
              } else {
                console.error("Failed to load mentionable users:", data.error);
              }
            } catch (error) {
              console.error("Error loading mentionable users:", error);
            }
          }

          // Show mention dropdown
          function showMentionDropdown(query, position) {
            const dropdown = document.getElementById("punchlist-mention-dropdown");
            const textarea = document.getElementById("punchlist-item-message");

            if (!dropdown || !textarea) return;

            const filteredUsers = mentionableUsers.filter(
              (user) =>
                user.name.toLowerCase().includes(query.toLowerCase()) ||
                user.email.toLowerCase().includes(query.toLowerCase())
            );

            if (filteredUsers.length === 0) {
              hideMentionDropdown();
              return;
            }

            // Separate project author from other users
            const projectAuthor = filteredUsers.find((user) => user.id === authorProfile?.id);
            const otherUsers = filteredUsers.filter((user) => user.id !== authorProfile?.id);

            let html = "";
            let itemIndex = 0;

            // Add project author first with special styling
            if (projectAuthor) {
              html += `
        <div class="mention-item px-3 py-2 cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 ${itemIndex === 0 ? "bg-blue-50 dark:bg-blue-900/20" : ""} border-b border-gray-200 dark:border-gray-600" 
             data-index="${itemIndex}" 
             data-user-name="${projectAuthor.name}">
          <div class="flex items-center gap-2">
            <i class="bx bx-user-circle text-blue-600 dark:text-blue-400 text-lg"></i>
            <div>
              <div class="font-medium text-blue-900 dark:text-blue-100">${projectAuthor.name}</div>
              <div class="text-sm text-blue-600 dark:text-blue-400">Project Author</div>
            </div>
          </div>
        </div>
      `;
              itemIndex++;
            }

            // Add other users
            html += otherUsers
              .map(
                (user, index) => `
      <div class="mention-item px-3 py-2 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-600 ${itemIndex === 0 ? "bg-gray-50 dark:bg-gray-600" : ""}" 
           data-index="${itemIndex}" 
           data-user-name="${user.name}">
        <div class="flex items-center gap-2">
          <i class="bx bx-user text-gray-500 dark:text-gray-400 text-lg"></i>
          <div>
            <div class="font-medium text-gray-900 dark:text-white">${user.name}</div>
            <div class="text-sm text-gray-500 dark:text-gray-400">${user.email}</div>
          </div>
        </div>
      </div>
    `
              )
              .join("");

            dropdown.innerHTML = html;
            dropdown.classList.remove("hidden");

            // Add click handlers
            dropdown.querySelectorAll(".mention-item").forEach((item) => {
              item.addEventListener("click", () => {
                const userName = item.getAttribute("data-user-name");
                if (userName) insertMention(userName);
              });
            });
          }

          // Hide mention dropdown
          function hideMentionDropdown() {
            const dropdown = document.getElementById("punchlist-mention-dropdown");
            if (dropdown) {
              dropdown.classList.add("hidden");
            }
            currentMentionStart = -1;
          }

          // Insert mention into textarea
          function insertMention(userName) {
            const textarea = document.getElementById("punchlist-item-message");
            if (!textarea || currentMentionStart === -1) return;

            // Format the username to replace spaces with underscores
            const formattedUserName = userName.replace(/\s+/g, "_");

            const beforeMention = textarea.value.substring(0, currentMentionStart);
            const afterMention = textarea.value.substring(textarea.selectionStart);
            const mentionText = `@${formattedUserName} `;

            textarea.value = beforeMention + mentionText + afterMention;

            // Set cursor position after mention
            const newPosition = beforeMention.length + mentionText.length;
            textarea.setSelectionRange(newPosition, newPosition);
            textarea.focus();

            hideMentionDropdown();
          }

          // Handle mention input
          function handleMentionInput() {
            const textarea = document.getElementById("punchlist-item-message");
            if (!textarea) return;

            const cursorPos = textarea.selectionStart;
            const textBeforeCursor = textarea.value.substring(0, cursorPos);

            // Look for @ symbol
            const atIndex = textBeforeCursor.lastIndexOf("@");
            if (atIndex === -1) {
              hideMentionDropdown();
              return;
            }

            // Check if there's a space after @ (not a mention)
            const textAfterAt = textBeforeCursor.substring(atIndex + 1);
            if (textAfterAt.includes(" ")) {
              hideMentionDropdown();
              return;
            }

            // Show dropdown with filtered users
            currentMentionStart = atIndex;
            showMentionDropdown(textAfterAt, atIndex);
          }

          // Initialize punchlist functionality when punchlist tab is shown
          function initializePunchlist() {
            // Set user role from server-side data (already set via define:vars)
            currentUserRole = window.PROJECT_USER_ROLE || "Client";
            console.log("🔔 [PUNCHLIST] User role set to:", currentUserRole);

            // Make user role available globally for reply forms
            window.currentUserRole = currentUserRole;

            const punchlistContainer = document.getElementById("punchlist-container");
            if (punchlistContainer) {
              currentProjectId = punchlistContainer.dataset.projectId || "";
              if (currentProjectId) {
                loadPunchlistItems(currentProjectId);
                loadMentionableUsers();
              }
            }

            // Remove existing event listeners to prevent duplicates
            const newPunchlistItemBtn = document.getElementById("new-punchlist-item-btn");
            const submitPunchlistItemBtn = document.getElementById("submit-punchlist-item-btn");
            const punchlistItemTextarea = document.getElementById("punchlist-item-message");

            if (newPunchlistItemBtn) {
              // Remove existing event listeners by cloning the node
              const newBtn = newPunchlistItemBtn.cloneNode(true);
              newPunchlistItemBtn.parentNode?.replaceChild(newBtn, newPunchlistItemBtn);

              // Add single clean event listener
              newBtn.addEventListener("click", function (e) {
                e.preventDefault();
                e.stopPropagation();
                console.log("🔔 [PUNCHLIST] New punchlist item button clicked!");
                togglePunchlistItemForm();
              });
            }

            if (submitPunchlistItemBtn) {
              submitPunchlistItemBtn.removeEventListener("click", submitPunchlistItem);
              submitPunchlistItemBtn.addEventListener("click", submitPunchlistItem);
            }

            // Image upload functionality
            const imageInput = document.getElementById("punchlist-item-images");
            const clearImagesBtn = document.getElementById("clear-punchlist-images-btn");

            // Image upload event listeners
            if (imageInput) {
              imageInput.addEventListener("change", handlePunchlistImageUpload);
            }

            if (clearImagesBtn) {
              clearImagesBtn.addEventListener("click", clearAllPunchlistImages);
            }

            // Add mention functionality to textarea
            if (punchlistItemTextarea) {
              punchlistItemTextarea.addEventListener("input", handleMentionInput);
              punchlistItemTextarea.addEventListener("keydown", (e) => {
                const dropdown = document.getElementById("punchlist-mention-dropdown");
                if (!dropdown || dropdown.classList.contains("hidden")) return;

                const items = dropdown.querySelectorAll(".mention-item");
                const selected = dropdown.querySelector(
                  ".mention-item.bg-gray-50, .mention-item.dark\\:bg-gray-600"
                );
                let selectedIndex = 0;

                if (selected) {
                  selectedIndex = parseInt(selected.getAttribute("data-index") || "0");
                }

                if (e.key === "ArrowDown") {
                  e.preventDefault();
                  const nextIndex = Math.min(selectedIndex + 1, items.length - 1);
                  items.forEach((item, i) => {
                    item.classList.toggle("bg-gray-50", i === nextIndex);
                    item.classList.toggle("dark:bg-gray-600", i === nextIndex);
                  });
                } else if (e.key === "ArrowUp") {
                  e.preventDefault();
                  const prevIndex = Math.max(selectedIndex - 1, 0);
                  items.forEach((item, i) => {
                    item.classList.toggle("bg-gray-50", i === prevIndex);
                    item.classList.toggle("dark:bg-gray-600", i === prevIndex);
                  });
                } else if (e.key === "Enter" || e.key === "Tab") {
                  e.preventDefault();
                  const selectedItem = items[selectedIndex];
                  if (selectedItem) {
                    const userName = selectedItem.getAttribute("data-user-name");
                    if (userName) insertMention(userName);
                  }
                } else if (e.key === "Escape") {
                  e.preventDefault();
                  hideMentionDropdown();
                }
              });

              // Hide dropdown when clicking outside
              document.addEventListener("click", (e) => {
                const dropdown = document.getElementById("punchlist-mention-dropdown");
                const textarea = document.getElementById("punchlist-item-message");
                if (dropdown && !dropdown.contains(e.target) && e.target !== textarea) {
                  hideMentionDropdown();
                }
              });
            }

            // Add event delegation for completed toggles
            document.addEventListener("change", (e) => {
              const target = e.target;
              if (target.classList.contains("punchlist-completed-toggle")) {
                const punchlistId = parseInt(target.getAttribute("data-discussion-id") || "0");
                const isCompleted = target.checked;
                if (punchlistId) {
                  togglePunchlistCompleted(punchlistId, isCompleted);
                }
              }
            });

            // Add event delegation for reply buttons
            document.addEventListener("click", (e) => {
              const target = e.target;

              if (
                target.classList.contains("punchlist-reply-button") ||
                target.closest(".punchlist-reply-button")
              ) {
                const button = target.classList.contains("punchlist-reply-button")
                  ? target
                  : target.closest(".punchlist-reply-button");
                if (button) {
                  const punchlistId = parseInt(button.getAttribute("data-punchlist-id") || "0");
                  if (punchlistId) {
                    showPunchlistReplyForm(punchlistId);
                  }
                }
              }
            });

            console.log("🔔 [PUNCHLIST] Event listeners attached");
          }

          // Show reply form for a specific punchlist item
          function showPunchlistReplyForm(parentItemId) {
            // First, hide any existing inline reply forms
            const existingReplyForms = document.querySelectorAll(".inline-reply-form");
            existingReplyForms.forEach((form) => form.remove());

            // Find the punchlist item element to reply to
            const itemElement = document.querySelector(`[data-punchlist-id="${parentItemId}"]`);
            if (!itemElement) {
              console.error(
                "🔔 [PUNCHLIST] Punchlist item element not found for ID:",
                parentItemId
              );
              return;
            }

            // Create inline reply form
            const replyFormHTML = `
      <div class="inline-reply-form mt-3 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-600">
        <!-- Textarea -->
        <div class="relative">
          <textarea
            class="reply-message-input w-full resize-none rounded-lg border border-gray-300 p-3 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            placeholder="Type your reply here..."
            rows="3"
          ></textarea>
        </div>
        
        <!-- Admin/Staff Only Toggles for Reply -->
        ${(() => {
          const userRole = window.currentUserRole || "Client";
          return userRole === "Admin" || userRole === "Staff"
            ? `
            <div class="mt-3 flex flex-wrap gap-6 border-t border-gray-200 pt-3 dark:border-gray-600">
              <!-- Internal Only Toggle -->
              <label class="flex items-center gap-3 cursor-pointer">
                <div class="relative">
                  <input
                    type="checkbox"
                    class="reply-internal-toggle sr-only peer"
                  />
                  <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800 rounded-lg peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-lg after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                </div>
                <span class="text-sm text-gray-700 dark:text-gray-300">
                  <i class="bx bx-lock mr-1"></i>
                  Internal Only
                </span>
              </label>
            </div>
          `
            : "";
        })()}
        
        <!-- Buttons Row -->
        <div class="mt-3 flex items-center justify-between">
          <button
            class="cancel-reply-btn px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
            onclick="window.cancelPunchlistReply(${parentItemId})"
          >
            Cancel
          </button>
          <button
            class="submit-reply-btn rounded-lg bg-blue-600 px-4 py-2 text-white transition-colors hover:bg-blue-700"
            onclick="window.submitPunchlistReply(${parentItemId})"
          >
            <i class="bx bx-send mr-2"></i>
            Post Reply
          </button>
        </div>
      </div>
    `;

            // Insert the reply form after the punchlist item
            itemElement.insertAdjacentHTML("afterend", replyFormHTML);

            // Set the parent item ID for the reply
            window.currentPunchlistReplyTo = parentItemId;

            // Focus on the reply textarea
            const replyTextarea = document.querySelector(".reply-message-input");
            if (replyTextarea) {
              replyTextarea.focus();
            }

            console.log(
              "🔔 [PUNCHLIST] Inline reply form created for punchlist item:",
              parentItemId
            );
          }

          // Toggle punchlist item completed status
          async function togglePunchlistCompleted(punchlistId, isCompleted) {
            try {
              console.log("🔔 [PUNCHLIST] Toggling completed status:", {
                punchlistId,
                isCompleted,
              });

              const response = await fetch("/api/update-punchlist-completed", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                credentials: "include",
                body: JSON.stringify({
                  punchlistId: punchlistId,
                  mark_completed: isCompleted,
                }),
              });

              const data = await response.json();

              if (data.success) {
                console.log("✅ [PUNCHLIST] Punchlist item completed status updated successfully");
                // Update the local punchlist data
                const punchlistItem = punchlistItems.find((d) => d.id === punchlistId);
                if (punchlistItem) {
                  punchlistItem.mark_completed = isCompleted;
                }

                // Update the incomplete punchlist items count
                updateIncompletePunchlistItemsCount();
                // Show success notification
                if (window.showModal) {
                  window.showModal(
                    "success",
                    "Punchlist status updated",
                    `Marked as ${isCompleted ? "completed" : "incomplete"}`,
                    1500
                  );
                }

                // Reload the toggle with the updated state
                loadToggleForPunchlistItem(punchlistId, isCompleted, true);
              } else {
                console.error("❌ [PUNCHLIST] Failed to update punchlist status:", data.error);
                // Revert the toggle to previous state
                loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
                // Show error notification
                if (window.showModal) {
                  window.showModal("error", "Update Failed", "Failed to update punchlist status");
                }
              }
            } catch (error) {
              console.error("❌ [PUNCHLIST] Error updating punchlist status:", error);
              // Revert the toggle to previous state
              loadToggleForPunchlistItem(punchlistId, !isCompleted, true);
              // Show error notification
              if (window.showModal) {
                window.showModal("error", "Update Failed", "Error updating punchlist status");
              }
            }
          }

          // Initialize punchlist functionality when component loads
          document.addEventListener("DOMContentLoaded", function () {
            console.log("🔔 [PUNCHLIST] Punchlist component loaded, initializing...");
            setTimeout(initializePunchlist, 100);
          });

          // Make initializePunchlist globally available for tab switching
          window.initializePunchlist = initializePunchlist;
        </script>
      </div>
    </div>
  </div>
</div>
