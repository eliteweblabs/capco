---
import {
  getFilteredUnifiedFormElements,
  isFormElementReadOnly,
} from "../../lib/project-form-config";
import { getColumnClasses } from "../../pages/api/global/global-classes";

import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import InlineAddressSearch from "../form/InlineAddressSearch.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";

interface Props {
  project?: any;
  currentUser?: any;
  isNewProject?: boolean;
  projectStatus?: number | null;
  globalInputClasses?: string;
  secondaryTextClasses?: string;
  primaryTextClasses?: string;
}

const {
  project = {},
  currentUser = {},
  isNewProject = true,
  projectStatus = null,
  globalInputClasses,
  secondaryTextClasses,
  primaryTextClasses,
} = Astro.props;

const currentRole = currentUser?.profile?.role;
const projectId = project?.id;
// Generate a temporary ID for new projects
const formId = isNewProject ? `${Date.now()}` : projectId || "";
// Get unified form elements based on user role and project status
const formElements = await getFilteredUnifiedFormElements(currentRole, isNewProject, projectStatus);

// Filter out only fields (not actions) for the step-by-step process
const fieldElements = formElements.filter(
  (element) => element.type === "field" || element.type === "button-group"
);
---

<div id="multi-step-form-container" class="w-full max-w-4xl mx-auto mb-12 px-8">
  <!-- Form -->
  <form
    id="multi-step-form"
    class="w-full"
    data-project-id={formId}
    data-is-new-project={isNewProject}
    data-current-role={currentRole}
    data-project-data={JSON.stringify(project || {})}
    autocomplete="off"
  >
    <!-- Step Container -->
    <div id="step-container" class="min-h-[400px]">
      <!-- Steps will be rendered here by JavaScript -->
    </div>

    <!-- Navigation Buttons -->
    <div class="flex gap-4 mt-8 justify-between">
      <Button
        id="prev-step-btn"
        variant="secondary"
        size="xl"
        icon="chevron-left"
        iconPosition="left"
        class="hidden"
      >
        Previous
      </Button>
      <div class="flex-1"></div>
      <Button
        id="next-step-btn"
        variant="primary"
        size="xl"
        icon="chevron-right"
        iconPosition="right"
      >
        Next
      </Button>
      <Button
        id="submit-step-btn"
        type="submit"
        variant="success"
        size="xl"
        icon="save"
        iconPosition="left"
        class="hidden"
      >
        Save Project
      </Button>
    </div>
  </form>
</div>

<script
  define:vars={{
    formElements: fieldElements,
    project,
    globalInputClasses,
    secondaryTextClasses,
    primaryTextClasses,
    currentRole,
    projectId: formId,
    isNewProject,
    projectStatus,
  }}
>
  // Multi-step form state
  let currentStepIndex = 0;
  const totalSteps = formElements.length;
  const formData = {};

  // Initialize form on DOMContentLoaded
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.getElementById("multi-step-form");
    const stepContainer = document.getElementById("step-container");
    const prevBtn = document.getElementById("prev-step-btn");
    const nextBtn = document.getElementById("next-step-btn");
    const submitBtn = document.getElementById("submit-step-btn");
    const progressBar = document.getElementById("progress-bar");
    const currentStepNumber = document.getElementById("current-step-number");
    const progressPercentage = document.getElementById("progress-percentage");

    if (!form || !stepContainer || !prevBtn || !nextBtn || !submitBtn) {
      console.error("[MULTI-STEP] Required elements not found");
      return;
    }

    // Store if address component has been initialized
    let addressComponentInitialized = false;

    // Listen for address selection events
    window.addEventListener("inline-address-select", (e) => {
      const { componentId, value, label } = e.detail;
      if (componentId === "multi-step-address") {
        console.log("[MULTI-STEP] Address selected:", label, value);
        formData["address"] = label; // Store the full address label
      }
    });

    // Render current step
    async function renderStep(stepIndex) {
      if (stepIndex < 0 || stepIndex >= totalSteps) return;

      const element = formElements[stepIndex];
      const isReadOnly = false; // For new projects, nothing is read-only

      // Clear step container
      stepContainer.innerHTML = "";

      // Create step wrapper
      const stepDiv = document.createElement("div");
      stepDiv.className = "step-content animate-fade-in";

      // Add step label/title
      const titleDiv = document.createElement("div");
      titleDiv.className = "mb-6";
      const title = document.createElement("h2");
      title.className = "text-2xl font-bold text-gray-900 dark:text-white mb-2";
      title.textContent = element.label;
      titleDiv.appendChild(title);

      // Add step counter
      const counter = document.createElement("p");
      counter.className = "text-sm text-gray-500 dark:text-gray-400";
      counter.textContent = `Question ${stepIndex + 1} of ${totalSteps}`;
      titleDiv.appendChild(counter);
      stepDiv.appendChild(titleDiv);

      // Render field based on type
      if (element.type === "field") {
        if (element.id === "address-input") {
          // Address field - use shared HTML creator
          const { createAddressSearchHTML } = await import("../../scripts/inline-address-search");
          const addressWrapper = createAddressSearchHTML({
            id: "multi-step-address",
            name: "address",
            placeholder: "Search for an address...",
            inputClasses: `${globalInputClasses} text-xl py-5 text-center`,
            value: formData["address"] || project?.address || "",
          });

          stepDiv.appendChild(addressWrapper);

          // Initialize address search functionality only once
          if (!addressComponentInitialized) {
            setTimeout(() => {
              import("../../scripts/inline-address-search").then((module) => {
                module.initializeAddressSearch({
                  id: "multi-step-address",
                  fetchApiEndpoint: "/api/google/places-autocomplete",
                  apiParams: {
                    types: "address",
                    components: "country:us",
                    locationBias: "circle:100@42.3601,-71.0589",
                  },
                  valueField: "description",
                  labelField: "description",
                  onSelect: (value, label, data) => {
                    formData["address"] = label;
                  },
                });
              });
            }, 100);
            addressComponentInitialized = true;
          }

          // Auto-focus the search input
          const searchInput = addressWrapper.querySelector("input[type='text']");
          if (searchInput) {
            setTimeout(() => searchInput.focus(), 150);
          }
        } else if (element.elementType === "text" || element.elementType === "number") {
          // Text/Number input
          const label = document.createElement("label");
          label.htmlFor = `step-${stepIndex}-${element.id}`;
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label + (element.required ? " *" : "");
          stepDiv.appendChild(label);

          const input = document.createElement("input");
          input.type = element.elementType === "number" ? "number" : "text";
          input.id = `step-${stepIndex}-${element.id}`;
          input.name = element.name;
          input.value = formData[element.name] || project?.[element.name] || element.value || "";
          input.className = `${globalInputClasses} text-lg`;
          input.placeholder = element.placeholder || "";
          input.required = element.required || false;
          if (element.min !== undefined) input.min = element.min;
          if (element.max !== undefined) input.max = element.max;
          if (element.step !== undefined) input.step = element.step;
          input.autocomplete = "off";

          // Auto-focus input
          setTimeout(() => input.focus(), 100);

          // Handle Enter key to go to next step
          input.addEventListener("keypress", (e) => {
            if ((e.key === "Enter" && !element.required) || (element.required && input.value)) {
              e.preventDefault();
              goToNextStep();
            }
          });

          stepDiv.appendChild(input);
        } else if (element.elementType === "textarea") {
          // Textarea
          const label = document.createElement("label");
          label.htmlFor = `step-${stepIndex}-${element.id}`;
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label;
          stepDiv.appendChild(label);

          const textarea = document.createElement("textarea");
          textarea.id = `step-${stepIndex}-${element.id}`;
          textarea.name = element.name;
          textarea.value = formData[element.name] || project?.[element.name] || element.value || "";
          textarea.className = `${globalInputClasses} text-lg`;
          textarea.placeholder = element.placeholder || "";
          textarea.rows = 4;

          // Auto-focus textarea
          setTimeout(() => textarea.focus(), 100);

          stepDiv.appendChild(textarea);
        } else if (element.elementType === "checkbox") {
          // Checkbox/Toggle
          const label = document.createElement("label");
          label.className = "inline-flex items-center cursor-pointer";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.id = `step-${stepIndex}-${element.id}`;
          input.name = element.name;
          input.checked =
            formData[element.name] ||
            project?.[element.name] === true ||
            project?.[element.name] === "true" ||
            project?.[element.name] === 1;
          input.className = "peer sr-only";

          const toggleDiv = document.createElement("div");
          toggleDiv.className = `peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-gray-100 after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-300 dark:border-gray-600 dark:peer-focus:ring-primary-800 rtl:peer-checked:after:-translate-x-full bg-gray-200 peer-checked:bg-primary-600 dark:bg-gray-700 dark:peer-checked:bg-primary-600`;

          const textSpan = document.createElement("span");
          textSpan.className = "ms-3 text-lg font-medium text-gray-900 dark:text-gray-300";
          textSpan.textContent = element.label;

          label.appendChild(input);
          label.appendChild(toggleDiv);
          label.appendChild(textSpan);
          stepDiv.appendChild(label);
        } else if (element.elementType === "component" && element.component === "UnitSlider") {
          // Unit slider - render as range input
          const label = document.createElement("label");
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label;
          stepDiv.appendChild(label);

          const sliderWrapper = document.createElement("div");
          sliderWrapper.id = `step-${stepIndex}-slider-wrapper`;
          sliderWrapper.className = "mb-4";
          stepDiv.appendChild(sliderWrapper);

          // We'll need to render UnitSlider here - for now create placeholder
          const sliderPlaceholder = document.createElement("div");
          sliderPlaceholder.id = `slider-placeholder-${stepIndex}`;
          sliderWrapper.appendChild(sliderPlaceholder);
        }
      } else if (element.type === "button-group") {
        // Button group
        const label = document.createElement("label");
        label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-4";
        label.textContent = element.label;
        stepDiv.appendChild(label);

        const buttonGroup = document.createElement("div");
        buttonGroup.className = "flex flex-wrap gap-3";
        buttonGroup.dataset.groupName = element.name;
        buttonGroup.dataset.groupType = element.groupType || "radio";

        // Parse selected values from project data or formData
        let selectedValues = [];
        const storedValue = formData[element.name] || project?.[element.name];
        if (storedValue) {
          if (Array.isArray(storedValue)) {
            selectedValues = storedValue;
          } else if (typeof storedValue === "string") {
            try {
              const parsed = JSON.parse(storedValue);
              selectedValues = Array.isArray(parsed) ? parsed : [storedValue];
            } catch {
              selectedValues = storedValue
                .split(",")
                .map((s) => s.trim())
                .filter((s) => s);
            }
          } else {
            selectedValues = [storedValue];
          }
        }

        element.options?.forEach((option) => {
          const optionValue = typeof option === "string" ? option : option.value;
          const optionLabel = typeof option === "string" ? option : option.label;
          const isSelected = selectedValues.includes(optionValue);

          const button = document.createElement("button");
          button.type = "button";
          button.className = `px-6 py-3 rounded-lg border-2 transition-all font-medium text-lg ${
            isSelected
              ? "bg-primary-600 text-white border-primary-600"
              : "bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-primary-500"
          }`;
          button.dataset.value = optionValue;
          button.dataset.selected = isSelected ? "true" : "false";
          button.textContent = optionLabel;

          // Click handler
          button.addEventListener("click", () => {
            const groupType = buttonGroup.dataset.groupType;
            const groupName = buttonGroup.dataset.groupName;

            if (groupType === "radio") {
              // Radio - deselect all others, select this one
              buttonGroup.querySelectorAll("button").forEach((btn) => {
                btn.classList.remove("bg-primary-600", "text-white", "border-primary-600");
                btn.classList.add(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                btn.dataset.selected = "false";
              });
              button.classList.add("bg-primary-600", "text-white", "border-primary-600");
              button.classList.remove(
                "bg-white",
                "dark:bg-gray-800",
                "text-gray-700",
                "dark:text-gray-300",
                "border-gray-300",
                "dark:border-gray-600"
              );
              button.dataset.selected = "true";
              formData[groupName] = optionValue;
            } else {
              // Multi-select - toggle selection
              const isCurrentlySelected = button.dataset.selected === "true";
              if (isCurrentlySelected) {
                button.classList.remove("bg-primary-600", "text-white", "border-primary-600");
                button.classList.add(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                button.dataset.selected = "false";
              } else {
                button.classList.add("bg-primary-600", "text-white", "border-primary-600");
                button.classList.remove(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                button.dataset.selected = "true";
              }

              // Update formData with all selected values
              const selectedButtons = Array.from(
                buttonGroup.querySelectorAll('button[data-selected="true"]')
              );
              formData[groupName] = selectedButtons.map((btn) => btn.dataset.value);
            }
          });

          buttonGroup.appendChild(button);
        });

        stepDiv.appendChild(buttonGroup);
      }

      stepContainer.appendChild(stepDiv);

      // Update progress
      updateProgress();

      // Update button visibility
      updateButtons();
    }

    // Update progress bar
    function updateProgress() {
      const progress = Math.round((currentStepIndex / totalSteps) * 100);
      if (progressBar) progressBar.style.width = `${progress}%`;
      if (currentStepNumber) currentStepNumber.textContent = currentStepIndex + 1;
      if (progressPercentage) progressPercentage.textContent = progress;

      // Show/hide progress bar based on current step
      const progressBarContainer = document.getElementById("multi-step-progress-bar-container");
      if (progressBarContainer) {
        if (currentStepIndex === 0) {
          progressBarContainer.classList.add("hidden");
        } else {
          progressBarContainer.classList.remove("hidden");
        }
      }
    }

    // Update button visibility
    function updateButtons() {
      if (currentStepIndex === 0) {
        prevBtn.classList.add("hidden");
      } else {
        prevBtn.classList.remove("hidden");
      }

      if (currentStepIndex === totalSteps - 1) {
        nextBtn.classList.add("hidden");
        submitBtn.classList.remove("hidden");
      } else {
        nextBtn.classList.remove("hidden");
        submitBtn.classList.add("hidden");
      }
    }

    // Save current step data
    function saveCurrentStepData() {
      const element = formElements[currentStepIndex];

      // Special handling for address field
      if (element.id === "address-input") {
        const hiddenInput = document.getElementById("multi-step-address-value");
        const searchInput = document.getElementById("multi-step-address-search-input");
        if (hiddenInput && hiddenInput.value) {
          formData[element.name] = hiddenInput.value;
        } else if (searchInput && searchInput.value) {
          // Fallback to search input if hidden input is empty
          formData[element.name] = searchInput.value;
        }
        return;
      }

      const input = document.querySelector(`[name="${element.name}"]`);

      if (input) {
        if (input.type === "checkbox") {
          formData[element.name] = input.checked;
        } else {
          formData[element.name] = input.value;
        }
      }

      // Handle button groups
      if (element.type === "button-group") {
        const buttonGroup = document.querySelector(`[data-group-name="${element.name}"]`);
        if (buttonGroup) {
          const groupType = buttonGroup.dataset.groupType;
          if (groupType === "radio") {
            const selectedButton = buttonGroup.querySelector('button[data-selected="true"]');
            formData[element.name] = selectedButton ? selectedButton.dataset.value : "";
          } else {
            const selectedButtons = Array.from(
              buttonGroup.querySelectorAll('button[data-selected="true"]')
            );
            formData[element.name] = selectedButtons.map((btn) => btn.dataset.value);
          }
        }
      }
    }

    // Go to next step
    function goToNextStep() {
      const element = formElements[currentStepIndex];

      // Special validation for address field
      if (element.id === "address-input" && element.required) {
        const hiddenInput = document.getElementById("multi-step-address-value");
        const searchInput = document.getElementById("multi-step-address-search-input");
        const hasValue = (hiddenInput && hiddenInput.value) || (searchInput && searchInput.value);

        if (!hasValue) {
          if (window.showNotice) {
            window.showNotice("error", "Required Field", "Please select an address to continue.");
          }
          if (searchInput) searchInput.focus();
          return;
        }
      }

      // Validate required field
      if (element.required && element.type === "field" && element.id !== "address-input") {
        const input = document.querySelector(`[name="${element.name}"]`);
        if (input && !input.value) {
          if (window.showNotice) {
            window.showNotice("error", "Required Field", "Please fill out this field to continue.");
          }
          input.focus();
          return;
        }
      }

      // Save data
      saveCurrentStepData();

      // Go to next step
      if (currentStepIndex < totalSteps - 1) {
        currentStepIndex++;
        renderStep(currentStepIndex);
      }
    }

    // Go to previous step
    function goToPreviousStep() {
      // Save data
      saveCurrentStepData();

      // Go to previous step
      if (currentStepIndex > 0) {
        currentStepIndex--;
        renderStep(currentStepIndex);
      }
    }

    // Button event listeners
    nextBtn.addEventListener("click", (e) => {
      e.preventDefault();
      goToNextStep();
    });

    prevBtn.addEventListener("click", (e) => {
      e.preventDefault();
      goToPreviousStep();
    });

    // Form submission
    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      // Save current step data
      saveCurrentStepData();

      console.log("üìù [MULTI-STEP] Form submission started", formData);

      try {
        submitBtn.disabled = true;
        const loaderIcon =
          window.SimpleIcons?.getIcon("loader-2", {
            className: "animate-spin mr-1 inline-block w-4 h-4",
          }) || "";
        submitBtn.innerHTML = `${loaderIcon}Saving...`;

        if (window.showNotice) {
          window.showNotice("info", "Saving Project", "Creating your project...", 10000);
        }

        // Make API call
        const response = await fetch("/api/projects/upsert", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(formData),
        });

        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const textResponse = await response.text();
          console.error("üìù [MULTI-STEP] Non-JSON response received:", {
            status: response.status,
            contentType,
            body: textResponse.substring(0, 200) + "...",
          });
          throw new Error(
            `API returned non-JSON response (${response.status}): ${textResponse.substring(0, 100)}`
          );
        }

        const result = await response.json();

        if (result.success) {
          // Update status to trigger notifications
          try {
            const project = result.project;
            const nextStatus = 10;

            window.updateStatus(project, nextStatus, undefined).then((data) => {
              if (data.success) {
                if (
                  window.handleNewStatusModalAndEmail &&
                  typeof window.handleNewStatusModalAndEmail === "function"
                ) {
                  window.handleNewStatusModalAndEmail(data, "MULTI-STEP-FORM");
                }
                // Redirect to project page
                window.location.href = `/project/${data.project.id}?status=discussion`;
              } else {
                console.error("‚ùå [MULTI-STEP] Failed to update status:", data.error);
                // Fallback: redirect even if status update failed
                window.location.href = `/project/${project.id}`;
              }
            });
          } catch (statusError) {
            console.error("üìù [MULTI-STEP] Status update failed:", statusError);
            window.location.reload();
          }
        } else {
          console.error("üìù [MULTI-STEP] API returned success: false");
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("üìù [MULTI-STEP] Error saving project:", error);
        if (window.showNotice) {
          window.showNotice(
            "error",
            "Save Failed",
            error instanceof Error ? error.message : "Failed to save project"
          );
        }
      } finally {
        // Reset button state
        submitBtn.disabled = false;
        const saveIcon =
          window.SimpleIcons?.getIcon("save", {
            className: "mr-1 inline-block w-4 h-4",
          }) || "";
        submitBtn.innerHTML = `${saveIcon}<span class='hidden md:block'>Save Project</span><span class='block md:hidden'>Save</span>`;
      }
    });

    // Initialize first step
    renderStep(0);
  });
</script>

<style>
  .animate-fade-in {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Step content styling */
  .step-content {
    min-height: 300px;
  }
</style>
