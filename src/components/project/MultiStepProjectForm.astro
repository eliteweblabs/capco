---
import {
  getFilteredUnifiedFormElements,
  isFormElementReadOnly,
} from "../../lib/project-form-config";
import { getColumnClasses } from "../../pages/api/global/global-classes";

import ToggleButton from "../form/ToggleButton.astro";
import UnitSlider from "../form/UnitSlider.astro";
import SlotMachineModal from "../form/SlotMachineModal.astro";
import InlineAddressSearch from "../form/InlineAddressSearch.astro";
import IsNewOrExistingClient from "./IsNewOrExistingClient.astro";
import Button from "../common/Button.astro";
import SimpleIcon from "../common/SimpleIcon.astro";

interface Props {
  project?: any;
  currentUser?: any;
  isNewProject?: boolean;
  projectStatus?: number | null;
  globalInputClasses?: string;
  secondaryTextClasses?: string;
  primaryTextClasses?: string;
}

const {
  project = {},
  currentUser = {},
  isNewProject = true,
  projectStatus = null,
  globalInputClasses,
  secondaryTextClasses,
  primaryTextClasses,
} = Astro.props;

const currentRole = currentUser?.profile?.role;
const projectId = project?.id;
// Generate a temporary ID for new projects
const formId = isNewProject ? `${Date.now()}` : projectId || "";
// Get unified form elements based on user role and project status
const formElements = await getFilteredUnifiedFormElements(currentRole, isNewProject, projectStatus);

// Filter out only fields (not actions) for the step-by-step process
const fieldElements = formElements.filter(
  (element) => element.type === "field" || element.type === "button-group"
);
---

<div id="multi-step-form-container" class="w-full max-w-4xl mx-auto mb-12 px-8">
  <!-- Progress Bar -->
  <div class="mb-8">
    <div class="flex items-center justify-between mb-2">
      <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
        Step <span id="current-step-number">1</span> of <span id="total-steps"
          >{fieldElements.length}</span
        >
      </span>
      <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
        <span id="progress-percentage">0</span>% Complete
      </span>
    </div>
    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
      <div
        id="progress-bar"
        class="bg-primary-600 h-2.5 rounded-full transition-all duration-300"
        style="width: 0%"
      >
      </div>
    </div>
  </div>

  <!-- Form -->
  <form
    id="multi-step-form"
    class="w-full"
    data-project-id={formId}
    data-is-new-project={isNewProject}
    data-current-role={currentRole}
    data-project-data={JSON.stringify(project || {})}
    autocomplete="off"
  >
    <!-- Step Container -->
    <div id="step-container" class="min-h-[400px]">
      <!-- Steps will be rendered here by JavaScript -->
    </div>

    <!-- Navigation Buttons -->
    <div class="flex gap-4 mt-8 justify-between">
      <Button
        id="prev-step-btn"
        variant="secondary"
        size="xl"
        icon="chevron-left"
        iconPosition="left"
        class="hidden"
      >
        Previous
      </Button>
      <div class="flex-1"></div>
      <Button
        id="next-step-btn"
        variant="primary"
        size="xl"
        icon="chevron-right"
        iconPosition="right"
      >
        Next
      </Button>
      <Button
        id="submit-step-btn"
        type="submit"
        variant="success"
        size="xl"
        icon="save"
        iconPosition="left"
        class="hidden"
      >
        Save Project
      </Button>
    </div>
  </form>
</div>

<script
  define:vars={{
    formElements: fieldElements,
    project,
    globalInputClasses,
    secondaryTextClasses,
    primaryTextClasses,
    currentRole,
    projectId: formId,
    isNewProject,
    projectStatus,
  }}
>
  // Multi-step form state
  let currentStepIndex = 0;
  const totalSteps = formElements.length;
  const formData = {};

  // Initialize form on DOMContentLoaded
  document.addEventListener("DOMContentLoaded", function () {
    const form = document.getElementById("multi-step-form");
    const stepContainer = document.getElementById("step-container");
    const prevBtn = document.getElementById("prev-step-btn");
    const nextBtn = document.getElementById("next-step-btn");
    const submitBtn = document.getElementById("submit-step-btn");
    const progressBar = document.getElementById("progress-bar");
    const currentStepNumber = document.getElementById("current-step-number");
    const progressPercentage = document.getElementById("progress-percentage");

    if (!form || !stepContainer || !prevBtn || !nextBtn || !submitBtn) {
      console.error("[MULTI-STEP] Required elements not found");
      return;
    }

    // Store if address component has been initialized
    let addressComponentInitialized = false;

    // Listen for address selection events
    window.addEventListener("inline-address-select", (e) => {
      const { componentId, value, label } = e.detail;
      if (componentId === "multi-step-address") {
        console.log("[MULTI-STEP] Address selected:", label, value);
        formData["address"] = label; // Store the full address label
      }
    });

    // Render current step
    function renderStep(stepIndex) {
      if (stepIndex < 0 || stepIndex >= totalSteps) return;

      const element = formElements[stepIndex];
      const isReadOnly = false; // For new projects, nothing is read-only

      // Clear step container
      stepContainer.innerHTML = "";

      // Create step wrapper
      const stepDiv = document.createElement("div");
      stepDiv.className = "step-content animate-fade-in";

      // Add step label/title
      const titleDiv = document.createElement("div");
      titleDiv.className = "mb-6";
      const title = document.createElement("h2");
      title.className = "text-2xl font-bold text-gray-900 dark:text-white mb-2";
      title.textContent = element.label;
      titleDiv.appendChild(title);

      // Add step counter
      const counter = document.createElement("p");
      counter.className = "text-sm text-gray-500 dark:text-gray-400";
      counter.textContent = `Question ${stepIndex + 1} of ${totalSteps}`;
      titleDiv.appendChild(counter);
      stepDiv.appendChild(titleDiv);

      // Render field based on type
      if (element.type === "field") {
        if (element.id === "address-input") {
          // Address field - create InlineAddressSearch HTML dynamically
          const addressWrapper = document.createElement("div");
          addressWrapper.className = "inline-address-search-wrapper";

          // Hidden input
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.id = "multi-step-address-value";
          hiddenInput.name = "address";
          hiddenInput.value = formData["address"] || project?.address || "";
          addressWrapper.appendChild(hiddenInput);

          // Search input container
          const searchContainer = document.createElement("div");
          searchContainer.className = "relative mb-4";

          const searchInput = document.createElement("input");
          searchInput.type = "text";
          searchInput.id = "multi-step-address-search-input";
          searchInput.placeholder = "Search for an address...";
          searchInput.autocomplete = "off";
          searchInput.className = `${globalInputClasses} text-xl py-5 text-center`;
          searchInput.value = formData["address"] || project?.address || "";
          searchContainer.appendChild(searchInput);

          // Search icon button
          const searchButton = document.createElement("button");
          searchButton.type = "button";
          searchButton.className = "absolute right-2 top-1/2 -translate-y-1/2 transform p-1.5 text-gray-400 transition-colors duration-200 hover:text-gray-600 dark:hover:text-gray-300";
          searchButton.title = "Search for address";
          searchButton.innerHTML = `<svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>`;
          searchContainer.appendChild(searchButton);

          addressWrapper.appendChild(searchContainer);

          // Results container
          const resultsContainer = document.createElement("div");
          resultsContainer.className = "inline-address-results-container relative mb-4 min-h-48 overflow-hidden rounded-lg border-2 border-gray-200 dark:border-gray-600 color-background";
          resultsContainer.style.cssText = "position: relative; min-height: 12rem; max-height: 24rem;";

          const resultsList = document.createElement("ul");
          resultsList.id = "multi-step-address-results-list";
          resultsList.className = "absolute inset-0 overflow-y-auto transition-all duration-300 ease-out";
          resultsList.style.cssText = "height: 100%; min-height: 12rem; position: absolute; top: 0; left: 0; right: 0; bottom: 0;";
          resultsContainer.appendChild(resultsList);

          // Empty state
          const emptyState = document.createElement("div");
          emptyState.id = "multi-step-address-empty-state";
          emptyState.className = "absolute inset-0 flex items-center justify-center text-gray-500 dark:text-gray-400";
          emptyState.innerHTML = `<div class="text-center"><p class="text-sm">Type to search addresses...</p></div>`;
          resultsContainer.appendChild(emptyState);

          addressWrapper.appendChild(resultsContainer);
          stepDiv.appendChild(addressWrapper);

          // Initialize address search functionality only once
          if (!addressComponentInitialized) {
            setTimeout(() => initializeAddressSearch(), 100);
            addressComponentInitialized = true;
          }

          // Auto-focus the search input
          setTimeout(() => searchInput.focus(), 150);
        } else if (element.elementType === "text" || element.elementType === "number") {
          // Text/Number input
          const label = document.createElement("label");
          label.htmlFor = `step-${stepIndex}-${element.id}`;
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label + (element.required ? " *" : "");
          stepDiv.appendChild(label);

          const input = document.createElement("input");
          input.type = element.elementType === "number" ? "number" : "text";
          input.id = `step-${stepIndex}-${element.id}`;
          input.name = element.name;
          input.value = formData[element.name] || project?.[element.name] || element.value || "";
          input.className = `${globalInputClasses} text-lg`;
          input.placeholder = element.placeholder || "";
          input.required = element.required || false;
          if (element.min !== undefined) input.min = element.min;
          if (element.max !== undefined) input.max = element.max;
          if (element.step !== undefined) input.step = element.step;
          input.autocomplete = "off";

          // Auto-focus input
          setTimeout(() => input.focus(), 100);

          // Handle Enter key to go to next step
          input.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !element.required || (element.required && input.value)) {
              e.preventDefault();
              goToNextStep();
            }
          });

          stepDiv.appendChild(input);
        } else if (element.elementType === "textarea") {
          // Textarea
          const label = document.createElement("label");
          label.htmlFor = `step-${stepIndex}-${element.id}`;
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label;
          stepDiv.appendChild(label);

          const textarea = document.createElement("textarea");
          textarea.id = `step-${stepIndex}-${element.id}`;
          textarea.name = element.name;
          textarea.value = formData[element.name] || project?.[element.name] || element.value || "";
          textarea.className = `${globalInputClasses} text-lg`;
          textarea.placeholder = element.placeholder || "";
          textarea.rows = 4;

          // Auto-focus textarea
          setTimeout(() => textarea.focus(), 100);

          stepDiv.appendChild(textarea);
        } else if (element.elementType === "checkbox") {
          // Checkbox/Toggle
          const label = document.createElement("label");
          label.className = "inline-flex items-center cursor-pointer";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.id = `step-${stepIndex}-${element.id}`;
          input.name = element.name;
          input.checked =
            formData[element.name] ||
            project?.[element.name] === true ||
            project?.[element.name] === "true" ||
            project?.[element.name] === 1;
          input.className = "peer sr-only";

          const toggleDiv = document.createElement("div");
          toggleDiv.className = `peer relative h-6 w-11 rounded-full after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:bg-gray-100 after:transition-all after:content-[''] peer-checked:after:translate-x-full peer-checked:after:border-white peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-300 dark:border-gray-600 dark:peer-focus:ring-primary-800 rtl:peer-checked:after:-translate-x-full bg-gray-200 peer-checked:bg-primary-600 dark:bg-gray-700 dark:peer-checked:bg-primary-600`;

          const textSpan = document.createElement("span");
          textSpan.className = "ms-3 text-lg font-medium text-gray-900 dark:text-gray-300";
          textSpan.textContent = element.label;

          label.appendChild(input);
          label.appendChild(toggleDiv);
          label.appendChild(textSpan);
          stepDiv.appendChild(label);
        } else if (element.elementType === "component" && element.component === "UnitSlider") {
          // Unit slider - render as range input
          const label = document.createElement("label");
          label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3";
          label.textContent = element.label;
          stepDiv.appendChild(label);

          const sliderWrapper = document.createElement("div");
          sliderWrapper.id = `step-${stepIndex}-slider-wrapper`;
          sliderWrapper.className = "mb-4";
          stepDiv.appendChild(sliderWrapper);

          // We'll need to render UnitSlider here - for now create placeholder
          const sliderPlaceholder = document.createElement("div");
          sliderPlaceholder.id = `slider-placeholder-${stepIndex}`;
          sliderWrapper.appendChild(sliderPlaceholder);
        }
      } else if (element.type === "button-group") {
        // Button group
        const label = document.createElement("label");
        label.className = "block text-lg font-medium text-gray-700 dark:text-gray-300 mb-4";
        label.textContent = element.label;
        stepDiv.appendChild(label);

        const buttonGroup = document.createElement("div");
        buttonGroup.className = "flex flex-wrap gap-3";
        buttonGroup.dataset.groupName = element.name;
        buttonGroup.dataset.groupType = element.groupType || "radio";

        // Parse selected values from project data or formData
        let selectedValues = [];
        const storedValue = formData[element.name] || project?.[element.name];
        if (storedValue) {
          if (Array.isArray(storedValue)) {
            selectedValues = storedValue;
          } else if (typeof storedValue === "string") {
            try {
              const parsed = JSON.parse(storedValue);
              selectedValues = Array.isArray(parsed) ? parsed : [storedValue];
            } catch {
              selectedValues = storedValue.split(",").map((s) => s.trim()).filter((s) => s);
            }
          } else {
            selectedValues = [storedValue];
          }
        }

        element.options?.forEach((option) => {
          const optionValue = typeof option === "string" ? option : option.value;
          const optionLabel = typeof option === "string" ? option : option.label;
          const isSelected = selectedValues.includes(optionValue);

          const button = document.createElement("button");
          button.type = "button";
          button.className = `px-6 py-3 rounded-lg border-2 transition-all font-medium text-lg ${
            isSelected
              ? "bg-primary-600 text-white border-primary-600"
              : "bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-primary-500"
          }`;
          button.dataset.value = optionValue;
          button.dataset.selected = isSelected ? "true" : "false";
          button.textContent = optionLabel;

          // Click handler
          button.addEventListener("click", () => {
            const groupType = buttonGroup.dataset.groupType;
            const groupName = buttonGroup.dataset.groupName;

            if (groupType === "radio") {
              // Radio - deselect all others, select this one
              buttonGroup.querySelectorAll("button").forEach((btn) => {
                btn.classList.remove(
                  "bg-primary-600",
                  "text-white",
                  "border-primary-600"
                );
                btn.classList.add(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                btn.dataset.selected = "false";
              });
              button.classList.add("bg-primary-600", "text-white", "border-primary-600");
              button.classList.remove(
                "bg-white",
                "dark:bg-gray-800",
                "text-gray-700",
                "dark:text-gray-300",
                "border-gray-300",
                "dark:border-gray-600"
              );
              button.dataset.selected = "true";
              formData[groupName] = optionValue;
            } else {
              // Multi-select - toggle selection
              const isCurrentlySelected = button.dataset.selected === "true";
              if (isCurrentlySelected) {
                button.classList.remove(
                  "bg-primary-600",
                  "text-white",
                  "border-primary-600"
                );
                button.classList.add(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                button.dataset.selected = "false";
              } else {
                button.classList.add("bg-primary-600", "text-white", "border-primary-600");
                button.classList.remove(
                  "bg-white",
                  "dark:bg-gray-800",
                  "text-gray-700",
                  "dark:text-gray-300",
                  "border-gray-300",
                  "dark:border-gray-600"
                );
                button.dataset.selected = "true";
              }

              // Update formData with all selected values
              const selectedButtons = Array.from(
                buttonGroup.querySelectorAll('button[data-selected="true"]')
              );
              formData[groupName] = selectedButtons.map((btn) => btn.dataset.value);
            }
          });

          buttonGroup.appendChild(button);
        });

        stepDiv.appendChild(buttonGroup);
      }

      stepContainer.appendChild(stepDiv);

      // Update progress
      updateProgress();

      // Update button visibility
      updateButtons();
    }

    // Update progress bar
    function updateProgress() {
      const progress = Math.round((currentStepIndex / totalSteps) * 100);
      if (progressBar) progressBar.style.width = `${progress}%`;
      if (currentStepNumber) currentStepNumber.textContent = currentStepIndex + 1;
      if (progressPercentage) progressPercentage.textContent = progress;
    }

    // Update button visibility
    function updateButtons() {
      if (currentStepIndex === 0) {
        prevBtn.classList.add("hidden");
      } else {
        prevBtn.classList.remove("hidden");
      }

      if (currentStepIndex === totalSteps - 1) {
        nextBtn.classList.add("hidden");
        submitBtn.classList.remove("hidden");
      } else {
        nextBtn.classList.remove("hidden");
        submitBtn.classList.add("hidden");
      }
    }

    // Save current step data
    function saveCurrentStepData() {
      const element = formElements[currentStepIndex];

      // Special handling for address field
      if (element.id === "address-input") {
        const hiddenInput = document.getElementById("multi-step-address-value");
        const searchInput = document.getElementById("multi-step-address-search-input");
        if (hiddenInput && hiddenInput.value) {
          formData[element.name] = hiddenInput.value;
        } else if (searchInput && searchInput.value) {
          // Fallback to search input if hidden input is empty
          formData[element.name] = searchInput.value;
        }
        return;
      }

      const input = document.querySelector(`[name="${element.name}"]`);

      if (input) {
        if (input.type === "checkbox") {
          formData[element.name] = input.checked;
        } else {
          formData[element.name] = input.value;
        }
      }

      // Handle button groups
      if (element.type === "button-group") {
        const buttonGroup = document.querySelector(`[data-group-name="${element.name}"]`);
        if (buttonGroup) {
          const groupType = buttonGroup.dataset.groupType;
          if (groupType === "radio") {
            const selectedButton = buttonGroup.querySelector('button[data-selected="true"]');
            formData[element.name] = selectedButton ? selectedButton.dataset.value : "";
          } else {
            const selectedButtons = Array.from(
              buttonGroup.querySelectorAll('button[data-selected="true"]')
            );
            formData[element.name] = selectedButtons.map((btn) => btn.dataset.value);
          }
        }
      }
    }

    // Go to next step
    function goToNextStep() {
      const element = formElements[currentStepIndex];

      // Special validation for address field
      if (element.id === "address-input" && element.required) {
        const hiddenInput = document.getElementById("multi-step-address-value");
        const searchInput = document.getElementById("multi-step-address-search-input");
        const hasValue = (hiddenInput && hiddenInput.value) || (searchInput && searchInput.value);

        if (!hasValue) {
          if (window.showNotice) {
            window.showNotice("error", "Required Field", "Please select an address to continue.");
          }
          if (searchInput) searchInput.focus();
          return;
        }
      }

      // Validate required field
      if (element.required && element.type === "field" && element.id !== "address-input") {
        const input = document.querySelector(`[name="${element.name}"]`);
        if (input && !input.value) {
          if (window.showNotice) {
            window.showNotice("error", "Required Field", "Please fill out this field to continue.");
          }
          input.focus();
          return;
        }
      }

      // Save data
      saveCurrentStepData();

      // Go to next step
      if (currentStepIndex < totalSteps - 1) {
        currentStepIndex++;
        renderStep(currentStepIndex);
      }
    }

    // Go to previous step
    function goToPreviousStep() {
      // Save data
      saveCurrentStepData();

      // Go to previous step
      if (currentStepIndex > 0) {
        currentStepIndex--;
        renderStep(currentStepIndex);
      }
    }

    // Button event listeners
    nextBtn.addEventListener("click", (e) => {
      e.preventDefault();
      goToNextStep();
    });

    prevBtn.addEventListener("click", (e) => {
      e.preventDefault();
      goToPreviousStep();
    });

    // Form submission
    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      // Save current step data
      saveCurrentStepData();

      console.log("ðŸ“ [MULTI-STEP] Form submission started", formData);

      try {
        submitBtn.disabled = true;
        const loaderIcon =
          window.SimpleIcons?.getIcon("loader-2", {
            className: "animate-spin mr-1 inline-block w-4 h-4",
          }) || "";
        submitBtn.innerHTML = `${loaderIcon}Saving...`;

        if (window.showNotice) {
          window.showNotice("info", "Saving Project", "Creating your project...", 10000);
        }

        // Make API call
        const response = await fetch("/api/projects/upsert", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(formData),
        });

        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          const textResponse = await response.text();
          console.error("ðŸ“ [MULTI-STEP] Non-JSON response received:", {
            status: response.status,
            contentType,
            body: textResponse.substring(0, 200) + "...",
          });
          throw new Error(
            `API returned non-JSON response (${response.status}): ${textResponse.substring(0, 100)}`
          );
        }

        const result = await response.json();

        if (result.success) {
          // Update status to trigger notifications
          try {
            const project = result.project;
            const nextStatus = 10;

            window.updateStatus(project, nextStatus, undefined).then((data) => {
              if (data.success) {
                if (
                  window.handleNewStatusModalAndEmail &&
                  typeof window.handleNewStatusModalAndEmail === "function"
                ) {
                  window.handleNewStatusModalAndEmail(data, "MULTI-STEP-FORM");
                }
                // Redirect to project page
                window.location.href = `/project/${data.project.id}?status=discussion`;
              } else {
                console.error("âŒ [MULTI-STEP] Failed to update status:", data.error);
                // Fallback: redirect even if status update failed
                window.location.href = `/project/${project.id}`;
              }
            });
          } catch (statusError) {
            console.error("ðŸ“ [MULTI-STEP] Status update failed:", statusError);
            window.location.reload();
          }
        } else {
          console.error("ðŸ“ [MULTI-STEP] API returned success: false");
          throw new Error(result.error || "Failed to save project");
        }
      } catch (error) {
        console.error("ðŸ“ [MULTI-STEP] Error saving project:", error);
        if (window.showNotice) {
          window.showNotice(
            "error",
            "Save Failed",
            error instanceof Error ? error.message : "Failed to save project"
          );
        }
      } finally {
        // Reset button state
        submitBtn.disabled = false;
        const saveIcon =
          window.SimpleIcons?.getIcon("save", {
            className: "mr-1 inline-block w-4 h-4",
          }) || "";
        submitBtn.innerHTML = `${saveIcon}Save Project`;
      }
    });

    // Initialize address search functionality
    function initializeAddressSearch() {
      const searchInput = document.getElementById("multi-step-address-search-input");
      const resultsList = document.getElementById("multi-step-address-results-list");
      const hiddenInput = document.getElementById("multi-step-address-value");
      const emptyState = document.getElementById("multi-step-address-empty-state");

      if (!searchInput || !resultsList || !hiddenInput || !emptyState) {
        console.error("[MULTI-STEP] Address search elements not found");
        return;
      }

      let searchTimeout;
      let selectedIndex = -1;

      // Helper function to create result element
      function createResultElement(result, index, isSelected = false) {
        const li = document.createElement("li");
        li.className = `inline-address-result-item cursor-pointer transition-all duration-200 p-3 hover:bg-gray-100 dark:hover:bg-gray-800 ${
          isSelected
            ? "bg-primary-500 text-white hover:bg-primary-600"
            : "text-gray-900 dark:text-white"
        }`;
        li.style.cssText = "user-select: none; -webkit-user-select: none;";
        li.dataset.index = index;
        li.dataset.value = result.description || result.value || result.place_id || result.id;
        li.dataset.label = result.description || result.label;

        const textSpan = document.createElement("span");
        textSpan.className = "block";
        textSpan.textContent = result.description || result.label;

        li.appendChild(textSpan);
        return li;
      }

      // Helper function to populate results
      function populateResults(results) {
        resultsList.innerHTML = "";

        if (results.length > 0) {
          emptyState.classList.add("hidden");
          results.forEach((result, index) => {
            const li = createResultElement(result, index, index === selectedIndex);
            resultsList.appendChild(li);
          });
        } else {
          emptyState.classList.remove("hidden");
        }
      }

      // Handle search input
      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();

        // Clear previous timeout
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }

        // Clear results if query is empty
        if (query.length === 0) {
          resultsList.innerHTML = "";
          emptyState.classList.remove("hidden");
          selectedIndex = -1;
          return;
        }

        // Perform search after debounce
        if (query.length >= 2) {
          searchTimeout = setTimeout(async () => {
            try {
              console.log(`[MULTI-STEP] Searching for: ${query}`);

              // Build search URL with API params
              const searchParams = new URLSearchParams({
                input: query,
                types: "address",
                components: "country:us",
                locationBias: "circle:100@42.3601,-71.0589",
              });

              const response = await fetch(`/api/google/places-autocomplete?${searchParams}`, {
                credentials: "include",
              });

              if (!response.ok) {
                throw new Error(`Search failed: ${response.status}`);
              }

              const data = await response.json();
              console.log(`[MULTI-STEP] Search results:`, data);

              // Handle different data formats
              let resultsArray = [];
              if (Array.isArray(data)) {
                resultsArray = data;
              } else if (data && Array.isArray(data.predictions)) {
                resultsArray = data.predictions;
              } else if (data && Array.isArray(data.results)) {
                resultsArray = data.results;
              } else if (data && data.data && Array.isArray(data.data)) {
                resultsArray = data.data;
              }

              populateResults(resultsArray);
            } catch (error) {
              console.error(`[MULTI-STEP] Search error:`, error);
              resultsList.innerHTML = "";
              emptyState.classList.remove("hidden");
            }
          }, 300);
        }
      });

      // Handle click on result items
      resultsList.addEventListener("click", (e) => {
        const li = e.target.closest("li[data-index]");
        if (li) {
          const value = li.dataset.value;
          const label = li.dataset.label;

          console.log(`[MULTI-STEP] Selected: ${label} (${value})`);

          // Update hidden input
          hiddenInput.value = label;

          // Update search input to show selected value
          searchInput.value = label;

          // Store in formData
          formData["address"] = label;

          // Update selection styling
          const allItems = resultsList.querySelectorAll("li");
          allItems.forEach((item) => {
            item.classList.remove("bg-primary-500", "text-white");
            item.classList.add(
              "text-gray-900",
              "dark:text-white",
              "hover:bg-gray-100",
              "dark:hover:bg-gray-800"
            );
          });
          li.classList.add("bg-primary-500", "text-white");
          li.classList.remove(
            "text-gray-900",
            "dark:text-white",
            "hover:bg-gray-100",
            "dark:hover:bg-gray-800"
          );

          selectedIndex = parseInt(li.dataset.index);
        }
      });

      // Handle keyboard navigation
      searchInput.addEventListener("keydown", (e) => {
        const items = resultsList.querySelectorAll("li");
        const maxIndex = items.length - 1;

        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            if (maxIndex >= 0) {
              selectedIndex = Math.min(selectedIndex + 1, maxIndex);
              updateSelection(items);
              scrollToSelected(items[selectedIndex]);
            }
            break;

          case "ArrowUp":
            e.preventDefault();
            if (maxIndex >= 0) {
              selectedIndex = Math.max(selectedIndex - 1, 0);
              updateSelection(items);
              scrollToSelected(items[selectedIndex]);
            }
            break;

          case "Enter":
            e.preventDefault();
            if (selectedIndex >= 0 && selectedIndex <= maxIndex) {
              items[selectedIndex].click();
            }
            break;
        }
      });

      // Update selection styling
      function updateSelection(items) {
        items.forEach((item, index) => {
          if (index === selectedIndex) {
            item.classList.add("bg-primary-500", "text-white");
            item.classList.remove(
              "text-gray-900",
              "dark:text-white",
              "hover:bg-gray-100",
              "dark:hover:bg-gray-800"
            );
          } else {
            item.classList.remove("bg-primary-500", "text-white");
            item.classList.add(
              "text-gray-900",
              "dark:text-white",
              "hover:bg-gray-100",
              "dark:hover:bg-gray-800"
            );
          }
        });
      }

      // Scroll to selected item
      function scrollToSelected(item) {
        if (item) {
          item.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }
    }

    // Initialize first step
    renderStep(0);
  });
</script>

<style>
  .animate-fade-in {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Step content styling */
  .step-content {
    min-height: 300px;
  }
</style>
