---
import SimpleIcon from "../common/SimpleIcon.astro";
import Button from "../common/Button.astro";

interface Props {
  id?: string;
  width?: number;
  height?: number;
  required?: boolean;
  currentUser?: any;
  project: any;
  statusData?: any;
}
const {
  id = "signature-canvas",
  width = 400,
  height = 200,
  required = false,
  currentUser,
  project,
  statusData,
} = Astro.props;

const newStatus = 50;
---

<div class="">
  <div class="digital-signature-container mb-6">
    <label class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
      Digital Signature {required && <span class="text-red-500">*</span>}
    </label>

    <div class="signature-container relative" data-max-width={width} data-max-height={height}>
      <!-- Canvas for signature -->
      <canvas
        {id}
        class="signature-canvas block w-full cursor-crosshair rounded-full border-2 border-dashed border-gray-300 bg-gray-100"
        data-max-width={width}
        data-max-height={height}
        data-aspect-ratio={width / height}
      >
        <!-- Placeholder text (shows when empty) -->
      </canvas>

      <div
        class="signature-placeholder pointer-events-none absolute inset-0 flex items-center justify-center"
      >
        <span class="text-sm font-medium text-gray-400 dark:text-gray-500"> Sign here...</span>
      </div>
      <!-- Signature controls -->
      <div class="mt-3 flex justify-end gap-2">
        <button
          type="button"
          class="signature-clear rounded bg-red-500 px-3 py-1 text-xs text-white transition-colors hover:bg-red-600"
          data-signature-id={id}
        >
          <SimpleIcon name="trash-2" class="mr-1" />
          Clear
        </button>
      </div>

      <!-- Hidden input to store signature data -->
      <input type="hidden" id={`${id}-data`} name={`${id}-data`} class="signature-data" />

      <!-- Signature status -->
      <div class="signature-status mt-2 text-sm">
        <span class="signature-empty text-gray-500"></span>
      </div>

      <!-- Agreement button -->
      <div class="mt-4">
        <p class="mt-2 text-center text-xs text-gray-500 dark:text-gray-400">
          Please sign above before agreeing to the contract terms
        </p>
      </div>
    </div>
    <Button
      type="button"
      id="agree-contract-btn"
      variant="success"
      size="xl"
      icon="check"
      iconPosition="right"
    >
      I Agree to the Contract Terms
    </Button>
  </div>

  <script define:vars={{ newStatus, project, currentUser, statusData }} is:inline>
    // Load SignaturePad from CDN
    let SignaturePad;
    const currentRole = currentUser?.profile?.role;
    const projectId = project?.id;

    async function loadSignaturePad() {
      if (SignaturePad) return SignaturePad;

      // Check if already loaded
      if (window.SignaturePad) {
        SignaturePad = window.SignaturePad;
        console.log("✅ SignaturePad already loaded");
        return SignaturePad;
      }

      try {
        const script = document.createElement("script");
        script.src =
          "https://cdn.jsdelivr.net/npm/signature_pad@4.1.7/dist/signature_pad.umd.min.js";
        script.async = true;
        script.defer = true;

        document.head.appendChild(script);

        // Wait for script to load
        return new Promise((resolve, reject) => {
          script.onload = () => {
            SignaturePad = window.SignaturePad;
            console.log("✅ SignaturePad loaded successfully");
            resolve(SignaturePad);
          };
          script.onerror = () => {
            console.error("❌ Failed to load SignaturePad script");
            reject(new Error("Failed to load SignaturePad"));
          };

          // Timeout after 10 seconds
          setTimeout(() => {
            if (!SignaturePad) {
              reject(new Error("SignaturePad loading timeout"));
            }
          }, 10000);
        });
      } catch (error) {
        console.error("❌ Failed to load SignaturePad:", error);
        return null;
      }
    }

    class DigitalSignatureManager {
      constructor() {
        this.signaturePads = new Map();
        this.initializeSignatures();
      }

      async initializeSignatures() {
        // Wait for SignaturePad to load
        await loadSignaturePad();

        if (!SignaturePad) {
          console.error("❌ SignaturePad not available");
          return;
        }

        const canvases = document.querySelectorAll(".signature-canvas");
        console.log("🎨 [DigitalSignature] Found", canvases.length, "signature canvases");

        canvases.forEach((canvas, index) => {
          console.log(
            "🎨 [DigitalSignature] Setting up canvas",
            index + 1,
            "of",
            canvases.length,
            ":",
            canvas.id
          );
          this.setupSignaturePad(canvas);
        });
      }

      initializeCanvas(canvas, maxWidth, maxHeight, aspectRatio, retryCount = 0) {
        const container = canvas.parentElement;
        if (!container) {
          console.warn("🎨 [DigitalSignature] No container found for canvas:", canvas.id);
          return;
        }

        // Wait for container to be properly sized
        const containerWidth = container.clientWidth || container.offsetWidth;

        // Ensure we have a valid container width, but limit retries to prevent infinite loops
        if ((!containerWidth || containerWidth < 100) && retryCount < 10) {
          console.warn(
            `🎨 [DigitalSignature] Container not ready (${containerWidth}px), retrying ${retryCount + 1}/10`
          );
          setTimeout(
            () => this.initializeCanvas(canvas, maxWidth, maxHeight, aspectRatio, retryCount + 1),
            100
          );
          return;
        }

        // If we've exceeded retry limit, use fallback dimensions
        if (retryCount >= 10) {
          console.warn("🎨 [DigitalSignature] Retry limit exceeded, using fallback dimensions");
        }

        // Calculate responsive dimensions with fallback for failed container detection
        const effectiveContainerWidth = containerWidth || 600; // Fallback to 600px if detection failed
        const availableWidth = Math.min(effectiveContainerWidth - 8, maxWidth); // -8 for border and padding
        const calculatedHeight = availableWidth / aspectRatio;
        const availableHeight = Math.min(calculatedHeight, maxHeight);

        // Ensure minimum dimensions
        const displayWidth = Math.max(availableWidth, 300); // Minimum 300px width
        const displayHeight = Math.max(availableHeight, 150); // Minimum 150px height

        console.log("📐 [DigitalSignature] Initializing canvas dimensions:", {
          containerWidth: containerWidth || "FAILED_TO_DETECT",
          effectiveContainerWidth,
          retryCount,
          maxWidth,
          maxHeight,
          aspectRatio,
          availableWidth,
          availableHeight,
          displayWidth,
          displayHeight,
        });

        // Set canvas internal dimensions (actual drawing surface)
        canvas.width = displayWidth;
        canvas.height = displayHeight;

        // Set canvas display dimensions (CSS size)
        canvas.style.width = displayWidth + "px";
        canvas.style.height = displayHeight + "px";

        const context = canvas.getContext("2d");
        if (context) {
          // Clear the canvas and set up proper scaling
          context.clearRect(0, 0, displayWidth, displayHeight);

          // Ensure crisp lines on high-DPI displays
          const pixelRatio = window.devicePixelRatio || 1;
          if (pixelRatio > 1) {
            canvas.width = displayWidth * pixelRatio;
            canvas.height = displayHeight * pixelRatio;
            context.scale(pixelRatio, pixelRatio);
            canvas.style.width = displayWidth + "px";
            canvas.style.height = displayHeight + "px";
            console.log("📐 [DigitalSignature] Applied high-DPI scaling:", pixelRatio);
          }
        }
      }

      setupSignaturePad(canvas) {
        const maxWidth = canvas.getAttribute("data-max-width") || "400";
        const maxHeight = canvas.getAttribute("data-max-height") || "200";
        const aspectRatio = canvas.getAttribute("data-aspect-ratio") || "2";

        console.log(
          "🎨 [DigitalSignature] Setting up responsive canvas:",
          canvas.id,
          "Max dimensions:",
          maxWidth,
          "x",
          maxHeight,
          "Aspect ratio:",
          aspectRatio
        );

        // Ensure canvas has proper dimensions before creating SignaturePad
        this.initializeCanvas(
          canvas,
          parseInt(maxWidth),
          parseInt(maxHeight),
          parseFloat(aspectRatio)
        );

        const signaturePad = new SignaturePad(canvas, {
          backgroundColor: "rgba(255, 255, 255, 0)",
          penColor: "rgb(0, 0, 0)",
          velocityFilterWeight: 0.7,
          minWidth: 0.5,
          maxWidth: 2.5,
          throttle: 16,
          minDistance: 5,
        });

        console.log("✅ [DigitalSignature] SignaturePad created for canvas:", canvas.id);

        const canvasId = canvas.id;
        this.signaturePads.set(canvasId, signaturePad);

        // Get related elements
        const container = canvas.closest(".digital-signature-container");
        const placeholder = container?.querySelector(".signature-placeholder") || null;
        const hiddenInput = container?.querySelector(".signature-data") || null;
        const clearBtn = container?.querySelector(".signature-clear") || null;
        // const saveBtn = container?.querySelector(".signature-save") || null;
        const statusEmpty = container?.querySelector(".signature-empty") || null;

        // Handle signature events
        signaturePad.addEventListener("beginStroke", () => {
          this.hideSignatureStatus(statusEmpty);
          if (placeholder) placeholder.style.display = "none";
        });

        signaturePad.addEventListener("endStroke", () => {
          this.updateSignatureData(signaturePad, hiddenInput, statusEmpty);
        });

        // Handle clear button
        console.log(
          "🎨 [DigitalSignature] Clear button found:",
          !!clearBtn,
          "for canvas:",
          canvas.id
        );
        if (clearBtn) {
          clearBtn.addEventListener("click", (e) => {
            console.log("🗑️ [DigitalSignature] Clear button clicked for canvas:", canvas.id);
            e.preventDefault();
            this.clearSignature(signaturePad, hiddenInput, placeholder, statusEmpty);
          });
        } else {
          console.warn("🎨 [DigitalSignature] Clear button not found for canvas:", canvas.id);
        }

        // Handle save button
        // saveBtn?.addEventListener("click", () => {
        //   this.saveSignature(signaturePad, hiddenInput, statusEmpty);
        // });

        // Handle canvas resize
        window.addEventListener("resize", () => {
          this.resizeCanvas(canvas, signaturePad);
        });

        // Use ResizeObserver for more responsive resizing
        if (window.ResizeObserver && container) {
          let resizeTimeout = null;
          const resizeObserver = new ResizeObserver(() => {
            // Debounce resize events to prevent loops
            if (resizeTimeout) {
              clearTimeout(resizeTimeout);
            }
            resizeTimeout = window.setTimeout(() => {
              try {
                this.resizeCanvas(canvas, signaturePad);
              } catch (error) {
                console.warn("ResizeObserver resize error:", error);
              }
            }, 16); // ~60fps
          });
          resizeObserver.observe(container);
        }

        // Initial resize
        this.resizeCanvas(canvas, signaturePad);

        // Setup agree button functionality
        this.setupAgreeButton(canvas.id, signaturePad);
      }

      setupAgreeButton(signatureId, pad) {
        const agreeBtn = document.getElementById("agree-contract-btn");
        if (!agreeBtn) return;

        // Enable/disable button based on signature status
        const updateButtonState = () => {
          if (pad && !pad.isEmpty()) {
            agreeBtn.disabled = false;
            agreeBtn.classList.remove("bg-gray-400", "cursor-not-allowed");
            agreeBtn.classList.add("bg-green-600", "hover:bg-green-700");
          } else {
            agreeBtn.disabled = true;
            agreeBtn.classList.add("bg-gray-400", "cursor-not-allowed");
            agreeBtn.classList.remove("bg-green-600", "hover:bg-green-700");
          }
        };

        // Update button state when signature changes
        pad.addEventListener("endStroke", updateButtonState);
        pad.addEventListener("clear", updateButtonState);

        // Handle agree button click
        agreeBtn.addEventListener("click", async () => {
          await this.handleAgreement(signatureId);
        });

        // Initial button state
        updateButtonState();
      }

      async handleAgreement(signatureId) {
        const agreeBtn = document.getElementById("agree-contract-btn");
        if (!agreeBtn) return;

        //  const notification = data.notificationData.client || data.notificationData.admin;
        if (window.showModal) {
          window.showModal(
            "info",
            "Generating Contract...",
            "Please wait while we generate a PDF copy of the contract for your records.",
            5000
          );
        }

        // Get signature data from the signature pad
        const signaturePad = this.signaturePads.get(signatureId);
        if (!signaturePad || signaturePad.isEmpty()) {
          console.error("❌ [DigitalSignature] No signature found");
          if (window.showModal) {
            window.showModal(
              "No Signature",
              "Please provide a signature before agreeing to the contract.",
              "error"
            );
          }
          return;
        }

        const signatureData = signaturePad.toDataURL("image/png");

        if (!project || !currentUser) {
          console.error("❌ [DigitalSignature] Missing project or user data");
          if (window.showModal) {
            window.showModal(
              "Error",
              "Unable to process agreement. Please refresh the page and try again.",
              "error"
            );
          }
          return;
        }

        // Set loading state
        const originalText = agreeBtn.innerHTML;
        agreeBtn.disabled = true;
        agreeBtn.innerHTML = `
          <svg class="animate-spin mr-2 inline h-5 w-5" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Processing Agreement...
        `;

        // right here we need to save the signature to the project database using the project ID in the proposal_signatures column
        // also save the timestamp to signedAt column
        const response = await fetch("/api/save-signature", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            project: project,
            signature: signatureData,
            signedAt: new Date().toISOString(),
          }),
        });

        const data = await response.json();

        if (response.ok && data.success) {
          console.log("✅ [DigitalSignature] Signature saved successfully");

          // Generate PDF with signature after successful signature save
          try {
            console.log("📄 [DigitalSignature] Generating contract PDF with signature...");

            const pdfResponse = await fetch("/api/pdf/generate", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                type: "contract",
                projectId: project.id,
                signature: signatureData,
                signedAt: new Date().toISOString(),
              }),
            });

            const pdfData = await pdfResponse.json();

            if (pdfResponse.ok && pdfData.success) {
              console.log(
                "✅ [DigitalSignature] Contract PDF generated successfully:",
                pdfData.contractUrl
              );
            } else {
              console.warn("⚠️ [DigitalSignature] PDF generation failed:", pdfData.error);
              // Don't fail the entire process if PDF generation fails
            }
          } catch (pdfError) {
            console.error("❌ [DigitalSignature] PDF generation error:", pdfError);
            // Don't fail the entire process if PDF generation fails
          }

          try {
            if (data.success) {
              console.log("✅ [DigitalSignature] Contract agreement processed successfully");

              // Update button to show success state
              agreeBtn.innerHTML = `
    <SimpleIcon name="check" class="mr-2 inline h-5 w-5" />
    Contract Agreed ✓
  `;
              agreeBtn.classList.remove("bg-green-600", "hover:bg-green-700");
              agreeBtn.classList.add("bg-green-500");

              // Call global updateStatus function to set status
              const nextStatus = 50;
              const statusResult = await window.updateStatus(
                project,
                nextStatus,
                statusData[nextStatus]
              );

              // Check if handleNewStatusModalAndEmail exists and is a function
              if (
                window.handleNewStatusModalAndEmail &&
                typeof window.handleNewStatusModalAndEmail === "function"
              ) {
                const notificationPromise = window.handleNewStatusModalAndEmail(
                  statusResult,
                  "PROJECT-FORM"
                );
                if (notificationPromise && typeof notificationPromise.then === "function") {
                  notificationPromise
                    .then(async (data) => {
                      newStatus = 55;
                      const data2 = await window.updateStatus(
                        project,
                        newStatus,
                        statusData[newStatus]
                      );
                      if (
                        window.handleNewStatusModalAndEmail &&
                        typeof window.handleNewStatusModalAndEmail === "function"
                      ) {
                        window.handleNewStatusModalAndEmail(data2, "DIGITAL-SIGNATURE");
                      }
                    })
                    .catch((error) => {
                      console.error("❌ [DigitalSignature] Error in notification chain:", error);
                    });
                } else {
                  console.warn(
                    "⚠️ [DigitalSignature] handleNewStatusModalAndEmail did not return a Promise"
                  );
                }
              } else {
                console.warn(
                  "⚠️ [DigitalSignature] handleNewStatusModalAndEmail function not available"
                );
              }
            } else {
              throw new Error(data.error || "Failed to process agreement");
            }
          } catch (error) {
            console.error("❌ [DigitalSignature] Error processing agreement:", error);

            // Show error message
            if (window.showModal) {
              window.showModal(
                "Agreement Failed",
                "There was an error processing your agreement. Please try again.",
                "error"
              );
            }

            // Reset button state
            agreeBtn.disabled = false;
            agreeBtn.innerHTML = originalText;
          }
        } else {
          throw new Error(data.error || "Failed to save signature");
        }
      }

      updateSignatureData(signaturePad, hiddenInput, statusEmpty) {
        if (!signaturePad.isEmpty()) {
          const signatureData = signaturePad.toDataURL("image/png");
          if (hiddenInput) {
            hiddenInput.value = signatureData;
          }
          // Hide the "No signature captured" message when signature is present
          if (statusEmpty) statusEmpty.classList.add("hidden");

          // Emit custom event for form validation
          const event = new CustomEvent("signatureUpdated", {
            detail: { data: signatureData, isEmpty: false },
          });
          document.dispatchEvent(event);
        } else {
          if (hiddenInput) {
            hiddenInput.value = "";
          }
          // Show the "No signature captured" message when signature is empty
          if (statusEmpty) statusEmpty.classList.remove("hidden");

          // Emit custom event for form validation
          const event = new CustomEvent("signatureUpdated", {
            detail: { data: null, isEmpty: true },
          });
          document.dispatchEvent(event);
        }
      }

      clearSignature(signaturePad, hiddenInput, placeholder, statusEmpty) {
        console.log("🗑️ [DigitalSignature] Clearing signature...", {
          signaturePad: !!signaturePad,
          hiddenInput: !!hiddenInput,
          placeholder: !!placeholder,
          statusEmpty: !!statusEmpty,
          isEmpty: signaturePad?.isEmpty(),
        });

        if (signaturePad) {
          signaturePad.clear();
          console.log("✅ [DigitalSignature] SignaturePad cleared");
        }

        if (hiddenInput) {
          hiddenInput.value = "";
          console.log("✅ [DigitalSignature] Hidden input cleared");
        }

        if (placeholder) {
          placeholder.style.display = "flex";
          console.log("✅ [DigitalSignature] Placeholder shown");
        }

        // Show the "No signature captured" message
        if (statusEmpty) {
          statusEmpty.classList.remove("hidden");
          console.log("✅ [DigitalSignature] Status empty shown");
        }

        // Emit custom event
        const event = new CustomEvent("signatureCleared");
        document.dispatchEvent(event);
        console.log("✅ [DigitalSignature] Clear event dispatched");
      }

      saveSignature(signaturePad, hiddenInput, statusEmpty) {
        if (!signaturePad.isEmpty()) {
          const signatureData = signaturePad.toDataURL("image/png");
          if (hiddenInput) {
            hiddenInput.value = signatureData;
          }
          // Don't show "signature saved" status - just leave it there
          // Hide the "No signature captured" message
          if (statusEmpty) statusEmpty.classList.add("hidden");

          // Emit custom event
          const event = new CustomEvent("signatureSaved", {
            detail: { data: signatureData },
          });
          document.dispatchEvent(event);
        } else {
          // Show error notification
          if (window.showModal) {
            window.showModal("error", "No Signature", "Please provide a signature before saving.");
          } else {
            console.error("🔔 [No Signature] Please provide a signature before saving.");
          }
        }
      }

      resizeCanvas(canvas, signaturePad) {
        const container = canvas.parentElement;
        if (!container) return;

        const containerWidth = container.clientWidth;

        // Get the maximum dimensions and aspect ratio from data attributes
        const maxWidth = parseInt(canvas.getAttribute("data-max-width") || "400");
        const maxHeight = parseInt(canvas.getAttribute("data-max-height") || "200");
        const aspectRatio = parseFloat(canvas.getAttribute("data-aspect-ratio") || "2");

        // Calculate responsive dimensions
        // Use container width but respect max dimensions and aspect ratio
        const availableWidth = Math.min(containerWidth - 4, maxWidth); // -4 for border
        const calculatedHeight = availableWidth / aspectRatio;
        const availableHeight = Math.min(calculatedHeight, maxHeight);

        // Final dimensions
        const displayWidth = availableWidth;
        const displayHeight = availableHeight;

        console.log("📐 [DigitalSignature] Responsive canvas resize:", {
          containerWidth,
          maxWidth,
          maxHeight,
          aspectRatio,
          availableWidth,
          availableHeight,
          displayWidth,
          displayHeight,
        });

        // Set canvas dimensions (1:1 pixel mapping to avoid coordinate issues)
        canvas.width = displayWidth;
        canvas.height = displayHeight;

        // Set canvas display dimensions (for CSS)
        canvas.style.width = displayWidth + "px";
        canvas.style.height = displayHeight + "px";

        const context = canvas.getContext("2d");
        if (context) {
          // No scaling needed with 1:1 mapping
        }

        // Clear and redraw if there was content
        if (signaturePad && !signaturePad.isEmpty()) {
          const data = signaturePad.toDataURL();
          signaturePad.clear();
          signaturePad.fromDataURL(data);
        }
      }

      showSignatureStatus(show, hide) {
        if (show) show.classList.remove("hidden");
        if (hide) hide.classList.add("hidden");
      }

      hideSignatureStatus(statusEmpty, statusSaved) {
        if (statusEmpty) statusEmpty.classList.add("hidden");
        if (statusSaved) statusSaved.classList.add("hidden");
      }

      // Public methods for external access
      getSignatureData(canvasId) {
        const signaturePad = this.signaturePads.get(canvasId);
        return signaturePad && !signaturePad.isEmpty() ? signaturePad.toDataURL("image/png") : null;
      }

      isSignatureEmpty(canvasId) {
        const signaturePad = this.signaturePads.get(canvasId);
        return !signaturePad || signaturePad.isEmpty();
      }

      clearSignatureById(canvasId) {
        const signaturePad = this.signaturePads.get(canvasId);
        if (signaturePad) {
          signaturePad.clear();
        }
      }

      getAllSignatures() {
        const signatures = {};
        this.signaturePads.forEach((pad, canvasId) => {
          signatures[canvasId] = pad.isEmpty() ? null : pad.toDataURL("image/png");
        });
        return signatures;
      }
    }

    // Initialize when DOM is ready
    document.addEventListener("DOMContentLoaded", async () => {
      console.log(
        "🎨 [DigitalSignature] DOMContentLoaded - initializing digital signature manager"
      );

      if (!window.digitalSignatureManager) {
        console.log("🎨 [DigitalSignature] Creating new DigitalSignatureManager");
        window.digitalSignatureManager = new DigitalSignatureManager();
        // Wait for initialization to complete
        await window.digitalSignatureManager.initializeSignatures();
        console.log("🎨 [DigitalSignature] DigitalSignatureManager initialization complete");
      } else {
        console.log(
          "🎨 [DigitalSignature] DigitalSignatureManager already exists, reinitializing signatures"
        );
        await window.digitalSignatureManager.initializeSignatures();
      }
    });

    // Make manager globally accessible
    window.digitalSignatureManager = null;
  </script>

  <style>
    .signature-canvas {
      touch-action: none;
      display: block;
      border-radius: 0.5rem;
    }

    .signature-placeholder {
      transition: opacity 0.2s ease;
    }

    .digital-signature-container:hover .signature-placeholder {
      opacity: 0.7;
    }

    /* Responsive signature container */
    .signature-container {
      width: 100%;
      max-width: 100%;
      position: relative;
    }

    /* Responsive canvas sizing - let JavaScript handle dimensions */
    .signature-canvas {
      /* Remove !important to allow JavaScript control */
      min-height: 150px;
      max-height: 400px;
    }

    /* Maintain aspect ratio on larger screens */
    @media (min-width: 640px) {
      .signature-canvas {
        min-height: 200px;
        max-height: 500px;
      }
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
      .signature-canvas {
        min-height: 120px;
        max-height: 250px;
      }
    }

    /* Very small screens */
    @media (max-width: 480px) {
      .signature-canvas {
        min-height: 100px;
        max-height: 200px;
      }
    }
  </style>
</div>
