---
// import { supabase } from "../lib/supabaseClient";
import SectionContainer from "./SectionContainer.astro";

const { role } = Astro.props;
---

<!-- Upload Progress -->
<div id="upload-progress" class="mt-6 hidden">
  <h3 class="mb-4 text-lg font-medium text-gray-900 dark:text-white">
    Uploading...
  </h3>
  <div id="progress-list" class="space-y-3"></div>
</div>
<!-- Created Projects -->

<!-- Responsive Projects and PDF Viewer Layout -->
<div
  class="mt-6 flex flex-col md:flex-row gap-6 border-2 border-green-500 relative"
  id="layout-container"
>
  <!-- Component Debug Label -->
  <div
    class="absolute top-0 left-0 bg-green-500 text-white text-xs px-2 py-1 rounded-br-md font-mono z-10"
  >
    Dashboard
  </div>
  <!-- Projects List - 2/3 width on md+ screens -->
  <SectionContainer id="projects-list" class="w-full md:w-2/3">
    <!-- Search Filter for Projects -->
    <div class="mb-4 relative">
      <input
        type="text"
        id="project-search"
        placeholder="Search active projects..."
        class="w-full pr-10 px-4 py-2 text-sm border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
      />
      <button
        id="clear-search-btn-new"
        class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 transition-colors hidden"
        title="Clear search"
      >
        <i class="bx bx-x text-lg"></i>
      </button>
    </div>
    <!-- Projects will be populated here -->
  </SectionContainer>
  <!-- PDF Viewer - 1/3 width on md+ screens, sticky on md+ -->
  <SectionContainer
    id="new-project-upload"
    class="w-full md:w-1/3 md:sticky md:top-20 md:self-start"
  />
</div>

<script src="/js/pdf.worker.min.js" defer is:inline></script>
<script src="/js/pdf.min.js" defer is:inline></script>

<!-- NEW CLASS-BASED APPROACH -->
<script type="module" is:inline>
  import { createClient } from "https://cdn.skypack.dev/@supabase/supabase-js";

  class PDFUploader {
    async setupSession() {
      if (window.SUPABASE_ACCESS_TOKEN && window.SUPABASE_REFRESH_TOKEN) {
        try {
          await this.supabase.auth.setSession({
            access_token: window.SUPABASE_ACCESS_TOKEN,
            refresh_token: window.SUPABASE_REFRESH_TOKEN,
          });
          console.log("Session set up successfully");
        } catch (error) {
          console.error("Error setting up session:", error);
        }
      }
    }

    constructor(container) {
      this.container = container;
      this.supabaseUrl = window.SUPABASE_URL;
      this.supabaseAnonKey = window.SUPABASE_ANON_KEY;
      // Reuse existing client or create new one
      if (window.supabaseClient) {
        this.supabase = window.supabaseClient;
      } else {
        this.supabase = createClient(this.supabaseUrl, this.supabaseAnonKey);
        window.supabaseClient = this.supabase;
      }

      this.generateHTML();
      this.setupEventListeners();

      // Set up session if tokens are available (async)
      this.setupSession();
    }

    generateHTML() {
      // Generate dropzone HTML
      this.container.innerHTML = `<h3 class="text-lg font-medium text-center text-gray-900 dark:text-white">Create New Project</h3>
        <div id="dropzone-landing" class="rounded-xl border-2 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-sky-500 dark:border-gray-600 dark:hover:border-sky-400">
          <div class="space-y-4">
            <i class="bx bx-upload bx-lg text-gray-400 dark:text-gray-500"></i>
            <div>
              <p class="hidden md:block text-lg font-medium text-gray-900 dark:text-white">Drop PDF or click to browse</p>
              <p class="hidden text-sm text-gray-500 dark:text-gray-400">Supports PDF files up to 10MB</p>
            </div>
            <input type="file" id="file-input" accept=".pdf" multiple class="hidden" />
            <button id="browse-btn" class="rounded-md bg-sky-500 px-4 py-2 text-sm font-medium text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2">Browse Files</button>
          </div>
        </div>
        <div id="upload-progress" class="mt-6 hidden">
          <h3 class="mb-4 text-lg font-medium text-gray-900 dark:text-white">Uploading...</h3>
          <div id="progress-list" class="space-y-3"></div>
        </div>
      `;
    }

    setupEventListeners() {
      const dropzone = this.container.querySelector("#dropzone-landing");
      const fileInput = this.container.querySelector("#file-input");
      const browseBtn = this.container.querySelector("#browse-btn");

      // Browse button
      browseBtn.addEventListener("click", () => {
        console.log("Browse button clicked");
        fileInput.click();
      });

      // File input change
      fileInput.addEventListener("change", (e) => {
        console.log("File input changed");
        this.handleFiles(e.target.files);
      });

      // Drag and drop events
      dropzone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropzone.classList.add("border-sky-500", "bg-sky-50");
        dropzone.classList.remove("border-gray-300");
      });

      dropzone.addEventListener("dragleave", (e) => {
        e.preventDefault();
        dropzone.classList.remove("border-sky-500", "bg-sky-50");
        dropzone.classList.add("border-gray-300");
      });

      dropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropzone.classList.remove("border-sky-500", "bg-sky-50");
        dropzone.classList.add("border-gray-300");

        const files = e.dataTransfer.files;
        this.handleFiles(files);
      });
    }

    async handleFiles(files) {
      console.log("Handling files:", files);
      const pdfFiles = Array.from(files).filter(
        (file) =>
          file.type === "application/pdf" && file.size <= 10 * 1024 * 1024
      );

      if (pdfFiles.length === 0) {
        alert("Please select valid PDF files under 10MB");
        return;
      }

      // Show upload progress
      const uploadProgress = this.container.querySelector("#upload-progress");
      const progressList = this.container.querySelector("#progress-list");
      uploadProgress.classList.remove("hidden");
      progressList.innerHTML = "";

      for (const file of pdfFiles) {
        const progressItem = this.createProgressItem(file.name);
        progressList.appendChild(progressItem);

        try {
          // Get current user from Supabase auth
          const {
            data: { user },
            error: userError,
          } = await this.supabase.auth.getUser();

          if (userError || !user) {
            throw new Error("User not authenticated - please sign in again");
          }

          // Step 1: Create new project with minimal data
          const { data: project, error: projectError } = await this.supabase
            .from("projects")
            .insert({
              title: "New Project",
              description: "Project created from PDF upload",
              author_id: user.id,
              status: 0,
              sq_ft: 0,
              new_construction: false,
            })
            .select()
            .single();

          if (projectError) throw projectError;

          // Step 2: Upload PDF to storage
          const timestamp = Date.now();
          const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, "_");
          const fileName = `${user.id}/${timestamp}_${sanitizedFileName}`;

          const { data: uploadData, error: uploadError } =
            await this.supabase.storage
              .from("project-documents")
              .upload(fileName, file, {
                cacheControl: "3600",
                upsert: false,
              });

          if (uploadError) throw uploadError;

          // Step 3: Get public URL
          const {
            data: { publicUrl },
          } = this.supabase.storage
            .from("project-documents")
            .getPublicUrl(fileName);

          // Step 4: Create file record in database
          const { error: fileError } = await this.supabase
            .from("files")
            .insert({
              project_id: project.id,
              author_id: user.id,
              name: file.name,
              file_name: file.name,
              file_path: fileName,
              file_type: "application/pdf",
              file_size: file.size,
              status: "active",
            });

          if (fileError) throw fileError;

          // Update progress
          this.updateProgress(
            progressItem,
            "success",
            "Project created successfully"
          );

          // Store file and URL for viewer
          this.uploadedFile = file;
          this.publicUrl = publicUrl;
          this.projectId = project.id;

          // Replace with PDF viewer
          this.onUploadComplete();
        } catch (error) {
          console.error("Upload error:", error);
          this.updateProgress(
            progressItem,
            "error",
            error.message || "Upload failed"
          );
        }
      }

      // Hide progress after a delay
      setTimeout(() => {
        uploadProgress.classList.add("hidden");
      }, 3000);
    }

    createProgressItem(fileName) {
      const div = document.createElement("div");
      div.className =
        "flex items-center justify-between rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-700";
      div.innerHTML = `
        <div class="flex items-center space-x-3">
          <i class="bx bx-file-pdf bx-sm text-red-500"></i>
          <span class="text-sm font-medium text-gray-900 dark:text-white">${fileName}</span>
        </div>
        <div class="flex items-center space-x-2">
          <div class="h-2 w-20 rounded-full bg-gray-200 dark:bg-gray-600">
            <div class="progress-bar h-2 rounded-full bg-sky-500 transition-all duration-300" style="width: 0%"></div>
          </div>
          <span class="progress-text text-xs text-gray-500 dark:text-gray-400">0%</span>
        </div>
      `;
      return div;
    }

    updateProgress(progressItem, status, message) {
      const progressBar = progressItem.querySelector(".progress-bar");
      const progressText = progressItem.querySelector(".progress-text");

      // debugger;
      if (status === "success") {
        progressBar.className =
          "progress-bar h-2 rounded-full bg-green-500 transition-all duration-300 w-full";
        // progressBar.style.width = "100%";
        progressText.textContent = "100%";
        progressText.className = "progress-text text-xs text-green-500";
      } else if (status === "error") {
        progressBar.className =
          "progress-bar h-2 rounded-full bg-red-500 transition-all duration-300";
        progressText.textContent = "Failed";
        progressText.className = "progress-text text-xs text-red-500";
      }
    }

    onUploadComplete() {
      // Destroy uploader, create PDFViewer + PDFScraper
      this.container.innerHTML = "";
      new PDFViewer(
        this.container,
        this.uploadedFile,
        this.publicUrl,
        this.projectId
      );
      new PDFScraper(this.container, this.projectId);

      // Toggle layout: hide projects list, make PDF viewer full width
      if (window.toggleLayoutForPDF) {
        window.toggleLayoutForPDF(true);
      }
    }

    toggleLayoutForPDF(hasPDF) {
      const projectsList = document.getElementById("projects-list");
      const pdfViewerContainer = document.getElementById("new-project-upload");
      const layoutContainer = document.getElementById("layout-container");
      const statusFilterButtons = document.getElementById(
        "status-filter-buttons"
      );

      if (hasPDF) {
        // Hide projects list
        if (projectsList) {
          projectsList.style.display = "none";
        }

        // Hide status filter buttons
        if (statusFilterButtons) {
          statusFilterButtons.style.visibility = "hidden";
        }

        // Make PDF viewer full width
        if (pdfViewerContainer) {
          pdfViewerContainer.className = pdfViewerContainer.className.replace(
            "w-full md:w-1/3 md:sticky md:top-20 md:self-start",
            "w-full"
          );
        }

        // Update layout container to single column
        if (layoutContainer) {
          layoutContainer.className = layoutContainer.className.replace(
            "md:flex-row",
            "flex-col"
          );
        }
      } else {
        // Show projects list
        if (projectsList) {
          projectsList.style.display = "block";
        }

        // Show status filter buttons
        if (statusFilterButtons) {
          statusFilterButtons.style.visibility = "visible";
        }

        // Restore PDF viewer to 1/3 width with sticky positioning
        if (pdfViewerContainer) {
          if (!pdfViewerContainer.className.includes("md:w-1/3")) {
            pdfViewerContainer.className = pdfViewerContainer.className.replace(
              /w-full(?!\s+md:)/,
              "w-full md:w-1/3 md:sticky md:top-20 md:self-start"
            );
          }
        }

        // Restore layout container to responsive row
        if (layoutContainer) {
          if (!layoutContainer.className.includes("md:flex-row")) {
            layoutContainer.className = layoutContainer.className.replace(
              /flex-col(?!\s+md:)/,
              "flex-col md:flex-row"
            );
          }
        }
      }
    }
  }

  // Global function to toggle layout (accessible from anywhere)
  window.toggleLayoutForPDF = function (hasPDF) {
    const projectsList = document.getElementById("projects-list");
    const pdfViewerContainer = document.getElementById("new-project-upload");
    const layoutContainer = document.getElementById("layout-container");
    const statusFilterButtons = document.getElementById(
      "status-filter-buttons"
    );

    if (hasPDF) {
      // Hide projects list
      if (projectsList) {
        projectsList.style.display = "none";
      }

      // Hide status filter buttons
      if (statusFilterButtons) {
        statusFilterButtons.style.visibility = "hidden";
      }

      // Make PDF viewer full width
      if (pdfViewerContainer) {
        pdfViewerContainer.className = pdfViewerContainer.className.replace(
          "w-full md:w-1/3 md:sticky md:top-20 md:self-start",
          "w-full"
        );
      }

      // Update layout container to single column
      if (layoutContainer) {
        layoutContainer.className = layoutContainer.className.replace(
          "md:flex-row",
          "flex-col"
        );
      }
    } else {
      // Show projects list
      if (projectsList) {
        projectsList.style.display = "block";
      }

      // Show status filter buttons
      if (statusFilterButtons) {
        statusFilterButtons.style.visibility = "visible";
      }

      // Restore PDF viewer to 1/3 width with sticky positioning
      if (pdfViewerContainer) {
        if (!pdfViewerContainer.className.includes("md:w-1/3")) {
          pdfViewerContainer.className = pdfViewerContainer.className.replace(
            /w-full(?!\s+md:)/,
            "w-full md:w-1/3 md:sticky md:top-20 md:self-start"
          );
        }
      }

      // Restore layout container to responsive row
      if (layoutContainer) {
        if (!layoutContainer.className.includes("md:flex-row")) {
          layoutContainer.className = layoutContainer.className.replace(
            /flex-col(?!\s+md:)/,
            "flex-col md:flex-row"
          );
        }
      }
    }
  };

  class PDFViewer {
    constructor(container, file, publicUrl, projectId) {
      this.container = container;
      this.file = file;
      this.publicUrl = publicUrl;
      this.projectId = projectId;
      // Reuse existing client or create new one
      if (window.supabaseClient) {
        this.supabase = window.supabaseClient;
      } else {
        this.supabase = createClient(
          window.SUPABASE_URL,
          window.SUPABASE_ANON_KEY
        );
        window.supabaseClient = this.supabase;
      }
      this.generateHTML();
      this.setupEventListeners();
    }

    generateHTML() {
      // Generate PDF viewer HTML with controls (using Acrobat.astro style)
      this.container.innerHTML = `
        <div class="flex flex-col md:flex-row gap-4">
          <!-- PDF Viewer (3/4 on medium+) -->
          <div class="flex-1 md:w-3/4">
            <div class="rounded-lg border border-gray-200 bg-white dark:border-gray-700 dark:bg-gray-800">
              <div id="pdf-canvas-container" class="relative flex justify-center  rounded border border-gray-200 dark:border-gray-600">
                <!-- Delete button - X bubble in top right -->
                <button class="pdf-delete absolute -top-4 -right-4 z-20 w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center shadow-lg transition-colors">
                  <i class="bx bx-x text-lg"></i>
                </button>
                <canvas id="pdf-canvas" style="width:100%;height:auto;display:block;margin:0 auto;"></canvas>
                <canvas id="pdf-meta-extractor-overlay" style="position:absolute; left:0; top:0;width: 100%;"></canvas>
              </div>
              <!-- PDF Controls at bottom -->
              <div class="controls flex gap-2 justify-between">
                <div class="flex items-center gap-2">
                  <button class="pdf-prev-page">
                    <i class="bx bx-chevron-left size-6 text-hub-subtitle dark:text-hub-subtitle-dark duration-300 ease-in-out hover:-translate-x-1"></i>
                  </button>
                  <span class="pdf-page-info font-medium text-base text-hub-title dark:text-hub-title-dark">Page 1 of 1</span>
                  <button class="pdf-next-page">
                    <i class="bx bx-chevron-right size-6 text-hub-subtitle dark:text-hub-subtitle-dark duration-300 ease-in-out hover:translate-x-1"></i>
                  </button>
                </div>
                <div>
                  <button class="pdf-download px-4 py-2 text-sm w-auto hover:text-hub-title text-hub-title font-bold dark:text-hub-title-dark">
                    <i class="bx bx-download bx-sm"></i>
                  </button>
                  <button class="pdf-print px-4 py-2 text-sm w-auto hover:text-hub-title text-hub-title font-bold dark:text-hub-title-dark">
                    <i class="bx bx-printer bx-sm"></i>
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Scraper Sidebar (1/4 on medium+) -->
          <div class="md:w-1/4" id="scraper-sidebar">
            <!-- Scraper content will be inserted here -->
          </div>
        </div>
      `;
    }

    setupEventListeners() {
      const prevBtn = this.container.querySelector(".pdf-prev-page");
      const nextBtn = this.container.querySelector(".pdf-next-page");
      const pageInfo = this.container.querySelector(".pdf-page-info");
      const downloadBtn = this.container.querySelector(".pdf-download");
      const printBtn = this.container.querySelector(".pdf-print");
      const deleteBtn = this.container.querySelector(".pdf-delete");
      const canvas = this.container.querySelector("#pdf-canvas");

      // Basic PDF viewer setup
      this.pdfDoc = null;
      this.currentPage = 1;
      this.totalPages = 1;
      this.pageRendering = false;
      this.pageNumPending = null;
      this.scale = 1.5;

      // Navigation buttons
      prevBtn.addEventListener("click", () => {
        console.log("Previous page clicked");
        if (this.currentPage <= 1) return;
        if (this.pageRendering) {
          this.pageNumPending = this.currentPage - 1;
        } else {
          this.currentPage--;
          this.renderPage(this.currentPage);
        }
      });

      nextBtn.addEventListener("click", () => {
        console.log("Next page clicked");
        if (this.currentPage >= this.totalPages) return;
        if (this.pageRendering) {
          this.pageNumPending = this.currentPage + 1;
        } else {
          this.currentPage++;
          this.renderPage(this.currentPage);
        }
      });

      downloadBtn.addEventListener("click", () => {
        console.log("Download clicked");
        const link = document.createElement("a");
        link.href = this.publicUrl;
        link.download = this.publicUrl.split("/").pop() || "document.pdf";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });

      printBtn.addEventListener("click", () => {
        console.log("Print clicked");
        window.print();
      });

      deleteBtn.addEventListener("click", () => {
        console.log("Delete clicked");
        if (confirm("Are you sure you want to delete this PDF?")) {
          this.deletePDF();
        }
      });

      // Setup drag/swipe navigation
      this.setupDragNavigation();

      // Load PDF if public URL is provided
      if (this.publicUrl) {
        this.loadPDF();
      } else {
        console.log("No PDF URL provided, showing placeholder");
        pageInfo.textContent = "PDF viewer ready";
      }
    }

    loadPDF() {
      console.log("Loading PDF from Supabase URL:", this.publicUrl);

      // Wait for PDF.js to be available
      this.waitForPDFJS().then(() => {
        const pdfjsLib = window.pdfjsLib;

        // Set worker source
        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = "/js/pdf.worker.min.js";
        }

        // Load PDF from Supabase URL
        if (this.publicUrl) {
          console.log("Loading PDF from URL:", this.publicUrl);

          pdfjsLib
            .getDocument(this.publicUrl)
            .promise.then((pdf) => {
              this.pdfDoc = pdf;
              this.totalPages = pdf.numPages;
              this.currentPage = 1;
              this.renderPage(this.currentPage);
            })
            .catch((error) => {
              console.error("Error loading PDF from URL:", error);
            });
        } else {
          console.log("No public URL to load");
        }
      });
    }

    waitForPDFJS() {
      return new Promise((resolve) => {
        function check() {
          if (window.pdfjsLib) {
            resolve();
          } else {
            setTimeout(check, 50);
          }
        }
        check();
      });
    }

    setupDragNavigation() {
      const canvas = this.container.querySelector("#pdf-canvas");
      if (!canvas) {
        console.log("Canvas not found for drag navigation");
        return;
      }

      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let startTime = 0;
      const minDragDistance = 50; // Minimum pixels to trigger navigation
      const maxDragTime = 500; // Maximum time for a valid swipe (ms)
      const maxVerticalMovement = 100; // Maximum vertical movement for horizontal swipe

      // Mouse events
      const handleMouseStart = (e) => {
        // Check if overlay is active for scraping - if so, don't start drag
        const overlay = this.container.querySelector(
          "#pdf-meta-extractor-overlay"
        );
        if (overlay && overlay.style.pointerEvents === "auto") {
          return; // Let the overlay handle the interaction
        }

        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startTime = Date.now();
        canvas.style.cursor = "grabbing";
        e.preventDefault();
      };

      const handleMouseMove = (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        // Visual feedback - add a subtle transform
        const translateX = Math.max(-30, Math.min(30, deltaX * 0.3));
        canvas.style.transform = `translateX(${translateX}px)`;

        e.preventDefault();
      };

      const handleMouseEnd = (e) => {
        if (!isDragging) return;

        isDragging = false;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const deltaTime = Date.now() - startTime;

        // Reset visual state
        canvas.style.cursor = "grab";
        canvas.style.transform = "translateX(0px)";

        // Check if this was a valid horizontal swipe
        if (
          deltaTime <= maxDragTime &&
          Math.abs(deltaY) <= maxVerticalMovement &&
          Math.abs(deltaX) >= minDragDistance
        ) {
          if (deltaX > 0) {
            // Swiped right - go to previous page
            this.goToPreviousPage();
          } else {
            // Swiped left - go to next page
            this.goToNextPage();
          }
        }

        e.preventDefault();
      };

      // Touch events
      const handleTouchStart = (e) => {
        if (e.touches.length === 1) {
          // Check if overlay is active for scraping - if so, don't start drag
          const overlay = this.container.querySelector(
            "#pdf-meta-extractor-overlay"
          );
          if (overlay && overlay.style.pointerEvents === "auto") {
            return; // Let the overlay handle the interaction
          }

          const touch = e.touches[0];
          isDragging = true;
          startX = touch.clientX;
          startY = touch.clientY;
          startTime = Date.now();
          e.preventDefault();
        }
      };

      const handleTouchMove = (e) => {
        if (!isDragging || e.touches.length !== 1) return;

        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;

        // Visual feedback
        const translateX = Math.max(-30, Math.min(30, deltaX * 0.3));
        canvas.style.transform = `translateX(${translateX}px)`;

        e.preventDefault();
      };

      const handleTouchEnd = (e) => {
        if (!isDragging) return;

        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        const deltaTime = Date.now() - startTime;

        isDragging = false;

        // Reset visual state
        canvas.style.transform = "translateX(0px)";

        // Check if this was a valid horizontal swipe
        if (
          deltaTime <= maxDragTime &&
          Math.abs(deltaY) <= maxVerticalMovement &&
          Math.abs(deltaX) >= minDragDistance
        ) {
          if (deltaX > 0) {
            // Swiped right - go to previous page
            this.goToPreviousPage();
          } else {
            // Swiped left - go to next page
            this.goToNextPage();
          }
        }

        e.preventDefault();
      };

      // Add event listeners
      canvas.addEventListener("mousedown", handleMouseStart);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseEnd);
      canvas.addEventListener("mouseleave", handleMouseEnd); // Handle mouse leaving canvas

      canvas.addEventListener("touchstart", handleTouchStart, {
        passive: false,
      });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: false });

      // Set initial cursor style
      canvas.style.cursor = "grab";
      canvas.style.transition = "transform 0.2s ease-out";

      console.log("Drag navigation setup complete");
    }

    goToPreviousPage() {
      if (this.currentPage <= 1) return;
      if (this.pageRendering) {
        this.pageNumPending = this.currentPage - 1;
      } else {
        this.currentPage--;
        this.renderPage(this.currentPage);
      }
      console.log("Dragged to previous page:", this.currentPage);
    }

    goToNextPage() {
      if (this.currentPage >= this.totalPages) return;
      if (this.pageRendering) {
        this.pageNumPending = this.currentPage + 1;
      } else {
        this.currentPage++;
        this.renderPage(this.currentPage);
      }
      console.log("Dragged to next page:", this.currentPage);
    }

    renderPage(num) {
      console.log("Rendering page:", num);
      if (!this.pdfDoc) {
        console.log("No PDF document loaded");
        return;
      }

      this.pageRendering = true;
      this.pdfDoc.getPage(num).then((page) => {
        const canvas = this.container.querySelector("#pdf-canvas");
        const overlay = this.container.querySelector(
          "#pdf-meta-extractor-overlay"
        );
        const viewport = page.getViewport({ scale: this.scale });

        canvas.width = viewport.width;
        canvas.height = viewport.height;

        // Size the overlay to match the canvas
        if (overlay) {
          overlay.width = viewport.width;
          overlay.height = viewport.height;
        }

        const context = canvas.getContext("2d");
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };

        const renderTask = page.render(renderContext);
        renderTask.promise.then(() => {
          this.pageRendering = false;
          this.container.querySelector(".pdf-page-info").textContent =
            `Page ${this.currentPage} of ${this.totalPages}`;

          if (this.pageNumPending !== null) {
            this.renderPage(this.pageNumPending);
            this.pageNumPending = null;
          }
        });
      });
    }

    async deletePDF() {
      console.log("Deleting PDF and returning to uploader");

      if (this.projectId && this.publicUrl) {
        try {
          // Get the file path from the URL
          const urlParts = this.publicUrl.split("/");
          const fileName = urlParts[urlParts.length - 1];
          const filePath = `${fileName}`;

          // Delete from Supabase storage
          const { error: storageError } = await this.supabase.storage
            .from("project-documents")
            .remove([filePath]);

          if (storageError) {
            console.error("Error deleting from storage:", storageError);
          }

          // Delete file record from database
          const { error: fileError } = await this.supabase
            .from("files")
            .delete()
            .eq("project_id", this.projectId);

          if (fileError) {
            console.error("Error deleting file record:", fileError);
          }

          // Delete project from database
          const { error: projectError } = await this.supabase
            .from("projects")
            .delete()
            .eq("id", this.projectId);

          if (projectError) {
            console.error("Error deleting project:", projectError);
          }
        } catch (error) {
          console.error("Error during deletion:", error);
        }
      }

      // Clear cached data
      this.pdfDoc = null;
      this.file = null;

      // Return to uploader
      this.container.innerHTML = "";

      // Clean up any active scraper instance
      if (window.currentPDFScraper && window.currentPDFScraper.cleanup) {
        window.currentPDFScraper.cleanup();
        window.currentPDFScraper = null;
      }

      // Restore layout: show projects list, restore original widths
      if (window.toggleLayoutForPDF) {
        window.toggleLayoutForPDF(false);
      }

      new PDFUploader(this.container);
    }
  }

  class PDFScraper {
    constructor(container, projectId) {
      this.container = container;
      this.projectId = projectId;
      this.canvas = null;
      this.overlay = null;
      this.isSelecting = false;
      this.readyToSelect = false;
      this.blurTimeout = null;
      this.startX = 0;
      this.startY = 0;
      this.endX = 0;
      this.endY = 0;
      this.selectedField = null;
      this.targetImageId = null;
      this.ocrText = "";
      this.imageBlob = null;
      this.selectedImages = []; // Array to store multiple images with titles

      // Initialize Supabase client (same logic as PDFUploader)
      this.supabaseUrl = window.SUPABASE_URL;
      this.supabaseAnonKey = window.SUPABASE_ANON_KEY;
      if (window.supabaseClient) {
        this.supabase = window.supabaseClient;
      } else {
        this.supabase = createClient(this.supabaseUrl, this.supabaseAnonKey);
        window.supabaseClient = this.supabase;
      }

      this.attachToViewer();
      this.setupEventListeners();
      this.setupSession(); // Set up session if tokens are available
    }

    async setupSession() {
      if (window.SUPABASE_ACCESS_TOKEN && window.SUPABASE_REFRESH_TOKEN) {
        try {
          await this.supabase.auth.setSession({
            access_token: window.SUPABASE_ACCESS_TOKEN,
            refresh_token: window.SUPABASE_REFRESH_TOKEN,
          });
          console.log("PDFScraper: Session set up successfully");
        } catch (error) {
          console.error("PDFScraper: Error setting up session:", error);
        }
      }
    }

    attachToViewer() {
      const sidebar = this.container.querySelector("#scraper-sidebar");
      if (!sidebar) {
        console.error("Scraper sidebar not found");
        return;
      }

      // Add OCR overlay and field selection buttons to sidebar
      sidebar.innerHTML = `
        <div class="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
          <div class="flex flex-col gap-3">
                        <div class="relative scrape-input-container">
              <input
                type="text"
                id="address-input"
                data-field="address"
                class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                placeholder="Address / Title *"
                required
              >
            </div>
            
            <!-- Client Selection Toggle -->
            <div class="space-y-3">
              <div class="flex items-center justify-between">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Client Type
                </label>
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" id="owner-type-toggle" class="sr-only peer">
                  <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"></div>
                  <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">Existing Client</span>
                </label>
              </div>
              
              <!-- New Client Inputs (default visible) -->
              <div id="new-user-inputs" class="space-y-3">
                <div class="relative scrape-input-container">
                  <input
                    type="text"
                    id="owner-name-input"
                    data-field="owner_name"
                    class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                    placeholder="Company / Client Name *"
                    required
                  >
                </div>
                <div class="relative scrape-input-container">
                  <input
                    type="email"
                    id="owner-email-input"
                    data-field="owner_email"
                    class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                    placeholder="Email Address *"
                    required
                  >
                </div>
                <div class="relative scrape-input-container">
                  <input
                    type="tel"
                    id="owner-phone-input"
                    data-field="owner_phone"
                    class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                    placeholder="Phone Number"
                  >
                </div>
              </div>
              
              <!-- Existing Client Inputs (initially hidden) -->
              <div id="existing-user-inputs" class="space-y-3 hidden">
                <div class="relative">
                  <input
                    type="text"
                    id="existing-user-search"
                    class="w-full py-2 pr-8 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                    placeholder="Search existing clients..."
                  >
                  <button
                    type="button"
                    id="clear-user-search-btn"
                    class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none hidden"
                    title="Clear search"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                  </button>
                  <input type="hidden" id="existing-user-id">
                  <div id="user-search-results" class="absolute z-10 w-full mt-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg hidden max-h-40 overflow-y-auto">
                    <!-- Search results will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="relative scrape-input-container">
              <input
                type="text"
                id="architect-input"
                data-field="architect"
                class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                placeholder="Architect"
              >
            </div>
            
            <div class="relative scrape-input-container">
              <input
                type="number"
                id="square-foot-input"
                data-field="square_foot"
                class="scrape-input w-full py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400"
                placeholder="Gross Square Footage (GFA) *"
                min="0"
                max="50000"
                step="1"
                title="Maximum value: 50000 square feet"
                required
              >
            </div>

            <button id="select-image"
              class="pdf-meta-extractor-select-field px-4 py-2 text-sm rounded-md bg-blue-500 text-white hover:bg-blue-600 text-left"
              data-field="image"
              type="button">Select Image(s)</button>

           
            
            <div class="flex gap-4 mt-2">
              <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="sprinkler-toggle" class="sr-only peer">
                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"></div>
                <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">New Construction</span>
              </label>
              <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="alarm-toggle" class="sr-only peer">
                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"></div>
                <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">Existing</span>
              </label>
            </div>

            <div class="space-y-2">
              <label for="units-slider" class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Units: <span id="units-value" class="font-semibold text-blue-600 dark:text-blue-400">1</span>
              </label>
              <div class="relative">
               
                <input
                  type="range"
                  id="units-slider"
                  name="units"
                  min="0"
                  max="14"
                  value="0"
                  class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 units-range-slider relative z-10"
                  data-values="1,2,3,4,5,6,7,8,9,10,15,20,30,40,50"
                  aria-label="Select number of units"
                >
                <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-2">
                  <span>1</span>
                  <span>5</span>
                  <span>10</span>
                  <span>30</span>
                  <span>50</span>
                </div>
              </div>
            </div>

            <!-- Multi-select building type buttons (commented out for later use)
            <div class="space-y-3">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Building Type (Multi-select)
              </label>
              <div class="flex flex-wrap gap-2">
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Residential"
                >
                  Residential
                </button>
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Mixed use"
                >
                  Mixed use
                </button>
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Mercantile"
                >
                  Mercantile
                </button>
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Commercial"
                >
                  Commercial
                </button>
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Storage"
                >
                  Storage
                </button>
                 <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Warehouse"
                >
                  Warehouse
                </button>
                <button
                  type="button"
                  class="building-type-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Institutional"
                >
                  Institutional
                </button>
              </div>
            </div>
            -->

            <!-- Radio-style building type selection (single select) -->
            <div class="space-y-3">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Building
              </label>
              <div class="flex flex-wrap gap-2">
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Residential"
                >
                  Residential
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Mixed use"
                >
                  Mixed use
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Mercantile"
                >
                  Mercantile
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Commercial"
                >
                  Commercial
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Storage"
                >
                  Storage
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Warehouse"
                >
                  Warehouse
                </button>
                <button
                  type="button"
                  class="building-type-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Institutional"
                >
                  Institutional
                </button>
              </div>
            </div>

            <!-- Consulting Services (Multi-select) -->
            <div class="space-y-3">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Project
              </label>
              <div class="flex flex-wrap gap-2">
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Sprinkler"
                >
                  Sprinkler
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Alarm"
                >
                  Alarm
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Mechanical"
                >
                  Mechanical
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Electrical"
                >
                  Electrical
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Plumbing"
                >
                  Plumbing
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Civil engineering"
                >
                  Civil engineering
                </button>
                <button
                  type="button"
                  class="consulting-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Other"
                >
                  Other
                </button>
              </div>
            </div>

            <!-- Fire Service Type (Single select) -->
            <div class="space-y-3">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Supply / Service
              </label>
              <div class="flex flex-wrap gap-2">
                <button
                  type="button"
                  class="fire-service-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Pump &amp; Tank"
                >
                  Pump &amp; Tank
                </button>
                <button
                  type="button"
                  class="fire-service-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="2\' copper"
                >
                  2' Copper
                </button>
                <button
                  type="button"
                  class="fire-service-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="4\' Ductile"
                >
                  4' Ductile
                </button>
                <button
                  type="button"
                  class="fire-service-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="6\' Ductile"
                >
                  6' Ductile
                </button>
                <button
                  type="button"
                  class="fire-service-radio px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Unknown"
                >
                  Unknown
                </button>
              </div>
            </div>

            <!-- Fire Safety Services (Multi-select) -->
            <div class="space-y-3">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Reports Required
              </label>
              <div class="flex flex-wrap gap-2">
                <button
                  type="button"
                  class="fire-safety-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Sprinkler"
                >
                  Sprinkler
                </button>
                <button
                  type="button"
                  class="fire-safety-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="Alarm"
                >
                Alarm
                </button>
                <button
                  type="button"
                  class="fire-safety-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="NFPA 241"
                >
                  NFPA 241
                </button>
                <button
                  type="button"
                  class="fire-safety-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="IEBC"
                >
                  IEBC
                </button>
                <button
                  type="button"
                  class="fire-safety-service-btn px-3 py-2 text-sm rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  data-value="IBC"
                >
                  IBC
                </button>
              </div>
            </div>
          </div>
                   <!-- OCR result area for image gallery - initially hidden -->
         <div id="images-container" class="mt-4 bg-gray-50 dark:bg-gray-800 rounded-md min-h-[100px] hidden">
           <!-- Image gallery will be inserted here -->
         </div>
         
         <!-- Project action buttons - always visible at bottom -->
         <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
           <div class="flex gap-3 justify-end">
             <button id="clear-project" class="px-4 py-2 text-sm bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors">
               Clear All
             </button>
             <button id="save-project" class="px-4 py-2 text-sm bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors">
               Create & Save Project
             </button>
           </div>
         </div>
        </div>
      `;
    }

    setupEventListeners() {
      // Get references to canvas and overlay from the PDF viewer
      this.canvas = this.container.querySelector("#pdf-canvas");
      this.overlay = this.container.querySelector(
        "#pdf-meta-extractor-overlay"
      );
      const ocrResultDiv = this.container.querySelector("#images-container");
      const saveProjectBtn = this.container.querySelector("#save-project");
      const clearProjectBtn = this.container.querySelector("#clear-project");
      const fieldBtns = this.container.querySelectorAll(
        ".pdf-meta-extractor-select-field"
      );
      const scrapeButtons = this.container.querySelectorAll(
        "button[data-field][data-input-id]"
      );

      if (!this.canvas || !this.overlay) {
        console.error("Canvas or overlay not found");
        return;
      }

      // If field buttons are not found, retry after a short delay
      if (fieldBtns.length === 0) {
        console.log("Field buttons not found, retrying in 100ms...");
        setTimeout(() => {
          this.setupEventListeners();
        }, 100);
        return;
      }

      // Ensure overlay starts in inactive state
      this.overlay.style.pointerEvents = "none";
      this.overlay.style.cursor = "default";

      // Scrape buttons are now purely visual (CSS pseudo-elements)
      // No event listeners needed - input focus handles everything

      // Field selection buttons (for image and other special fields)
      fieldBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          console.log("Field button clicked:", btn.getAttribute("data-field"));
          this.selectedField = btn.getAttribute("data-field");
          this.overlay.style.pointerEvents = "auto";
          this.overlay.style.cursor = "crosshair";

          this.clearOverlay();
          this.isSelecting = false;

          if (this.selectedField === "image") {
            this.setupImageGallery();
          }
        });
      });

      // Add event delegation for select-image button (works even if button is created later)
      this.container.addEventListener("click", (e) => {
        const target = e.target.closest(".pdf-meta-extractor-select-field");
        if (target && target.id === "select-image") {
          console.log("Select image button clicked via event delegation");
          this.selectedField = "image";
          this.overlay.style.pointerEvents = "auto";
          this.overlay.style.cursor = "crosshair";

          this.clearOverlay();
          this.isSelecting = false;

          this.setupImageGallery();
        }
      });

      // Mouse events for selection
      this.overlay.addEventListener("mousedown", (e) => {
        // Only handle if overlay is in active scraping mode
        if (this.overlay.style.pointerEvents !== "auto") {
          return; // Let canvas drag handle it
        }

        console.log("Overlay mousedown");

        // Prevent input blur when clicking on overlay
        e.preventDefault();
        e.stopPropagation(); // Prevent canvas drag from interfering

        this.isSelecting = true;
        const rect = this.overlay.getBoundingClientRect();
        this.startX = e.clientX - rect.left;
        this.startY = e.clientY - rect.top;
      });

      this.overlay.addEventListener("mousemove", (e) => {
        if (!this.isSelecting) return;
        if (this.overlay.style.pointerEvents !== "auto") return;

        e.stopPropagation(); // Prevent canvas drag from interfering
        const rect = this.overlay.getBoundingClientRect();
        this.endX = e.clientX - rect.left;
        this.endY = e.clientY - rect.top;
        this.drawSelection();
      });

      this.overlay.addEventListener("mouseup", (e) => {
        if (!this.isSelecting) return;
        if (this.overlay.style.pointerEvents !== "auto") return;

        console.log("Overlay mouseup");
        e.stopPropagation(); // Prevent canvas drag from interfering

        this.isSelecting = false;
        this.cropAndOCR();

        // Don't disable overlay immediately - let blur handler manage it
        // This allows multiple inputs to work in sequence
      });

      // Save project button
      if (saveProjectBtn) {
        saveProjectBtn.addEventListener("click", () => {
          console.log("Save project clicked");
          this.saveProjectData();
        });
      }

      // Clear project button
      if (clearProjectBtn) {
        clearProjectBtn.addEventListener("click", () => {
          console.log("Clear project clicked");
          this.clearProjectData();
        });
      }

      // Setup input field listeners for focus-based scraping
      this.setupInputFieldListeners();

      // Setup units slider
      this.setupUnitsSlider();

      // Setup building type radio buttons
      this.setupBuildingTypeRadio();

      // Setup fire service type radio buttons
      this.setupFireServiceTypeRadio();

      // Setup consulting services multi-select buttons
      this.setupConsultingServices();

      // Setup fire safety services multi-select buttons
      this.setupFireSafetyServices();

      // Setup ESC key handler for exiting scrape mode
      this.setupEscapeKeyHandler();

      // Setup owner toggle functionality
      this.setupOwnerToggle();
    }

    setupOwnerToggle() {
      const ownerTypeToggle =
        this.container.querySelector("#owner-type-toggle");
      const newUserInputs = this.container.querySelector("#new-user-inputs");
      const existingUserInputs = this.container.querySelector(
        "#existing-user-inputs"
      );

      if (ownerTypeToggle) {
        // Set initial state (unchecked = new user, checked = existing user)
        this.updateOwnerInputs(ownerTypeToggle.checked);

        ownerTypeToggle.addEventListener("change", () => {
          this.updateOwnerInputs(ownerTypeToggle.checked);
        });
      }
    }

    updateOwnerInputs(isExistingUser) {
      const newUserInputs = this.container.querySelector("#new-user-inputs");
      const existingUserInputs = this.container.querySelector(
        "#existing-user-inputs"
      );

      if (isExistingUser) {
        // Show existing user inputs, hide new user inputs
        existingUserInputs.classList.remove("hidden");
        newUserInputs.classList.add("hidden");
        this.loadExistingUsers(); // Load users for dropdown
      } else {
        // Show new user inputs, hide existing user inputs
        newUserInputs.classList.remove("hidden");
        existingUserInputs.classList.add("hidden");
      }
    }

    async loadExistingUsers() {
      try {
        const response = await fetch("/api/get-staff-users");
        const result = await response.json();

        if (result.success) {
          // Store users for search functionality (even if empty array)
          this.availableUsers = result.staffUsers || [];

          // Update placeholder text based on availability
          const searchInput = this.container.querySelector("#existing-user-search");
          if (searchInput) {
            if (this.availableUsers.length === 0) {
              searchInput.placeholder = "No clients available";
              searchInput.disabled = true;
            } else {
              searchInput.placeholder = "Search existing clients...";
              searchInput.disabled = false;
            }
          }

          // Setup search input event listeners
          this.setupUserSearch();
        } else {
          console.error("Failed to load users:", result.error);
          // Handle error case
          const searchInput = this.container.querySelector("#existing-user-search");
          if (searchInput) {
            searchInput.placeholder = "Error loading clients";
            searchInput.disabled = true;
          }
        }
      } catch (error) {
        console.error("Error loading existing users:", error);
        // Handle network/other errors
        const searchInput = this.container.querySelector("#existing-user-search");
        if (searchInput) {
          searchInput.placeholder = "Error loading clients";
          searchInput.disabled = true;
        }
      }
    }

    setupUserSearch() {
      const searchInput = this.container.querySelector("#existing-user-search");
      const clearBtn = this.container.querySelector("#clear-user-search-btn");
      const resultsList = this.container.querySelector("#user-search-results");

      if (searchInput) {
        // Debounced search
        let searchTimeout;
        searchInput.addEventListener("input", (e) => {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            this.performUserSearch(e.target.value);
          }, 300);
        });

        // Clear search functionality
        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            searchInput.value = "";
            this.clearUserSearch();
          });
        }

        // Show/hide clear button based on input (only if clear button exists)
        if (clearBtn) {
          searchInput.addEventListener("input", () => {
            if (searchInput.value.length > 0) {
              clearBtn.classList.remove("hidden");
            } else {
              clearBtn.classList.add("hidden");
            }
          });
        }
      }
    }

    performUserSearch(searchTerm) {
      const resultsList = this.container.querySelector("#user-search-results");
      const searchInput = this.container.querySelector("#existing-user-search");

      if (!this.availableUsers || !resultsList) return;

      const filteredUsers = this.availableUsers.filter((user) => {
        const searchLower = searchTerm.toLowerCase();
        return (
          user.name.toLowerCase().includes(searchLower) ||
          (user.email && user.email.toLowerCase().includes(searchLower))
        );
      });

      // Display results
      if (searchTerm.length > 0 && filteredUsers.length > 0) {
        resultsList.innerHTML = filteredUsers
          .map(
            (user) => `
            <div class="user-result-item p-3 hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer border-b border-gray-200 dark:border-gray-600 last:border-b-0" data-user-id="${user.id}" data-user-name="${user.name}">
              <div class="font-medium text-gray-900 dark:text-white">${user.name}</div>
              <div class="text-sm text-gray-500 dark:text-gray-400">${user.email || "No email"}</div>
            </div>
          `
          )
          .join("");

        resultsList.classList.remove("hidden");

        // Add click handlers to results
        resultsList.querySelectorAll(".user-result-item").forEach((item) => {
          item.addEventListener("click", () => {
            const userId = item.getAttribute("data-user-id");
            const userName = item.getAttribute("data-user-name");
            this.selectUser(userId, userName);
          });
        });
      } else if (searchTerm.length > 0) {
        resultsList.innerHTML = `
          <div class="p-3 text-gray-500 dark:text-gray-400 text-center">
            No users found matching "${searchTerm}"
          </div>
        `;
        resultsList.classList.remove("hidden");
      } else {
        resultsList.classList.add("hidden");
      }
    }

    selectUser(userId, userName) {
      const searchInput = this.container.querySelector("#existing-user-search");
      const hiddenInput = this.container.querySelector("#existing-user-id");
      const resultsList = this.container.querySelector("#user-search-results");

      if (searchInput && hiddenInput) {
        searchInput.value = userName;
        hiddenInput.value = userId;
        if (resultsList) {
          resultsList.classList.add("hidden");
        }
      }
    }

    clearUserSearch() {
      const searchInput = this.container.querySelector("#existing-user-search");
      const hiddenInput = this.container.querySelector("#existing-user-id");
      const resultsList = this.container.querySelector("#user-search-results");
      const clearBtn = this.container.querySelector("#clear-user-search-btn");

      if (searchInput && hiddenInput) {
        searchInput.value = "";
        hiddenInput.value = "";
        if (resultsList) {
          resultsList.classList.add("hidden");
        }
        if (clearBtn) {
          clearBtn.classList.add("hidden");
        }
      }
    }

    showSaveSuccessToast() {
      // Create a temporary toast message
      const toast = document.createElement("div");
      toast.className = `fixed top-4 right-4 z-50 px-6 py-3 rounded-md text-sm font-medium transition-all duration-300 transform translate-x-full opacity-0 bg-green-500 text-white shadow-lg`;
      toast.innerHTML = `
        <div class="flex items-center gap-2">
          <i class="bx bx-check-circle text-lg"></i>
          <span>Project saved successfully!</span>
        </div>
      `;
      document.body.appendChild(toast);

      // Animate in
      setTimeout(() => {
        toast.style.transform = "translateX(0)";
        toast.style.opacity = "1";
      }, 10);

      // Animate out and remove
      setTimeout(() => {
        toast.style.transform = "translateX(full)";
        toast.style.opacity = "0";
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, 3000);
    }

    setupImageGallery() {
      const ocrResultDiv = this.container.querySelector("#images-container");

      if (ocrResultDiv) {
        ocrResultDiv.classList.remove("hidden");

        // Check for existing gallery container in the correct location
        const selectImageBtn = document.querySelector("#select-image");
        let galleryContainer = null;

        if (selectImageBtn) {
          // Look for existing gallery after the select-image button
          galleryContainer = selectImageBtn.nextElementSibling;
          if (galleryContainer && galleryContainer.id === "image-gallery") {
            // Gallery already exists, just ensure it's visible
            galleryContainer.style.display = "block";
            return;
          }

          // Clean up any duplicate galleries that might exist elsewhere
          this.cleanupDuplicateGalleries();
        }

        // Create new gallery container if it doesn't exist
        if (!galleryContainer) {
          galleryContainer = document.createElement("div");
          galleryContainer.id = "image-gallery";
          galleryContainer.innerHTML = `
            <h4 class="text-sm font-medium text-gray-900 dark:text-white mb-2">Selected Images</h4>
            <div id="images-list" class="space-y-3"></div>
          `;

          if (selectImageBtn) {
            selectImageBtn.insertAdjacentElement("afterend", galleryContainer);
          } else {
            console.warn("Select image button not found for gallery container");
          }
        }
      }
    }

    cleanupDuplicateGalleries() {
      // Remove any duplicate image-gallery containers
      const allGalleries = document.querySelectorAll("#image-gallery");
      if (allGalleries.length > 1) {
        console.log(
          `Found ${allGalleries.length} gallery containers, cleaning up duplicates`
        );
        // Keep only the first one, remove the rest
        for (let i = 1; i < allGalleries.length; i++) {
          allGalleries[i].remove();
        }
      }
    }

    clearOverlay() {
      if (!this.overlay) return;
      const ctx = this.overlay.getContext("2d");
      ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);
    }

    resetSelectionState() {
      // Reset all selection-related state
      this.selectedField = null;
      this.isSelecting = false;
      this.targetInputId = null;
      this.targetImageId = null;

      if (this.overlay) {
        this.overlay.style.pointerEvents = "none";
        this.overlay.style.cursor = "default";
      }

      console.log("Selection state reset - ready for next selection");
    }

    drawSelection() {
      if (!this.overlay) return;

      this.clearOverlay();
      const ctx = this.overlay.getContext("2d");
      ctx.strokeStyle = "red";
      ctx.lineWidth = 6;
      ctx.setLineDash([6]);

      // Scale coordinates from CSS pixels to canvas pixels
      const overlayRect = this.overlay.getBoundingClientRect();
      const scaleX = this.overlay.width / overlayRect.width;
      const scaleY = this.overlay.height / overlayRect.height;

      const x = Math.min(this.startX, this.endX) * scaleX;
      const y = Math.min(this.startY, this.endY) * scaleY;
      const w = Math.abs(this.endX - this.startX) * scaleX;
      const h = Math.abs(this.endY - this.startY) * scaleY;

      ctx.strokeRect(x, y, w, h);
    }

    cropAndOCR() {
      if (!this.canvas) return;

      console.log("Crop and OCR");
      // Map overlay selection to actual canvas pixel coordinates
      const overlayRect = this.overlay.getBoundingClientRect();
      const scaleX = this.canvas.width / overlayRect.width;
      const scaleY = this.canvas.height / overlayRect.height;
      const sx = Math.min(this.startX, this.endX) * scaleX;
      const sy = Math.min(this.startY, this.endY) * scaleY;
      const sw = Math.abs(this.endX - this.startX) * scaleX;
      const sh = Math.abs(this.endY - this.startY) * scaleY;

      // Validate selection size - must be at least 10x10 pixels
      if (sw < 10 || sh < 10) {
        console.log("Selection too small, skipping OCR");
        this.clearOverlay();
        return;
      }

      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = sw;
      tempCanvas.height = sh;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(this.canvas, sx, sy, sw, sh, 0, 0, sw, sh);

      if (this.selectedField === "image") {
        tempCanvas.toBlob((blob) => {
          this.addImageToGallery(blob);
          // Reset selection state after image is added
          this.resetSelectionState();
        }, "image/png");
        this.clearOverlay();
        return;
      }

      tempCanvas.toBlob((blob) => {
        if (blob && blob.size > 0) {
          // Capture current target IDs to prevent race conditions
          const capturedInputId = this.targetInputId;
          const capturedImageId = this.targetImageId;
          this.sendToOCR(blob, capturedInputId, capturedImageId);
        } else {
          console.error("Failed to create blob from selection");
        }
      }, "image/png");
      this.clearOverlay();
    }

    // Helper function to convert text to title case
    toTitleCase(str) {
      return str.replace(/\w\S*/g, (txt) => {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    }

    // Helper function to sanitize text for number inputs
    sanitizeNumber(str) {
      console.log("Sanitizing number from:", str);

      // Remove all non-numeric characters except decimal points and commas
      let cleaned = str.replace(/[^\d.,]/g, "");

      // Handle common OCR mistakes
      cleaned = cleaned
        .replace(/[Oo]/g, "0") // O → 0
        .replace(/[Il|]/g, "1") // I, l, | → 1
        .replace(/[Ss]/g, "5") // S → 5 (sometimes)
        .replace(/[Bb]/g, "6"); // B → 6 (sometimes)

      // Remove duplicate decimal points, keep only the first one
      const parts = cleaned.split(".");
      if (parts.length > 2) {
        cleaned = parts[0] + "." + parts.slice(1).join("");
      }

      // Remove commas (thousand separators)
      cleaned = cleaned.replace(/,/g, "");

      // Extract just the number part
      const match = cleaned.match(/^\d+\.?\d*/);
      const result = match ? match[0] : "";

      console.log("Sanitized number result:", result);
      return result;
    }

    // Start scraping mode for a specific field
    startScraping(field, inputId) {
      console.log("Starting scraping for field:", field, "inputId:", inputId);
      console.log("Overlay found:", !!this.overlay);

      this.selectedField = field;
      this.targetInputId = inputId;
      this.targetImageId = null; // Clear image ID when scraping form fields

      if (this.overlay) {
        this.overlay.style.pointerEvents = "auto";
        this.overlay.style.cursor = "crosshair";
        console.log("Set overlay to scraping mode");
      } else {
        console.error("Overlay not found!");
      }

      this.clearOverlay();
      this.isSelecting = false;
    }

    // Start scraping mode for image title
    startImageTitleScraping(imageId) {
      console.log("Starting image title scraping for:", imageId);
      console.log("Overlay found:", !!this.overlay);

      this.selectedField = "text"; // Set to text mode, not image mode
      this.targetInputId = null; // Clear form field ID
      this.targetImageId = imageId; // Set image ID for title scraping

      if (this.overlay) {
        this.overlay.style.pointerEvents = "auto";
        this.overlay.style.cursor = "crosshair";
        console.log("Set overlay to image title scraping mode (text OCR)");
      } else {
        console.error("Overlay not found!");
      }

      this.clearOverlay();
      this.isSelecting = false;
    }

    sendToOCR(blob, inputId, imageId) {
      console.log("Send to OCR");

      // Validate blob
      if (!blob || !(blob instanceof Blob) || blob.size === 0) {
        console.error("Invalid blob provided to sendToOCR");
        return;
      }

      // Set processing message in target input
      if (inputId) {
        const targetInput = this.container.querySelector(`#${inputId}`);
        if (targetInput) {
          targetInput.value = "Processing...";
        }
      }

      // Try multiple OCR services in sequence
      this.tryOCRService(blob, inputId, imageId, 0);
    }

    tryOCRService(blob, inputId, imageId, serviceIndex) {
      const services = [
        {
          name: "OCR.space",
          url: "https://api.ocr.space/parse/image",
          headers: { apikey: "K81932338788957" },
          body: (formData) => {
            formData.append("file", blob, "selection.png");
            formData.append("language", "eng");
            formData.append("isOverlayRequired", "false");
            formData.append("OCREngine", "2");
          },
        },
        {
          name: "OCR.space (backup)",
          url: "https://api.ocr.space/parse/image",
          headers: { apikey: "helloworld" }, // Free tier key
          body: (formData) => {
            formData.append("file", blob, "selection.png");
            formData.append("language", "eng");
            formData.append("isOverlayRequired", "false");
            formData.append("OCREngine", "1");
          },
        },
      ];

      if (serviceIndex >= services.length) {
        console.error("All OCR services failed");
        const errorMsg = "All OCR services failed. Please try again.";
        if (inputId) {
          const targetInput = this.container.querySelector(`#${inputId}`);
          if (targetInput) targetInput.value = errorMsg;
        }
        this.resetSelectionState();
        return;
      }

      const service = services[serviceIndex];
      console.log(`Trying OCR service: ${service.name}`);

      const formData = new FormData();
      service.body(formData);

      // Add timeout to prevent hanging
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout per service

      fetch(service.url, {
        method: "POST",
        headers: service.headers,
        body: formData,
        signal: controller.signal,
      })
        .then((response) => {
          clearTimeout(timeoutId);
          console.log(`${service.name} response status:`, response.status);
          if (!response.ok) {
            throw new Error(
              `${service.name} API error: ${response.status} ${response.statusText}`
            );
          }
          return response.json();
        })
        .then((data) => {
          console.log(`${service.name} response data:`, data);

          if (data.IsErroredOnProcessing) {
            const errorMsg = `${service.name} error: ${data.ErrorMessage || "Unknown error"}`;
            console.error(errorMsg);
            // Try next service
            this.tryOCRService(blob, inputId, imageId, serviceIndex + 1);
            return;
          }

          if (data.ParsedResults && data.ParsedResults[0].ParsedText) {
            // Get raw OCR text
            let rawText = data.ParsedResults[0].ParsedText.trim();
            console.log(`OCR text from ${service.name}:`, rawText);

            if (inputId) {
              const targetInput = this.container.querySelector(`#${inputId}`);
              if (targetInput) {
                // Check if this is a number input
                if (targetInput.type === "number") {
                  this.ocrText = this.sanitizeNumber(rawText);
                } else {
                  // Apply title case for text inputs
                  this.ocrText = this.toTitleCase(rawText);
                }
                targetInput.value = this.ocrText;
              }
            } else if (imageId) {
              // Handle image title OCR
              const titleInput = this.container.querySelector(
                `input[data-image-id="${imageId}"]`
              );
              if (titleInput) {
                // Apply title case for image titles
                this.ocrText = this.toTitleCase(rawText);
                titleInput.value = this.ocrText;

                // Update the stored image data
                const image = this.selectedImages.find(
                  (img) => img.id === imageId
                );
                if (image) {
                  image.title = this.ocrText;
                }

                console.log(
                  `Updated image ${imageId} title to: ${this.ocrText}`
                );
              }
            }

            // Reset selection state after successful OCR
            this.resetSelectionState();
          } else {
            const noTextMsg = "No text found.";
            if (inputId) {
              const targetInput = this.container.querySelector(`#${inputId}`);
              if (targetInput) targetInput.value = noTextMsg;
            }
            this.resetSelectionState();
          }
        })
        .catch((err) => {
          clearTimeout(timeoutId);
          console.error(`${service.name} error:`, err);

          // Try next service
          this.tryOCRService(blob, inputId, imageId, serviceIndex + 1);
        });
    }

    setupInputFieldListeners() {
      // Add event listeners for input fields (both form inputs and image title inputs)
      const inputFields = this.container.querySelectorAll(
        "input[data-field], input[data-image-id]"
      );
      console.log(
        "Setting up listeners for",
        inputFields.length,
        "input fields"
      );

      inputFields.forEach((input) => {
        this.setupSingleInputListener(input);
      });
    }

    setupUnitsSlider() {
      const slider = this.container.querySelector("#units-slider");
      const valueDisplay = this.container.querySelector("#units-value");

      if (!slider || !valueDisplay) return;

      const values = slider
        .getAttribute("data-values")
        .split(",")
        .map((v) => parseInt(v));

      // Update display when slider changes
      slider.addEventListener("input", (e) => {
        const index = parseInt(e.target.value);
        const actualValue = values[index];
        valueDisplay.textContent = actualValue;

        // Store the actual value in a data attribute for easy access
        slider.setAttribute("data-current-value", actualValue);
      });

      // Initialize with first value
      valueDisplay.textContent = values[0];
      slider.setAttribute("data-current-value", values[0]);
    }

    setupBuildingTypeRadio() {
      const buttons = this.container.querySelectorAll(".building-type-radio");

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const value = button.getAttribute("data-value");

          // Radio behavior - deselect all others first
          buttons.forEach((btn) => {
            btn.classList.remove(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            btn.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          });

          // Select the clicked button
          button.classList.add(
            "selected",
            "bg-blue-500",
            "text-white",
            "border-blue-500"
          );
          button.classList.remove(
            "bg-white",
            "dark:bg-gray-700",
            "text-gray-700",
            "dark:text-gray-300",
            "border-gray-300",
            "dark:border-gray-600",
            "hover:bg-gray-50",
            "dark:hover:bg-gray-600"
          );

          console.log("Building type selected:", value);
        });
      });
    }

    setupFireServiceTypeRadio() {
      const buttons = this.container.querySelectorAll(".fire-service-radio");

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const value = button.getAttribute("data-value");

          // Radio behavior - deselect all others first
          buttons.forEach((btn) => {
            btn.classList.remove(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            btn.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          });

          // Select the clicked button
          button.classList.add(
            "selected",
            "bg-blue-500",
            "text-white",
            "border-blue-500"
          );
          button.classList.remove(
            "bg-white",
            "dark:bg-gray-700",
            "text-gray-700",
            "dark:text-gray-300",
            "border-gray-300",
            "dark:border-gray-600",
            "hover:bg-gray-50",
            "dark:hover:bg-gray-600"
          );

          console.log("Fire service type selected:", value);
        });
      });
    }

    /* Multi-select building type setup (commented out for later use)
    setupBuildingTypeButtons() {
      const buttons = this.container.querySelectorAll(".building-type-btn");

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const value = button.getAttribute("data-value");

          // Toggle selection state
          if (button.classList.contains("selected")) {
            // Deselect
            button.classList.remove(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          } else {
            // Select
            button.classList.add(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.remove(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          }

          console.log(
            "Building type toggled:",
            value,
            button.classList.contains("selected")
          );
        });
      });
    }
    */

    setupConsultingServices() {
      const buttons = this.container.querySelectorAll(
        ".consulting-service-btn"
      );

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const value = button.getAttribute("data-value");

          // Toggle selection state (multi-select behavior)
          if (button.classList.contains("selected")) {
            // Deselect
            button.classList.remove(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          } else {
            // Select
            button.classList.add(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.remove(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          }

          console.log(
            "Consulting service toggled:",
            value,
            button.classList.contains("selected")
          );
        });
      });
    }

    setupFireSafetyServices() {
      const buttons = this.container.querySelectorAll(
        ".fire-safety-service-btn"
      );

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const value = button.getAttribute("data-value");

          // Toggle selection state (multi-select behavior)
          if (button.classList.contains("selected")) {
            // Deselect
            button.classList.remove(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          } else {
            // Select
            button.classList.add(
              "selected",
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.remove(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600",
              "hover:bg-gray-50",
              "dark:hover:bg-gray-600"
            );
          }

          console.log(
            "Fire safety service toggled:",
            value,
            button.classList.contains("selected")
          );
        });
      });
    }

    setupEscapeKeyHandler() {
      // Create bound handler function so we can remove it later if needed
      this.handleEscapeKey = (e) => {
        // Check if ESC key was pressed
        if (e.key === "Escape" || e.keyCode === 27) {
          // Check if we're currently in scrape mode
          if (this.overlay && this.overlay.style.pointerEvents === "auto") {
            console.log("ESC pressed - exiting scrape mode");

            // Find the currently focused input
            const focusedInput = document.activeElement;
            if (
              focusedInput &&
              (focusedInput.hasAttribute("data-field") ||
                focusedInput.hasAttribute("data-image-id"))
            ) {
              // Blur the focused input (this will trigger the blur handler)
              focusedInput.blur();
            }

            // Reset scrape state immediately
            this.resetSelectionState();

            // Add visual feedback that scrape mode was exited
            this.showEscapeFeedback();

            // Prevent default ESC behavior
            e.preventDefault();
          }
        }
      };

      // Add event listener to document
      document.addEventListener("keydown", this.handleEscapeKey);

      console.log("ESC key handler setup for scrape mode exit");
    }

    showEscapeFeedback() {
      // Add a subtle flash to the overlay to indicate scrape mode exit
      if (this.overlay) {
        const ctx = this.overlay.getContext("2d");

        // Save current overlay state
        const imageData = ctx.getImageData(
          0,
          0,
          this.overlay.width,
          this.overlay.height
        );

        // Flash with a semi-transparent overlay
        ctx.fillStyle = "rgba(59, 130, 246, 0.1)"; // Blue flash
        ctx.fillRect(0, 0, this.overlay.width, this.overlay.height);

        // Restore original state after a brief moment
        setTimeout(() => {
          if (this.overlay) {
            ctx.putImageData(imageData, 0, 0);
          }
        }, 150);
      }

      // Also show a small toast-like message
      this.showToastMessage("Scrape mode exited (ESC)", "info");
    }

    showToastMessage(message, type = "info") {
      // Create a temporary toast message
      const toast = document.createElement("div");
      toast.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-md text-sm font-medium transition-all duration-300 transform translate-x-full opacity-0`;

      // Style based on type
      if (type === "info") {
        toast.className += " bg-blue-500 text-white";
      }

      toast.textContent = message;
      document.body.appendChild(toast);

      // Animate in
      setTimeout(() => {
        toast.style.transform = "translateX(0)";
        toast.style.opacity = "1";
      }, 10);

      // Animate out and remove
      setTimeout(() => {
        toast.style.transform = "translateX(full)";
        toast.style.opacity = "0";
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, 2000);
    }

    // Clean up method (call when PDFScraper is destroyed)
    cleanup() {
      if (this.handleEscapeKey) {
        document.removeEventListener("keydown", this.handleEscapeKey);
      }
    }

    setupSingleInputListener(input) {
      // Add focus listener to automatically start scraping mode
      input.addEventListener("focus", () => {
        const field = input.getAttribute("data-field");
        const inputId = input.getAttribute("id");
        const imageId = input.getAttribute("data-image-id");

        console.log(
          "Input focused:",
          field || `image-title-${imageId}`,
          inputId || imageId
        );

        // Clear any pending blur timeouts to prevent interference
        if (this.blurTimeout) {
          clearTimeout(this.blurTimeout);
          this.blurTimeout = null;
        }

        // For image title inputs, set up special OCR mode
        if (imageId) {
          this.startImageTitleScraping(imageId);
        } else if (field && inputId) {
          // Use the same logic as the + button click for form fields
          this.startScraping(field, inputId);
        }
      });

      // Add blur listener to stop scraping mode when focus is lost
      input.addEventListener("blur", () => {
        console.log("Input blurred");

        // Store timeout reference so focus can cancel it
        this.blurTimeout = setTimeout(() => {
          // Only reset if we're not currently in the middle of a selection
          if (!this.isSelecting) {
            console.log("Resetting scraping mode after blur");
            this.overlay.style.cursor = "default";
            this.overlay.style.pointerEvents = "none";
            this.targetInputId = null;
          }
          this.blurTimeout = null;
        }, 200);
      });
    }

    // updateScrapeButton removed - now handled by CSS pseudo-elements

    addImageToGallery(blob) {
      const imageId = `image-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const imageUrl = URL.createObjectURL(blob);

      // Store image data
      const imageData = {
        id: imageId,
        blob: blob,
        url: imageUrl,
        title: `Image ${this.selectedImages.length + 1}`,
      };
      this.selectedImages.push(imageData);

      // Add to gallery UI
      const imagesList = this.container.querySelector("#images-list");
      if (imagesList) {
        const imageItem = document.createElement("div");
        imageItem.className =
          "flex gap-3 p-3 border border-gray-200 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800";
        imageItem.innerHTML = `
          <img src="${imageUrl}" alt="Selected image" class="w-20 h-20 object-cover rounded border">
          <div class="flex-1 space-y-2">
            <div class="relative scrape-input-container">
              <input 
                type="text" 
                value="${imageData.title}"
                data-image-id="${imageId}"
                class="scrape-input w-full !pl-3 !pr-10 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="Enter image title..."
              >
            </div>
            <div class="flex gap-2">
              <button 
                onclick="window.currentPDFScraper.downloadImage('${imageId}')"
                class="px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600">
                Download
              </button>
              <button 
                onclick="window.currentPDFScraper.removeImage('${imageId}')"
                class="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600">
                Remove
              </button>
            </div>
          </div>
        `;
        imagesList.appendChild(imageItem);

        // Setup title input listener for value changes
        const titleInput = imageItem.querySelector(
          `input[data-image-id="${imageId}"]`
        );
        titleInput.addEventListener("input", (e) => {
          const image = this.selectedImages.find((img) => img.id === imageId);
          if (image) {
            image.title = e.target.value;
          }
        });

        // Setup scraping listeners for the new input
        this.setupSingleInputListener(titleInput);
      }

      console.log(
        `Added image ${imageId} to gallery. Total images: ${this.selectedImages.length}`
      );
    }

    downloadImage(imageId) {
      const image = this.selectedImages.find((img) => img.id === imageId);
      if (image) {
        const link = document.createElement("a");
        link.href = image.url;
        link.download = `${image.title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.png`;
        link.click();
      }
    }

    removeImage(imageId) {
      // Remove from array
      this.selectedImages = this.selectedImages.filter(
        (img) => img.id !== imageId
      );

      // Remove from UI
      const imageItem = this.container
        .querySelector(`input[data-image-id="${imageId}"]`)
        ?.closest(".flex");
      if (imageItem) {
        // Cleanup blob URL
        const image = this.selectedImages.find((img) => img.id === imageId);
        if (image) {
          URL.revokeObjectURL(image.url);
        }
        imageItem.remove();
      }

      console.log(
        `Removed image ${imageId}. Remaining images: ${this.selectedImages.length}`
      );
    }

    async saveProjectData() {
      console.log("Saving complete project data...");

      // Collect all form data
      const unitsSlider = this.container.querySelector("#units-slider");
      const selectedBuildingType =
        this.container
          .querySelector(".building-type-radio.selected")
          ?.getAttribute("data-value") || "";
      const selectedFireServiceType =
        this.container
          .querySelector(".fire-service-radio.selected")
          ?.getAttribute("data-value") || "";
      const selectedConsultingServices = Array.from(
        this.container.querySelectorAll(".consulting-service-btn.selected")
      ).map((btn) => btn.getAttribute("data-value"));

      console.log("Consulting services selection:", {
        buttonsFound: this.container.querySelectorAll(
          ".consulting-service-btn.selected"
        ).length,
        selectedValues: selectedConsultingServices,
        allConsultingButtons: Array.from(
          this.container.querySelectorAll(".consulting-service-btn")
        ).map((btn) => ({
          text: btn.textContent?.trim(),
          hasSelected: btn.classList.contains("selected"),
          hasBgBlue: btn.classList.contains("bg-blue-500"),
          dataValue: btn.getAttribute("data-value"),
        })),
      });
      const selectedFireSafetyServices = Array.from(
        this.container.querySelectorAll(".fire-safety-service-btn.selected")
      ).map((btn) => btn.getAttribute("data-value"));

      // Get owner data based on toggle selection
      const isExistingUser =
        this.container.querySelector("#owner-type-toggle")?.checked || false;
      let ownerData = {};

      if (!isExistingUser) {
        // New user data
        ownerData = {
          owner_type: "new",
          owner_name:
            this.container.querySelector("#owner-name-input")?.value || "",
          owner_email:
            this.container.querySelector("#owner-email-input")?.value || "",
          owner_phone:
            this.container.querySelector("#owner-phone-input")?.value || "",
          owner: this.container.querySelector("#owner-name-input")?.value || "", // Legacy compatibility
        };
      } else {
        // Existing user data
        const selectedUserId =
          this.container.querySelector("#existing-user-id")?.value || "";
        const selectedUserName =
          this.container.querySelector("#existing-user-search")?.value || "";

        ownerData = {
          owner_type: "existing",
          existing_user_id: selectedUserId,
          owner: selectedUserName, // Legacy compatibility
        };
      }

      const formData = {
        address: this.container.querySelector("#address-input")?.value || "",
        ...ownerData,
        architect:
          this.container.querySelector("#architect-input")?.value || "",
        squareFootage:
          this.container.querySelector("#square-foot-input")?.value || "",
        units: unitsSlider?.getAttribute("data-current-value") || "1",
        buildingType: selectedBuildingType,
        fireServiceType: selectedFireServiceType,
        consultingServices: selectedConsultingServices,
        fireSafetyServices: selectedFireSafetyServices,
        sprinkler:
          this.container.querySelector("#sprinkler-toggle")?.checked || false,
        alarm: this.container.querySelector("#alarm-toggle")?.checked || false,
        images: this.selectedImages.map((img) => ({
          title: img.title,
          blob: img.blob,
        })),
      };

      console.log("Project data to save:", formData);

      // Show saving state
      const saveBtn = this.container.querySelector("#save-project");
      if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saving...";
        saveBtn.disabled = true;

        try {
          console.log("Starting project save...");
          console.log("Project ID:", this.projectId);
          console.log("Form data:", formData);

          // Check if we have a project ID to update
          if (!this.projectId) {
            console.error("No project ID found");
            throw new Error("No project ID found. Please upload a PDF first.");
          }

          // Clean address for title (remove state and zip code)
          console.log("Cleaning address:", formData.address);
          const cleanedTitle = this.cleanAddressForTitle(formData.address);
          console.log("Cleaned title:", cleanedTitle);

          // Prepare metadata to store as JSON (use formData directly)
          const projectMetadata = {
            ...formData,
            // Remove images from metadata since they're handled separately
            images: undefined,
          };

          console.log("Project metadata:", projectMetadata);

          // Safely stringify metadata
          let metadataString;
          try {
            metadataString = JSON.stringify(projectMetadata);
            console.log("Metadata JSON string length:", metadataString.length);
          } catch (jsonError) {
            console.error("Error stringifying metadata:", jsonError);
            throw new Error("Error preparing project data for storage");
          }

          // Validate and prepare square footage (PostgreSQL integer max: 2,147,483,647)
          let squareFootage = parseInt(formData.squareFootage) || 0;
          const MAX_INTEGER = 2147483647;

          if (squareFootage > MAX_INTEGER) {
            console.warn(
              `Square footage ${squareFootage} exceeds database limit. Setting to maximum allowed value.`
            );
            squareFootage = MAX_INTEGER;

            // Show warning to user
            alert(
              `Warning: Square footage value is too large (max: ${MAX_INTEGER.toLocaleString()}). Value has been adjusted.`
            );
          }

          if (squareFootage < 0) {
            console.warn(
              `Square footage ${squareFootage} is negative. Setting to 0.`
            );
            squareFootage = 0;
          }

          // Prepare update data
          const updateData = {
            title: cleanedTitle || formData.address || "Project",
            address: formData.address || "",
            description: metadataString,
            sq_ft: squareFootage,
            new_construction: formData.buildingType === "New Construction",
            // Add button group fields with correct database column names
            building: formData.buildingType || null,
            project: formData.consultingServices
              ? JSON.stringify(formData.consultingServices)
              : null,
            service: formData.fireServiceType || null,
            requested_docs: formData.fireSafetyServices
              ? JSON.stringify(formData.fireSafetyServices)
              : null,
            status: 0,
          };

          console.log("Button group data being saved:", {
            buildingType: formData.buildingType,
            consultingServices: formData.consultingServices,
            fireServiceType: formData.fireServiceType,
            fireSafetyServices: formData.fireSafetyServices,
            projectField: formData.consultingServices?.join(", ") || null,
          });

          console.log("Update data:", updateData);

          // Check if supabase client exists
          if (!this.supabase) {
            console.error("Supabase client not found");
            throw new Error("Database connection not available");
          }

          // Update the existing project with all metadata
          console.log("Executing database update...");
          const { data: updatedProject, error: updateError } =
            await this.supabase
              .from("projects")
              .update(updateData)
              .eq("id", this.projectId)
              .select()
              .single();

          if (updateError) {
            console.error("Database update error:", updateError);
            throw new Error(`Database error: ${updateError.message}`);
          }

          console.log("Project updated successfully:", updatedProject);

          // Update save button to show success
          saveBtn.textContent = "Saved!";
          saveBtn.disabled = false;
          saveBtn.className = saveBtn.className
            .replace("bg-green-500", "bg-green-600")
            .replace("hover:bg-green-600", "hover:bg-green-700");
          console.log("Save button updated to 'Saved!'");

          // Show a toast notification
          this.showSaveSuccessToast();

          // Refresh project list
          if (window.projectsList && window.projectsList.loadProjects) {
            window.projectsList.loadProjects();
          }

          // Exit "new project" mode by showing success message and resetting
          setTimeout(() => {
            this.resetForNewProject();
          }, 1000);
        } catch (error) {
          console.error("Error saving project data:", error);
          console.error("Error details:", {
            message: error.message,
            stack: error.stack,
            projectId: this.projectId,
            formData: formData,
          });

          saveBtn.textContent = "Error saving";
          setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
          }, 2000);

          // Show more detailed error message
          const errorMessage = error.message || "Unknown error occurred";
          alert(
            `Error saving project: ${errorMessage}\n\nCheck browser console for details.`
          );
        }
      }
    }

    cleanAddressForTitle(address) {
      try {
        if (!address || typeof address !== "string") {
          console.log(
            "Invalid address provided to cleanAddressForTitle:",
            address
          );
          return "";
        }

        // Remove state and zip code from address
        // Common formats: "123 Main St, City, State 12345" or "123 Main St, City, ST 12345-1234"
        // Strategy: Remove everything after the second comma, or remove state/zip patterns

        let cleanedAddress = address.trim();

        // Method 1: Remove everything after the second comma
        const commaCount = (cleanedAddress.match(/,/g) || []).length;
        if (commaCount >= 2) {
          const parts = cleanedAddress.split(",");
          cleanedAddress = parts.slice(0, 2).join(",").trim();
        }

        // Method 2: Remove common state/zip patterns at the end
        // Remove patterns like "CA 12345", "California 12345-1234", etc.
        cleanedAddress = cleanedAddress.replace(
          /,?\s*[A-Z]{2}\s+\d{5}(-\d{4})?$/i,
          ""
        );
        cleanedAddress = cleanedAddress.replace(
          /,?\s*[A-Za-z\s]+\s+\d{5}(-\d{4})?$/i,
          ""
        );

        // Remove trailing comma and spaces
        cleanedAddress = cleanedAddress.replace(/,\s*$/, "").trim();

        return cleanedAddress;
      } catch (error) {
        console.error(
          "Error in cleanAddressForTitle:",
          error,
          "Address:",
          address
        );
        return address || ""; // Return original address or empty string as fallback
      }
    }

    populateFormFromProject(project) {
      console.log("Populating form with project data:", project);

      try {
        // Parse metadata from description field (stored as JSON)
        let metadata = {};
        if (project.description) {
          try {
            metadata = JSON.parse(project.description);
            console.log("Successfully parsed metadata:", metadata);
          } catch (e) {
            console.warn("Could not parse project metadata:", e);
            console.log("Raw description:", project.description);
            metadata = {};
          }
        } else {
          console.log("No description field found in project");
        }

        // Populate basic form fields
        if (project.address) {
          const addressInput = this.container.querySelector("#address-input");
          if (addressInput) {
            addressInput.value = project.address;
            console.log("Set address to:", project.address);
          } else {
            console.warn("Address input not found");
          }
        }

        // Populate owner fields based on type
        console.log("Owner type from metadata:", metadata.owner_type);
        if (metadata.owner_type === "existing" && metadata.existing_user_id) {
          console.log("Setting up existing user mode");
          // Set existing user toggle
          const ownerTypeToggle =
            this.container.querySelector("#owner-type-toggle");
          if (ownerTypeToggle) {
            ownerTypeToggle.checked = true;
            this.updateOwnerInputs(true); // Show existing user inputs
            console.log("Set owner type toggle to existing user");
          } else {
            console.warn("Owner type toggle not found");
          }

          // Set the selected user in search input
          const existingUserSearch = this.container.querySelector(
            "#existing-user-search"
          );
          const existingUserId =
            this.container.querySelector("#existing-user-id");

          if (existingUserSearch && existingUserId) {
            // We need to find the user name by ID
            if (this.availableUsers) {
              const user = this.availableUsers.find(
                (u) => u.id === metadata.existing_user_id
              );
              if (user) {
                existingUserSearch.value = user.name;
                existingUserId.value = user.id;
              }
            }
          }
        } else {
          console.log("Setting up new user mode");
          // Set new user toggle (default state)
          const ownerTypeToggle =
            this.container.querySelector("#owner-type-toggle");
          if (ownerTypeToggle) {
            ownerTypeToggle.checked = false;
            this.updateOwnerInputs(false); // Show new user inputs
            console.log("Set owner type toggle to new user");
          } else {
            console.warn("Owner type toggle not found");
          }

          // Populate new user fields
          if (metadata.owner_name) {
            const ownerNameInput =
              this.container.querySelector("#owner-name-input");
            if (ownerNameInput) {
              ownerNameInput.value = metadata.owner_name;
              console.log("Set owner name to:", metadata.owner_name);
            } else {
              console.warn("Owner name input not found");
            }
          }

          if (metadata.owner_email) {
            const ownerEmailInput =
              this.container.querySelector("#owner-email-input");
            if (ownerEmailInput) {
              ownerEmailInput.value = metadata.owner_email;
              console.log("Set owner email to:", metadata.owner_email);
            } else {
              console.warn("Owner email input not found");
            }
          }

          if (metadata.owner_phone) {
            const ownerPhoneInput =
              this.container.querySelector("#owner-phone-input");
            if (ownerPhoneInput) {
              ownerPhoneInput.value = metadata.owner_phone;
              console.log("Set owner phone to:", metadata.owner_phone);
            } else {
              console.warn("Owner phone input not found");
            }
          }
        }

        // Legacy compatibility - populate hidden owner input
        if (metadata.owner) {
          const ownerInput = this.container.querySelector("#owner-input");
          if (ownerInput) ownerInput.value = metadata.owner;
        }

        // Also populate the visible owner input field for backward compatibility
        if (metadata.owner_name) {
          const ownerInput = this.container.querySelector("#owner-input");
          if (ownerInput) ownerInput.value = metadata.owner_name;
        }

        if (metadata.architect) {
          const architectInput =
            this.container.querySelector("#architect-input");
          if (architectInput) {
            architectInput.value = metadata.architect;
            console.log("Set architect to:", metadata.architect);
          } else {
            console.warn("Architect input not found");
          }
        }

        if (metadata.squareFootage) {
          const sqFtInput = this.container.querySelector("#square-foot-input");
          if (sqFtInput) {
            sqFtInput.value = metadata.squareFootage;
            console.log("Set square footage to:", metadata.squareFootage);
          } else {
            console.warn("Square footage input not found");
          }
        } else if (project.sq_ft) {
          const sqFtInput = this.container.querySelector("#square-foot-input");
          if (sqFtInput) {
            sqFtInput.value = project.sq_ft.toString();
            console.log("Set square footage to:", project.sq_ft);
          } else {
            console.warn("Square footage input not found");
          }
        }

        // Populate units slider
        if (metadata.units) {
          const unitsSlider = this.container.querySelector("#units-slider");
          const unitsValue = this.container.querySelector("#units-value");
          console.log("Populating units slider with:", metadata.units);
          if (unitsSlider) {
            const unitsIndex = parseInt(metadata.units) - 1;
            unitsSlider.value = unitsIndex.toString();
            unitsSlider.setAttribute("data-current-value", metadata.units);
            console.log("Set units slider value to:", unitsIndex);
          } else {
            console.warn("Units slider not found");
          }
          if (unitsValue) {
            unitsValue.textContent = metadata.units;
            console.log("Set units value text to:", metadata.units);
          } else {
            console.warn("Units value display not found");
          }
        }

        // Populate building type selection
        if (metadata.buildingType) {
          const buildingTypeBtn = this.container.querySelector(
            `.building-type-radio[data-value="${metadata.buildingType}"]`
          );
          if (buildingTypeBtn) {
            this.selectButton(buildingTypeBtn);
          }
        }

        // Populate fire service type selection
        if (metadata.fireServiceType) {
          const fireServiceBtn = this.container.querySelector(
            `.fire-service-radio[data-value="${metadata.fireServiceType}"]`
          );
          if (fireServiceBtn) {
            this.selectButton(fireServiceBtn);
          }
        }

        // Populate consulting services (multi-select)
        if (
          metadata.consultingServices &&
          Array.isArray(metadata.consultingServices)
        ) {
          metadata.consultingServices.forEach((service) => {
            const serviceBtn = this.container.querySelector(
              `.consulting-service-btn[data-value="${service}"]`
            );
            if (serviceBtn) {
              this.selectButton(serviceBtn);
            }
          });
        }

        // Populate fire safety services (multi-select)
        if (
          metadata.fireSafetyServices &&
          Array.isArray(metadata.fireSafetyServices)
        ) {
          metadata.fireSafetyServices.forEach((service) => {
            const serviceBtn = this.container.querySelector(
              `.fire-safety-service-btn[data-value="${service}"]`
            );
            if (serviceBtn) {
              this.selectButton(serviceBtn);
            }
          });
        }

        // Populate toggles
        if (metadata.sprinkler !== undefined) {
          const sprinklerToggle =
            this.container.querySelector("#sprinkler-toggle");
          if (sprinklerToggle) sprinklerToggle.checked = metadata.sprinkler;
        }

        if (metadata.alarm !== undefined) {
          const alarmToggle = this.container.querySelector("#alarm-toggle");
          if (alarmToggle) alarmToggle.checked = metadata.alarm;
        }

        console.log("Form populated successfully");
      } catch (error) {
        console.error("Error populating form:", error);
      }
    }

    selectButton(button) {
      // Helper method to select a button with proper styling
      button.classList.add(
        "selected",
        "bg-blue-500",
        "text-white",
        "border-blue-500"
      );
      button.classList.remove(
        "bg-white",
        "dark:bg-gray-700",
        "text-gray-700",
        "dark:text-gray-300",
        "border-gray-300",
        "dark:border-gray-600",
        "hover:bg-gray-50",
        "dark:hover:bg-gray-600"
      );
    }

    clearProjectData() {
      console.log("Clearing all project data...");

      // Clear form inputs
      const inputs = this.container.querySelectorAll(
        "#address-input, #owner-input, #architect-input, #square-foot-input"
      );
      inputs.forEach((input) => {
        if (input) input.value = "";
      });

      // Clear toggles
      const sprinklerToggle = this.container.querySelector("#sprinkler-toggle");
      const alarmToggle = this.container.querySelector("#alarm-toggle");
      if (sprinklerToggle) sprinklerToggle.checked = false;
      if (alarmToggle) alarmToggle.checked = false;

      // Reset units slider
      const unitsSlider = this.container.querySelector("#units-slider");
      const unitsValue = this.container.querySelector("#units-value");
      if (unitsSlider) {
        unitsSlider.value = "0";
        unitsSlider.setAttribute("data-current-value", "1");
      }
      if (unitsValue) {
        unitsValue.textContent = "1";
      }

      // Clear building type selection
      const buildingTypeButtons = this.container.querySelectorAll(
        ".building-type-radio"
      );
      buildingTypeButtons.forEach((button) => {
        button.classList.remove(
          "selected",
          "bg-blue-500",
          "text-white",
          "border-blue-500"
        );
        button.classList.add(
          "bg-white",
          "dark:bg-gray-700",
          "text-gray-700",
          "dark:text-gray-300",
          "border-gray-300",
          "dark:border-gray-600",
          "hover:bg-gray-50",
          "dark:hover:bg-gray-600"
        );
      });

      // Clear fire service type selection
      const fireServiceTypeButtons = this.container.querySelectorAll(
        ".fire-service-radio"
      );
      fireServiceTypeButtons.forEach((button) => {
        button.classList.remove(
          "selected",
          "bg-blue-500",
          "text-white",
          "border-blue-500"
        );
        button.classList.add(
          "bg-white",
          "dark:bg-gray-700",
          "text-gray-700",
          "dark:text-gray-300",
          "border-gray-300",
          "dark:border-gray-600",
          "hover:bg-gray-50",
          "dark:hover:bg-gray-600"
        );
      });

      // Clear consulting services selections
      const consultingServiceButtons = this.container.querySelectorAll(
        ".consulting-service-btn"
      );
      consultingServiceButtons.forEach((button) => {
        button.classList.remove(
          "selected",
          "bg-blue-500",
          "text-white",
          "border-blue-500"
        );
        button.classList.add(
          "bg-white",
          "dark:bg-gray-700",
          "text-gray-700",
          "dark:text-gray-300",
          "border-gray-300",
          "dark:border-gray-600",
          "hover:bg-gray-50",
          "dark:hover:bg-gray-600"
        );
      });

      // Clear fire safety services selections
      const fireSafetyServiceButtons = this.container.querySelectorAll(
        ".fire-safety-service-btn"
      );
      fireSafetyServiceButtons.forEach((button) => {
        button.classList.remove(
          "selected",
          "bg-blue-500",
          "text-white",
          "border-blue-500"
        );
        button.classList.add(
          "bg-white",
          "dark:bg-gray-700",
          "text-gray-700",
          "dark:text-gray-300",
          "border-gray-300",
          "dark:border-gray-600",
          "hover:bg-gray-50",
          "dark:hover:bg-gray-600"
        );
      });

      // Clear all images
      this.selectedImages.forEach((img) => {
        URL.revokeObjectURL(img.url);
      });
      this.selectedImages = [];

      // Clear image gallery
      const imagesList = this.container.querySelector("#images-list");
      if (imagesList) {
        imagesList.innerHTML = "";
      }

      // Hide image gallery if empty
      const galleryContainer =
        this.container.querySelector("#images-container");
      if (galleryContainer) {
        galleryContainer.classList.add("hidden");
      }

      console.log("Project data cleared");
    }

    resetForNewProject() {
      console.log("Resetting for new project...");

      // Show success message briefly
      const successMessage = document.createElement("div");
      successMessage.className =
        "text-center py-8 text-green-600 dark:text-green-400 font-medium";
      successMessage.innerHTML = `
        <div class="mb-4">
          <svg class="w-16 h-16 mx-auto text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
          </svg>
        </div>
        <p class="text-lg">Project Saved Successfully!</p>
        <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">You can now upload a new PDF to start another project.</p>
      `;

      this.container.innerHTML = "";
      this.container.appendChild(successMessage);

      // After showing success message, reset to uploader
      setTimeout(() => {
        // Clear all project data first
        this.clearProjectData();

        // Reset project ID and other state
        this.projectId = null;
        this.uploadedFile = null;
        this.publicUrl = null;

        // Clear global references to prevent auto-loading
        window.currentPDFScraper = null;

        // Mark that we want a fresh start (to override auto-loading)
        window.forceNewProject = true;

        // Restore layout: show projects list, restore original widths
        if (window.toggleLayoutForPDF) {
          window.toggleLayoutForPDF(false);
        }

        // Clear the entire container and show uploader again
        this.container.innerHTML = "";

        try {
          // Create new uploader instance
          const uploader = new PDFUploader(this.container);

          console.log("Reset complete - ready for new project");
        } catch (error) {
          console.error("Error creating new uploader:", error);
          // Fallback: reload the page
          window.location.reload();
        }
      }, 2000);
    }
  }

  // Initialize the uploader when the DOM is loaded
  document.addEventListener("DOMContentLoaded", async () => {
    const container = document.getElementById("new-project-upload");
    if (container) {
      // Check if there's already a PDF file for this project
      // Reuse existing supabase client if available, otherwise create new one
      let supabase;
      if (window.supabaseClient) {
        supabase = window.supabaseClient;
      } else {
        supabase = createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
        window.supabaseClient = supabase; // Store for reuse
      }

      // Set up session if tokens are available
      if (window.SUPABASE_ACCESS_TOKEN && window.SUPABASE_REFRESH_TOKEN) {
        try {
          console.log("Setting up client-side session...");
          const { data, error } = await supabase.auth.setSession({
            access_token: window.SUPABASE_ACCESS_TOKEN,
            refresh_token: window.SUPABASE_REFRESH_TOKEN,
          });
          console.log("Session setup result:", { data, error });
        } catch (error) {
          console.error("Error setting up session:", error);
        }
      } else {
        console.log("No tokens available for client-side auth");
      }

      // Get current user
      const {
        data: { user },
        error: userError,
      } = await supabase.auth.getUser();

      console.log("Client-side user check:", { user, userError });

      if (user && !userError) {
        // Check if we're forcing a new project (after save)
        if (window.forceNewProject) {
          console.log("Forcing new project - skipping existing project check");
          window.forceNewProject = false; // Reset the flag
          new PDFUploader(container);
          return;
        }

        // Default behavior: Always start fresh with uploader
        console.log("Starting fresh with new project uploader");
        new PDFUploader(container);
        window.currentPDFScraper = null; // Clear any existing scraper reference

        // Optional: Add a "Load Previous Project" button for users who want to continue existing work
        // const loadPreviousBtn = document.createElement("div");
        // loadPreviousBtn.className = "mt-4 text-center";
        // loadPreviousBtn.innerHTML = `
        //   <button
        //     id="load-previous-project"
        //     class="text-sm text-blue-600 dark:text-blue-400 hover:underline"
        //   >
        //     Load Previous Project
        //   </button>
        // `;
        // container.appendChild(loadPreviousBtn);

        // Add click handler for loading previous project
        // const loadBtn = loadPreviousBtn.querySelector("#load-previous-project");
        // loadBtn?.addEventListener("click", async () => {
        //   console.log("Loading previous project...");
        //   loadBtn.textContent = "Loading...";

        //   try {
        //     // Query for the most recent project
        //     const { data: files, error: filesError } = await supabase
        //       .from("files")
        //       .select(
        //         "id, author_id, project_id, file_type, status, file_path, name"
        //       )
        //       .eq("author_id", user.id)
        //       .eq("file_type", "application/pdf")
        //       .eq("status", "active")
        //       .order("uploaded_at", { ascending: false })
        //       .limit(1);

        //     if (files && files.length > 0 && !filesError) {
        //       const file = files[0];

        //       if (!file.project_id) {
        //         throw new Error("No valid project found");
        //       }

        //       // Get the project data
        //       const { data: project, error: projectError } = await supabase
        //         .from("projects")
        //         .select("*")
        //         .eq("id", file.project_id)
        //         .single();

        //       if (project && !projectError) {
        //         // Get the public URL for the file
        //         const {
        //           data: { publicUrl },
        //         } = supabase.storage
        //           .from("project-documents")
        //           .getPublicUrl(file.file_path);

        //         console.log("Loading existing PDF:", publicUrl);

        //         // Clear container and load existing project
        //         container.innerHTML = "";

        //         // Create PDF viewer with existing file
        //         new PDFViewer(container, null, publicUrl, project.id);
        //         const scraper = new PDFScraper(container);

        //         // Set the project ID so saving works correctly
        //         scraper.projectId = project.id;

        //         // Populate form with existing project data
        //         scraper.populateFormFromProject(project);

        //         window.currentPDFScraper = scraper;
        //       } else {
        //         throw new Error("Error loading project data");
        //       }
        //     } else {
        //       throw new Error("No previous projects found");
        //     }
        //   } catch (error) {
        //     console.error("Error loading previous project:", error);
        //     loadBtn.textContent = "No previous project found";
        //     setTimeout(() => {
        //       loadPreviousBtn.remove();
        //     }, 2000);
        //   }
        // });
      } else {
        // No user or error, show uploader
        console.log("User error:", userError);
        new PDFUploader(container);
      }
    }
  });
</script>

<style>
  .pdf-meta-extractor-selection-rect {
    border: 2px dashed #3b82f6;
    background-color: rgba(59, 130, 246, 0.1);
    position: absolute;
    pointer-events: none;
  }

  /* Scrape input pseudo-element buttons */
  /* Input container styling */
  .scrape-input-container {
    position: relative;
  }

  /* Default + icon */
  .scrape-input-container::after {
    content: "\ebc0"; /* bx-plus */
    font-family: "boxicons";
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    background: #f3f4f6;
    color: #6b7280;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    transition: all 0.2s ease;
    cursor: pointer;
    pointer-events: none;
  }

  .dark .scrape-input-container::after {
    background: #4b5563;
    color: #d1d5db;
  }

  /* Pulsing when input is focused */
  .scrape-input-container:has(.scrape-input:focus)::after {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    color: #3b82f6;
  }

  .dark .scrape-input-container:has(.scrape-input:focus)::after {
    color: #60a5fa;
  }

  /* Hover state */
  .scrape-input-container:hover::after {
    background: #e5e7eb;
    color: #3b82f6;
  }

  .dark .scrape-input-container:hover::after {
    background: #374151;
    color: #60a5fa;
  }

  /* Show X when input has value */
  .scrape-input-container:has(.scrape-input:not(:placeholder-shown))::after {
    content: "\ec8d"; /* bx-x */
    color: #ef4444;
  }

  .dark
    .scrape-input-container:has(.scrape-input:not(:placeholder-shown))::after {
    color: #f87171;
  }

  /* Units slider styling - Override Flowbite */
  .units-range-slider {
    -webkit-appearance: none !important;
    appearance: none !important;
    background: transparent !important;
    cursor: pointer !important;
    height: 8px !important;
  }

  .units-range-slider::-webkit-slider-track {
    -webkit-appearance: none !important;
    background: #e5e7eb !important;
    height: 8px !important;
    border-radius: 4px !important;
    border: none !important;
  }

  .dark .units-range-slider::-webkit-slider-track {
    background: #374151 !important;
  }

  .units-range-slider::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 20px !important;
    width: 20px !important;
    border-radius: 50% !important;
    background: #3b82f6 !important;
    cursor: pointer !important;
    border: 2px solid #ffffff !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
    margin-top: -6px !important;
  }

  .units-range-slider::-moz-range-track {
    background: #e5e7eb !important;
    height: 8px !important;
    border-radius: 4px !important;
    border: none !important;
  }

  .dark .units-range-slider::-moz-range-track {
    background: #374151 !important;
  }

  .units-range-slider::-moz-range-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 20px !important;
    width: 20px !important;
    border-radius: 50% !important;
    background: #3b82f6 !important;
    cursor: pointer !important;
    border: 2px solid #ffffff !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
  }

  .dark .units-range-slider::-webkit-slider-thumb {
    background: #60a5fa !important;
  }

  .dark .units-range-slider::-moz-range-thumb {
    background: #60a5fa !important;
  }

  .units-range-slider:focus {
    outline: none !important;
  }

  .units-range-slider:focus::-webkit-slider-thumb {
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
  }

  /* Additional Flowbite override */
  input[type="range"].units-range-slider {
    -webkit-appearance: none !important;
    appearance: none !important;
    background: transparent !important;
    border: none !important;
    outline: none !important;
  }

  /* Ensure track is visible */
  input[type="range"].units-range-slider::-webkit-slider-runnable-track {
    -webkit-appearance: none !important;
    background: #e5e7eb !important;
    height: 8px !important;
    border-radius: 4px !important;
  }

  .dark input[type="range"].units-range-slider::-webkit-slider-runnable-track {
    background: #374151 !important;
  }

  /* Building type buttons - disable hover when selected */
  .building-type-btn.selected:hover,
  .building-type-radio.selected:hover,
  .fire-service-radio.selected:hover {
    background-color: #3b82f6 !important;
    color: white !important;
    border-color: #3b82f6 !important;
  }

  .dark .building-type-btn.selected:hover,
  .dark .building-type-radio.selected:hover,
  .dark .fire-service-radio.selected:hover {
    background-color: #3b82f6 !important;
    color: white !important;
    border-color: #3b82f6 !important;
  }

  /* PDF Canvas drag styling */
  #pdf-canvas {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  #pdf-canvas:active {
    cursor: grabbing !important;
  }

  /* Smooth transition for drag feedback */
  #pdf-canvas {
    transition: transform 0.2s ease-out;
  }

  /* Disable text selection on canvas container during drag */
  #pdf-canvas-container {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  /* Ensure overlay doesn't interfere when inactive */
  #pdf-meta-extractor-overlay {
    pointer-events: none; /* Default to inactive */
    position: absolute;
    z-index: 10;
  }

  /* Only when explicitly activated for scraping */
  #pdf-meta-extractor-overlay[style*="pointer-events: auto"] {
    z-index: 20;
  }
</style>
