---
/**
 * StandardForm - Single-page form renderer for MultiStepFormConfig
 * Accepts the same config as MultiStepForm; flattens all steps into one form.
 * Use when you want a traditional single-page form instead of step-by-step.
 *
 * Example: <StandardForm config={loginFormConfig} initialData={{ redirect: "/dashboard" }} />
 */
import type {
  MultiStepFormConfig,
  FormFieldConfig,
  FormStepConfig,
} from "../../../lib/multi-step-form-config";
import { getButtonConfig, normalizeFormConfig } from "../../../lib/multi-step-form-config";
import Button from "../../../components/common/Button.astro";
import SimpleIcon from "../../../components/common/SimpleIcon.astro";
import AuthProviders from "../../../components/form/AuthProviders.astro";
import InlineAddressSearch from "../../../components/form/InlineAddressSearch.astro";
import UnitSlider from "../../../components/form/UnitSlider.astro";
import ToggleButton from "../../../components/form/ToggleButton.astro";
import FileUpload from "../../../components/form/FileUpload.astro";
import SlideToggle from "../../../components/form/SlideToggle.astro";
import SlotMachineModalStaff from "../../../components/form/SlotMachineModalStaff.astro";
import { SMS_UTILS } from "../../../lib/sms-utils";
import { globalClasses } from "../../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
}

const {
  config: rawConfig,
  containerClass = "min-w-sm max-w-md sm:max-w-lg md:max-w-xl lg:max-w-2xl mx-auto w-full",
  initialData = {},
} = Astro.props;

const config = normalizeFormConfig(rawConfig);

const { multiStepInputClasses } = globalClasses();
const appendedMultiStepInputClasses = multiStepInputClasses;

const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));

/** Flatten all fields from all steps (skip review steps) */
function flattenFields(steps: FormStepConfig[]): FormFieldConfig[] {
  return steps.filter((s) => !s.isReview).flatMap((s) => s.fields || []);
}

/** First step that has auth providers */
function getAuthProviderStep(steps: FormStepConfig[]): FormStepConfig | undefined {
  return steps.find(
    (s) => s.additionalContent === "google-oauth" || s.additionalContent === "auth-providers"
  );
}

/** Submit button from last step, or config default */
function getSubmitButton(config: MultiStepFormConfig) {
  const steps = config.steps.filter((s) => !s.isReview);
  const lastStep = steps[steps.length - 1];
  const submitBtn = lastStep?.buttons?.find((b) => b.type === "submit");
  const defaults = config.buttonDefaults?.submit || {};
  return getButtonConfig(submitBtn || { type: "submit", ...defaults }, defaults);
}

const allFields = flattenFields(config.steps);
const authStep = getAuthProviderStep(config.steps);
const submitConfig = getSubmitButton(config);

/** Resolve hidden field value: initialData overrides config */
function getHiddenValue(name: string): string {
  if (initialData[name] !== undefined && initialData[name] !== null) {
    return String(initialData[name]);
  }
  const fromConfig = config.hiddenFields?.find((f) => f.name === name);
  return fromConfig?.value ?? "";
}
---

<div data-standard-form class={containerClass}>
  {
    config.responseType === "inline" && (
      <div id={`${config.formId}-response-alert`} class="w-100 mb-4 hidden p-2" role="alert" />
    )
  }
  <form
    id={config.formId}
    action={config.formAction}
    method={config.formMethod || "post"}
    class="space-y-6"
    data-form-config={JSON.stringify({ formId: config.formId, formConfig: config, initialData })}
  >
    {/* Auth providers (login/register) */}
    {
      authStep && (
        <div>
          <AuthProviders
            mode={authStep.additionalContent === "auth-providers" ? "login" : "register"}
          />
          <div class="flex items-center gap-4 pb-4">
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
            <span class="text-sm uppercase text-zinc-500 dark:text-zinc-400">
              {authStep.additionalContent === "auth-providers"
                ? "or login with email"
                : "or register with email"}
            </span>
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
          </div>
        </div>
      )
    }

    {/* Fields */}
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2 md:gap-6">
      {
        allFields.map((field) => {
          if (field.type === "hidden") {
            return (
              <input
                type="hidden"
                name={field.name}
                value={initialData[field.name] ?? field.value ?? ""}
              />
            );
          }

          const colClass = field.columns === 1 ? "md:col-span-2" : "";
          const wrapperClass = `input-wrapper w-full ${colClass}`;

          // Component types
          if (field.type === "component") {
            if (field.component === "SlotMachineModalStaff") {
              return (
                <div class={wrapperClass}>
                  <SlotMachineModalStaff
                    id={field.id}
                    name={field.name}
                    title={field.label || "Select an option"}
                    options={mobileCarrierOptions}
                    selectedValue=""
                    globalInputClasses={appendedMultiStepInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "SlideToggle") {
              return (
                <div class={`${wrapperClass} flex items-center justify-center py-4`}>
                  <SlideToggle id={field.id} name={field.name} {...field.componentProps} />
                </div>
              );
            }
            if (field.component === "InlineAddressSearch") {
              return (
                <div class={wrapperClass}>
                  <InlineAddressSearch
                    id={field.id}
                    name={field.name}
                    globalInputClasses={appendedMultiStepInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "UnitSlider") {
              return (
                <div class={wrapperClass}>
                  <UnitSlider
                    name={field.name}
                    label={field.label || field.name}
                    value={Number(field.value) || 1}
                    required={field.required}
                    min={field.min}
                    max={field.max}
                    step={field.step}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "ToggleButton") {
              return (
                <div class={`${wrapperClass} multi-step-toggle-group flex flex-wrap gap-3`}>
                  {field.options?.map((option) => (
                    <ToggleButton
                      value={option.value}
                      group={field.name}
                      type={field.toggleType || "radio"}
                      class={field.classes}
                    >
                      {option.label}
                    </ToggleButton>
                  ))}
                </div>
              );
            }
            if (field.component === "FileUpload") {
              return (
                <div class={wrapperClass}>
                  <FileUpload
                    name={field.name}
                    label={field.label}
                    required={field.required}
                    accept={field.accept}
                    multiple={field.multiple}
                    maxFiles={field.maxFiles}
                    maxSize={field.maxSize}
                    {...field.componentProps}
                  />
                </div>
              );
            }
          }

          if (field.type === "range") {
            return (
              <div class={wrapperClass}>
                <UnitSlider
                  name={field.name}
                  label={field.label || field.name}
                  value={Number(field.value) || Number(field.min) || 0}
                  required={field.required}
                  min={field.min || 0}
                  max={field.max || 100}
                  step={field.step || 1}
                />
              </div>
            );
          }

          if (field.type === "textarea") {
            return (
              <div class={wrapperClass}>
                {field.label && (
                  <label
                    for={field.id}
                    class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                  >
                    {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                  </label>
                )}
                {/* prettier-ignore */}
                <textarea id={field.id} name={field.name} placeholder={field.placeholder} required={field.required} rows={field.rows || 4} autocomplete={field.autocomplete} class={appendedMultiStepInputClasses} data-error={field.errorMessage} data-validate={field.validate} data-validate-message={field.validateMessage}>{""}</textarea>
              </div>
            );
          }

          {
            /* Input with icon */
          }
          if (field.icon) {
            return (
              <div
                class:list={[
                  wrapperClass,
                  "input-with-icon relative",
                  field.iconPosition === "right" ? "icon-right" : "icon-left",
                ]}
                data-icon={field.icon}
              >
                <input
                  type={field.type as "text" | "email" | "tel" | "password"}
                  id={field.id}
                  name={field.name}
                  placeholder={field.placeholder}
                  required={field.required}
                  autocomplete={field.autocomplete}
                  minlength={field.minlength}
                  autofocus={field.autofocus}
                  class={`${appendedMultiStepInputClasses} pl-12 pr-12`}
                  data-error={field.errorMessage}
                  data-validate={field.validate}
                  data-validate-message={field.validateMessage}
                />
              </div>
            );
          }

          // Plain input
          return (
            <div class={wrapperClass}>
              {field.label && (
                <label
                  for={field.id}
                  class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                </label>
              )}
              <input
                type={field.type as "text" | "email" | "tel" | "password"}
                id={field.id}
                name={field.name}
                placeholder={field.placeholder}
                required={field.required}
                autocomplete={field.autocomplete}
                minlength={field.minlength}
                autofocus={field.autofocus}
                class={appendedMultiStepInputClasses}
                data-error={field.errorMessage}
                data-validate={field.validate}
                data-validate-message={field.validateMessage}
              />
            </div>
          );
        })
      }
    </div>

    {/* Submit button */}
    <div class="flex justify-end pt-4">
      <Button
        type="submit"
        variant={submitConfig.variant}
        size={submitConfig.size}
        icon={submitConfig.icon}
        iconPosition={submitConfig.iconPosition}
        class="submit-step"
      >
        {submitConfig.label && <span set:html={submitConfig.label} />}
      </Button>
    </div>

    {/* Hidden fields from config (initialData overrides) */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={getHiddenValue(field.name) || field.value} />
      ))
    }
  </form>
</div>

<script>
  import { initializeStandardForm } from "../../../lib/multi-step-form-handler";

  function runStandardFormInit() {
    const wrapper = document.querySelector("[data-standard-form]");
    const form = wrapper?.querySelector("form[data-form-config]") as HTMLFormElement | null;
    if (!form) return;

    let formId: string;
    let formConfig: any;
    let initialData: Record<string, any> = {};
    try {
      const parsed = JSON.parse(form.getAttribute("data-form-config") ?? "{}");
      formId = parsed.formId;
      formConfig = parsed.formConfig;
      initialData = parsed.initialData ?? {};
    } catch {
      return;
    }
    if (!formId || !formConfig) return;

    initializeStandardForm(form, { initialData, formConfig });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", runStandardFormInit);
  } else {
    runStandardFormInit();
  }
</script>
