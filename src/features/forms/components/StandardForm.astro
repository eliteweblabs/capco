---
/**
 * StandardForm - Single-page form renderer for MultiStepFormConfig
 * Accepts the same config as MultiStepForm; flattens all steps into one form.
 * Use when you want a traditional single-page form instead of step-by-step.
 *
 * Example: <StandardForm config={loginFormConfig} initialData={{ redirect: "/dashboard" }} />
 */
import type {
  MultiStepFormConfig,
  FormFieldConfig,
  FormStepConfig,
} from "../../../lib/multi-step-form-config";
import { getButtonConfig, normalizeFormConfig } from "../../../lib/multi-step-form-config";
import Button from "../../../components/common/Button.astro";
import SimpleIcon from "../../../components/common/SimpleIcon.astro";
import AuthProviders from "../../../components/form/AuthProviders.astro";
import InlineAddressSearch from "../../../components/form/InlineAddressSearch.astro";
import UnitSlider from "../../../components/form/UnitSlider.astro";
import ToggleButton from "../../../components/form/ToggleButton.astro";
import FileUpload from "../../../components/form/FileUpload.astro";
import SlideToggle from "../../../components/form/SlideToggle.astro";
import SlotMachineModalStaff from "../../../components/form/SlotMachineModalStaff.astro";
import PhoneAndSMS from "../../../components/form/PhoneAndSMS.astro";
import ProfileAvatarBlock from "../../../components/profile/ProfileAvatarBlock.astro";
import { SMS_UTILS } from "../../../lib/sms-utils";
import { globalClasses } from "../../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
  /** When true, render fields without form tag (embed in parent form). Skips StandardForm init. */
  wrapInForm?: boolean;
  /** Prefix for field ids (e.g. "admin-" for admin form) */
  fieldIdPrefix?: string;
}

const {
  config: rawConfig,
  containerClass = "min-w-md max-w-md sm:max-w-lg md:max-w-xl lg:max-w-2xl mx-auto w-full",
  initialData = {},
  wrapInForm = false,
  fieldIdPrefix = "",
} = Astro.props;

const fid = (id: string) => (fieldIdPrefix ? `${fieldIdPrefix}${id}` : id);

const config = normalizeFormConfig(rawConfig);
const FormOrDiv = wrapInForm ? "div" : "form";

const { globalInputClasses } = globalClasses();
const appendedGlobalInputClasses = `${globalInputClasses}`;

const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));

/** Flatten all fields from all steps (skip review steps) */
function flattenFields(steps: FormStepConfig[]): FormFieldConfig[] {
  return steps.filter((s) => !s.isReview).flatMap((s) => s.fields || []);
}

/** First step that has auth providers */
function getAuthProviderStep(steps: FormStepConfig[]): FormStepConfig | undefined {
  return steps.find(
    (s) => s.additionalContent === "google-oauth" || s.additionalContent === "auth-providers"
  );
}

/** Submit button from last step, or config default */
function getSubmitButton(config: MultiStepFormConfig) {
  const steps = config.steps.filter((s) => !s.isReview);
  const lastStep = steps[steps.length - 1];
  const submitBtn = lastStep?.buttons?.find((b) => b.type === "submit");
  const defaults = config.buttonDefaults?.submit || {};
  return getButtonConfig(submitBtn || { type: "submit", ...defaults }, defaults);
}

const allFields = flattenFields(config.steps);
const authStep = getAuthProviderStep(config.steps);
const submitConfig = getSubmitButton(config);

/** Resolve hidden field value: initialData overrides config */
function getHiddenValue(name: string): string {
  if (initialData[name] !== undefined && initialData[name] !== null) {
    return String(initialData[name]);
  }
  const fromConfig = config.hiddenFields?.find((f) => f.name === name);
  return fromConfig?.value ?? "";
}

const iconLeftPadding = "pl-10 sm:pl-12";
const iconRightPadding = "pr-10 sm:pr-12";
---

<div data-standard-form class={containerClass} data-skip-init={wrapInForm}>
  {
    !wrapInForm && config.responseType === "inline" && (
      <div id={`${config.formId}-response-alert`} class="mb-4 hidden w-full p-2" role="alert" />
    )
  }
  <FormOrDiv
    id={!wrapInForm ? config.formId : undefined}
    action={!wrapInForm ? config.formAction : undefined}
    method={!wrapInForm ? config.formMethod || "post" : undefined}
    class="space-y-6"
    data-form-config={!wrapInForm
      ? JSON.stringify({ formId: config.formId, formConfig: config, initialData })
      : undefined}
  >
    {
      authStep && (
        <div>
          <AuthProviders
            mode={authStep.additionalContent === "auth-providers" ? "login" : "register"}
          />
          <div class="flex items-center gap-4 pb-4">
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
            <span class="text-sm uppercase text-zinc-500 dark:text-zinc-400">
              {authStep.additionalContent === "auth-providers"
                ? "or login with email"
                : "or register with email"}
            </span>
            <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
          </div>
        </div>
      )
    }

    {/* Fields */}
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2 md:gap-6">
      {
        allFields.map((field) => {
          if (field.type === "hidden") {
            return (
              <input
                type="hidden"
                name={field.name}
                value={initialData[field.name] ?? field.value ?? ""}
              />
            );
          }

          const colClass = field.columns === 1 ? "md:col-span-2" : "";
          const wrapperClass = `input-wrapper w-full ${colClass}`;

          // Component types
          if (field.type === "component") {
            if (field.component === "ProfileAvatar") {
              return (
                <div class={wrapperClass}>
                  <ProfileAvatarBlock
                    idPrefix={initialData._avatarIdPrefix ?? ""}
                    avatarUrl={initialData.avatarUrl ?? initialData.avatar ?? ""}
                    label={field.label}
                  />
                </div>
              );
            }
            if (field.component === "PhoneAndSMS") {
              const phoneWrapperClass = field.icon
                ? [
                    wrapperClass,
                    "input-with-icon relative",
                    field.iconPosition === "right" ? "icon-right" : "icon-left",
                  ].join(" ")
                : wrapperClass;
              const phoneInputClasses = field.icon
                ? `${appendedGlobalInputClasses} ${field.iconPosition === "left" ? iconLeftPadding : iconRightPadding}`
                : appendedGlobalInputClasses;
              return (
                <div class={phoneWrapperClass} data-icon={field.icon || undefined}>
                  <PhoneAndSMS
                    id={fid(field.id)}
                    name={field.name}
                    value={initialData[field.name] ?? initialData.phone ?? ""}
                    placeholder={field.placeholder}
                    required={field.required}
                    showSMS={field.componentProps?.showSMS ?? true}
                    smsChecked={initialData.smsAlerts ?? false}
                    selectedCarrier={initialData.mobileCarrier ?? ""}
                    globalInputClasses={phoneInputClasses}
                  />
                </div>
              );
            }
            if (field.component === "Select") {
              const opts = field.options || [];
              const val = initialData[field.name] ?? "";
              const selId = fid(field.id);
              return (
                <div class={wrapperClass}>
                  {field.label && (
                    <label
                      for={selId}
                      class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                    >
                      {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                    </label>
                  )}
                  <select
                    id={selId}
                    name={field.name}
                    required={field.required}
                    class={appendedGlobalInputClasses}
                  >
                    <option value="">{field.placeholder || "Select..."}</option>
                    {opts.map((o: { value: string; label: string }) => (
                      <option value={o.value} selected={o.value === val}>
                        {o.label}
                      </option>
                    ))}
                  </select>
                </div>
              );
            }
            if (field.component === "SlotMachineModalStaff") {
              return (
                <div class={wrapperClass}>
                  <SlotMachineModalStaff
                    id={fid(field.id)}
                    name={field.name}
                    title={field.label || "Select an option"}
                    options={mobileCarrierOptions}
                    selectedValue=""
                    globalInputClasses={appendedGlobalInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "SlideToggle") {
              return (
                <div class={`${wrapperClass} flex items-center justify-center py-4`}>
                  <SlideToggle
                    id={fid(field.id)}
                    name={field.name}
                    globalInputClasses={appendedGlobalInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "InlineAddressSearch") {
              return (
                <div class={wrapperClass}>
                  <InlineAddressSearch
                    id={fid(field.id)}
                    name={field.name}
                    globalInputClasses={appendedGlobalInputClasses}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "UnitSlider") {
              return (
                <div class={wrapperClass}>
                  <UnitSlider
                    name={field.name}
                    label={field.label || field.name}
                    value={Number(field.value) || 1}
                    required={field.required}
                    min={field.min}
                    max={field.max}
                    step={field.step}
                    {...field.componentProps}
                  />
                </div>
              );
            }
            if (field.component === "ToggleButton") {
              return (
                <div class={`${wrapperClass} multi-step-toggle-group flex flex-wrap gap-3`}>
                  {field.options?.map((option) => (
                    <ToggleButton
                      value={option.value}
                      group={field.name}
                      type={field.toggleType || "radio"}
                      class={field.classes}
                    >
                      {option.label}
                    </ToggleButton>
                  ))}
                </div>
              );
            }
            if (field.component === "FileUpload") {
              return (
                <div class={wrapperClass}>
                  <FileUpload
                    name={field.name}
                    label={field.label}
                    required={field.required}
                    accept={field.accept}
                    multiple={field.multiple}
                    maxFiles={field.maxFiles}
                    maxSize={field.maxSize}
                    {...field.componentProps}
                  />
                </div>
              );
            }
          }

          if (field.type === "range") {
            return (
              <div class={wrapperClass}>
                <UnitSlider
                  name={field.name}
                  label={field.label || field.name}
                  value={Number(field.value) || Number(field.min) || 0}
                  required={field.required}
                  min={field.min || 0}
                  max={field.max || 100}
                  step={field.step || 1}
                />
              </div>
            );
          }

          if (field.type === "textarea") {
            const textareaVal = initialData[field.name] ?? "";
            const txtId = fid(field.id);
            const textareaWrapperClass = field.icon
              ? [
                  wrapperClass,
                  "input-with-icon relative",
                  field.iconPosition === "right" ? "icon-right" : "icon-left",
                ].join(" ")
              : wrapperClass;
            const textareaInputClasses = field.icon
              ? `${appendedGlobalInputClasses} ${field.iconPosition === "left" ? iconLeftPadding : iconRightPadding}`
              : appendedGlobalInputClasses;
            return (
              <div class={textareaWrapperClass} data-icon={field.icon || undefined}>
                {field.label && (
                  <label
                    for={txtId}
                    class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                  >
                    {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                  </label>
                )}
                {/* prettier-ignore */}
                <textarea id={txtId} name={field.name} placeholder={field.placeholder} required={field.required} rows={field.rows || 4} minlength={field.minlength ?? 10} maxlength={field.maxlength ?? 500} autocomplete={field.autocomplete} class={textareaInputClasses} data-error={field.errorMessage} data-validate={field.validate} data-validate-message={field.validateMessage}>{textareaVal}</textarea>
              </div>
            );
          }

          {
            /* Input with icon */
          }
          if (field.icon) {
            const iconId = fid(field.id);
            return (
              <div
                class:list={[
                  wrapperClass,
                  "input-with-icon relative",
                  field.iconPosition === "right" ? "icon-right" : "icon-left",
                ]}
                data-icon={field.icon}
              >
                {field.label && (
                  <label
                    for={iconId}
                    class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                  >
                    {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                  </label>
                )}
                <input
                  type={field.type as "text" | "email" | "tel" | "password" | "number"}
                  id={iconId}
                  name={field.name}
                  value={initialData[field.name] ?? field.value ?? ""}
                  placeholder={field.placeholder}
                  required={field.required}
                  autocomplete={field.autocomplete}
                  minlength={field.type !== "number" ? (field.minlength ?? 2) : undefined}
                  maxlength={field.type !== "number" ? (field.maxlength ?? 50) : undefined}
                  min={field.type === "number" ? field.min : undefined}
                  max={field.type === "number" ? field.max : undefined}
                  step={field.type === "number" ? field.step : undefined}
                  autofocus={field.autofocus}
                  readonly={(field.componentProps as any)?.readonly}
                  class={`${appendedGlobalInputClasses} ${field.iconPosition === "left" ? iconLeftPadding : iconRightPadding}`}
                  data-error={field.errorMessage}
                  data-validate={field.validate}
                  data-validate-message={field.validateMessage}
                />
              </div>
            );
          }

          // Plain input
          const inputVal = initialData[field.name] ?? field.value ?? "";
          const inpId = fid(field.id);
          return (
            <div class={wrapperClass}>
              {field.label && (
                <label
                  for={inpId}
                  class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  {field.label} {field.required ? <span class="text-red-500">*</span> : ""}
                </label>
              )}
              <input
                type={field.type as "text" | "email" | "tel" | "password" | "number"}
                id={inpId}
                name={field.name}
                value={inputVal}
                placeholder={field.placeholder}
                required={field.required}
                autocomplete={field.autocomplete}
                minlength={field.type !== "number" ? (field.minlength ?? 2) : undefined}
                maxlength={field.type !== "number" ? (field.maxlength ?? 50) : undefined}
                min={field.type === "number" ? field.min : undefined}
                max={field.type === "number" ? field.max : undefined}
                step={field.type === "number" ? field.step : undefined}
                autofocus={field.autofocus}
                readonly={(field.componentProps as any)?.readonly}
                class={`${appendedGlobalInputClasses} ${field.iconPosition === "left" ? iconLeftPadding : iconRightPadding}`}
                data-error={field.errorMessage}
                data-validate={field.validate}
                data-validate-message={field.validateMessage}
              />
            </div>
          );
        })
      }
    </div>

    {/* Submit button - prev/back buttons are ignored */}
    <div class="flex gap-3 pt-4">
      <Button
        type="submit"
        variant={submitConfig.variant}
        size={submitConfig.size}
        icon={submitConfig.icon}
        iconPosition={submitConfig.iconPosition}
        class={`submit-step save-profile-btn ${(submitConfig as any).classes || ""}`}
      >
        {submitConfig.label && <span set:html={submitConfig.label} />}
      </Button>
    </div>

    {/* Hidden fields from config (initialData overrides) */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={getHiddenValue(field.name) || field.value} />
      ))
    }
  </FormOrDiv>
</div>

<script>
  import { initializeStandardForm } from "../../../lib/multi-step-form-handler";

  function runStandardFormInit() {
    const wrapper = document.querySelector("[data-standard-form]");
    if (wrapper?.hasAttribute("data-skip-init")) return;
    const form = wrapper?.querySelector("form[data-form-config]") as HTMLFormElement | null;
    if (!form) return;

    let formId: string;
    let formConfig: any;
    let initialData: Record<string, any> = {};
    try {
      const parsed = JSON.parse(form.getAttribute("data-form-config") ?? "{}");
      formId = parsed.formId;
      formConfig = parsed.formConfig;
      initialData = parsed.initialData ?? {};
    } catch {
      return;
    }
    if (!formId || !formConfig) return;

    initializeStandardForm(form, { initialData, formConfig });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", runStandardFormInit);
  } else {
    runStandardFormInit();
  }
</script>
