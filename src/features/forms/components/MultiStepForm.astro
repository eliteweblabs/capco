---
// Reusable multi-step form component that renders from JSON configuration
import type { MultiStepFormConfig } from "../../../lib/multi-step-form-config";
import { getButtonConfig, normalizeFormConfig } from "../../../lib/multi-step-form-config";
import Button from "../../../components/common/Button.astro";
import SimpleIcon from "../../../components/common/SimpleIcon.astro";
import Tooltip from "../../../components/ui/Tooltip.astro";
import FormFieldRenderer from "./FormFieldRenderer.astro";
import AuthProviders from "../../../components/form/AuthProviders.astro";
import { SMS_UTILS } from "../../../lib/sms-utils";
import { globalClasses } from "../../../pages/api/global/global-classes";

interface Props {
  config: MultiStepFormConfig;
  containerClass?: string;
  initialData?: Record<string, any>;
  /** TEST: Disables cascade/visibility animations to debug iOS keypad. Remove when fixed. */
  testNoCascade?: boolean;
}

const {
  config: rawConfig,
  containerClass = "min-w-md max-w-md sm:min-w-lg sm:max-w-lg md:min-w-xl md:max-w-xl lg:min-w-2xl lg:max-w-2xl mx-auto w-full min-w-0",
  initialData = {},
  testNoCascade = false,
} = Astro.props;

const config = normalizeFormConfig(rawConfig);

const { globalInputClasses, multiStepInputClasses, multiStepInputCoreClasses, globalCardStyle } =
  globalClasses();
const appendedGlobalInputClasses = `${globalInputClasses} text-center`;
/** On wrapper so animated placeholder and icons get size/color; input uses core to fill and inherit */
const appendedMultiStepInputClasses = multiStepInputClasses;
const appendedMultiStepInputCoreClasses = multiStepInputCoreClasses;

// Get carrier options for mobile carrier component
const mobileCarrierOptions = SMS_UTILS.CARRIERS.map((carrier: any) => ({
  value: carrier.id,
  label: carrier.name,
}));

const iconLeftPadding = "pl-14 sm:pl-16 md:pl-18 lg:pl-20";
const iconRightPadding = "pr-14 sm:pr-16 md:pr-18 lg:pr-20";
---

<div data-multi-step-form class:list={[containerClass]} tabindex="-1">
  <form
    id={config.formId}
    action={config.formAction}
    method={config.formMethod || "post"}
    class={`w-full min-w-0 max-w-full ${config.progressBar ? "" : ""}`.trim()}
    data-form-config={JSON.stringify({ formId: config.formId, formConfig: config, initialData })}
    data-project-id={config.formId}
  >
    {
      config.responseType === "inline" && (
        <div
          id={`${config.formId}-response-alert`}
          class="mb-4 hidden"
          aria-live="polite"
          aria-atomic="true"
        />
      )
    }
    <div
      class:list={[
        "multi-step-form-steps expand-down relative flex w-full min-w-0 flex-col items-stretch justify-center pb-16 scrollbar-hide",
      ]}
      id={`${config.formId}-steps`}
      data-dynamic-height="minHeight"
      tabindex="-1"
    >
      {
        config.steps.map((step) => (
          <div
            class:list={[
              "step-content space-y-8 overflow-y-visible p-2 sm:space-y-8 sm:p-4 md:my-0", // leave mt-20 for tooltips MUST MATGCG INPUTD,
              step.stepNumber === 1 ? "first-step active" : "",
            ]}
            data-step={step.stepNumber}
            data-hide-progress-bar={step.hideProgressBar ? "true" : "false"}
            tabindex="-1"
          >
            {/* Step Header */}

            {step.title || step.subtitle ? (
              <div class="step-title text-xl sm:text-2xl md:text-3xl lg:text-4xl" tabindex="-1">
                {step.title && (
                  <h2 class="flex flex-wrap items-center gap-1.5 sm:gap-2" tabindex="-1">
                    <span
                      class={`inline ${
                        step.effect === "typewriter" || !step.effect ? "typewriter-text" : ""
                      }`}
                      data-text={step.title}
                      set:html={step.title || ""}
                    />
                    {step.moreInfoTooltip && (
                      <span class="step-more-info-tooltip inline-flex shrink-0">
                        <Tooltip
                          text={step.moreInfoTooltip}
                          html={true}
                          position="top"
                          className="shrink-0"
                          mobileClickable={true}
                          tooltipClass="whitespace-normal"
                        >
                          <SimpleIcon
                            name="help-circle"
                            class="h-5 w-5 shrink-0 text-gray-500 dark:text-gray-400 sm:h-6 sm:w-6 md:h-7 md:w-7 lg:h-9 lg:w-9"
                          />
                        </Tooltip>
                      </span>
                    )}
                  </h2>
                )}
                {step.subtitle && (
                  <p
                    class="mt-2 max-w-md text-sm text-gray-600 dark:text-gray-400 sm:mt-3 sm:text-base"
                    tabindex="-1"
                  >
                    {step.subtitle}
                  </p>
                )}
              </div>
            ) : null}

            {/* Auth Providers (for registration and login forms) - at top */}
            {(step.additionalContent === "google-oauth" ||
              step.additionalContent === "auth-providers") && (
              <div class="" tabindex="-1">
                <AuthProviders
                  mode={step.additionalContent === "auth-providers" ? "login" : "register"}
                  redirectUrl={initialData?.redirect ?? "/project/dashboard"}
                />
                <div class="flex items-center gap-4 pb-4" tabindex="-1">
                  <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
                  <span class="text-sm uppercase text-zinc-500 dark:text-zinc-400">
                    {step.additionalContent === "auth-providers"
                      ? "or login with email"
                      : "or register with email"}
                  </span>
                  <div class="h-px flex-1 bg-zinc-300 dark:bg-zinc-600" />
                </div>
              </div>
            )}

            {/* Step Fields */}
            {step.isReview ? (
              // Review step - show summary
              <div class={`color-background space-y-4 ${globalCardStyle} p-8`} tabindex="-1">
                {step.reviewFields?.map((fieldName) => (
                  <div
                    class="flex items-start justify-between border-b border-gray-200 pb-2 last:border-b-0 dark:border-gray-700"
                    tabindex="-1"
                  >
                    <div tabindex="-1">
                      <p class="text-sm capitalize text-gray-600 dark:text-gray-400" tabindex="-1">
                        {fieldName.replace(/([A-Z])/g, " $1").trim()}
                      </p>
                      <p
                        id={`review-${fieldName}`}
                        class="text-lg font-medium text-gray-900 dark:text-white"
                        tabindex="-1"
                      >
                        {fieldName === "password" ? "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" : "-"}
                      </p>
                    </div>
                    <button
                      type="button"
                      class="edit-step text-sm font-medium text-primary-600 hover:text-primary-700 dark:text-primary-400"
                      data-edit={
                        config.steps.findIndex((s) => s.fields.some((f) => f.name === fieldName)) +
                        1
                      }
                    >
                      Edit
                    </button>
                  </div>
                ))}
              </div>
            ) : step.fields?.length ? (
              <div class="step-form-fields-wrapper flex flex-col gap-3" tabindex="-1">
                {step.fields.map((field) => (
                  <FormFieldRenderer
                    field={field}
                    context="multistep"
                    inputClasses={appendedMultiStepInputCoreClasses}
                    initialData={initialData}
                    buttonDefaults={config.buttonDefaults}
                    mobileCarrierOptions={mobileCarrierOptions}
                    iconLeftPadding={iconLeftPadding}
                    iconRightPadding={iconRightPadding}
                    wrapperClass={
                      field.type === "hidden"
                        ? ""
                        : `input-wrapper w-full ${appendedMultiStepInputClasses}`
                    }
                  />
                ))}
              </div>
            ) : null}

            {/* Step Buttons */}
            {/* Choice buttons (radio-style options) */}
            {step.buttons.some((b) => b.type === "choice") && (
              <div
                class={`multi-step-choice-buttons flex ${step.buttons.some((b) => b.type === "choice" && b.classes?.includes("w-full")) ? "flex-col" : "flex-wrap justify-center"} mb-6 gap-3`}
                tabindex="-1"
              >
                {step.buttons
                  .filter((button) => button.type === "choice")
                  .map((button) => {
                    const btnConfig = getButtonConfig(
                      button,
                      config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                    );

                    return (
                      <Button
                        id={button.id}
                        type="button"
                        variant={btnConfig.variant || "outline"}
                        size={btnConfig.size || "md"}
                        class={`${button.type}-step sms-choice ${button.classes || ""}`}
                        disabled={button.disabled}
                        dataAttributes={{
                          ...(button.dataNext !== undefined && {
                            "data-next": button.dataNext.toString(),
                          }),
                          ...(button.dataValue !== undefined && { "data-value": button.dataValue }),
                          ...(button.dataValue !== undefined && {
                            "data-sms-value": button.dataValue,
                          }), // Keep for backward compatibility with SMS
                        }}
                      >
                        {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                      </Button>
                    );
                  })}
              </div>
            )}

            {/* Navigation buttons (prev, next, submit, skip) */}
            <div
              class:list={[
                "step-form-buttons-wrapper",
                "flex",
                "gap-3",
                step.buttons.filter((b) => b.type !== "choice").length === 1
                  ? "justify-end"
                  : "justify-between",
              ]}
            >
              {step.buttons
                .filter((button) => button.type !== "choice")
                .map((button) => {
                  const btnConfig = getButtonConfig(
                    button,
                    config.buttonDefaults?.[button.type as keyof typeof config.buttonDefaults]
                  );

                  const buttonEl = button.href ? (
                    <Button
                      id={button.id}
                      variant={btnConfig.variant}
                      size={btnConfig.size || "md"}
                      icon={btnConfig.icon}
                      iconPosition={btnConfig.iconPosition}
                      href={button.href}
                      class={`${button.type}-step ${button.classes || ""}`}
                      disabled={button.disabled}
                    >
                      {btnConfig.label && <Fragment set:html={btnConfig.label} />}
                    </Button>
                  ) : (
                    <Button
                      id={button.id}
                      variant={btnConfig.variant}
                      size={btnConfig.size || "md"}
                      icon={btnConfig.icon}
                      iconClasses="mr-0"
                      iconPosition={btnConfig.iconPosition}
                      type="button"
                      antispam={button.antispam}
                      class={`${button.type}-step ${button.classes || ""}`}
                      disabled={button.disabled}
                      dataAttributes={{
                        ...(button.dataNext !== undefined && {
                          "data-next": button.dataNext.toString(),
                        }),
                        ...(button.dataSkip !== undefined && {
                          "data-skip": button.dataSkip.toString(),
                        }),
                        ...(button.dataPrev !== undefined && {
                          "data-prev": button.dataPrev.toString(),
                        }),
                        ...(button.label && {
                          "data-default-label": button.label,
                        }),
                        ...(button.validLabel && {
                          "data-valid-label": button.validLabel,
                        }),
                      }}
                    >
                      {btnConfig.label &&
                        (btnConfig.label === "back" ? (
                          <span class="hidden sm:inline">
                            <Fragment set:html={btnConfig.label} />
                          </span>
                        ) : (
                          <span class="button-text">
                            <Fragment set:html={btnConfig.label} />
                          </span>
                        ))}
                      {/* Valid state icon (hidden by default, shown when valid; default check, override with button.validIcon e.g. "enter") */}
                      {btnConfig.iconPosition === "right" && (
                        <SimpleIcon
                          name={button.validIcon ?? "return"}
                          size={btnConfig.size}
                          class="icon-valid ml-2 hidden"
                        />
                      )}
                    </Button>
                  );
                  return button.tooltipText ? (
                    <Tooltip text={button.tooltipText} position={button.tooltipPosition || "top"}>
                      {buttonEl}
                    </Tooltip>
                  ) : (
                    buttonEl
                  );
                })}
            </div>
          </div>
        ))
      }
    </div>

    {/* Hidden Fields */}
    {
      config.hiddenFields?.map((field) => (
        <input type="hidden" name={field.name} value={field.value} />
      ))
    }
  </form>
</div>

<!-- Advanced Stepper - Fixed to bottom (outside of container to avoid flex interference) -->
{
  config.progressBar && (
    <div
      id={`${config.formId}-progress-bar`}
      class="fixed bottom-0 left-0 right-0 z-40 border-t border-gray-200 bg-white/90 px-4 py-4 backdrop-blur-md transition-opacity duration-300 dark:border-gray-700 dark:bg-gray-900/90"
      tabindex="-1"
    >
      <div class="mx-auto w-[90vw] max-w-6xl sm:w-[85vw] md:w-[80vw] lg:w-[75vw]" tabindex="-1">
        <ol class="flex w-full items-center" id={`${config.formId}-stepper`} tabindex="-1">
          {config.steps
            .filter((step) => !step.hideProgressBar)
            .map((step, index, filteredSteps) => (
              <li
                class={`relative flex items-center ${index < filteredSteps.length - 1 ? "w-full" : ""}`}
                data-step-indicator={step.stepNumber}
                tabindex="-1"
              >
                {/* Step Circle/Icon with Tooltip */}
                <Tooltip text={step.title} position="top" mobileClickable={true} html={true}>
                  <span
                    class="step-indicator relative flex h-3 w-3 shrink-0 items-center justify-center rounded-full bg-gray-300 transition-all duration-300 dark:bg-gray-700 sm:h-4 sm:w-4"
                    data-step-title={step.title}
                    tabindex="-1"
                  />
                </Tooltip>

                {/* Connecting Line */}
                {index < filteredSteps.length - 1 && (
                  <div
                    class="mx-2 h-1 w-full overflow-hidden rounded-full bg-transparent dark:bg-transparent"
                    tabindex="-1"
                  >
                    <div
                      class="step-progress-line h-full bg-transparent transition-all duration-500 ease-out dark:bg-transparent"
                      style="width: 0%"
                      tabindex="-1"
                    />
                  </div>
                )}
              </li>
            ))}
        </ol>
      </div>
    </div>
  )
}

<style is:global>
  /* Title scroll container with max height */
  .title-scroll-container {
    display: flex;
    position: relative;
    flex-direction: column;
  }

  /* Wrapper cascade: hidden until typewriter completes, then 250ms > fields/choice > 250ms > buttons */
  .step-content.has-typewriter .step-form-fields-wrapper,
  .step-content.has-typewriter .multi-step-choice-buttons,
  .step-content.has-typewriter .step-form-buttons-wrapper {
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transition:
      max-height 0.4s ease-out,
      opacity 0.25s ease-out;
  }

  .step-content.typewriter-complete .step-form-fields-wrapper,
  .step-content.typewriter-complete .multi-step-choice-buttons {
    max-height: 200rem;
    opacity: 1;
    overflow: visible;
    transition-delay: 250ms;
  }

  .step-content.typewriter-complete .step-form-buttons-wrapper {
    max-height: 200rem;
    opacity: 1;
    overflow: visible;
    transition-delay: 500ms;
  }

  /* For steps without typewriter, show wrappers immediately */
  .step-content:not(.has-typewriter) .step-form-fields-wrapper,
  .step-content:not(.has-typewriter) .multi-step-choice-buttons,
  .step-content:not(.has-typewriter) .step-form-buttons-wrapper {
    max-height: none;
    opacity: 1;
    overflow: visible;
  }

  /* More-info tooltip: fade in after title (typewriter complete) */
  .step-content.has-typewriter .step-more-info-tooltip {
    opacity: 0;
    transition: opacity 0.25s ease-out;
  }
  .step-content.typewriter-complete .step-more-info-tooltip {
    opacity: 1;
    transition-delay: 150ms;
  }
  .step-content:not(.has-typewriter) .step-more-info-tooltip {
    opacity: 1;
  }

  /* Inner elements: opacity tied to wrapper reveal (no per-element stagger) */
  .step-content.has-typewriter .input-wrapper,
  .step-content.has-typewriter .inline-address-search-wrapper,
  .step-content.has-typewriter .step-form-fields-wrapper button,
  .step-content.has-typewriter .step-form-fields-wrapper a,
  .step-content.has-typewriter .multi-step-choice-buttons button,
  .step-content.has-typewriter .step-form-buttons-wrapper button,
  .step-content.has-typewriter .step-form-buttons-wrapper a,
  .step-content.has-typewriter textarea {
    opacity: 0;
    transition: opacity 0.25s ease-out;
  }

  .step-content.typewriter-complete .input-wrapper,
  .step-content.typewriter-complete .inline-address-search-wrapper,
  .step-content.typewriter-complete textarea {
    opacity: 1;
    transition-delay: 250ms; /* sync with fields-wrapper */
  }

  .step-content.typewriter-complete .step-form-fields-wrapper button,
  .step-content.typewriter-complete .step-form-fields-wrapper a,
  .step-content.typewriter-complete .multi-step-choice-buttons button {
    opacity: 1;
    transition-delay: 250ms;
  }

  .step-content.typewriter-complete .step-form-buttons-wrapper button,
  .step-content.typewriter-complete .step-form-buttons-wrapper a {
    opacity: 1;
    transition-delay: 500ms; /* sync with buttons-wrapper */
  }

  /* For steps without typewriter effect, show content immediately */
  .step-content:not(.has-typewriter) .input-wrapper,
  .step-content:not(.has-typewriter) .inline-address-search-wrapper,
  .step-content:not(.has-typewriter) button,
  .step-content:not(.has-typewriter) a,
  .step-content:not(.has-typewriter) textarea,
  .step-content:not(.has-typewriter) .multi-step-choice-buttons {
    transform: translateY(0);
    opacity: 1;
  }

  /* TEST: When data-test-no-cascade, bypass all hiding - everything visible immediately for keypad debugging */
  [data-multi-step-form][data-test-no-cascade] .step-form-fields-wrapper,
  [data-multi-step-form][data-test-no-cascade] .multi-step-choice-buttons,
  [data-multi-step-form][data-test-no-cascade] .step-form-buttons-wrapper {
    max-height: none !important;
    opacity: 1 !important;
    overflow: visible !important;
    transition: none !important;
    transition-delay: 0ms !important;
  }
  [data-multi-step-form][data-test-no-cascade] .input-wrapper,
  [data-multi-step-form][data-test-no-cascade] .inline-address-search-wrapper,
  [data-multi-step-form][data-test-no-cascade] button,
  [data-multi-step-form][data-test-no-cascade] a,
  [data-multi-step-form][data-test-no-cascade] textarea,
  [data-multi-step-form][data-test-no-cascade] .step-more-info-tooltip {
    opacity: 1 !important;
    transition: none !important;
    transition-delay: 0ms !important;
  }
</style>

<style>
  /* Hide steps that are neither completed nor active so we don't scroll to blank content */
  .multi-step-form-steps .step-content:not(.completed):not(.active) {
    display: none;
  }

  /* Step indicator states */
  .step-indicator {
    background-color: rgb(209 213 219); /* gray-300 */
  }

  .dark .step-indicator {
    background-color: rgb(55 65 81); /* gray-700 */
  }

  .step-indicator.active {
    animation: pulse 2s infinite;
    background-color: var(--color-secondary-400);
  }

  .dark .step-indicator.active {
    animation: pulse 2s infinite;
    background-color: var(--color-secondary-600);
  }

  .step-indicator.completed {
    background-color: var(--color-success-500);
  }

  .dark .step-indicator.completed {
    background-color: var(--color-success-600);
  }

  /* Steps: scroll internally so user can scroll up to see completed steps */
  .multi-step-form-steps {
    overflow-y: auto;
  }
  /* Default: content centered, grows down */
  .multi-step-form-steps.expand-down {
    justify-content: center;
  }
  /* When bottom would hit threshold: lock at current gap (no jump), content grows up; user scrolls up to see completed */
  .multi-step-form-steps.expand-up {
    justify-content: flex-end;
    padding-bottom: var(--steps-bottom-gap, 20dvh);
  }

  /* Form is the scroll container; .multi-step-form-steps is the single scrollable content block */
  [data-multi-step-form] form {
    position: relative;
    /* margin: 0 auto; */
    /* width: 100%; */

    scroll-behavior: smooth;
    /* padding-top: 40vh; */
  }

  .step-content:not(.active).completed .step-form-buttons-wrapper {
    /* margin-top: 0 !important; */
    /* height: 0;
    transition: height 0.3s ease-in-out; */
    display: none;
  }

  .step-content.completed.active .step-form-buttons-wrapper {
    /* display: flex; */
  }

  /* When a panel is completed, collapse input wrapper width and align right */
  .step-content.completed .input-wrapper,
  .step-content.completed .inline-address-search-wrapper {
    transition:
      width 0.3s ease-out,
      margin 0.3s ease-out;
    margin-left: auto;
    width: fit-content;
    max-width: 100%;
  }

  .step-content.completed .input-wrapper input,
  .step-content.completed .input-wrapper textarea,
  .step-content.completed .inline-address-search-wrapper input {
    /* width: auto;
    min-width: 14ch; */
  }

  /* ml-8 for response steps is applied via class in template (step.response) */
</style>

{
  /* Inline: move focus to new step when step changes. Runs even if handler bundle is pending or doFocus doesn't run. */
}
<script is:inline>
  (function () {
    document.addEventListener("multistep-step-change", function (e) {
      var stepNumber = (e.detail && e.detail.stepNumber) || 0;
      var form =
        (e.target && e.target.closest && e.target.closest("form")) ||
        document.querySelector("[data-multi-step-form] form");
      if (!form) return;
      var active = document.activeElement;
      if (
        active &&
        (active.tagName === "INPUT" ||
          active.tagName === "TEXTAREA" ||
          active.tagName === "SELECT") &&
        (active.type || "") !== "hidden" &&
        form.contains(active)
      ) {
        active.blur();
        console.log("[MULTISTEP-FOCUS] inline: blurred previous input on step change", stepNumber);
      }
      function focusFirstInActive() {
        var wrapper = document.querySelector("[data-multi-step-form]");
        if (!wrapper) return;
        var step = wrapper.querySelector(".step-content.active");
        if (!step) return;
        var smsChoice = step.querySelector('button.sms-choice[data-sms-value="true"]');
        if (smsChoice) {
          smsChoice.focus();
          console.log("[MULTISTEP-FOCUS] inline: focused sms button for step", stepNumber);
          return;
        }
        var first = step.querySelector(
          "input:not([type=hidden]):not([readonly]), textarea, select"
        );
        if (first && first.focus) {
          first.focus();
          console.log(
            "[MULTISTEP-FOCUS] inline: focused first input for step",
            stepNumber,
            first.name || first.id
          );
        } else {
          console.log("[MULTISTEP-FOCUS] inline: no focusable field in step", stepNumber);
        }
      }
      setTimeout(focusFirstInActive, 50);
      setTimeout(focusFirstInActive, 450);
    });
  })();
</script>

<script>
  if (typeof window !== "undefined" && (window as any).__jsOrderLog)
    (window as any).__jsOrderLog("MultiStepForm (module)");
  import { initializeMultiStepForm } from "../../../lib/multi-step-form-handler";

  function runMultiStepPageInit() {
    if (typeof window !== "undefined" && (window as any).__traceLog)
      (window as any).__traceLog("MultiStepForm.astro DOMContentLoaded running");
    // Tap-to-focus: tapping the field wrapper focuses the input (iOS keypad requires direct user gesture)
    document.addEventListener(
      "click",
      (e) => {
        const target = e.target as HTMLElement;
        if (target.closest("button") || target.closest("a")) return;
        const wrapper =
          target.closest(".input-wrapper") ?? target.closest(".inline-address-search-wrapper");
        if (!wrapper) return;
        const input = wrapper.querySelector(
          "input:not([type=hidden]):not([readonly]), textarea, select"
        ) as HTMLInputElement | HTMLTextAreaElement | null;
        if (input?.focus && document.activeElement !== input) input.focus();
      },
      true
    );

    // Type-to-focus fallback: if focus is in the form but not on an input and user types, focus first field in active step (fixes autofocus race)
    document.addEventListener(
      "keydown",
      (e) => {
        const form = document.querySelector("[data-multi-step-form]");
        if (!form?.contains(e.target as Node)) return;
        const active = document.activeElement as HTMLElement;
        const isField =
          active &&
          (active.tagName === "INPUT" ||
            active.tagName === "TEXTAREA" ||
            active.tagName === "SELECT") &&
          (active as HTMLInputElement).type !== "hidden";
        if (isField) return;
        const stepContent = form.querySelector(".step-content.active") as HTMLElement | null;
        if (!stepContent) return;
        const firstInput = stepContent.querySelector(
          "input:not([type=hidden]):not([readonly]), textarea, select"
        ) as HTMLInputElement | HTMLTextAreaElement | null;
        if (!firstInput?.focus) return;
        firstInput.focus();
        const key = e.key;
        const isPrintable = key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey && !e.repeat;
        if (isPrintable && (firstInput.tagName === "INPUT" || firstInput.tagName === "TEXTAREA")) {
          const inputEl = firstInput as HTMLInputElement | HTMLTextAreaElement;
          const type = (firstInput as HTMLInputElement).type;
          if (type !== "email" && type !== "number" && type !== "tel" && type !== "url") {
            e.preventDefault();
            const start = inputEl.selectionStart ?? inputEl.value.length;
            const end = inputEl.selectionEnd ?? inputEl.value.length;
            const before = inputEl.value.slice(0, start);
            const after = inputEl.value.slice(end);
            inputEl.value = before + key + after;
            inputEl.setSelectionRange(start + 1, start + 1);
            inputEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }
      },
      true
    );

    // Shrink-to-fit: when multi-step input text overflows, reduce font size until it fits
    const MIN_FONT_PX = 12;
    function shrinkToFit(el: HTMLInputElement | HTMLTextAreaElement) {
      if (!el.classList.contains("shrink-to-fit")) return;
      if (!el.value) {
        el.style.fontSize = "";
        return;
      }
      el.style.fontSize = ""; /* reset so we measure at base size */
      const basePx = parseFloat(getComputedStyle(el).fontSize) || 24;
      if (el.scrollWidth <= el.clientWidth) {
        el.style.fontSize = "";
        return;
      }
      let px = basePx;
      while (px >= MIN_FONT_PX && el.scrollWidth > el.clientWidth) {
        px -= 2;
        el.style.fontSize = `${px}px`;
      }
    }
    document.addEventListener(
      "input",
      (e) => {
        const el = e.target as HTMLInputElement | HTMLTextAreaElement;
        if (el?.nodeName === "INPUT" || el?.nodeName === "TEXTAREA") shrinkToFit(el);
      },
      true
    );
    document.querySelectorAll(".shrink-to-fit").forEach((el) => {
      shrinkToFit(el as HTMLInputElement | HTMLTextAreaElement);
    });
    window.addEventListener("resize", () => {
      document.querySelectorAll(".shrink-to-fit").forEach((el) => {
        shrinkToFit(el as HTMLInputElement | HTMLTextAreaElement);
      });
    });

    // Expand-up/expand-down: measure the expanding step content; when it reaches ~70% of viewport, fix bottom and expand up
    const VIEWPORT_THRESHOLD = 0.7; /* content height >= 70% viewport = within 30% of filling it */
    function updateStepsExpandMode() {
      const stepsEl = document.querySelector(".multi-step-form-steps") as HTMLElement | null;
      if (!stepsEl) return;
      const active = stepsEl.querySelector(".step-content.active") as HTMLElement | null;
      const contentHeight = active?.offsetHeight ?? 0;
      const viewportHeight = window.innerHeight;
      const useExpandUp = contentHeight >= viewportHeight * VIEWPORT_THRESHOLD;
      if (useExpandUp) {
        const rect = stepsEl.getBoundingClientRect();
        const contentBottom = rect.top + stepsEl.scrollTop + stepsEl.scrollHeight;
        const gapPx = Math.max(viewportHeight * 0.1, viewportHeight - contentBottom);
        stepsEl.style.setProperty("--steps-bottom-gap", `${gapPx}px`);
        stepsEl.classList.remove("expand-down");
        stepsEl.classList.add("expand-up");
      } else {
        stepsEl.style.removeProperty("--steps-bottom-gap");
        stepsEl.classList.remove("expand-up");
        stepsEl.classList.add("expand-down");
      }
    }

    const stepsEl = document.querySelector(".multi-step-form-steps");
    if (stepsEl) {
      updateStepsExpandMode();
      const resizeObserver = new ResizeObserver(() => updateStepsExpandMode());
      const observeActiveStep = () => {
        const active = stepsEl.querySelector(".step-content.active");
        resizeObserver.disconnect();
        if (active) resizeObserver.observe(active);
      };
      observeActiveStep();
      window.addEventListener("resize", updateStepsExpandMode);
      document.addEventListener("multistep-step-change", () => {
        observeActiveStep();
        requestAnimationFrame(() => updateStepsExpandMode());
      });
    }

    // Scroll so the active step (and newly revealed content) is visible. User should never have to scroll to see the next step.
    // Only run when form.config.layout === "multi-step" and form is NOT in a dropdown (login popover, etc.)
    function shouldSkipScrollToBottom(stepsEl: Element): boolean {
      const form = stepsEl.closest("form");
      if (!form) return true;
      const configJson = form.getAttribute("data-form-config");
      if (!configJson) return true;
      try {
        const parsed = JSON.parse(configJson);
        const layout = parsed?.formConfig?.layout;
        if (layout !== undefined && layout !== "multi-step") return true;
      } catch {
        return true;
      }
      return !!stepsEl.closest("[data-popover], [role='tooltip'], [id$='-dropdown']");
    }

    function scrollToBottom() {
      const stepsEl = document.querySelector(".multi-step-form-steps");
      if (!stepsEl || shouldSkipScrollToBottom(stepsEl)) return;

      const revealScroll = document.getElementById("reveal-scroll") as HTMLElement | null;
      if (revealScroll && revealScroll.scrollHeight > revealScroll.clientHeight) {
        revealScroll.scrollTo({
          top: revealScroll.scrollHeight - revealScroll.clientHeight,
          behavior: "smooth",
        });
      }

      const stepsContainer = stepsEl as HTMLElement;
      if (
        stepsContainer.scrollHeight > stepsContainer.clientHeight &&
        stepsContainer.offsetParent != null
      ) {
        stepsContainer.scrollTo({
          top: stepsContainer.scrollHeight - stepsContainer.clientHeight,
          behavior: "smooth",
        });
      }
    }

    // Observer on active step-content: fires 3‚Äì7 times per step during transitions, scrolls page to bottom so content stays visible
    const SCROLL_THROTTLE_MS = 180;
    let lastScrollCall = 0;
    let scrollRaf: number | null = null;
    function throttledScrollToBottom() {
      const now = Date.now();
      if (now - lastScrollCall < SCROLL_THROTTLE_MS) {
        if (!scrollRaf)
          scrollRaf = requestAnimationFrame(() => {
            throttledScrollToBottom();
            scrollRaf = null;
          });
        return;
      }
      lastScrollCall = now;
      scrollToBottom();
    }

    let stepScrollObserverRef: { mutation: MutationObserver; resize: ResizeObserver } | null = null;
    function observeStepContentForScroll(active: HTMLElement | null, stepsEl: Element) {
      if (stepScrollObserverRef) {
        stepScrollObserverRef.mutation.disconnect();
        stepScrollObserverRef.resize.disconnect();
        stepScrollObserverRef = null;
      }
      if (!active) return;
      if (shouldSkipScrollToBottom(stepsEl)) return; // Skip dropdown forms (login, etc.)
      const onChange = () => {
        if (shouldSkipScrollToBottom(stepsEl)) return;
        throttledScrollToBottom();
      };
      const mutationObs = new MutationObserver(onChange);
      mutationObs.observe(active, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true,
        attributeFilter: ["class", "style"],
      });
      const resizeObs = new ResizeObserver(onChange);
      resizeObs.observe(active);
      stepScrollObserverRef = { mutation: mutationObs, resize: resizeObs };
    }

    const stepsElForScroll = document.querySelector(".multi-step-form-steps");
    if (stepsElForScroll) {
      const syncScrollObserver = () => {
        const active = stepsElForScroll.querySelector(".step-content.active") as HTMLElement | null;
        observeStepContentForScroll(active, stepsElForScroll);
      };
      syncScrollObserver();
      document.addEventListener("multistep-step-change", () => {
        syncScrollObserver();
        requestAnimationFrame(() => {
          scrollToBottom();
          setTimeout(scrollToBottom, 100);
          setTimeout(scrollToBottom, 400);
        });
      });
    }

    // Listen for typewriter completion to trigger content animations (wrapper cascade: 250ms > fields > 250ms > buttons)
    document.addEventListener("typewriter-complete", (e) => {
      const target = e.target as HTMLElement;
      const stepContent = target.closest(".step-content");
      const stepNum = stepContent?.getAttribute("data-step");
      console.log("[TYPEWRITER-COMPLETE] Step", stepNum, "animations finished");
      if (stepContent) {
        // Add the class to trigger wrapper cascade (fields at 250ms, buttons at 500ms)
        stepContent.classList.add("typewriter-complete");
        requestAnimationFrame(() => scrollToBottom());
        setTimeout(scrollToBottom, 300);
        setTimeout(scrollToBottom, 600);

        // Focus first input after cascade. On touch: skip entirely.
        // typewriter-complete fires async (transitionend/setTimeout); focus would not open iOS keypad.
        // User taps the input wrapper ‚Üí tap-to-focus runs in click handler (same gesture) ‚Üí keypad opens.
        const isTouch = typeof window !== "undefined" && "ontouchstart" in window;
        const FOCUS_DELAY_AFTER_ANIMATIONS_MS = 250;
        let focusDone = false;
        let fallbackId: ReturnType<typeof setTimeout> | null = null;
        const runFocus = () => {
          if (focusDone || isTouch) return;
          focusDone = true;
          if (fallbackId != null) {
            clearTimeout(fallbackId);
            fallbackId = null;
          }
          const focusFirstIn = (window as any).focusFirstInputIn;
          const ok = typeof focusFirstIn === "function" && focusFirstIn(stepContent);
          console.log("[FOCUS] Step", stepNum, "focusFirstInputIn:", ok ? "ok" : "no-focus");
        };

        // Fallback: run focus after cascade completes (handles missing wrapper or transitionend not firing)
        const CASCADE_END_MS = 750; /* 500ms buttons delay + ~250ms opacity/expand */
        const fallbackMs = CASCADE_END_MS + FOCUS_DELAY_AFTER_ANIMATIONS_MS + 200;
        fallbackId = setTimeout(() => {
          fallbackId = null;
          console.log("[FOCUS] Step", stepNum, "fallback setTimeout fired at", fallbackMs, "ms");
          runFocus();
        }, fallbackMs);

        // Prefer fields-wrapper transition (250ms): when it fires, cancel fallback and schedule focus
        const fieldsWrapper = stepContent.querySelector(".step-form-fields-wrapper");
        const buttonsWrapper = stepContent.querySelector(".step-form-buttons-wrapper");
        const wrapperToUse = fieldsWrapper ?? buttonsWrapper;
        const onTransitionEnd = (e: Event) => {
          const te = e as TransitionEvent;
          if (te.propertyName !== "opacity") return;
          // Only handle events from the wrapper itself; ignore bubbling from children (avoids race from multiple opacity transitions)
          if (te.target !== wrapperToUse) return;
          wrapperToUse!.removeEventListener("transitionend", onTransitionEnd);
          if (fallbackId != null) {
            clearTimeout(fallbackId);
            fallbackId = null;
          }
          console.log(
            "[FOCUS] Step",
            stepNum,
            "transitionend (opacity), scheduling focus in",
            FOCUS_DELAY_AFTER_ANIMATIONS_MS,
            "ms"
          );
          setTimeout(runFocus, FOCUS_DELAY_AFTER_ANIMATIONS_MS);
        };
        if (wrapperToUse) {
          wrapperToUse.addEventListener("transitionend", onTransitionEnd);
          console.log(
            "[FOCUS] Step",
            stepNum,
            "listening for",
            fieldsWrapper ? "fields-wrapper" : "buttons-wrapper",
            "transitionend"
          );
        } else {
          console.log("[FOCUS] Step", stepNum, "no wrapper found, relying on fallback setTimeout");
        }
      }
    });

    // Mark steps with typewriter effect
    document.querySelectorAll(".step-content").forEach((step) => {
      const hasTypewriter = step.querySelector(".typewriter-text");
      if (hasTypewriter) {
        step.classList.add("has-typewriter");
      }
    });

    // Initialize rotating placeholders for all inputs with animated placeholders
    const animatedInputs = document.querySelectorAll(
      'input[data-has-animated-placeholder="true"]'
    ) as NodeListOf<HTMLInputElement>;

    // console.log(
    //   `[ANIMATED-PLACEHOLDER] üéØ Found ${animatedInputs.length} inputs with animated placeholders`
    // );

    // Store placeholder data for each field
    const placeholderData = new Map<
      string,
      { index: number; values: string[]; syncGroup?: string }
    >();

    // Initialize placeholder data for each input
    animatedInputs.forEach((input) => {
      const placeholders = input.getAttribute("data-animated-placeholders");
      const fieldId = input.id;

      // console.log(
      //   `[ANIMATED-PLACEHOLDER] üîç Checking input: ${fieldId}, has value: ${!!input.value}, value length: ${input.value?.length || 0}`
      // );

      if (placeholders) {
        try {
          const values = JSON.parse(placeholders);

          // Note: Sync groups have been removed - all fields now use staggered delays
          // Previously firstName and lastName were synced, but this prevented the stagger effect

          placeholderData.set(fieldId, { index: 0, values, syncGroup: undefined });
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] ‚úÖ Initialized ${fieldId} with ${values.length} placeholders`
          // );
        } catch (e) {
          console.error(
            `[ANIMATED-PLACEHOLDER] ‚ùå Failed to parse placeholders for ${fieldId}:`,
            e
          );
        }
      }
    });

    // Hide placeholder spans when input has value
    animatedInputs.forEach((input) => {
      const span = document.querySelector(
        `.animated-placeholder[data-for="${input.id}"]`
      ) as HTMLElement;
      if (span) {
        // console.log(`[ANIMATED-PLACEHOLDER] üé¨ Setting up detection for ${input.id}`);

        // Helper function to check and hide/show placeholder
        // Hide only when: has value or autofilled. Show when empty so animation plays until data is entered.
        const checkAndHidePlaceholder = () => {
          const hasValue = input.value && input.value.length > 0;

          let isAutofilled = false;
          try {
            isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
          } catch (e) {
            console.log(
              `[ANIMATED-PLACEHOLDER] ‚ö†Ô∏è Could not check autofill pseudo-class for ${input.id}`
            );
          }

          if (hasValue || isAutofilled) {
            span.style.display = "none";
          } else {
            span.style.display = "flex";
          }
        };

        input.addEventListener("focus", () => {
          checkAndHidePlaceholder();
        });
        input.addEventListener("blur", () => {
          checkAndHidePlaceholder();
        });

        // Listen for manual input changes
        input.addEventListener("input", () => {
          // console.log(`[ANIMATED-PLACEHOLDER] üìù Input event fired for ${input.id}`);
          checkAndHidePlaceholder();
        });

        // Listen for change events (fired by browser autofill in some cases)
        input.addEventListener("change", () => {
          // console.log(`[ANIMATED-PLACEHOLDER] üîÑ Change event fired for ${input.id}`);
          checkAndHidePlaceholder();
        });

        // Listen for autofill detection via CSS animation
        input.addEventListener("animationstart", (e: AnimationEvent) => {
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] üé® Animation started: ${e.animationName} for ${input.id}`
          // );
          if (e.animationName === "onAutoFillStart") {
            console.log(
              `[ANIMATED-PLACEHOLDER] üéØ Autofill CSS animation detected for ${input.id}`
            );
            checkAndHidePlaceholder();
          }
        });

        // Watch for attribute changes (some browsers add data attributes on autofill)
        const observer = new MutationObserver(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] üî¨ Mutation observed for ${input.id}`);
          checkAndHidePlaceholder();
        });
        observer.observe(input, {
          attributes: true,
          attributeFilter: ["value", "data-value"],
        });

        // Check initial value immediately
        console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Initial check (0ms) for ${input.id}`);
        checkAndHidePlaceholder();

        // Delayed checks for autofill (fallback for browsers that don't support animation detection)
        // Browser autofill can happen at various times, so we check multiple times
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Delayed check (100ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 100);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Delayed check (500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 500);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Delayed check (1000ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 1000);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Delayed check (1500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 1500);
        setTimeout(() => {
          // console.log(`[ANIMATED-PLACEHOLDER] ‚è±Ô∏è Delayed check (2500ms) for ${input.id}`);
          checkAndHidePlaceholder();
        }, 2500);
      }
    });

    function rotatePlaceholders() {
      animatedInputs.forEach((input, index) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        // Check both value and autofill state
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // console.log(
        //   `[ANIMATED-PLACEHOLDER] üîÑ Rotate check ${input.id}: hasValue=${hasValue}, isAutofilled=${isAutofilled}, span.display=${span?.style.display}`
        // );

        if (span && data && !hasValue && !isAutofilled && span.style.display !== "none") {
          // Scope to this input's form (contact form vs login form when both on page)
          const form = input.closest("form");
          const activeStep = form?.querySelector(".step-content.active");
          const isInActiveStep = activeStep?.contains(input);

          if (!isInActiveStep) return;

          // Find the index of this input within the active step
          const activeStepInputs = Array.from(
            activeStep!.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);

          // ‚ö†Ô∏è PROTECTED CODE - DO NOT REMOVE ‚ö†Ô∏è
          // This stagger delay creates a cascading animation effect for successive placeholders.
          // See: .cursor/rules/multistep-form-placeholder-stagger.md
          // See: markdowns/animated-placeholder-stagger-delay.md
          // Stagger delay: 200ms per field for smooth cascade effect
          const staggerDelay = stepIndex * 200;

          setTimeout(() => {
            // Only rotate if visible
            span.style.animation = "slideOutDownPlaceholder 400ms ease-out forwards";

            setTimeout(() => {
              data.index = (data.index + 1) % data.values.length;
              span.textContent = data.values[data.index];
              span.style.animation = "slideInUpPlaceholder 400ms ease-out forwards";
            }, 400);
          }, staggerDelay);
        }
      });
    }

    // Reset and restart placeholder animation
    function resetPlaceholderAnimation() {
      // console.log(`[ANIMATED-PLACEHOLDER] üîÑ Resetting placeholder animation`);

      animatedInputs.forEach((input) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const fieldId = input.id;
        const data = placeholderData.get(fieldId);

        // Check both value and autofill state
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // Skip if input has a value (from autofill or manual entry)
        if (hasValue || isAutofilled) {
          if (span) {
            span.style.display = "none";
          }
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] ‚è≠Ô∏è Skipping reset for ${input.id} (has value: ${hasValue}, autofilled: ${isAutofilled})`
          // );
          return;
        }

        if (span && data) {
          // Scope to this input's form (contact form vs login form when both on page)
          const form = input.closest("form");
          const activeStep = form?.querySelector(".step-content.active");
          const isInActiveStep = activeStep?.contains(input);

          if (!isInActiveStep) {
            // Not in active step, just reset without animation
            data.index = 0;
            span.textContent = data.values[0];
            return;
          }

          // Find the index of this input within the active step for stagger delay
          const activeStepInputs = Array.from(
            activeStep!.querySelectorAll('input[data-has-animated-placeholder="true"]')
          );
          const stepIndex = activeStepInputs.indexOf(input);

          // Apply stagger delay for reset animation too (200ms per field)
          const staggerDelay = stepIndex * 200;

          setTimeout(() => {
            data.index = 0;
            span.textContent = data.values[0];
            span.style.animation = "slideInDownPlaceholder 400ms ease-out forwards";
          }, staggerDelay);
        }
      });
    }

    // Store interval ID so we can clear it
    let placeholderInterval: ReturnType<typeof setInterval> | null = null;

    // Start placeholder rotation
    function startPlaceholderRotation() {
      // console.log(`[ANIMATED-PLACEHOLDER] üöÄ Starting placeholder rotation`);

      // Clear any existing interval
      if (placeholderInterval) {
        clearInterval(placeholderInterval);
      }

      // Check all inputs for values one more time before starting animation
      // This catches browser autofill that may have completed
      animatedInputs.forEach((input) => {
        const span = document.querySelector(
          `.animated-placeholder[data-for="${input.id}"]`
        ) as HTMLElement;
        const hasValue = input.value && input.value.length > 0;

        let isAutofilled = false;
        try {
          isAutofilled = input.matches(":-webkit-autofill") || input.matches(":autofill");
        } catch (e) {
          // Ignore
        }

        // console.log(
        //   `[ANIMATED-PLACEHOLDER] üé¨ Pre-animation check for ${input.id}: hasValue=${hasValue}, isAutofilled=${isAutofilled}`
        // );

        if (span && (hasValue || isAutofilled)) {
          span.style.display = "none";
          // console.log(
          //   `[ANIMATED-PLACEHOLDER] ‚úÖ Pre-animation: hiding placeholder for ${input.id} (has value: ${hasValue}, autofilled: ${isAutofilled})`
          // );
        }
      });

      // Reset to first placeholder
      resetPlaceholderAnimation();

      // Start new interval
      placeholderInterval = setInterval(rotatePlaceholders, 2000);
      // console.log(`[ANIMATED-PLACEHOLDER] ‚è∞ Rotation interval started (2000ms)`);
    }

    // Rotate placeholders every 2 seconds. Defer start so it runs after form handler
    // has set .step-content.active (initializeMultiStepForm runs later in this same callback).
    if (animatedInputs.length > 0) {
      setTimeout(() => startPlaceholderRotation(), 0);

      // Watch for step changes and restart animation
      const stepObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "class") {
            const target = mutation.target as HTMLElement;
            if (target.classList.contains("active") && target.classList.contains("step-content")) {
              // Check if this step has animated placeholders
              const hasPlaceholders = target.querySelector(
                '[data-has-animated-placeholder="true"]'
              );
              if (hasPlaceholders) {
                // console.log("[PLACEHOLDER] Restarting placeholder animation for active step");
                startPlaceholderRotation();
              }
            }
          }
        });
      });

      // Observe all step-content elements
      const steps = document.querySelectorAll(".step-content");
      steps.forEach((step) => {
        stepObserver.observe(step, {
          attributes: true,
          attributeFilter: ["class"],
        });
      });
    }

    // Add focus/blur shadow animation to all form inputs using event delegation
    // This works for both existing and dynamically added inputs
    // Run immediately, not waiting for DOMContentLoaded
    // document.addEventListener(
    //   "focus",
    //   (e) => {
    //     const target = e.target as HTMLElement;
    //     if (
    //       target &&
    //       (target.tagName === "INPUT" ||
    //         target.tagName === "TEXTAREA" ||
    //         target.tagName === "SELECT") &&
    //       (target as HTMLInputElement).type !== "hidden"
    //     ) {
    //       const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
    //       // console.log("[FOCUS-SHADOW] Adding shadow to:", formElement.id || formElement.name);
    //       target.classList.add("shadow-focus");

    //       // Scroll the form so focused element is at cursor line (40vh from top of form viewport)
    //       setTimeout(() => {
    //         const form = target.closest("form");
    //         if (form) {
    //           const formRect = form.getBoundingClientRect();
    //           const elementRect = target.getBoundingClientRect();
    //           const delta = elementRect.top - (formRect.top + form.clientHeight * 0.4);
    //           form.scrollBy({ top: delta, behavior: "smooth" });
    //           console.log("[MULTISTEP-SCROLL] Form scrollBy (focus):", {
    //             element: formElement.id || formElement.name,
    //             delta,
    //             formScrollTopBefore: form.scrollTop,
    //             reason: "position input at cursor line (40vh)",
    //           });
    //         }
    //       }, 100);
    //     }
    //   },
    //   true
    // );

    // When user focuses an input (e.g. after scrolling up to edit), set that step's panel as .active
    document.addEventListener(
      "focus",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          !target ||
          (target.tagName !== "INPUT" &&
            target.tagName !== "TEXTAREA" &&
            target.tagName !== "SELECT") ||
          (target as HTMLInputElement).type === "hidden"
        ) {
          return;
        }
        const form = target.closest("form");
        if (!form?.closest("[data-multi-step-form]")) return;

        const stepContent = target.closest(".step-content");
        const stepNumber = parseInt(stepContent?.getAttribute("data-step") || "0", 10);
        if (!stepNumber) return;

        const handler = (
          form as HTMLFormElement & {
            multiStepHandler?: {
              setActiveStepByFocus: (n: number) => void;
              getCurrentStep?: () => number;
            };
          }
        ).multiStepHandler;

        // Don't allow focus to land on a step we haven't reached (errant click/tab on password etc.)
        const currentStep = handler?.getCurrentStep?.() ?? 1;
        if (stepNumber > currentStep) {
          console.log("[MULTISTEP-CLICK-DEBUG] focus blocked (future step)", {
            stepNumber,
            currentStep,
            targetId: target.id,
          });
          setTimeout(() => (target as HTMLInputElement).blur(), 0);
          return;
        }

        console.log("[MULTISTEP-CLICK-DEBUG] focus on input ‚Üí setActiveStepByFocus", {
          stepNumber,
          targetId: target.id,
          targetName: (target as HTMLInputElement).name,
        });
        if (handler?.setActiveStepByFocus) {
          handler.setActiveStepByFocus(stepNumber);
        }
      },
      true
    );

    document.addEventListener(
      "blur",
      (e) => {
        const target = e.target as HTMLElement;
        if (
          target &&
          (target.tagName === "INPUT" ||
            target.tagName === "TEXTAREA" ||
            target.tagName === "SELECT")
        ) {
          const formElement = target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
          // console.log("[FOCUS-SHADOW] Removing shadow from:", formElement.id || formElement.name);
          target.classList.remove("shadow-focus");
        }
      },
      true
    );

    // Prevent non-interactive elements from stealing focus
    // This prevents accidental taps on background elements from removing input focus
    document.addEventListener(
      "mousedown",
      (e) => {
        const target = e.target as HTMLElement;

        if (!target) return;

        // Get the currently focused element
        const focusedElement = document.activeElement as HTMLElement;

        // Check if an input/textarea/select is currently focused
        const isInputFocused =
          focusedElement &&
          (focusedElement.tagName === "INPUT" ||
            focusedElement.tagName === "TEXTAREA" ||
            focusedElement.tagName === "SELECT") &&
          (focusedElement as HTMLInputElement).type !== "hidden";

        if (!isInputFocused) return;

        // Define interactive elements that SHOULD be allowed to take focus
        const isInteractiveElement =
          target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.tagName === "SELECT" ||
          target.tagName === "BUTTON" ||
          target.tagName === "A" ||
          target.hasAttribute("contenteditable") ||
          target.closest("button") || // Check if inside a button
          target.closest("a"); // Check if inside a link

        // If clicking on a non-interactive element while an input has focus,
        // prevent focus loss
        if (!isInteractiveElement) {
          console.log("[MULTISTEP-CLICK-DEBUG] mousedown (MultiStepForm): prevented focus loss", {
            targetTag: target.tagName,
            targetClass: target.className?.slice?.(0, 60),
            focusedTag: focusedElement?.tagName,
          });
          e.preventDefault();
          // Ensure focus stays on the input
          setTimeout(() => {
            focusedElement.focus();
          }, 0);
        }
      },
      true
    );

    // Get all form configs from data-form-config attribute (avoids script-order / TDZ issues)
    function runMultiStepInit() {
      const forms = document.querySelectorAll("form[data-form-config]");
      if (forms.length === 0) return;
      forms.forEach((formEl) => {
        const form = formEl as HTMLFormElement;
        let formId: string;
        let formConfig: any;
        let initialData: Record<string, any> = {};
        try {
          const parsed = JSON.parse(form.getAttribute("data-form-config") ?? "{}");
          formId = parsed.formId;
          formConfig = parsed.formConfig;
          initialData = parsed.initialData ?? {};
        } catch (e) {
          console.error("[MULTISTEP-FORM] Invalid data-form-config on form", form.id || formEl, e);
          return;
        }
        if (!formId || !formConfig) {
          console.error("[MULTISTEP-FORM] Missing formId or formConfig in data-form-config");
          return;
        }

        console.log("[MULTISTEP-FORM] Attaching handler for form:", formId);

        // Pre-fill form fields with initial data
        Object.entries(initialData || {}).forEach(([key, value]) => {
          const input = form.querySelector(`[name="${key}"]`) as HTMLInputElement;
          if (input && value) {
            (input as HTMLInputElement).value = value as string;
            console.log(`[MULTISTEP-FORM] Pre-filled ${key}:`, value);

            // Hide animated placeholder if this input has one
            if (input.hasAttribute("data-has-animated-placeholder")) {
              const span = document.querySelector(
                `.animated-placeholder[data-for="${input.id}"]`
              ) as HTMLElement;
              if (span) {
                span.style.display = "none";
                console.log(`[MULTISTEP-FORM] Hid animated placeholder for ${key}`);
              }
            }
          }
        });

        // Initialize the form with skip logic
        initializeMultiStepForm(form, {
          initialData: initialData || {},
          formConfig,
        });
      });
    }

    // Run init when DOM is ready; if script loaded late (e.g. deferred), run immediately
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", runMultiStepInit);
    } else {
      runMultiStepInit();
    }
  }

  // Run when DOM is ready; if this script loaded after DOMContentLoaded (e.g. deferred module), run now
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", runMultiStepPageInit);
  } else {
    runMultiStepPageInit();
  }

  // Helper function to check if all fields in current step are valid
  function checkAllFieldsValid() {
    const activeStep = document.querySelector(".step-content.active");
    if (!activeStep) {
      console.log("[FIELD-VALIDATION] No active step found");
      return false;
    }

    const allInputsSelector =
      'input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea, select';
    const requiredInputs = activeStep.querySelectorAll(
      `input[required]:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea[required], select[required]`
    );
    // Include optional fields that have value (e.g. phone with required: false) so valid icon updates
    const inputsToCheck =
      requiredInputs.length > 0 ? requiredInputs : activeStep.querySelectorAll(allInputsSelector);

    function hasValue(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement): boolean {
      if (el instanceof HTMLSelectElement) return el.value !== "";
      const input = el as HTMLInputElement;
      if (input.type === "checkbox") return input.checked;
      if (input.type === "radio") {
        const name = input.name;
        if (!name) return input.checked;
        const group = activeStep.querySelectorAll<HTMLInputElement>(
          `input[type="radio"][name="${name}"]`
        );
        return Array.from(group).some((r) => r.checked);
      }
      return (el.value ?? "").length > 0;
    }

    let allValid = true;
    const fieldStates: { name: string; value: string; valid: boolean }[] = [];
    const seenRadioGroups = new Set<string>();

    inputsToCheck.forEach((input) => {
      const inputEl = input as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
      const inputAsInput = inputEl as HTMLInputElement;
      // When step has no required fields, only validate inputs that have value (e.g. optional phone)
      if (requiredInputs.length === 0 && !hasValue(inputEl as HTMLInputElement)) return;
      if (inputAsInput.type === "radio" && inputAsInput.name) {
        if (seenRadioGroups.has(inputAsInput.name)) return;
        seenRadioGroups.add(inputAsInput.name);
      }
      const hasVal = hasValue(inputEl as HTMLInputElement);
      const validByValidity = inputEl.validity?.valid !== false && hasVal;
      const validByClass = inputEl.classList?.contains("is-valid") && hasVal;
      const valid = inputAsInput.type === "radio" ? hasVal : validByValidity || validByClass;

      let displayValue: string;
      if (inputEl instanceof HTMLSelectElement) {
        displayValue = inputEl.value;
      } else if (inputAsInput.type === "checkbox") {
        displayValue = inputAsInput.checked ? "checked" : "";
      } else if (inputAsInput.type === "radio") {
        const checkedRadio =
          inputAsInput.name &&
          activeStep.querySelector<HTMLInputElement>(
            `input[type="radio"][name="${inputAsInput.name}"]:checked`
          );
        displayValue = checkedRadio?.value ?? "";
      } else {
        const v = (inputEl as HTMLInputElement | HTMLTextAreaElement).value ?? "";
        displayValue = v.substring(0, 20) + (v.length > 20 ? "..." : "");
      }

      fieldStates.push({
        name: inputEl.name || inputEl.id || "",
        value: displayValue,
        valid,
      });

      if (!valid) allValid = false;
    });

    // Step with no required fields and nothing filled: show default icon (e.g. "skip"), not valid
    if (requiredInputs.length === 0 && fieldStates.length === 0) allValid = false;

    console.log("[FIELD-VALIDATION] Current step field states:", fieldStates);

    if (allValid) {
      console.log("‚úÖ [FIELD-VALIDATION] ALL FIELDS IN PANEL ARE VALID!");
    } else {
      console.log("‚ùå [FIELD-VALIDATION] Some fields are invalid or empty");
    }

    // When panel is valid: show valid icon, hide default icon (and vice versa). CSS in global.css uses button.is-valid to control .icon-valid/.icon-default display.
    activeStep.querySelectorAll("button").forEach((btn) => {
      const iconValid = btn.querySelector(".icon-valid");
      const iconDefault = btn.querySelector(".icon-default");
      if (!iconValid || !iconDefault) return;
      if (allValid) {
        btn.classList.add("is-valid");
        const buttonText = btn.querySelector(".button-text");
        const validLabel = btn.getAttribute("data-valid-label");
        const defaultLabel = btn.getAttribute("data-default-label");
        if (buttonText && validLabel && defaultLabel) buttonText.textContent = validLabel;
      } else {
        btn.classList.remove("is-valid");
        const buttonText = btn.querySelector(".button-text");
        const defaultLabel = btn.getAttribute("data-default-label");
        if (buttonText && defaultLabel) buttonText.textContent = defaultLabel;
      }
    });

    return allValid;
  }

  /** Mark invalid/empty required fields with is-invalid so icons turn red. Call on submit attempt when form is invalid. */
  function showValidationErrorsForForm(formEl?: HTMLFormElement | null) {
    const form = formEl ?? document.querySelector("[data-multi-step-form] form");
    if (!form?.closest("[data-multi-step-form]")) return;
    const activeStep = form.querySelector(".step-content.active");
    if (!activeStep) return;

    function hasValue(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement): boolean {
      if (el instanceof HTMLSelectElement) return el.value !== "";
      const input = el as HTMLInputElement;
      if (input.type === "checkbox" || input.type === "radio") return input.checked;
      return (el.value ?? "").trim().length > 0;
    }

    const requiredInputs = activeStep.querySelectorAll<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >(
      'input[required]:not([type="hidden"]):not([type="submit"]):not([type="button"]), textarea[required], select[required]'
    );
    const seenRadioGroups = new Set<string>();
    requiredInputs.forEach((input) => {
      const inputAsInput = input as HTMLInputElement;
      if (inputAsInput.type === "radio" && inputAsInput.name) {
        if (seenRadioGroups.has(inputAsInput.name)) return;
        seenRadioGroups.add(inputAsInput.name);
      }
      const hasVal = hasValue(input);
      const valid = input.validity?.valid !== false && hasVal;
      if (!hasVal || !valid) {
        input.classList.add("is-invalid");
        input.classList.remove("is-valid");
      }
    });
    checkAllFieldsValid();
  }
  (window as any).showMultiStepFormValidationErrors = showValidationErrorsForForm;

  // Add validation state classes for visual feedback (all input types, textarea, select)
  document.addEventListener("DOMContentLoaded", () => {
    const form =
      document.querySelector(".multi-step-form-steps")?.closest("form") ??
      document.querySelector("[data-multi-step-form] form") ??
      document.querySelector("form");
    const scope = form ?? document;
    const fields = scope.querySelectorAll<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >(
      'input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="image"]):not([type="reset"]), textarea, select'
    );

    function hasValue(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement): boolean {
      if (el instanceof HTMLSelectElement) return el.value !== "";
      const input = el as HTMLInputElement;
      if (input.type === "checkbox" || input.type === "radio") return input.checked;
      return (el.value ?? "").length > 0;
    }

    function updateValidityState(
      target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    ) {
      const hasVal = hasValue(target as HTMLInputElement);
      const valid = target.validity?.valid !== false;
      if (hasVal) {
        if (valid) {
          target.classList.add("is-valid");
          target.classList.remove("is-invalid");
        } else {
          target.classList.add("is-invalid");
          target.classList.remove("is-valid");
        }
      } else {
        target.classList.remove("is-valid", "is-invalid");
      }
      checkAllFieldsValid();
    }

    fields.forEach((field) => {
      const isCheckboxOrRadio =
        field instanceof HTMLInputElement && (field.type === "checkbox" || field.type === "radio");
      const isSelect = field instanceof HTMLSelectElement;

      if (isCheckboxOrRadio || isSelect) {
        field.addEventListener("change", () => updateValidityState(field));
        field.addEventListener("blur", () => updateValidityState(field));
      } else {
        let inputDebounce: ReturnType<typeof setTimeout> | null = null;
        field.addEventListener("input", () => {
          if (inputDebounce) clearTimeout(inputDebounce);
          inputDebounce = setTimeout(() => {
            inputDebounce = null;
            updateValidityState(field);
          }, 150);
        });
        field.addEventListener("blur", () => {
          if (inputDebounce) {
            clearTimeout(inputDebounce);
            inputDebounce = null;
          }
          updateValidityState(field);
        });
      }

      field.addEventListener("focus", () => {
        field.classList.remove("is-invalid");
      });

      // Initial state in case of pre-filled or server state
      updateValidityState(field);
    });
  });
</script>

<!-- Input-with-icon icons are injected by global initInputWithIcon() in App.astro (DOMContentLoaded + astro:after-swap) -->
