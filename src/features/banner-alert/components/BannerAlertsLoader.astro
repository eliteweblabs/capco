---
/**
 * BannerAlertsLoader Component
 * Automatically loads and displays all active banner alerts from the database
 * Include this component in your layout to show site-wide banners
 */

import { supabaseAdmin } from "../../../lib/supabase-admin";
import BannerAlert from "./BannerAlert.astro";

interface Props {
  position?: "top" | "bottom" | "all";
  width?: "full" | "auto";
  hideFooter?: boolean;
  /** Current pathname (e.g. from Astro.url.pathname). Used to filter banners by targetPages. */
  pathname?: string;
  /** Page template/layout. When "fullform", skip the scroll-driven translateY reveal effect. */
  template?: string;
}

const { position = "all", width = "full", pathname, template, hideFooter = false } = Astro.props;

// Fetch active banner alerts
let banners: any[] = [];

if (supabaseAdmin) {
  const now = new Date().toISOString();

  let query = supabaseAdmin
    .from("bannerAlerts")
    .select("*")
    .eq("isActive", true)
    .or(`startDate.is.null,startDate.lte.${now}`)
    .or(`endDate.is.null,endDate.gte.${now}`)
    .order("createdAt", { ascending: false });

  if (position !== "all") {
    query = query.eq("position", position);
  }

  const { data, error } = await query;

  if (error) {
    console.error("Error fetching banner alerts:", error);
  } else {
    banners = data || [];
  }
}

// Filter by target pages when pathname is provided
const currentSlug = pathname ? pathname.replace(/^\//, "").split("/")[0] || "" : null;
const filteredBanners =
  pathname && currentSlug !== ""
    ? banners.filter((b) => {
        const target = (b.targetPages || "").trim();
        if (!target) return true; // no targeting = show on all pages
        const slugs = target.split(",").map((s: string) => s.trim().toLowerCase()).filter(Boolean);
        return slugs.includes(currentSlug.toLowerCase());
      })
    : banners;

// Group banners by position; only show banners that have content (avoid empty "space" from bad data)
const hasContent = (b: { content?: string | null }) => (b.content ?? "").trim().length > 0;
const topBanners = filteredBanners.filter((b) => b.position === "top" && hasContent(b));
const bottomBanners = filteredBanners.filter((b) => b.position === "bottom" && hasContent(b));

// Hide top banners on auth pages (e.g. /auth/login) to avoid layout/focus interference with iOS keypad
const isAuthPath = pathname?.startsWith("/auth") ?? false;
const topBannersToShow = isAuthPath ? [] : topBanners;

// Debug logging
// console.log("[BannerAlertsLoader] Total banners:", banners.length);
// console.log("[BannerAlertsLoader] Top banners:", topBanners.length);
// console.log("[BannerAlertsLoader] Bottom banners:", bottomBanners.length);
// console.log("[BannerAlertsLoader] Position filter:", position);

// Get all banner IDs for early dismiss check (use filtered so hidden banners stay hidden)
const allBannerIds = filteredBanners.map((b) => String(b.id));

import { MOBILE_MEDIA_QUERY } from "../../../lib/ux-utils";
---

<!-- 
  CRITICAL: This script must run BEFORE banners render to prevent layout shift.
  It injects CSS to hide dismissed banners immediately, before they cause page hop.
-->
<script is:inline define:vars={{ allBannerIds }}>
  (function() {
    try {
      const stored = localStorage.getItem("dismissedBanners");
      if (stored) {
        const dismissed = JSON.parse(stored);
        // Create a style element to hide dismissed banners IMMEDIATELY
        const style = document.createElement("style");
        style.id = "banner-dismiss-styles";
        let css = "";
        allBannerIds.forEach(function(id) {
          if (dismissed.includes(id) || dismissed.includes(String(id))) {
            css += `.banner-alert[data-banner-id="${id}"] { display: none !important; }\n`;
          }
        });
        if (css) {
          style.textContent = css;
          // Insert at the start of head for highest priority
          document.head.insertBefore(style, document.head.firstChild);
        }
      }
    } catch (e) {
      // Ignore localStorage errors
    }
  })();
</script>

{
  topBannersToShow.length > 0 && (position === "all" || position === "top") && (
    <div class={`z-50 flex flex-col ${width === "full" ? "w-full" : ""}`} id="top-banner-container">
      {topBannersToShow.map((banner) => (
        <BannerAlert
          id={banner.id}
          type={banner.type}
          title=""
          description={banner.content ?? ""}
          position="top"
          expireMs={banner.expireMs}
          dismissible={banner.dismissible}
          width={width}
        />
      ))}
    </div>
  )
}


{
  bottomBanners.length > 0 && (position === "all" || position === "bottom") && (
    <div class="banner-alerts-bottom fixed bottom-0 left-0 right-0 z-[60] flex flex-col" id="bottom-banner-container">
      {bottomBanners.map((banner) => (
        <BannerAlert
          id={banner.id}
          type={banner.type}
          title=""
          description={banner.content ?? ""}
          position="bottom"
          expireMs={banner.expireMs}
          dismissible={banner.dismissible}
        />
      ))}
    </div>
  )
}

<script define:vars={{ pathname: pathname ?? "", template: template ?? "", MOBILE_MEDIA_QUERY }}>
  (function () {
    const isAuthPath = typeof pathname === "string" && pathname.startsWith("/auth");
    const remPx = () => parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
    const isMobile = () => window.matchMedia(MOBILE_MEDIA_QUERY).matches;

    /** Re-apply dismiss styles from localStorage after SPA swap (inline script only runs on first load). */
    function applyDismissStylesFromStorage() {
      try {
        const stored = localStorage.getItem("dismissedBanners");
        if (!stored) return;
        const dismissed = JSON.parse(stored);
        const dismissedSet = new Set(dismissed.map((id) => String(id)));
        const banners = document.querySelectorAll(".banner-alert[data-banner-id]");
        let css = "";
        banners.forEach((el) => {
          const id = el.getAttribute("data-banner-id");
          if (id && dismissedSet.has(id)) {
            css += `.banner-alert[data-banner-id="${id}"] { display: none !important; }\n`;
          }
        });
        if (!css) return;
        let styleEl = document.getElementById("banner-dismiss-styles");
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = "banner-dismiss-styles";
          document.head.insertBefore(styleEl, document.head.firstChild);
        }
        styleEl.textContent = css;
      } catch (_) {
        // ignore
      }
    }

    function getDismissedSet() {
      let dismissedSet = new Set();
      try {
        const stored = localStorage.getItem("dismissedBanners");
        if (stored) {
          const dismissed = JSON.parse(stored);
          dismissedSet = new Set(dismissed.map((id) => String(id)));
        }
      } catch { /* ignore localStorage errors */ }
      return dismissedSet;
    }

    function updateBannerOffsets() {
      const scrollEl = document.getElementById("reveal-scroll");
      const sidebar = document.getElementById("sidebar");
      if (!scrollEl) return;

      const rem = remPx();
      const off = window.__revealSidebarOffsets || { topPx: 4 * rem, topBannersOnlyPx: 0, bottomPx: 4 * rem };
      window.__revealSidebarOffsets = off;

      const topBannerContainer = document.getElementById("top-banner-container");
      const bottomBannerContainer = document.getElementById("bottom-banner-container");
      const dismissedSet = getDismissedSet();
      // Use navbar-content only (the bar); top-banner-container is inside main-navbar so main-navbar height would include alerts
      const navbarContent = document.getElementById("navbar-content");
      const navbarBarHeight = navbarContent ? navbarContent.offsetHeight : 4 * rem;
      const dynamicHeightEls = document.querySelectorAll('[data-dynamic-height]');

      let topAlertsHeight = 0;
      if (topBannerContainer) {
        const topBanners = topBannerContainer.querySelectorAll(".banner-alert");
        let visibleCount = 0;
        topBanners.forEach((banner) => {
          const id = banner.getAttribute("data-banner-id");
          if (!id || !dismissedSet.has(id)) visibleCount++;
        });
        topBannerContainer.style.display = visibleCount > 0 ? "" : "none";
        topAlertsHeight = visibleCount > 0 ? topBannerContainer.offsetHeight : 0;

        const baseHeight = navbarBarHeight;
        const totalTopHeight = baseHeight + topAlertsHeight;
        off.topPx = totalTopHeight;
        off.topBannersOnlyPx = topAlertsHeight;
        scrollEl.style.marginTop = totalTopHeight + "px";
        /* Do NOT set minHeight: flex layout (flex-1 min-h-0) constrains #reveal-scroll as the scroll container */
        if (isMobile()) {
          // dynamicHeightEls.forEach((el) => {
            // (el as HTMLElement).style.transition = (el as HTMLElement).style.transition || "margin-top 0.3s ease-in-out";
            // (el as HTMLElement).style.marginTop = totalTopHeight + "px";
          // });
         
        } else {
          // if (sidebar) (sidebar as HTMLElement).style.minHeight = "";
        }

        if (sidebar) {
            sidebar.style.height = "calc(100dvh - " + totalTopHeight + "px)";
          }
          
        dynamicHeightEls.forEach((el) => {
            const v = (el.getAttribute("data-dynamic-height") || "true").toLowerCase();
            const elH = el;
            if (!elH.style.transition && !elH.style.transitionDuration) {
              elH.style.transition = "margin-top 0.3s ease-in-out";
            }
            const calcVal = "calc(100dvh - " + totalTopHeight + "px)";
            if (v === "height") {
              elH.style.height = calcVal;
              elH.style.minHeight = "";
            } else {
              elH.style.minHeight = calcVal;
              elH.style.height = "";
            }
          });
      } else {
        off.topBannersOnlyPx = 0;
        const baseHeight = navbarBarHeight;
        off.topPx = baseHeight;
        dynamicHeightEls.forEach((el) => {
            const v = (el.getAttribute("data-dynamic-height") || "true").toLowerCase();
            const elH = el;
            if (!elH.style.transition && !elH.style.transitionDuration) {
              elH.style.transition = "margin-top 0.3s ease-in-out";
            }
            const calcVal = "calc(100dvh - " + baseHeight + "px)";
            if (v === "height") {
              elH.style.height = calcVal;
              elH.style.minHeight = "";
            } else {
              elH.style.minHeight = calcVal;
              elH.style.height = "";
            }
          });
        scrollEl.style.marginTop = baseHeight + "px";
   
      }

      let bottomBannerHeight = 0;
      if (bottomBannerContainer) {
        const bottomBanners = bottomBannerContainer.querySelectorAll(".banner-alert");
        let visibleCount = 0;
        bottomBanners.forEach((banner) => {
          const id = banner.getAttribute("data-banner-id");
          if (!id || !dismissedSet.has(id)) visibleCount++;
        });
        bottomBannerContainer.style.display = visibleCount > 0 ? "" : "none";
        bottomBannerHeight = visibleCount > 0 ? bottomBannerContainer.offsetHeight : 0;
        const footerEl = document.querySelector("footer");
        if (bottomBannerHeight > 0) {
          document.body.style.paddingBottom = bottomBannerHeight + "px";
          if (footerEl) footerEl.style.marginBottom = bottomBannerHeight + "px";
        } else {
          document.body.style.paddingBottom = "";
          if (footerEl) footerEl.style.marginBottom = "";
        }
        off.bottomPx = 4 * rem + bottomBannerHeight;
      }
    }

    let prevScrollTop = 0;
    let translateY = 0;
    let lastAppliedTranslateY = -1;
    let scrollRafId = 0;
    const skipReveal = typeof template === "string" && template === "fullform";

    function run() {
      const scrollEl = document.getElementById("reveal-scroll");
      if (!scrollEl) return;

      const navbarContent = document.getElementById("navbar-content");
      const footer = document.getElementById("reveal-footer");
      const REM = Math.max(navbarContent?.offsetHeight ?? 4 * 16, footer?.offsetHeight ?? 4 * 16) / 16;
      const maxPx = () => REM * remPx();

      function clampedScrollTop() {
        const maxScroll = Math.max(0, scrollEl.scrollHeight - scrollEl.clientHeight);
        return Math.max(0, Math.min(maxScroll, scrollEl.scrollTop));
      }

      function maxScroll() {
        return Math.max(0, scrollEl.scrollHeight - scrollEl.clientHeight);
      }

      function setSidebarPosition(translateYVal) {
        const off = window.__revealSidebarOffsets;
        const topPx = off?.topPx ?? 4 * remPx();
        const topBannersOnlyPx = off?.topBannersOnlyPx ?? 0;
        // Smooth: top moves with scroll so sidebar tracks the reveal (topPx - translateY), clamped to banners-only
        const topVal = Math.max(topBannersOnlyPx, topPx - translateYVal);
        const topStr = topVal + "px";
        const side = document.getElementById("sidebar");
        if (side) {
          side.style.bottom = "";
          side.style.top = topStr;
        }
        document.querySelectorAll("[data-drawer-top-offset]").forEach(function (el) {
          if (el instanceof HTMLElement) el.style.top = topStr;
        });
      }

      function syncNavbarAtTop(translateYVal) {
        const navbar = document.getElementById("main-navbar");
        if (navbar) navbar.classList.toggle("navbar-at-top", translateYVal <= 0);
      }

      function updateTranslate() {
        if (skipReveal) {
          scrollEl.style.transform = "";
          setSidebarPosition(0);
          syncNavbarAtTop(0);
          lastAppliedTranslateY = -1;
          return;
        }
        const scrollTop = clampedScrollTop();
        const curMaxScroll = maxScroll();

        if (!isMobile()) {
          scrollEl.style.transform = "";
          prevScrollTop = 0;
          translateY = 0;
          lastAppliedTranslateY = -1;
          setSidebarPosition(0);
          syncNavbarAtTop(0);
          return;
        }
        // When at bottom: keep full reveal (translateY = maxPx). Opening the nav/sidebar
        // sets body overflow:hidden and triggers layout shifts (e.g. iOS viewport resize).
        // That shrinks maxScroll and clamps scrollTop, producing negative deltaY and
        // incorrectly reducing translateY. Fix: if we're at bottom, always use maxPx().
        const atBottom = curMaxScroll <= 1 || scrollTop >= curMaxScroll - 2;
        if (atBottom) {
          translateY = maxPx();
        } else {
          const deltaY = scrollTop - prevScrollTop;
          translateY += deltaY;
          // translateY += deltaY;
          translateY = Math.max(0, Math.min(maxPx(), translateY));
        }
        prevScrollTop = scrollTop;
        // Skip DOM writes when unchanged to avoid stuck feel at limits
        if (lastAppliedTranslateY !== translateY) {
          lastAppliedTranslateY = translateY;
          scrollEl.style.transform = `translateY(-${translateY}px)`;
          setSidebarPosition(translateY);
          syncNavbarAtTop(translateY);
        }
      }

      updateBannerOffsets();

      if (!isMobile() || skipReveal) {
        scrollEl.style.transform = "";
        translateY = 0;
        setSidebarPosition(0);
        syncNavbarAtTop(0);
      }

      // Skip observers on auth pages (e.g. /auth/login) to avoid layout thrash that can block iOS keypad
      if (!isAuthPath) {
        if (navbarContent) {
          const ro = new ResizeObserver(() => requestAnimationFrame(updateBannerOffsets));
          ro.observe(navbarContent);
        }
        function recalcAfterBannerDismissed() {
          setTimeout(() => {
            updateBannerOffsets();
            if (!skipReveal) setSidebarPosition(translateY);
          }, 350);
        }
        const topContainer = document.getElementById("top-banner-container");
        const bottomContainer = document.getElementById("bottom-banner-container");
        const observe = (el) => {
          if (!el) return;
          new MutationObserver(recalcAfterBannerDismissed).observe(el, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ["style", "class"],
          });
        };
        observe(topContainer);
        observe(bottomContainer);
        window.addEventListener("resize", updateBannerOffsets);
        // Reveal-only: scroll-driven translateY and main-content observer (skip on fullform â€“ form layout conflicts)
        if (!skipReveal) {
          const mainContent = document.getElementById("main-content");
          if (mainContent && isMobile()) {
            const mo = new MutationObserver(() => {
              requestAnimationFrame(() => {
                prevScrollTop = clampedScrollTop();
                translateY = Math.max(0, Math.min(maxPx(), prevScrollTop));
                updateTranslate();
              });
            });
            mo.observe(mainContent, { attributes: true, attributeFilter: ["class"] });
          }
        }
      }
      // SPA disabled: document.addEventListener("astro:page-load", () => requestAnimationFrame(updateBannerOffsets));

      // SPA disabled: re-apply dismiss styles after swap
      // document.addEventListener("astro:after-swap", () => {
      //   requestAnimationFrame(() => {
      //     applyDismissStylesFromStorage();
      //     updateBannerOffsets();
      //   });
      // });
      // document.addEventListener("astro:page-load", () => {
      //   requestAnimationFrame(applyDismissStylesFromStorage);
      // });

      if (isMobile() && !isAuthPath && !skipReveal) {
        prevScrollTop = clampedScrollTop();
        translateY = Math.min(prevScrollTop, maxPx());
        updateTranslate();
      }

      if (!isAuthPath && !skipReveal) {
        if (!scrollEl.dataset.revealInit) {
          scrollEl.dataset.revealInit = "true";
          window.addEventListener("resize", () => {
            prevScrollTop = clampedScrollTop();
            translateY = Math.max(0, Math.min(maxPx(), prevScrollTop));
            updateTranslate();
            if (isMobile() && !scrollEl.dataset.revealScrollAdded) {
              scrollEl.dataset.revealScrollAdded = "true";
              scrollEl.addEventListener("scroll", () => {
                if (scrollRafId) return;
                scrollRafId = requestAnimationFrame(() => {
                  scrollRafId = 0;
                  updateTranslate();
                });
              }, { passive: true });
            }
          });
        }
        if (isMobile() && !scrollEl.dataset.revealScrollAdded) {
          scrollEl.dataset.revealScrollAdded = "true";
          scrollEl.addEventListener("scroll", () => {
            if (scrollRafId) return;
            scrollRafId = requestAnimationFrame(() => {
              scrollRafId = 0;
              updateTranslate();
            });
          }, { passive: true });
        }
      }
      if (skipReveal) {
        scrollEl.style.transform = "";
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => setTimeout(run, 10));
    } else {
      setTimeout(run, 10);
    }
    // SPA disabled: document.addEventListener("astro:page-load", () => requestAnimationFrame(run));
  })();
</script>
