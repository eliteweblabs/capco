---
/**
 * BannerAlertsLoader Component
 * Automatically loads and displays all active banner alerts from the database
 * Include this component in your layout to show site-wide banners
 */

import { supabaseAdmin } from "../../../lib/supabase-admin";
import BannerAlert from "./BannerAlert.astro";

interface Props {
  position?: "top" | "bottom" | "all";
  width?: "full" | "auto";
  /** Current pathname (e.g. from Astro.url.pathname). Used to filter banners by targetPages. */
  pathname?: string;
}

const { position = "all", width = "full", pathname } = Astro.props;

// Fetch active banner alerts
let banners: any[] = [];

if (supabaseAdmin) {
  const now = new Date().toISOString();

  let query = supabaseAdmin
    .from("bannerAlerts")
    .select("*")
    .eq("isActive", true)
    .or(`startDate.is.null,startDate.lte.${now}`)
    .or(`endDate.is.null,endDate.gte.${now}`)
    .order("createdAt", { ascending: false });

  if (position !== "all") {
    query = query.eq("position", position);
  }

  const { data, error } = await query;

  if (error) {
    console.error("Error fetching banner alerts:", error);
  } else {
    banners = data || [];
  }
}

// Filter by target pages when pathname is provided
const currentSlug = pathname ? pathname.replace(/^\//, "").split("/")[0] || "" : null;
const filteredBanners =
  pathname && currentSlug !== ""
    ? banners.filter((b) => {
        const target = (b.targetPages || "").trim();
        if (!target) return true; // no targeting = show on all pages
        const slugs = target.split(",").map((s: string) => s.trim().toLowerCase()).filter(Boolean);
        return slugs.includes(currentSlug.toLowerCase());
      })
    : banners;

// Group banners by position; only show banners that have content (avoid empty "space" from bad data)
const hasContent = (b: { content?: string | null }) => (b.content ?? "").trim().length > 0;
const topBanners = filteredBanners.filter((b) => b.position === "top" && hasContent(b));
const bottomBanners = filteredBanners.filter((b) => b.position === "bottom" && hasContent(b));

// Debug logging
// console.log("[BannerAlertsLoader] Total banners:", banners.length);
// console.log("[BannerAlertsLoader] Top banners:", topBanners.length);
// console.log("[BannerAlertsLoader] Bottom banners:", bottomBanners.length);
// console.log("[BannerAlertsLoader] Position filter:", position);

// Get all banner IDs for early dismiss check (use filtered so hidden banners stay hidden)
const allBannerIds = filteredBanners.map((b) => String(b.id));
---

<!-- 
  CRITICAL: This script must run BEFORE banners render to prevent layout shift.
  It injects CSS to hide dismissed banners immediately, before they cause page hop.
-->
<script is:inline define:vars={{ allBannerIds }}>
  (function() {
    try {
      const stored = localStorage.getItem("dismissedBanners");
      if (stored) {
        const dismissed = JSON.parse(stored);
        // Create a style element to hide dismissed banners IMMEDIATELY
        const style = document.createElement("style");
        style.id = "banner-dismiss-styles";
        let css = "";
        allBannerIds.forEach(function(id) {
          if (dismissed.includes(id) || dismissed.includes(String(id))) {
            css += `.banner-alert[data-banner-id="${id}"] { display: none !important; }\n`;
          }
        });
        if (css) {
          style.textContent = css;
          // Insert at the start of head for highest priority
          document.head.insertBefore(style, document.head.firstChild);
        }
      }
    } catch (e) {
      // Ignore localStorage errors
    }
  })();
</script>

{
  topBanners.length > 0 && (position === "all" || position === "top") && (
    <div class={`z-50 banner-alerts-top flex flex-col ${width === "full" ? "w-full" : ""} gap-1`} id="top-banner-container">
      {topBanners.map((banner) => (
        <BannerAlert
          id={banner.id}
          type={banner.type}
          title=""
          description={banner.content ?? ""}
          position="top"
          expireMs={banner.expireMs}
          dismissible={banner.dismissible}
          width={width}
        />
      ))}
    </div>
  )
}

{
  topBanners.length > 0 && (position === "all" || position === "top") && (
    <script is:inline>
      {/* // Adjust padding on all [data-dynamic-height] + #sidebar top/height = full navbar base (navbar + top banners); all update when a banner is cleared */}
      (function() {
        function adjustpageContentForTopBanners() {
          const topBannerContainer = document.getElementById("top-banner-container");
          const navbar = document.getElementById("main-navbar");
          const sidebar = document.getElementById("sidebar");

          if (topBannerContainer && navbar) {
            const applyNavbarBaseSpacing = function() {
              // Get dismissed banners from localStorage
              let dismissedSet = new Set();
              try {
                const stored = localStorage.getItem("dismissedBanners");
                if (stored) {
                  const dismissed = JSON.parse(stored);
                  dismissedSet = new Set(dismissed.map(function(id) { return String(id); }));
                }
              } catch (e) {
                // Ignore localStorage errors
              }

              // Count visible banners (not dismissed)
              const allBanners = topBannerContainer.querySelectorAll('.banner-alert');
              let bannerCount = 0;
              allBanners.forEach(function(banner) {
                const bannerId = banner.getAttribute('data-banner-id');
                if (!bannerId || !dismissedSet.has(String(bannerId))) {
                  bannerCount++;
                }
              });

              // Hide container when no visible banners so it doesn't leave empty space
              topBannerContainer.style.display = bannerCount > 0 ? "" : "none";

              var baseHeight = navbar.offsetHeight;

              // All [data-dynamic-height] elements get padding-top = full navbar base
              var dynamicHeightEls = document.querySelectorAll('[data-dynamic-height="true"]');
              dynamicHeightEls.forEach(function(el) {
                if (!el.style.transition) {
                  el.style.transition = "margin-top 0.3s ease-in-out";
                }
                el.style.marginTop = baseHeight + "px";
              });

              // #reveal-scroll: margin-top and height = 100dvh - baseHeight (same as sidebar)
              var revealScroll = document.getElementById("reveal-scroll");
              if (revealScroll) {
                revealScroll.style.marginTop = baseHeight + "px";
                revealScroll.style.height = "calc(100dvh - " + baseHeight + "px)";
              }

              // #sidebar top + height from combined height of visible alerts (top-banner-container)
              var combinedAlertsHeight = topBannerContainer.style.display !== "none" ? topBannerContainer.offsetHeight : 0;
              if (sidebar) {
                sidebar.style.top = baseHeight + combinedAlertsHeight + "px";
                sidebar.style.height = "calc(100dvh - 4rem - " + combinedAlertsHeight + "px)";
              }

              // Reveal layout: expose top/bottom offsets for sidebar (used by App.astro reveal script)
              var remPx = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
              window.__revealSidebarOffsets = window.__revealSidebarOffsets || { topPx: 4 * remPx, bottomPx: 4 * remPx };
              window.__revealSidebarOffsets.topPx = baseHeight + combinedAlertsHeight;
              window.__revealSidebarOffsets.bottomPx = 4 * remPx;
            };

            // Initial adjustment
            applyNavbarBaseSpacing();

            // Update on resize for responsive changes
            window.addEventListener("resize", applyNavbarBaseSpacing);

            // When navbar height changes (e.g. banner container hidden when last banner cleared)
            var resizeObserver = new ResizeObserver(function() {
              requestAnimationFrame(applyNavbarBaseSpacing);
            });
            resizeObserver.observe(navbar);

            // Watch for banner dismissals (display toggle, etc.)
            var mutationObserver = new MutationObserver(function() {
              setTimeout(applyNavbarBaseSpacing, 350); // After animation
            });
            mutationObserver.observe(topBannerContainer, {
              childList: true,
              subtree: true,
              attributes: true,
              attributeFilter: ["style"]
            });
          }
        }

        // Run immediately if DOM is ready, otherwise wait
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", adjustpageContentForTopBanners);
        } else {
          setTimeout(adjustpageContentForTopBanners, 10);
        }
        document.addEventListener("astro:page-load", () => requestAnimationFrame(adjustpageContentForTopBanners));
      })();
    </script>
  )
}

{
  bottomBanners.length > 0 && (position === "all" || position === "bottom") && (
    <div class="banner-alerts-bottom fixed bottom-0 left-0 right-0 z-[60] flex flex-col" id="bottom-banner-container">
      {bottomBanners.map((banner) => (
        <BannerAlert
          id={banner.id}
          type={banner.type}
          title=""
          description={banner.content ?? ""}
          position="bottom"
          expireMs={banner.expireMs}
          dismissible={banner.dismissible}
        />
      ))}
    </div>
  )
}

{
  bottomBanners.length > 0 && (position === "all" || position === "bottom") && (
    <script is:inline>
      (function() {
        function checkBottomBanner() {
          const container = document.getElementById("bottom-banner-container");
          if (!container) return;
          container.offsetHeight; // force reflow if needed for layout
        }
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", checkBottomBanner);
        } else {
          setTimeout(checkBottomBanner, 10);
        }
      })();
      
      {/* // Adjust footer/bottom content for bottom banners */}
      (function() {
        function adjustFooterForBanners() {
          const bottomBannerContainer = document.getElementById("bottom-banner-container");
          const footer = document.querySelector("footer");

          if (bottomBannerContainer) {
            const updateContentPadding = function() {
              // Get dismissed banners from localStorage
              let dismissedSet = new Set();
              try {
                const stored = localStorage.getItem("dismissedBanners");
                if (stored) {
                  const dismissed = JSON.parse(stored);
                  dismissedSet = new Set(dismissed.map(function(id) { return String(id); }));
                }
              } catch (e) {
                // Ignore localStorage errors
              }

              // Count visible banners (not dismissed)
              const allBanners = bottomBannerContainer.querySelectorAll('.banner-alert');
              let visibleCount = 0;
              allBanners.forEach(function(banner) {
                const bannerId = banner.getAttribute('data-banner-id');
                if (!bannerId || !dismissedSet.has(String(bannerId))) {
                  visibleCount++;
                }
              });

              // Hide container when no visible banners so it doesn't leave empty space
              bottomBannerContainer.style.display = visibleCount > 0 ? "" : "none";

              // Calculate height only if there are visible banners
              const bannerHeight = visibleCount > 0 ? bottomBannerContainer.offsetHeight : 0;

              if (bannerHeight > 0) {
                // Add padding to body to push footer up
                document.body.style.paddingBottom = bannerHeight + "px";
                
                // Adjust footer if it exists
                if (footer) {
                  footer.style.marginBottom = bannerHeight + "px";
                }
              } else {
                document.body.style.paddingBottom = "";
                if (footer) {
                  footer.style.marginBottom = "";
                }
              }

              // Reveal layout: expose bottom offset for sidebar (used by App.astro reveal script)
              var remPx = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
              window.__revealSidebarOffsets = window.__revealSidebarOffsets || { topPx: 4 * remPx, bottomPx: 4 * remPx };
              window.__revealSidebarOffsets.bottomPx = 4 * remPx + bannerHeight;
            };

            // Initial adjustment
            updateContentPadding();

            // Update on resize for responsive changes
            window.addEventListener("resize", updateContentPadding);

            // Watch for banner dismissals
            const observer = new MutationObserver(function() {
              setTimeout(updateContentPadding, 350); // After animation
            });

            observer.observe(bottomBannerContainer, {
              childList: true,
              subtree: true,
              attributes: true,
              attributeFilter: ["style"]
            });
          }
        }

        // Run immediately if DOM is ready, otherwise wait
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", adjustFooterForBanners);
        } else {
          // Small delay to ensure banner is rendered
          setTimeout(adjustFooterForBanners, 10);
        }
        
        // Also run on Astro page transitions (defer so swap paints first)
        document.addEventListener("astro:page-load", () => requestAnimationFrame(adjustFooterForBanners));
      })();
    </script>

    
  )
}



<script>
  (function () {
    const navbar = document.getElementById("navbar-content");
    const footer = document.getElementById("reveal-footer");
    const REM =  Math.max(navbar.offsetHeight, footer.offsetHeight) / 16;

    // const REM = baseHeight / 16; // 4rem max translate (header/footer height)
    const scrollEl = document.getElementById("reveal-scroll");
    if (!scrollEl) return;

    const sidebar = document.getElementById("sidebar");
    const isMobile = () => window.matchMedia("(max-width: 767px)").matches;
    const remPx = () => parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
    const maxPx = () => REM * remPx();
    const THRESH = 8; // px threshold for at-top / at-bottom

    /** Clamp to valid scroll range so overscroll / rubber-band doesn't trip translate */
    function clampedScrollTop() {
      const maxScroll = Math.max(0, scrollEl.scrollHeight - scrollEl.clientHeight);
      return Math.max(0, Math.min(maxScroll, scrollEl.scrollTop));
    }

    function setSidebarRevealValue(scrollTop, maxScroll) {
      if (!sidebar) return;
      const value = maxScroll <= 0 ? "top" : scrollTop <= THRESH ? "top" : scrollTop >= maxScroll - THRESH ? "bottom" : null;
      const off = (window as any).__revealSidebarOffsets;
      const topPx = off?.topPx ?? remPx() * REM;
      const bottomPx = off?.bottomPx ?? remPx() * REM;
      if (value === "top") {
        sidebar.style.top = topPx + "px";
        sidebar.style.bottom = "";
      } else if (value === "bottom") {
        sidebar.style.top = "";
        sidebar.style.bottom = bottomPx + "px";
      } else {
        sidebar.style.top = "";
        sidebar.style.bottom = "";
      }
    }

    let prevScrollTop = 0;
    let translateY = 0;

    function updateTranslate() {
      const maxScroll = Math.max(0, scrollEl.scrollHeight - scrollEl.clientHeight);
      const scrollTop = clampedScrollTop();
      // setSidebarRevealValue(scrollTop, maxScroll);

      if (!isMobile()) {
        scrollEl.style.transform = "";
        prevScrollTop = 0;
        translateY = 0;
        return;
      }
      const deltaY = scrollTop - prevScrollTop;
      prevScrollTop = scrollTop;
      translateY += deltaY;
      translateY = Math.max(0, Math.min(maxPx(), translateY));
      scrollEl.style.transform = `translateY(-${translateY}px)`;
      const sideBar = document.getElementById("sidebar");
      if (sideBar) {
        debugger;
        console.log("sidebar top", navbar.offsetHeight, "navbar height", footer.offsetHeight, "translateY", translateY);
        sideBar.style.top = `${Math.max(navbar.offsetHeight, footer.offsetHeight) - translateY}px`;
      }

      //  const actionButtons = document.getElementById("action-buttons");
      // if (actionButtons) {
      //   actionButtons.style.bottom = `${(translateY + 16) }px`;
      // }


    }

    scrollEl.addEventListener("scroll", updateTranslate, { passive: true });
    window.addEventListener("resize", () => {
      prevScrollTop = clampedScrollTop();
      translateY = Math.max(0, Math.min(maxPx(), prevScrollTop));
      updateTranslate();
    });
    prevScrollTop = clampedScrollTop();
    translateY = Math.min(prevScrollTop, maxPx());
    updateTranslate();
  })();
</script>
