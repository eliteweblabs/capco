---
// AI Agent Chat Component
// Chat interface for interacting with the AI agent (similar to Claude.ai)

interface Props {
  currentUser?: any;
  projectId?: number;
}

const { currentUser, projectId } = Astro.props;
---

<div
  id="ai-chat-agent"
  class="flex h-full flex-col bg-white dark:bg-gray-900"
  data-project-id={projectId || ""}
>
  <!-- Header -->
  <div
    class="flex items-center justify-between border-b border-gray-200 bg-gray-50 p-4 dark:border-gray-700 dark:bg-gray-900"
  >
    <div class="flex items-center space-x-3">
      <div
        class="dark:bg-primary-900/30 flex h-10 w-10 items-center justify-center rounded-lg bg-primary-100"
      >
        <svg
          class="h-6 w-6 text-primary-600 dark:text-primary-400"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
          ></path>
        </svg>
      </div>
      <div>
        <h3 class="text-sm font-semibold text-gray-900 dark:text-white">AI Assistant</h3>
        <p class="text-xs text-gray-500 dark:text-gray-400">Fire Protection Expert</p>
      </div>
    </div>
    <div class="flex items-center space-x-2">
      <!-- Conversation selector -->
      <select
        id="conversation-selector"
        class="rounded-lg border border-gray-300 bg-white px-3 py-1.5 text-xs text-gray-700 focus:border-primary-500 focus:outline-none focus:ring-2 focus:ring-primary-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
      >
        <option value="">New Conversation</option>
      </select>
      <button
        id="new-conversation-btn"
        class="rounded-lg p-1.5 text-gray-400 hover:bg-gray-200 hover:text-gray-600 dark:hover:bg-gray-700 dark:hover:text-gray-300"
        title="New Conversation"
      >
        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"
          ></path>
        </svg>
      </button>
      <button
        id="delete-conversation-btn"
        class="rounded-lg p-1.5 text-gray-400 hover:bg-red-200 hover:text-red-600 dark:hover:bg-red-900 dark:hover:text-red-300"
        title="Delete Conversation"
      >
        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
          ></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- Messages Container -->
  <div
    id="ai-chat-messages"
    class="flex-1 space-y-4 overflow-y-auto p-4"
    style="max-height: calc(100vh - 200px);"
  >
    <!-- Welcome message -->
    <div id="welcome-message" class="flex justify-center">
      <div class="max-w-2xl rounded-lg bg-gray-50 p-6 text-center dark:bg-gray-700/50">
        <div class="mb-4 flex justify-center">
          <div
            class="dark:bg-primary-900/30 flex h-16 w-16 items-center justify-center rounded-full bg-primary-100"
          >
            <svg
              class="h-8 w-8 text-primary-600 dark:text-primary-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
              ></path>
            </svg>
          </div>
        </div>
        <h3 class="mb-2 text-lg font-semibold text-gray-900 dark:text-white">
          Welcome to AI Assistant
        </h3>
        <p class="mb-4 text-sm text-gray-600 dark:text-gray-400">
          I'm your fire protection engineering assistant. I can help you with:
        </p>
        <div class="grid grid-cols-1 gap-2 text-left sm:grid-cols-2">
          <div class="rounded-lg bg-white p-3 dark:bg-gray-800">
            <p class="text-xs font-medium text-gray-900 dark:text-white">üìÑ Document Generation</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">
              Create inspection reports, certificates
            </p>
          </div>
          <div class="rounded-lg bg-white p-3 dark:bg-gray-800">
            <p class="text-xs font-medium text-gray-900 dark:text-white">üìä Project Analysis</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">
              Analyze projects and provide insights
            </p>
          </div>
          <div class="rounded-lg bg-white p-3 dark:bg-gray-800">
            <p class="text-xs font-medium text-gray-900 dark:text-white">‚úÖ Code Compliance</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">Check NFPA compliance</p>
          </div>
          <div class="rounded-lg bg-white p-3 dark:bg-gray-800">
            <p class="text-xs font-medium text-gray-900 dark:text-white">üí° General Assistance</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">
              Answer questions and provide guidance
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Input Area -->
  <div class="border-t border-gray-200 bg-gray-50 p-4 dark:border-gray-700 dark:bg-gray-900">
    <div class="flex items-end space-x-2">
      <div class="flex-1">
        <!-- Image previews container -->
        <div id="image-previews" class="mb-2 flex flex-wrap gap-2"></div>

        <!-- Input wrapper with drag-drop support -->
        <div
          id="input-wrapper"
          class="relative rounded-lg border-2 border-dashed border-gray-300 bg-white transition-colors dark:border-gray-600 dark:bg-gray-800"
        >
          <textarea
            id="ai-chat-input"
            rows="1"
            placeholder="Ask me anything about fire protection... (or drag images here)"
            class="w-full resize-none rounded-lg border-0 bg-transparent px-4 py-3 text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-0 dark:text-white dark:placeholder-gray-500"
            style="max-height: 120px;"></textarea>

          <!-- Drag overlay -->
          <div
            id="drag-overlay"
            class="bg-primary-50/80 dark:bg-primary-900/30 absolute inset-0 hidden items-center justify-center rounded-lg"
          >
            <div class="text-center">
              <svg
                class="mx-auto h-12 w-12 text-primary-600 dark:text-primary-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                ></path>
              </svg>
              <p class="mt-2 text-sm font-medium text-primary-600 dark:text-primary-400">
                Drop images here
              </p>
            </div>
          </div>
        </div>

        <div
          class="mt-1 flex items-center justify-between text-xs text-gray-500 dark:text-gray-400"
        >
          <span>Press Enter to send, Shift+Enter for new line ‚Ä¢ Drag images to attach</span>
          <span id="token-count" class="hidden">0 tokens</span>
        </div>
      </div>
      <button
        id="ai-chat-send"
        class="rounded-lg bg-primary-600 px-4 py-3 text-white transition-colors hover:bg-primary-700 disabled:cursor-not-allowed disabled:opacity-50"
        disabled
      >
        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<style>
  #ai-chat-messages {
    scroll-behavior: smooth;
  }

  .message-user {
    @apply flex justify-end;
  }

  .message-assistant {
    @apply flex justify-start;
  }

  .message-bubble {
    @apply max-w-3xl rounded-lg px-4 py-3 shadow-sm;
  }

  .message-user .message-bubble {
    @apply bg-primary-600 text-white;
  }

  .message-assistant .message-bubble {
    @apply bg-gray-100 text-gray-900 dark:bg-gray-700 dark:text-white;
  }

  .message-content {
    @apply whitespace-pre-wrap break-words;
  }

  .message-meta {
    @apply mt-1 text-xs opacity-75;
  }

  .typing-indicator {
    @apply flex space-x-1;
  }

  .typing-dot {
    @apply h-2 w-2 rounded-full bg-gray-400;
    animation: typing 1.4s infinite;
  }

  .typing-dot:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-dot:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing {
    0%,
    60%,
    100% {
      transform: translateY(0);
      opacity: 0.7;
    }
    30% {
      transform: translateY(-10px);
      opacity: 1;
    }
  }
</style>

<script>
  interface Message {
    role: "user" | "assistant";
    content: string;
    timestamp: string;
    metadata?: any;
  }

  interface ImageAttachment {
    file: File;
    preview: string;
    id: string;
  }

  class AIChatAgent {
    private currentConversationId: string | null = null;
    private messages: Message[] = [];
    private conversations: Array<{ id: string; title: string; updatedAt: string }> = [];
    private isProcessing = false;
    private imageAttachments: ImageAttachment[] = [];

    constructor() {
      this.initialize();
    }

    private initialize() {
      if (!document.getElementById("ai-chat-agent")) return;
      const input = document.getElementById("ai-chat-input") as HTMLTextAreaElement;
      const sendBtn = document.getElementById("ai-chat-send") as HTMLButtonElement;
      const newConvBtn = document.getElementById("new-conversation-btn");
      const deleteConvBtn = document.getElementById("delete-conversation-btn");
      const conversationSelector = document.getElementById(
        "conversation-selector"
      ) as HTMLSelectElement;
      const inputWrapper = document.getElementById("input-wrapper");
      const dragOverlay = document.getElementById("drag-overlay");

      // Drag and drop handlers
      this.setupDragAndDrop(inputWrapper, dragOverlay, input);

      // Auto-resize textarea
      input?.addEventListener("input", () => {
        this.adjustTextareaHeight(input);
        this.updateSendButtonState();
      });

      // Send on Enter (Shift+Enter for new line)
      input?.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          if (!sendBtn.disabled) {
            this.sendMessage();
          }
        }
      });

      // Send button
      sendBtn?.addEventListener("click", () => {
        if (!sendBtn.disabled) {
          this.sendMessage();
        }
      });

      // New conversation
      newConvBtn?.addEventListener("click", () => {
        this.startNewConversation();
      });

      // Delete conversation
      deleteConvBtn?.addEventListener("click", () => {
        if (this.currentConversationId) {
          this.deleteConversation(this.currentConversationId);
        }
      });

      // Conversation selector
      conversationSelector?.addEventListener("change", (e) => {
        const target = e.target as HTMLSelectElement;
        if (target.value) {
          this.loadConversation(target.value);
        } else {
          this.startNewConversation();
        }
      });

      // Load conversations on init
      this.loadConversations();
    }

    private setupDragAndDrop(
      wrapper: HTMLElement | null,
      overlay: HTMLElement | null,
      input: HTMLTextAreaElement
    ) {
      if (!wrapper || !overlay) return;

      // Prevent default drag behaviors on the wrapper
      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        wrapper.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });

      // Show overlay on drag enter
      wrapper.addEventListener("dragenter", () => {
        overlay?.classList.remove("hidden");
        overlay?.classList.add("flex");
        wrapper?.classList.add("border-primary-500");
      });

      // Hide overlay on drag leave
      wrapper.addEventListener("dragleave", (e) => {
        // Only hide if we're leaving the wrapper (not entering a child)
        const rect = wrapper.getBoundingClientRect();
        const x = e.clientX;
        const y = e.clientY;
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
          overlay?.classList.add("hidden");
          overlay?.classList.remove("flex");
          wrapper?.classList.remove("border-primary-500");
        }
      });

      // Handle drop
      wrapper.addEventListener("drop", (e) => {
        overlay?.classList.add("hidden");
        overlay?.classList.remove("flex");
        wrapper?.classList.remove("border-primary-500");

        const files = Array.from(e.dataTransfer?.files || []);
        this.handleImageFiles(files);
      });

      // Also handle paste
      input.addEventListener("paste", (e) => {
        const items = Array.from(e.clipboardData?.items || []);
        const imageFiles = items
          .filter((item) => item.type.startsWith("image/"))
          .map((item) => item.getAsFile())
          .filter((file): file is File => file !== null);

        if (imageFiles.length > 0) {
          this.handleImageFiles(imageFiles);
        }
      });
    }

    private handleImageFiles(files: File[]) {
      const imageFiles = files.filter((file) => file.type.startsWith("image/"));

      if (imageFiles.length === 0) {
        console.warn("‚ö†Ô∏è [AI-CHAT] No image files found");
        return;
      }

      imageFiles.forEach((file) => {
        // Check file size (max 10MB)
        if (file.size > 10 * 1024 * 1024) {
          alert(`Image "${file.name}" is too large. Maximum size is 10MB.`);
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const preview = e.target?.result as string;
          const id = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

          this.imageAttachments.push({
            file,
            preview,
            id,
          });

          this.renderImagePreviews();
          this.updateSendButtonState();
        };
        reader.readAsDataURL(file);
      });
    }

    private renderImagePreviews() {
      const container = document.getElementById("image-previews");
      if (!container) return;

      if (this.imageAttachments.length === 0) {
        container.innerHTML = "";
        return;
      }

      container.innerHTML = this.imageAttachments
        .map(
          (attachment) => `
        <div class="group relative inline-block">
          <img
            src="${attachment.preview}"
            alt="Preview"
            class="h-20 w-20 rounded-lg object-cover border-2 border-gray-300 dark:border-gray-600"
          />
          <button
            type="button"
            class="absolute -right-2 -top-2 flex h-6 w-6 items-center justify-center rounded-full bg-red-500 text-white opacity-0 transition-opacity group-hover:opacity-100"
            data-image-id="${attachment.id}"
            onclick="window.aiChatAgent?.removeImage('${attachment.id}')"
          >
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
      `
        )
        .join("");
    }

    private removeImage(imageId: string) {
      this.imageAttachments = this.imageAttachments.filter((img) => img.id !== imageId);
      this.renderImagePreviews();
      this.updateSendButtonState();
    }

    private updateSendButtonState() {
      const input = document.getElementById("ai-chat-input") as HTMLTextAreaElement;
      const sendBtn = document.getElementById("ai-chat-send") as HTMLButtonElement;
      const hasText = input?.value.trim().length > 0;
      const hasImages = this.imageAttachments.length > 0;
      sendBtn.disabled = (!hasText && !hasImages) || this.isProcessing;
    }

    private adjustTextareaHeight(textarea: HTMLTextAreaElement) {
      textarea.style.height = "auto";
      textarea.style.height = `${Math.min(textarea.scrollHeight, 120)}px`;
    }

    private async uploadImages(attachments: ImageAttachment[]): Promise<string[]> {
      const uploadedUrls: string[] = [];

      for (const attachment of attachments) {
        try {
          // Create FormData for file upload
          const formData = new FormData();
          formData.append("file", attachment.file);
          formData.append("folder", "ai-chat");

          // Upload to AI chat image upload endpoint
          const uploadResponse = await fetch("/api/agent/upload-image", {
            method: "POST",
            credentials: "include",
            body: formData,
          });

          if (uploadResponse.ok) {
            const result = await uploadResponse.json();
            if (result.url || result.publicUrl) {
              uploadedUrls.push(result.url || result.publicUrl);
            }
          } else {
            console.error("‚ùå [AI-CHAT] Failed to upload image:", attachment.file.name);
            // Fallback: use data URL (less ideal but works)
            uploadedUrls.push(attachment.preview);
          }
        } catch (error) {
          console.error("‚ùå [AI-CHAT] Error uploading image:", error);
          // Fallback: use data URL
          uploadedUrls.push(attachment.preview);
        }
      }

      return uploadedUrls;
    }

    private async sendMessage() {
      const input = document.getElementById("ai-chat-input") as HTMLTextAreaElement;
      const sendBtn = document.getElementById("ai-chat-send") as HTMLButtonElement;
      const message = input.value.trim();
      const hasImages = this.imageAttachments.length > 0;

      if ((!message && !hasImages) || this.isProcessing) return;

      // Store attachments before clearing
      const attachments = [...this.imageAttachments];

      // Clear input and attachments
      input.value = "";
      this.imageAttachments = [];
      this.renderImagePreviews();
      this.adjustTextareaHeight(input);
      sendBtn.disabled = true;
      this.isProcessing = true;

      // Add user message to UI (with image indicators)
      let displayMessage = message;
      if (attachments.length > 0) {
        displayMessage += `\n[${attachments.length} image${attachments.length > 1 ? "s" : ""} attached]`;
      }
      this.addMessage("user", displayMessage);

      // Show typing indicator
      this.showTypingIndicator();

      try {
        // Get project ID from component data attribute
        const chatContainer = document.getElementById("ai-chat-agent");
        const projectId = chatContainer?.dataset.projectId;

        // Upload images if any
        let imageUrls: string[] = [];
        if (attachments.length > 0) {
          imageUrls = await this.uploadImages(attachments);
        }

        // Send to API
        const response = await fetch("/api/agent/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            message: message || (imageUrls.length > 0 ? "Please analyze these images" : ""),
            conversationId: this.currentConversationId || undefined,
            context: projectId ? { projectId: parseInt(projectId) } : undefined,
            images: imageUrls.length > 0 ? imageUrls : undefined,
          }),
        });

        const data = await response.json();

        if (!response.ok) {
          // Provide more detailed error message
          const errorMsg = data.error || data.message || "Failed to send message";
          const errorDetails = data.debug ? ` (Debug: ${JSON.stringify(data.debug)})` : "";
          throw new Error(`${errorMsg}${errorDetails}`);
        }

        // Hide typing indicator
        this.hideTypingIndicator();

        // Add assistant response
        this.addMessage("assistant", data.response, data.metadata);

        // Update conversation ID if new
        if (data.conversationId && !this.currentConversationId) {
          this.currentConversationId = data.conversationId;
          await this.loadConversations();
          this.updateConversationSelector();
        }

        // Update token count
        if (data.metadata?.tokensUsed) {
          this.updateTokenCount(data.metadata.tokensUsed);
        }
      } catch (error: any) {
        console.error("‚ùå [AI-CHAT] Error:", error);
        console.error("‚ùå [AI-CHAT] Error details:", {
          message: error.message,
          name: error.name,
          stack: error.stack,
        });
        this.hideTypingIndicator();

        // Show more helpful error message
        let errorMessage = `Sorry, I encountered an error: ${error.message}`;
        if (error.message?.includes("API key")) {
          errorMessage = "Configuration error: API key issue. Please contact support.";
        } else if (error.message?.includes("rate limit")) {
          errorMessage = "Rate limit exceeded. Please try again in a moment.";
        } else if (error.message?.includes("Failed to process message")) {
          errorMessage = "Unable to process your message. Please check Railway logs for details.";
        }

        this.addMessage("assistant", errorMessage, { error: true });
      } finally {
        this.isProcessing = false;
        sendBtn.disabled = false;
        input.focus();
      }
    }

    private addMessage(role: "user" | "assistant", content: string, metadata?: any) {
      const messagesContainer = document.getElementById("ai-chat-messages");
      if (!messagesContainer) return;

      // Hide welcome message
      const welcomeMsg = document.getElementById("welcome-message");
      if (welcomeMsg) {
        welcomeMsg.style.display = "none";
      }

      const message: Message = {
        role,
        content,
        timestamp: new Date().toISOString(),
        metadata,
      };

      this.messages.push(message);

      const messageDiv = document.createElement("div");
      messageDiv.className = `message-${role}`;

      const bubble = document.createElement("div");
      bubble.className = "message-bubble";

      const contentDiv = document.createElement("div");
      contentDiv.className = "message-content";
      contentDiv.textContent = content;

      const metaDiv = document.createElement("div");
      metaDiv.className = "message-meta";
      metaDiv.textContent = new Date(message.timestamp).toLocaleTimeString();

      bubble.appendChild(contentDiv);
      bubble.appendChild(metaDiv);
      messageDiv.appendChild(bubble);
      messagesContainer.appendChild(messageDiv);

      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    private showTypingIndicator() {
      const messagesContainer = document.getElementById("ai-chat-messages");
      if (!messagesContainer) return;

      const indicator = document.createElement("div");
      indicator.id = "typing-indicator";
      indicator.className = "message-assistant";

      const bubble = document.createElement("div");
      bubble.className = "message-bubble";

      const typingDiv = document.createElement("div");
      typingDiv.className = "typing-indicator";
      typingDiv.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      `;

      bubble.appendChild(typingDiv);
      indicator.appendChild(bubble);
      messagesContainer.appendChild(indicator);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    private hideTypingIndicator() {
      const indicator = document.getElementById("typing-indicator");
      if (indicator) {
        indicator.remove();
      }
    }

    private async loadConversations() {
      try {
        const response = await fetch("/api/agent/conversations", {
          credentials: "include",
        });

        if (response.status === 401) return;

        const data = await response.json();

        if (data.success) {
          this.conversations = data.conversations || [];
          this.updateConversationSelector();
        }
      } catch (error) {
        console.error("‚ùå [AI-CHAT] Error loading conversations:", error);
      }
    }

    private updateConversationSelector() {
      const selector = document.getElementById("conversation-selector") as HTMLSelectElement;
      if (!selector) return;

      // Keep "New Conversation" option
      selector.innerHTML = '<option value="">New Conversation</option>';

      // Add conversations
      this.conversations.forEach((conv) => {
        const option = document.createElement("option");
        option.value = conv.id;
        option.textContent =
          conv.title || `Conversation ${new Date(conv.updatedAt).toLocaleDateString()}`;
        if (conv.id === this.currentConversationId) {
          option.selected = true;
        }
        selector.appendChild(option);
      });
    }

    private async loadConversation(conversationId: string) {
      try {
        const response = await fetch(`/api/agent/conversations?id=${conversationId}`, {
          credentials: "include",
        });

        const data = await response.json();

        if (data.success && data.conversation) {
          this.currentConversationId = conversationId;
          this.messages = (data.conversation.messages || []).map((msg: any) => ({
            role: msg.role,
            content: msg.content,
            timestamp: msg.createdAt,
            metadata: msg.metadata,
          }));

          this.renderMessages();
        }
      } catch (error) {
        console.error("‚ùå [AI-CHAT] Error loading conversation:", error);
      }
    }

    private renderMessages() {
      const messagesContainer = document.getElementById("ai-chat-messages");
      if (!messagesContainer) return;

      // Clear container
      messagesContainer.innerHTML = "";

      // Hide welcome message
      const welcomeMsg = document.getElementById("welcome-message");
      if (welcomeMsg) {
        welcomeMsg.style.display = "none";
      }

      // Render all messages
      this.messages.forEach((msg) => {
        this.addMessage(msg.role, msg.content, msg.metadata);
      });
    }

    private startNewConversation() {
      this.currentConversationId = null;
      this.messages = [];

      const messagesContainer = document.getElementById("ai-chat-messages");
      if (messagesContainer) {
        messagesContainer.innerHTML = "";
        const welcomeMsg = document.getElementById("welcome-message");
        if (welcomeMsg) {
          welcomeMsg.style.display = "block";
        }
      }

      const selector = document.getElementById("conversation-selector") as HTMLSelectElement;
      if (selector) {
        selector.value = "";
      }
    }

    private async deleteConversation(conversationId: string) {
      if (!confirm("Are you sure you want to delete this conversation?")) {
        return;
      }

      try {
        const response = await fetch(`/api/agent/conversations?id=${conversationId}`, {
          method: "DELETE",
          credentials: "include",
        });

        const data = await response.json();

        if (data.success) {
          // If deleted conversation was current, start new
          if (conversationId === this.currentConversationId) {
            this.startNewConversation();
          }

          // Reload conversations
          await this.loadConversations();
        }
      } catch (error) {
        console.error("‚ùå [AI-CHAT] Error deleting conversation:", error);
        alert("Failed to delete conversation");
      }
    }

    private updateTokenCount(tokens: number) {
      const tokenCount = document.getElementById("token-count");
      if (tokenCount) {
        tokenCount.textContent = `${tokens.toLocaleString()} tokens`;
        tokenCount.classList.remove("hidden");
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener("DOMContentLoaded", () => {
    const chatAgent = new AIChatAgent();

    // Expose to window for image removal button onclick
    window.aiChatAgent = chatAgent;
  });
</script>
