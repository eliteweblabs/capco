---
import Alert from "../../components/partials/Alert.astro";
import SimpleIcon from "../../components/common/SimpleIcon.astro";
import Dropzone from "../../components/common/Dropzone.astro";
import Tooltip from "../../components/common/Tooltip.astro";

export interface Props {
  currentUser?: any;
  globalInputClasses?: string;
  secondaryTextClasses?: string;
  primaryTextClasses?: string;
}

const {
  currentUser,
  globalInputClasses = "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white",
  secondaryTextClasses = "text-gray-600 dark:text-gray-400",
  primaryTextClasses = "text-gray-900 dark:text-white",
} = Astro.props;

import SlotMachineModalFunction from "../../components/form/SlotMachineModalFunction.astro";

console.log("üöÄ [PDF-SYSTEM] Current user:", currentUser);
---

<style>
  /* Custom scrollbar for fields list */
  #fields-list::-webkit-scrollbar {
    width: 8px;
  }

  #fields-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
  }

  #fields-list::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }

  #fields-list::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
  }

  /* Dark mode scrollbar */
  .dark #fields-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
  }

  .dark #fields-list::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
  }

  .dark #fields-list::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }
</style>
<div class="pdf-system-container p-6 color-background rounded-lg shadow-lg">
  <div class="mb-6">
    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">PDF System</h2>
    <p class="text-gray-600 dark:text-gray-400">Create templates and generate professional PDFs</p>
  </div>

  <!-- Tab Navigation -->
  <div class="mb-6">
    <div class="border-b border-gray-200 dark:border-gray-700">
      <nav class="-mb-px flex space-x-8">
        <button
          id="templates-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-primary-500 font-medium text-sm text-primary-600 dark:text-primary-400"
          data-tab="templates"
        >
          <SimpleIcon name="file-text" class="w-4 h-4 inline mr-2" />
          Templates
        </button>
        <button
          id="generate-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
          data-tab="generate"
        >
          <SimpleIcon name="file-plus" class="w-4 h-4 inline mr-2" />
          Generate PDF
        </button>
        <button
          id="contacts-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
          data-tab="contacts"
        >
          <SimpleIcon name="user" class="w-4 h-4 inline mr-2" />
          Google Contacts
        </button>
        <button
          id="scanner-tab"
          class="pdf-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
          data-tab="scanner"
        >
          <SimpleIcon name="file-search" class="w-4 h-4 inline mr-2" />
          Scanner
        </button>
      </nav>
    </div>
  </div>

  <!-- Templates Tab Content -->
  <div id="templates-content" class="pdf-tab-content">
    <div class="mb-6">
      <div class="flex justify-between items-center mb-4">
        <!-- <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Template Management</h3> -->
        <div class="w-full">
          <Dropzone
            id="new-template-dropzone"
            accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif"
            maxSize={50}
            label="Drop a document here or click to browse"
            description="Supported formats: PDF, DOC, DOCX, JPG, PNG, GIF"
            required={false}
          />
        </div>
      </div>

      <!-- Template Editor Accordion (hidden by default) -->
      <div
        id="template-editor-accordion"
        class="hidden mb-6 border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden"
      >
        <div class="color-background p-6">
          <!-- Template Form -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Name
              </label>
              <input
                type="text"
                id="template-name"
                placeholder="Enter template name..."
                class={globalInputClasses}
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Type
              </label>
              <select id="template-type" class={globalInputClasses}>
                <option value="body">Body Template</option>
                <option value="header">Header Template</option>
                <option value="footer">Footer Template</option>
              </select>
            </div>
          </div>

          <!-- Template Content Editor -->
          <div class="grid grid-cols-12 gap-4">
            <div class="mb-6 col-span-8">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Template Content
              </label>
              <div
                id="template-editor"
                class="border border-gray-300 dark:border-gray-600 rounded-md min-h-[400px]"
              >
                <!-- Quill Editor will be loaded here -->
              </div>
            </div>
            <!-- Extracted Fields -->
            <div id="extracted-fields" class="mb-6 hidden col-span-4 flex flex-col max-h-[600px]">
              <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3 flex-shrink-0">
                Detected Fields
              </h4>
              <div id="fields-list" class="space-y-2 overflow-y-auto flex-1 pr-2">
                <!-- Extracted fields will be displayed here -->
              </div>
            </div>
          </div>

          <!-- Save Options -->
          <div class="mb-4 p-4 border border-gray-200 dark:border-gray-700 rounded-md hidden">
            <label class="flex items-center space-x-2 cursor-pointer">
              <input
                type="checkbox"
                checked="checked"
                id="save-html-template-checkbox"
                class="w-4 h-4 text-primary-600 bg-gray-100 border-gray-300 rounded focus:ring-primary-500 dark:focus:ring-primary-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
              />
              <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
                Save HTML version to templates directory
              </span>
            </label>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1 ml-6">
              Saves the OCR'd/extracted content as an HTML file in the templates folder for preview
              purposes
            </p>
          </div>

          <!-- Save Template -->
          <div class="flex justify-end space-x-4 mt-6">
            <button
              id="cancel-template-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
            >
              Cancel
            </button>
            <button
              id="save-template-btn"
              class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
            >
              <SimpleIcon name="save" class="w-4 h-4 inline mr-2" />
              Save Template
            </button>
          </div>
        </div>
      </div>

      <!-- Template List -->
      <div id="templates-list" class="space-y-4">
        <!-- Templates will be loaded here -->
      </div>
    </div>
  </div>

  <!-- Scanner Tab Content -->
  <div id="scanner-content" class="pdf-tab-content hidden">
    <div class="mb-6">
      <div class="flex justify-between items-center mb-4">
        <div>
          <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Document Scanner</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
            Upload and view documents with OCR text extraction. No template generation - just scan
            and view.
          </p>
        </div>
      </div>

      <div class="w-full mb-6">
        <Dropzone
          id="scanner-dropzone"
          accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif"
          maxSize={50}
          label="Drop a document here or click to browse"
          description="Supported formats: PDF, DOC, DOCX, JPG, PNG, GIF"
          required={false}
        />
      </div>

      <!-- PDF Viewer / Document Display -->
      <div id="scanner-viewer-section" class="hidden mb-6">
        <div class="grid grid-cols-12 gap-4">
          <!-- PDF Viewer / Image Display -->
          <div class="col-span-8">
            <div
              class="border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-900 p-4 min-h-[600px] max-h-[800px] overflow-y-auto"
            >
              <div id="scanner-pdf-viewer" class="w-full">
                <!-- PDF.js viewer or image will be rendered here -->
                <div class="text-center text-gray-500 dark:text-gray-400 py-20">
                  <p>Document preview will appear here</p>
                </div>
              </div>
            </div>
          </div>

          <!-- Detected Fields Panel -->
          <div class="col-span-4">
            <div
              id="scanner-extracted-fields"
              class="border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 p-4 max-h-[600px] overflow-y-auto"
            >
              <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3">
                Detected Fields
              </h4>
              <div id="scanner-fields-list" class="space-y-2">
                <div class="text-sm text-gray-500 dark:text-gray-400 text-center py-8">
                  Upload a document to detect fields...
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Generate PDF Tab Content -->
  <div id="generate-content" class="pdf-tab-content hidden">
    <div class="mb-6">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Generate PDF</h3>

      <!-- User Search -->
      <div class="mb-6">
        <label class="hidden block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Search User
        </label>
        <div class="flex space-x-2">
          <!-- <input
            type="text"
            id="user-search"
            placeholder="Search by user name, address, or client..."
            class={globalInputClasses}
          />
          <button
            id="search-users-btn"
            class="bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
          >
            <SimpleIcon name="search" class="w-4 h-4 inline mr-2" />
            Search
          </button> -->
          <!-- replace the above with slot machine for google contacts endpoint -->
          <!-- <button
            id="search-user-btn"
            class="hidden px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
            onclick="window.pdfSystem.checkGoogleAuthAndSearch()"
          >
            <SimpleIcon name="user" class="w-4 h-4 inline mr-2" />
            Search for a user...
          </button> -->

          <!-- Hidden SlotMachineModal for when auth is ready -->
          <SlotMachineModalFunction
            id="user-search"
            icon="user"
            title="Search User"
            options={[]}
            placeholder="Search for a user..."
            showCloseButton={true}
            showCancelButton={true}
            fetchApiEndpoint="/api/google/contacts"
            searchText="Search for a user..."
            searchPlaceholder="Search for a user..."
            valueField="id"
            labelField="name"
            {currentUser}
            {globalInputClasses}
          />
        </div>
        <div class="flex space-x-2">
          <!-- Selected user preview (rendered by SlotMachineModalFunction) -->
          <div id="user-search-preview" class="mt-4 rounded-md border p-4 text-sm color-background">
          </div>
        </div>
      </div>

      <!-- Template Selection -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Select Template
        </label>
        <select id="template-select" class={globalInputClasses}>
          <option value="">Choose a template...</option>
        </select>
      </div>

      <!-- Template Preview Section (for interactive placeholder mapping) -->
      <div id="template-preview-section" class="mb-6 hidden">
        <div class="p-4 color-background rounded-lg border border-gray-200 dark:border-gray-700">
          <div class="flex items-center justify-between mb-4">
            <div>
              <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-1">
                Map Placeholders
              </h4>
              <p class="text-sm text-gray-600 dark:text-gray-400">
                <span id="placeholder-progress">0 of 0</span> placeholders mapped
              </p>
            </div>
            <button
              id="skip-mapping-btn"
              class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200"
            >
              Skip for now
            </button>
          </div>
          <div
            id="template-preview-container"
            class="border border-gray-300 dark:border-gray-600 rounded-md p-6 bg-white dark:bg-gray-800"
          >
            <!-- Template content with highlighted placeholders will be rendered here -->
          </div>
        </div>
      </div>

      <!-- Placeholder Mapping Tooltip (positioned absolutely) -->
      <div
        id="placeholder-tooltip"
        class="hidden fixed z-50 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl p-4 max-w-md"
        style="display: none;"
      >
        <div
          id="tooltip-drag-handle"
          class="flex items-center justify-between mb-3 cursor-move select-none"
        >
          <h5 class="text-sm font-semibold text-gray-900 dark:text-white">
            Select value for <span
              id="tooltip-placeholder-name"
              class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded"></span>
          </h5>
          <button
            id="close-tooltip-btn"
            class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 cursor-pointer"
          >
            √ó
          </button>
        </div>
        <div id="tooltip-contact-fields" class="space-y-2 max-h-64 overflow-y-auto mb-3">
          <!-- Contact field options will be rendered here -->
        </div>
        <div class="border-t border-gray-200 dark:border-gray-700 pt-3">
          <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
            Or enter manually:
          </label>
          <input
            type="text"
            id="tooltip-manual-input"
            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm"
            placeholder="Enter value..."
          />
          <button
            id="tooltip-apply-btn"
            class="mt-3 w-full bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
          >
            Apply
          </button>
        </div>
      </div>

      <!-- Placeholder Mapping Section -->
      <div id="placeholder-mapping-section" class="mb-6 hidden">
        <div class="p-4 color-background rounded-lg border border-gray-200 dark:border-gray-700">
          <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3">
            Map Template Placeholders to Contact Data
          </h4>
          <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
            Map each placeholder to a Google contact field or enter a value manually.
          </p>
          <div id="placeholder-mappings-list" class="space-y-3">
            <!-- Placeholder mappings will be rendered here -->
          </div>
        </div>
      </div>

      <!-- User Results -->
      <div id="user-results" class="mb-6">
        <!-- User search results will be displayed here -->
      </div>

      <!-- PDF Generation Options -->
      <div class="mb-6 p-4 color-background rounded-lg">
        <h4 class="text-md font-semibold text-gray-900 dark:text-white mb-3">PDF Options</h4>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Page Size
            </label>
            <select id="page-size" class={globalInputClasses}>
              <option value="8.5x11">8.5" x 11" (Letter)</option>
              <option value="A4">A4</option>
              <option value="A3">A3</option>
              <option value="11x17">11" x 17" (Tabloid)</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Orientation
            </label>
            <select id="orientation" class={globalInputClasses}>
              <option value="portrait">Portrait</option>
              <option value="landscape">Landscape</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Generate Button -->
      <div class="flex space-x-4">
        <button
          id="preview-pdf-btn"
          class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors"
        >
          <SimpleIcon name="eye" class="w-4 h-4 inline mr-2" />
          Preview
        </button>
        <button
          id="generate-pdf-btn"
          class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors"
        >
          <SimpleIcon name="download" class="w-4 h-4 inline mr-2" />
          Generate PDF
        </button>
      </div>
    </div>
  </div>

  <!-- Google Contacts Tab Content -->
  <div id="contacts-content" class="pdf-tab-content hidden">
    <div class="mb-6">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Google Contacts</h3>

      <!-- Information Card -->
      <div
        class="mb-6 p-4 bg-primary-50 dark:bg-primary-900/20 border border-primary-200 dark:border-primary-800 rounded-lg"
      >
        <div class="flex items-start">
          <div
            class="w-5 h-5 text-primary-600 dark:text-primary-400 mr-3 mt-0.5 flex-shrink-0 text-lg font-bold"
          >
            i
          </div>
          <div class="flex-1">
            <p class="text-sm text-primary-800 dark:text-primary-300">
              <strong>Note:</strong> Google Contacts cannot be embedded in iframes due to security restrictions.
              Click the button below to open Google Contacts in a new tab where you can manage your contacts.
            </p>
          </div>
        </div>
      </div>

      <!-- Open Google Contacts Button -->
      <div
        class="flex flex-col items-center justify-center p-12 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-800/50"
      >
        <SimpleIcon name="user" class="w-16 h-16 text-gray-400 dark:text-gray-500 mb-4" />
        <h4 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">
          Manage Google Contacts
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-400 mb-6 text-center max-w-md">
          Add, edit, or search your Google Contacts in a new tab
        </p>
        <a
          href="https://contacts.google.com/"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white rounded-md font-medium transition-colors shadow-lg hover:shadow-xl"
        >
          Open Google Contacts
          <span class="ml-2 text-sm">‚Üó</span>
        </a>
        <p class="text-xs text-gray-500 dark:text-gray-400 mt-4">Opens in a new tab</p>
      </div>
    </div>
  </div>
</div>

<script
  is:inline
  define:vars={{ currentUser, globalInputClasses, primaryTextClasses, secondaryTextClasses }}
>
  console.log("üöÄ [PDF-SYSTEM] Script starting...");

  class PDFSystem {
    constructor() {
      this.currentUser = null; // Will be set when needed
      this.selectedTemplate = null;
      this.selectedUser = null;
      this.selectedContactData = null; // Store Google contact data
      this.templates = [];
      this.users = [];
      this.editor = null;
      this.templateEditors = {}; // Store Quill editors for each template
      this.templateNameInput = null;
      this.templateTypeSelect = null;
      this.placeholderMappings = {}; // Store mappings: { placeholder: { source: 'contact'|'manual', value: string } }
      this.ocrResultsByPage = []; // Store OCR results with layout data for each page
      this.currentPlaceholderIndex = 0; // Track current placeholder being mapped
      this.placeholderElements = []; // Store DOM elements for placeholders in template preview
      this.placeholdersList = []; // Store list of placeholders to map
      this.tooltipListenersSetup = false; // Track if tooltip listeners are set up
      this.scannerFields = []; // Store fields with location data for scanner tab
      this.scannerPageScales = {}; // Store scale used for each page

      this.init();
    }

    async init() {
      console.log("üöÄ [PDF-SYSTEM] Initializing PDF system");
      this.setupEventListeners();
      await this.loadTemplates();
      this.setupTabNavigation();
    }

    setupEventListeners() {
      // Tab navigation

      document.querySelectorAll(".pdf-tab").forEach((tab) => {
        tab.addEventListener("click", (e) => {
          this.switchTab(e.target.dataset.tab);
        });
      });

      // Dropzone for new template file upload
      const dropzone = document.getElementById("new-template-dropzone");
      if (dropzone) {
        dropzone.addEventListener("dropzone-files-selected", (e) => {
          const { files } = e.detail;
          if (files && files.length > 0) {
            // Open the accordion and process the file
            this.openTemplateEditor();
            // Wait for editor to initialize before processing file
            setTimeout(() => {
              this.handleFileUpload(files[0]);
            }, 200);
          }
        });

        dropzone.addEventListener("dropzone-error", (e) => {
          const { error } = e.detail;
          this.showNotification(error || "Error uploading file", "error");
        });
      }

      // Dropzone for scanner tab
      const scannerDropzone = document.getElementById("scanner-dropzone");
      if (scannerDropzone) {
        scannerDropzone.addEventListener("dropzone-files-selected", (e) => {
          const { files } = e.detail;
          if (files && files.length > 0) {
            this.handleScannerFileUpload(files[0]);
          }
        });

        scannerDropzone.addEventListener("dropzone-error", (e) => {
          const { error } = e.detail;
          this.showNotification(error || "Error uploading file", "error");
        });
      }

      document.getElementById("save-template-btn")?.addEventListener("click", () => {
        this.saveTemplate();
      });

      document.getElementById("cancel-template-btn")?.addEventListener("click", () => {
        this.closeTemplateEditor();
      });

      // Listen for user selection from SlotMachineModal (Google Contacts)
      // The preview rendering is now handled by SlotMachineModalFunction.astro
      window.addEventListener("slot-select", (event) => {
        const ce = /** @type {CustomEvent} */ (event);
        const detail = (ce && ce.detail) || {};
        if (detail.componentId !== "user-search") return;

        // Store the contact data for placeholder mapping
        this.selectedContactData = detail.data || null;
        console.log("üìÑ [PDF-SYSTEM] Contact selected:", detail.label, detail.data);

        // Update selectedUser from the value
        if (detail.value) {
          this.selectUser(detail.value);
        }

        // Check if template is also selected, if so show mapping UI
        if (this.selectedTemplate) {
          this.updatePlaceholderMappingUI();

          // Check if both template and user are selected, trigger mapping workflow
          // Use setTimeout to ensure DOM and data are ready
          if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
            setTimeout(() => {
              this.startPlaceholderMappingWorkflow();
            }, 100);
          }
        }
      });

      // Watch for changes to the hidden input value from SlotMachineModalFunction
      this.setupUserInputWatcher();

      // Listen for template selection changes (set up after templates are loaded)
      // The listener will be attached in loadTemplatesForGeneration()

      // Generate PDF
      document.getElementById("search-users-btn")?.addEventListener("click", () => {
        this.searchUsers();
      });

      document.getElementById("preview-pdf-btn")?.addEventListener("click", () => {
        this.previewPDF();
      });

      document.getElementById("generate-pdf-btn")?.addEventListener("click", () => {
        this.generatePDF();
      });
    }

    setupTabNavigation() {
      // Set initial tab
      this.switchTab("templates");
    }

    switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll(".pdf-tab").forEach((tab) => {
        tab.classList.remove("border-primary-500", "text-primary-600", "dark:text-primary-400");
        tab.classList.add(
          "border-transparent",
          "text-gray-500",
          "hover:text-gray-700",
          "hover:border-gray-300",
          "dark:text-gray-400",
          "dark:hover:text-gray-300"
        );
      });

      const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
      if (activeTab) {
        activeTab.classList.remove(
          "border-transparent",
          "text-gray-500",
          "hover:text-gray-700",
          "hover:border-gray-300",
          "dark:text-gray-400",
          "dark:hover:text-gray-300"
        );
        activeTab.classList.add("border-primary-500", "text-primary-600", "dark:text-primary-400");
      }

      // Show/hide content
      document.querySelectorAll(".pdf-tab-content").forEach((content) => {
        content.classList.add("hidden");
      });

      const activeContent = document.getElementById(`${tabName}-content`);
      if (activeContent) {
        activeContent.classList.remove("hidden");
      }

      // Load content based on tab
      if (tabName === "generate") {
        this.loadTemplatesForGeneration();
      }
    }

    async loadTemplates() {
      try {
        console.log("üìÑ [PDF-SYSTEM] Loading templates");
        const response = await fetch("/api/pdf/templates/get", {
          method: "GET",
          credentials: "include",
        });

        const data = await response.json();
        if (data.success) {
          const newTemplates = data.data.templates || [];

          // Only re-render if templates actually changed
          const templatesChanged =
            JSON.stringify(this.templates?.map((t) => t.id).sort()) !==
            JSON.stringify(newTemplates.map((t) => t.id).sort());

          this.templates = newTemplates;

          if (templatesChanged) {
            console.log("üìÑ [PDF-SYSTEM] Templates changed, re-rendering...");
            this.renderTemplates();
          } else {
            console.log("üìÑ [PDF-SYSTEM] Templates unchanged, skipping re-render");
          }
        } else {
          console.error("‚ùå [PDF-SYSTEM] Error loading templates:", data.error);
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error loading templates:", error);
      }
    }

    renderTemplates() {
      const container = document.getElementById("templates-list");
      if (!container) return;

      // Destroy existing Quill editors before replacing HTML
      if (this.templateEditors) {
        console.log("üóëÔ∏è [PDF-SYSTEM] Destroying existing template editors before re-rendering...");
        Object.keys(this.templateEditors).forEach((templateId) => {
          const editor = this.templateEditors[templateId];
          if (editor) {
            try {
              // Quill doesn't have a built-in destroy method, but we can clear the container
              const editorContainer = document.getElementById(`template-editor-${templateId}`);
              if (editorContainer) {
                editorContainer.innerHTML = "";
              }
            } catch (error) {
              console.warn(
                `‚ö†Ô∏è [PDF-SYSTEM] Error destroying editor for template ${templateId}:`,
                error
              );
            }
          }
        });
        // Clear the editors object so they can be recreated
        this.templateEditors = {};
      }

      if (this.templates.length === 0) {
        container.innerHTML = `
          <div class="text-center py-8 text-gray-500 dark:text-gray-400">
            <SimpleIcon name="file-text" class="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No templates found. Create your first template!</p>
          </div>
        `;
        return;
      }

      // Create accordion HTML for each template (following FileManager pattern)
      container.innerHTML = this.templates
        .map((template, index) => {
          return this.createTemplateAccordion(template, false); // First one open by default
        })
        .join("");

      // Initialize accordions
      this.initAccordions();

      // Initialize Quill editors for each template
      this.templates.forEach((template) => {
        setTimeout(() => {
          this.initializeTemplateEditor(template.id);
        }, 100);
      });
    }

    // Create accordion HTML for a template (following FileManager accordion pattern)
    createTemplateAccordion(template, open = false) {
      const defaultBadge = template.isDefault
        ? '<span class="bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200 px-2 py-1 rounded text-xs">Default</span>'
        : "";

      const createdDate = template.createdAt
        ? new Date(template.createdAt).toLocaleDateString()
        : "Unknown";

      const description =
        template.description || template.html_content?.substring(0, 100) || "No description";

      return `
        <div class="border border-gray-200 dark:border-gray-700 rounded-lg relative">
          <!-- Accordion Header -->
          <div class="flex items-center justify-between cursor-pointer rounded-lg transition-colors hover:bg-gray-50 dark:hover:bg-gray-700">
            <!-- Clickable header area -->
            <div 
              class="flex-1"
              data-accordion-target="#accordion-template-${template.id}"
              aria-expanded="${open}"
              aria-controls="accordion-template-${template.id}"
              role="button"
              tabindex="0"
              onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();this.click();}"
            >
              <div class="p-4">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium ${primaryTextClasses} truncate">
                    ${template.name}
                  </h3>
                  ${defaultBadge}
                </div>
                <p class="mt-1 ${secondaryTextClasses} text-sm truncate">${description}</p>
                <div class="flex items-center space-x-4 mt-2 text-xs ${secondaryTextClasses}">
                  <span>Type: ${template.templateType || "body"}</span>
                  <span>Size: ${template.pageSize || "8.5x11"}</span>
                  <span>Created: ${createdDate}</span>
                </div>
              </div>
            </div>

            <!-- Accordion Toggle Button -->
            <button
              class="text-gray-400 transition-colors hover:text-gray-600 dark:hover:text-gray-300 p-4"
              data-accordion-target="#accordion-template-${template.id}"
              aria-expanded="${open}"
              aria-controls="accordion-template-${template.id}"
              type="button"
            >
              <svg
                class="w-5 h-5 transition-transform duration-200 ${open ? "rotate-180" : ""}"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </button>
          </div>

          <!-- Accordion Content -->
          <div
            id="accordion-template-${template.id}"
            class="${open ? "" : "hidden"}"
            aria-labelledby="accordion-template-${template.id}"
          >
            <div class="border-t border-gray-200 px-4 pb-4 dark:border-gray-700">
              <div class="pt-4 space-y-4">
                <!-- Template Name Input -->
                <div>
                  <label for="template-name-${template.id}" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Template Name
                  </label>
                  <input
                    type="text"
                    id="template-name-${template.id}"
                    class="${globalInputClasses}"
                    value="${template.name || ""}"
                    placeholder="Enter template name..."
                  />
                </div>

                <!-- Template Description -->
                <div>
                  <label for="template-description-${template.id}" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Description
                  </label>
                  <textarea
                    id="template-description-${template.id}"
                    class="${globalInputClasses}"
                    rows="2"
                    placeholder="Enter template description..."
                  >${template.description || ""}</textarea>
                </div>

                <!-- Quill Editor Container -->
                <div>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Template Content
                  </label>
                  <div id="template-editor-${template.id}" class="min-h-[300px] bg-white dark:bg-gray-800 rounded-lg border border-gray-300 dark:border-gray-600">
                    <!-- Quill editor will be initialized here -->
                  </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex justify-end space-x-2 pt-2">
                  <button
                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors delete-template-btn"
                    data-template-id="${template.id}"
                    type="button"
                  >
                    <SimpleIcon name="trash-2" class="w-4 h-4 inline mr-2" />
                    Delete
                  </button>
                  <button
                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors save-template-btn"
                    data-template-id="${template.id}"
                    type="button"
                  >
                    <SimpleIcon name="save" class="w-4 h-4 inline mr-2" />
                    Save Template
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Initialize accordions (following FileManager pattern)
    initAccordions() {
      const accordionButtons = document.querySelectorAll("[data-accordion-target]");
      accordionButtons.forEach((button) => {
        button.addEventListener("click", function () {
          const targetId = this.getAttribute("data-accordion-target");
          const target = document.querySelector(targetId);
          const isExpanded = this.getAttribute("aria-expanded") === "true";

          if (target) {
            if (isExpanded) {
              target.classList.add("hidden");
              this.setAttribute("aria-expanded", "false");
              // Update both the main header and the toggle button
              const svg = this.querySelector("svg");
              if (svg) svg.style.transform = "rotate(0deg)";
              // Also update the toggle button if it exists
              const toggleButton = document.querySelector(
                `button[data-accordion-target="${targetId}"]`
              );
              if (toggleButton && toggleButton !== this) {
                const toggleSvg = toggleButton.querySelector("svg");
                if (toggleSvg) toggleSvg.style.transform = "rotate(0deg)";
                toggleButton.setAttribute("aria-expanded", "false");
              }
            } else {
              target.classList.remove("hidden");
              this.setAttribute("aria-expanded", "true");
              // Update both the main header and the toggle button
              const svg = this.querySelector("svg");
              if (svg) svg.style.transform = "rotate(180deg)";
              // Also update the toggle button if it exists
              const toggleButton = document.querySelector(
                `button[data-accordion-target="${targetId}"]`
              );
              if (toggleButton && toggleButton !== this) {
                const toggleSvg = toggleButton.querySelector("svg");
                if (toggleSvg) toggleSvg.style.transform = "rotate(180deg)";
                toggleButton.setAttribute("aria-expanded", "true");
              }
            }
          }
        });
      });

      // Add event listeners for save and delete buttons
      const container = document.getElementById("templates-list");
      if (!container) return;

      container.querySelectorAll(".save-template-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          console.log("üîò [PDF-SYSTEM] Save button clicked:", e.target);
          const templateId = e.target
            .closest(".save-template-btn")
            .getAttribute("data-template-id");
          console.log("üîò [PDF-SYSTEM] Template ID from button:", templateId);
          this.saveTemplate(templateId);
        });
      });

      container.querySelectorAll(".delete-template-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const templateId = e.target
            .closest(".delete-template-btn")
            .getAttribute("data-template-id");
          this.deleteTemplate(templateId);
        });
      });
    }

    // Initialize Quill editor for a specific template
    async initializeTemplateEditor(templateId) {
      const editorContainer = document.getElementById(`template-editor-${templateId}`);
      if (!editorContainer) {
        console.warn(`‚ö†Ô∏è [PDF-SYSTEM] Editor container not found for template ${templateId}`);
        return;
      }

      // Check if editor already exists
      if (this.templateEditors && this.templateEditors[templateId]) {
        console.log(`‚úÖ [PDF-SYSTEM] Editor already exists for template ${templateId}`);
        return;
      }

      // Load Quill if not already loaded
      if (!window.Quill) {
        await this.loadQuill();
      }

      // Find the template data
      const template = this.templates.find((t) => t.id === templateId);
      if (!template) {
        console.error(`‚ùå [PDF-SYSTEM] Template ${templateId} not found`);
        return;
      }

      // Create Quill editor
      try {
        if (!this.templateEditors) {
          this.templateEditors = {};
        }

        this.templateEditors[templateId] = new window.Quill(`#template-editor-${templateId}`, {
          theme: "snow",
          modules: {
            toolbar: [
              [{ header: [1, 2, 3, false] }],
              ["bold", "italic", "underline", "strike"],
              [{ list: "ordered" }, { list: "bullet" }],
              [{ script: "sub" }, { script: "super" }],
              [{ indent: "-1" }, { indent: "+1" }],
              [{ direction: "rtl" }],
              [{ size: ["small", false, "large", "huge"] }],
              [{ color: [] }, { background: [] }],
              [{ font: [] }],
              [{ align: [] }],
              ["clean"],
              ["link", "image"],
            ],
          },
        });

        // Set initial content
        const content = template.html_content || template.content || "";
        if (content) {
          this.templateEditors[templateId].clipboard.dangerouslyPasteHTML(content);
        }

        console.log(`‚úÖ [PDF-SYSTEM] Quill editor initialized for template ${templateId}`);
      } catch (error) {
        console.error(
          `‚ùå [PDF-SYSTEM] Error initializing editor for template ${templateId}:`,
          error
        );
      }
    }

    // Load Quill CSS and JS if not already loaded
    async loadQuill() {
      return new Promise((resolve) => {
        // Load Quill CSS
        if (!document.querySelector("#quill-css-templates")) {
          const quillCSS = document.createElement("link");
          quillCSS.id = "quill-css-templates";
          quillCSS.rel = "stylesheet";
          quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
          document.head.appendChild(quillCSS);
        }

        // Load Quill JS
        if (!window.Quill) {
          const quillJS = document.createElement("script");
          quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
          quillJS.onload = () => {
            console.log("‚úÖ [PDF-SYSTEM] Quill JS loaded for templates");
            resolve();
          };
          document.head.appendChild(quillJS);
        } else {
          resolve();
        }
      });
    }

    // Save template
    async saveTemplate(templateId) {
      console.log("üíæ [PDF-SYSTEM] ===== SAVE TEMPLATE FUNCTION CALLED =====");
      console.log("üíæ [PDF-SYSTEM] Input templateId:", templateId, "Type:", typeof templateId);
      console.log("üíæ [PDF-SYSTEM] All templates:", this.templates);
      console.log(
        "üíæ [PDF-SYSTEM] Template IDs in array:",
        this.templates.map((t) => ({ id: t.id, type: typeof t.id, name: t.name }))
      );

      // Convert templateId to number if it's a string (from getAttribute)
      const numericId = typeof templateId === "string" ? parseInt(templateId, 10) : templateId;
      console.log("üíæ [PDF-SYSTEM] Numeric ID:", numericId, "Type:", typeof numericId);

      // Try both string and number matches
      const template = this.templates.find(
        (t) => t.id === templateId || t.id === numericId || String(t.id) === String(templateId)
      );

      console.log("üíæ [PDF-SYSTEM] ===== TEMPLATE LOOKUP =====");
      console.log("üíæ [PDF-SYSTEM] Template found:", !!template);
      console.log("üíæ [PDF-SYSTEM] Template details:", template);
      console.log("üíæ [PDF-SYSTEM] Search comparisons:", {
        templateId,
        numericId,
        matches: this.templates.map((t) => ({
          id: t.id,
          matchesString: t.id === templateId,
          matchesNumber: t.id === numericId,
          matchesStringCoerce: String(t.id) === String(templateId),
        })),
      });

      if (!template) {
        window.showNotification({
          type: "error",
          title: "Template Not Found",
          message: `Template not found (ID: ${templateId})`,
        });
        return;
      }

      // Get form elements - ensure we're using the correct templateId format
      const actualTemplateId = template.id; // Use the actual template ID from the data
      const nameInput = document.getElementById(`template-name-${actualTemplateId}`);
      const descriptionInput = document.getElementById(`template-description-${actualTemplateId}`);
      const editor =
        this.templateEditors?.[actualTemplateId] ||
        this.templateEditors?.[templateId] ||
        this.templateEditors?.[numericId];

      console.log("üíæ [PDF-SYSTEM] Form elements:", {
        actualTemplateId,
        nameInputFound: !!nameInput,
        descriptionInputFound: !!descriptionInput,
        editorFound: !!editor,
        editorKeys: Object.keys(this.templateEditors || {}),
      });

      if (!nameInput) {
        window.showNotification({
          type: "error",
          title: "Form Element Not Found",
          message: `Template name input not found for ID: ${actualTemplateId}`,
        });
        return;
      }

      if (!editor) {
        window.showNotification({
          type: "error",
          title: "Editor Not Found",
          message: `Template editor not found for ID: ${actualTemplateId}. Available editors: ${Object.keys(this.templateEditors || {}).join(", ")}`,
        });
        return;
      }

      const name = nameInput.value.trim();
      console.log("üíæ [PDF-SYSTEM] Name validation:", {
        rawValue: nameInput.value,
        trimmed: name,
        isEmpty: !name,
        length: name.length,
      });

      if (!name) {
        window.showNotification({
          type: "error",
          title: "Validation Error",
          message: "Template name is required",
        });
        return;
      }

      const description = descriptionInput?.value.trim() || "";
      const content = editor.root.innerHTML;

      // Check if content is effectively empty (just whitespace/empty tags)
      const contentText = editor.getText().trim();
      const contentIsEmpty = !contentText || contentText.length === 0;
      const contentIsOnlyEmptyTags = content.replace(/<[^>]*>/g, "").trim().length === 0;

      console.log("üíæ [PDF-SYSTEM] Content validation:", {
        htmlLength: content.length,
        htmlPreview: content.substring(0, 100),
        textLength: contentText.length,
        textPreview: contentText.substring(0, 50),
        contentIsEmpty,
        contentIsOnlyEmptyTags,
        isEmptyOrWhitespace: contentIsEmpty || contentIsOnlyEmptyTags,
      });

      if (!content || contentIsEmpty || contentIsOnlyEmptyTags) {
        window.showNotification({
          type: "error",
          title: "Validation Error",
          message: "Template content is required. Please add some content to the template.",
        });
        return;
      }

      console.log("üíæ [PDF-SYSTEM] ===== SAVE TEMPLATE - DATA COLLECTION =====");
      console.log("üíæ [PDF-SYSTEM] Template ID (actual):", actualTemplateId);
      console.log("üíæ [PDF-SYSTEM] Name input value:", nameInput.value);
      console.log("üíæ [PDF-SYSTEM] Name (trimmed):", name);
      console.log("üíæ [PDF-SYSTEM] Description input value:", descriptionInput?.value);
      console.log("üíæ [PDF-SYSTEM] Description (trimmed):", description);
      console.log("üíæ [PDF-SYSTEM] Editor root HTML length:", editor.root.innerHTML.length);
      console.log(
        "üíæ [PDF-SYSTEM] Editor root HTML (first 200 chars):",
        editor.root.innerHTML.substring(0, 200)
      );
      console.log("üíæ [PDF-SYSTEM] Content:", content);
      console.log("üíæ [PDF-SYSTEM] Template data:", {
        templateType: template.templateType,
        pageSize: template.pageSize,
        margins: template.margins,
      });

      const payload = {
        id: actualTemplateId,
        name,
        description,
        content,
        templateType: template.templateType || "body",
        pageSize: template.pageSize || "8.5x11",
        margins: template.margins || { top: "1in", right: "1in", bottom: "1in", left: "1in" },
      };

      console.log("üíæ [PDF-SYSTEM] ===== PAYLOAD TO SEND =====");
      console.log("üíæ [PDF-SYSTEM] Full payload:", JSON.stringify(payload, null, 2));
      console.log("üíæ [PDF-SYSTEM] Payload sizes:", {
        id: String(payload.id).length,
        name: payload.name.length,
        description: payload.description.length,
        content: payload.content.length,
      });

      try {
        console.log("üíæ [PDF-SYSTEM] ===== FETCH REQUEST =====");
        console.log("üíæ [PDF-SYSTEM] URL:", "/api/pdf/templates/upsert");
        console.log("üíæ [PDF-SYSTEM] Method: POST");

        const response = await fetch("/api/pdf/templates/upsert", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(payload),
        });

        console.log("üíæ [PDF-SYSTEM] ===== RESPONSE RECEIVED =====");
        console.log("üíæ [PDF-SYSTEM] Response status:", response.status);
        console.log("üíæ [PDF-SYSTEM] Response ok:", response.ok);
        console.log(
          "üíæ [PDF-SYSTEM] Response headers:",
          Object.fromEntries(response.headers.entries())
        );

        const responseText = await response.text();
        console.log("üíæ [PDF-SYSTEM] Response text (raw):", responseText);

        let data;
        try {
          data = JSON.parse(responseText);
          console.log("üíæ [PDF-SYSTEM] Response data (parsed):", data);
        } catch (parseError) {
          console.error("‚ùå [PDF-SYSTEM] Failed to parse response as JSON:", parseError);
          console.error("‚ùå [PDF-SYSTEM] Response text was:", responseText);
          throw new Error("Invalid JSON response from server");
        }

        console.log("üíæ [PDF-SYSTEM] ===== PROCESSING RESPONSE =====");
        console.log("üíæ [PDF-SYSTEM] Data success:", data.success);
        console.log("üíæ [PDF-SYSTEM] Data message:", data.message);
        console.log("üíæ [PDF-SYSTEM] Data error:", data.error);
        console.log("üíæ [PDF-SYSTEM] Full data object:", data);

        if (data.success) {
          console.log("‚úÖ [PDF-SYSTEM] Save successful!");
          window.showNotification({
            type: "success",
            title: "Template Saved",
            message: "Template saved successfully",
          });
          // Reload templates to refresh the list
          console.log("üíæ [PDF-SYSTEM] Reloading templates...");
          await this.loadTemplates();
          console.log("üíæ [PDF-SYSTEM] Templates reloaded");
        } else {
          console.error("‚ùå [PDF-SYSTEM] Save failed:", data);
          window.showNotification({
            type: "error",
            title: "Save Failed",
            message: data.message || data.error || "Failed to save template",
          });
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] ===== EXCEPTION CAUGHT =====");
        console.error("‚ùå [PDF-SYSTEM] Error type:", error?.constructor?.name);
        console.error("‚ùå [PDF-SYSTEM] Error message:", error?.message);
        console.error("‚ùå [PDF-SYSTEM] Error stack:", error?.stack);
        console.error("‚ùå [PDF-SYSTEM] Full error object:", error);
        window.showNotification({
          type: "error",
          title: "Save Error",
          message: `Error saving template: ${error?.message || "Unknown error"}`,
        });
      }
    }

    // Delete template
    async deleteTemplate(templateId) {
      if (
        !confirm("Are you sure you want to delete this template? This action cannot be undone.")
      ) {
        return;
      }

      try {
        const response = await fetch(`/api/pdf/templates/${templateId}`, {
          method: "DELETE",
        });

        if (response.ok) {
          window.showNotification({
            type: "success",
            title: "Template Deleted",
            message: "Template deleted successfully",
          });
          // Remove editor instance
          if (this.templateEditors?.[templateId]) {
            delete this.templateEditors[templateId];
          }
          // Reload templates
          await this.loadTemplates();
        } else {
          const data = await response.json().catch(() => ({}));
          window.showNotification({
            type: "error",
            title: "Delete Failed",
            message: data.message || "Failed to delete template",
          });
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error deleting template:", error);
        window.showNotification({
          type: "error",
          title: "Delete Error",
          message: "Error deleting template. Please try again.",
        });
      }
    }

    openTemplateEditor(templateId = null) {
      const accordion = document.getElementById("template-editor-accordion");

      if (accordion) {
        const isHidden = accordion.classList.contains("hidden");

        if (isHidden) {
          // Open accordion
          accordion.classList.remove("hidden");

          this.selectedTemplate = templateId;

          if (templateId) {
            this.loadTemplateForEdit(templateId);
          } else {
            this.resetTemplateForm();
          }

          // Initialize editor after accordion is visible
          setTimeout(() => {
            this.initializeEditor();
          }, 100);

          // Scroll to accordion
          setTimeout(() => {
            accordion.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }, 150);
        } else {
          // Close accordion if clicking again
          this.closeTemplateEditor();
        }
      }
    }

    closeTemplateEditor() {
      const accordion = document.getElementById("template-editor-accordion");

      if (accordion) {
        accordion.classList.add("hidden");
        this.selectedTemplate = null;

        // Properly destroy the editor
        if (this.editor) {
          console.log("üóëÔ∏è [PDF-SYSTEM] Destroying editor on close...");
          try {
            // Properly dispose of the Quill instance
            this.editor = null;
          } catch (error) {
            console.warn("‚ö†Ô∏è [PDF-SYSTEM] Error disposing editor:", error);
          }

          // Clear the editor container completely
          const editorContainer = document.getElementById("template-editor");
          if (editorContainer) {
            editorContainer.innerHTML = "";
            // Remove any Quill-specific classes that might be left behind
            editorContainer.className = "";
          }

          // Remove any existing Quill toolbars from the DOM
          const existingToolbars = document.querySelectorAll(".ql-toolbar");
          existingToolbars.forEach((toolbar) => {
            if (toolbar.parentNode) {
              toolbar.parentNode.removeChild(toolbar);
            }
          });

          // Remove any existing Quill containers
          const existingContainers = document.querySelectorAll(".ql-container");
          existingContainers.forEach((container) => {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
            }
          });
        }
      }
    }

    async initializeEditor() {
      // Initialize Quill WYSIWYG Editor (using contract system pattern)
      this.templateNameInput = document.getElementById("template-name");
      this.templateTypeSelect = document.getElementById("template-type");

      console.log("üöÄ [PDF-SYSTEM] Initializing Quill editor...");

      // Destroy existing editor if it exists
      if (this.editor) {
        console.log("üóëÔ∏è [PDF-SYSTEM] Destroying existing editor...");
        try {
          // Properly dispose of the Quill instance
          this.editor = null;
        } catch (error) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Error disposing editor:", error);
        }

        // Clear the editor container completely
        const editorContainer = document.getElementById("template-editor");
        if (editorContainer) {
          editorContainer.innerHTML = "";
          // Remove any Quill-specific classes that might be left behind
          editorContainer.className = "";
        }

        // Remove any existing Quill toolbars from the DOM
        const existingToolbars = document.querySelectorAll(".ql-toolbar");
        existingToolbars.forEach((toolbar) => {
          if (toolbar.parentNode) {
            toolbar.parentNode.removeChild(toolbar);
          }
        });

        // Remove any existing Quill containers
        const existingContainers = document.querySelectorAll(".ql-container");
        existingContainers.forEach((container) => {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
        });
      }

      // Load Quill CSS and JS dynamically (like contract system)
      if (!document.querySelector("#quill-css-pdf")) {
        console.log("üì¶ [PDF-SYSTEM] Loading Quill CSS...");
        const quillCSS = document.createElement("link");
        quillCSS.id = "quill-css-pdf";
        quillCSS.rel = "stylesheet";
        quillCSS.href = "https://cdn.quilljs.com/1.3.6/quill.snow.css";
        document.head.appendChild(quillCSS);
      }

      if (!window.Quill) {
        console.log("üì¶ [PDF-SYSTEM] Loading Quill JS...");
        const quillJS = document.createElement("script");
        quillJS.src = "https://cdn.quilljs.com/1.3.6/quill.min.js";
        quillJS.onload = async () => {
          console.log("‚úÖ [PDF-SYSTEM] Quill JS loaded, creating editor...");
          await this.createEditor();
        };
        document.head.appendChild(quillJS);
      } else {
        console.log("‚úÖ [PDF-SYSTEM] Quill JS already loaded, creating editor...");
        await this.createEditor();
      }
    }

    async createEditor() {
      console.log("üîß [PDF-SYSTEM] Creating Quill editor...");

      try {
        this.editor = new window.Quill("#template-editor", {
          theme: "snow",
          modules: {
            toolbar: [
              [{ header: [1, 2, 3, 4, 5, 6, false] }],
              ["bold", "italic", "underline", "strike"],
              [{ color: [] }, { background: [] }],
              [{ list: "ordered" }, { list: "bullet" }],
              [{ indent: "-1" }, { indent: "+1" }],
              [{ align: [] }],
              ["link", "image"],
              ["clean"],
            ],
          },
          placeholder: "Enter your template content here...",
          readOnly: false,
        });

        // Set the editor container style
        const editorElement = document.getElementById("template-editor");
        editorElement.style.height = "400px";
        editorElement.style.border = "1px solid #374151";
        editorElement.style.borderRadius = "0.375rem";

        console.log("‚úÖ [PDF-SYSTEM] Quill editor created successfully");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error creating editor:", error);
        // Fallback to textarea if Quill is not available
        const editorDiv = document.getElementById("template-editor");
        editorDiv.innerHTML = `
          <textarea 
            id="template-content-textarea" 
            class="w-full h-96 p-4 border border-gray-300 dark:border-gray-600 rounded-md font-mono text-sm"
            placeholder="Enter your template content here..."
          ></textarea>
        `;
      }
    }

    async handleFileUpload(file) {
      if (!file) return;

      console.log("üìÑ [PDF-SYSTEM] Processing uploaded file:", file.name);

      try {
        // Process file directly with PDF.js
        await this.runClientSideOCR(file);

        this.showNotification("File processed successfully!", "success");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error processing file:", error);
        this.showNotification("Error processing file", "error");
      }
    }

    async handleScannerFileUpload(file) {
      if (!file) return;

      console.log("üìÑ [SCANNER] Processing file:", file.name);

      const viewerSection = document.getElementById("scanner-viewer-section");
      const pdfViewer = document.getElementById("scanner-pdf-viewer");
      const fieldsList = document.getElementById("scanner-fields-list");

      // Show viewer section
      viewerSection?.classList.remove("hidden");

      // Show loading state
      if (pdfViewer) {
        pdfViewer.innerHTML =
          '<div class="text-center text-gray-500 dark:text-gray-400 py-20"><p>Loading document...</p></div>';
      }
      if (fieldsList) {
        fieldsList.innerHTML =
          '<div class="text-sm text-gray-500 dark:text-gray-400 text-center py-8"><p>Detecting fields...</p></div>';
      }

      try {
        if (file.type === "application/pdf") {
          // Display PDF immediately, then extract and highlight fields
          await this.displayPDFWithHighlights(file, pdfViewer);
        } else if (file.type.startsWith("image/")) {
          // Display image and highlight fields
          await this.displayImageWithHighlights(file, pdfViewer);
        } else {
          throw new Error("Unsupported file type. Please upload PDF or image files.");
        }

        this.showNotification("Document loaded successfully!", "success");
      } catch (error) {
        console.error("‚ùå [SCANNER] Error processing file:", error);
        if (pdfViewer) {
          pdfViewer.innerHTML = `<div class="text-center text-red-500 py-20"><p>Error: ${error.message}</p></div>`;
        }
        this.showNotification("Error processing file: " + error.message, "error");
      }
    }

    async processPDFForScanner(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this;
        fileReader.onload = async function (e) {
          try {
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;

            let fullText = "";
            const numPages = pdf.numPages;

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const structuredText = self.extractStructuredText(textContent.items);
              fullText += structuredText + "\n";
            }

            // Check if we got meaningful text
            const meaningfulText = fullText.trim().length > 50;

            if (!meaningfulText) {
              // Try OCR
              console.log("üìÑ [SCANNER] Minimal text, trying OCR...");
              const ocrResult = await self.processPDFWithOCRForScanner(file);
              fullText = ocrResult.text;
            }

            // Extract fields
            const fields = self.extractFieldsFromText(fullText);

            resolve({ text: fullText, fields });
          } catch (error) {
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    async processImageForScanner(file) {
      return new Promise((resolve, reject) => {
        const self = this;
        self
          .processImageWithCanvas(file)
          .then((result) => {
            const text = result.text || "";
            const fields = self.extractFieldsFromText(text);
            resolve({ text, fields });
          })
          .catch(reject);
      });
    }

    async displayPDFWithHighlights(file, container) {
      const self = this;
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = async function (e) {
          try {
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
            const numPages = pdf.numPages;

            // Extract text and fields in background
            let allText = "";
            let allTextItems = []; // Store text items with coordinates and font info

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();

              // Store text items with page number and font size info
              textContent.items.forEach((item) => {
                // Extract font size from PDF.js text item
                // PDF.js items have: height, transform[0] (horizontal scale), transform[3] (vertical scale)
                let fontSize = 12; // default
                if (item.height) {
                  fontSize = item.height;
                } else if (
                  item.transform &&
                  Array.isArray(item.transform) &&
                  item.transform.length >= 4
                ) {
                  // Use vertical scale from transform matrix (transform[3] or 'd' value)
                  fontSize = Math.abs(item.transform[3]) || Math.abs(item.transform[0]) || 12;
                }

                allTextItems.push({
                  ...item,
                  pageNum: i,
                  fontSize: fontSize,
                });
                if (item.str) {
                  allText += item.str + " ";
                }
              });
            }

            // Normalize text to fix word breaks (e.g., "istroy" -> "history")
            allText = self.fixWordBreaks(allText);

            // Extract fields from text with font size information
            const fields = self.extractFieldsFromTextWithFontInfo(allText.trim(), allTextItems);

            // Enrich fields with location data (page number and coordinates)
            const fieldsWithLocations = self.enrichFieldsWithLocations(fields, allTextItems);

            // Store fields with locations for click handlers
            self.scannerFields = fieldsWithLocations;

            // Display fields in sidebar
            self.displayScannerFields(fieldsWithLocations);

            // Display PDF pages with highlights
            const viewerHTML = document.createElement("div");
            viewerHTML.className = "space-y-4";
            viewerHTML.id = "scanner-pdf-viewer-container";

            // Get container width to calculate scale
            const container = document.getElementById("scanner-pdf-viewer");
            const containerWidth = container ? container.clientWidth - 32 : 800; // Subtract padding

            // Store scale for each page for field highlighting
            self.scannerPageScales = {};

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);

              // Calculate scale to fit 100% width
              const defaultViewport = page.getViewport({ scale: 1.0 });
              const scale = containerWidth / defaultViewport.width;
              const viewport = page.getViewport({ scale: scale });

              // Store scale for this page
              self.scannerPageScales[i] = scale;

              // Create container for page
              const pageContainer = document.createElement("div");
              pageContainer.className =
                "mb-4 border border-gray-300 dark:border-gray-600 rounded p-2 bg-white relative";
              pageContainer.id = `scanner-page-${i}`;
              pageContainer.dataset.pageNum = i.toString();
              pageContainer.style.width = "100%";
              pageContainer.style.overflowX = "hidden";

              const pageLabel = document.createElement("div");
              pageLabel.className = "text-xs text-gray-500 dark:text-gray-400 mb-2";
              pageLabel.textContent = `Page ${i} of ${numPages}`;
              pageContainer.appendChild(pageLabel);

              // Create canvas for PDF rendering
              const canvas = document.createElement("canvas");
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              canvas.style.width = "100%";
              canvas.style.height = "auto";
              canvas.style.display = "block";
              const context = canvas.getContext("2d");

              // Render PDF page
              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;

              // Create overlay canvas for highlights
              const overlayCanvas = document.createElement("canvas");
              overlayCanvas.height = viewport.height;
              overlayCanvas.width = viewport.width;
              overlayCanvas.className = "absolute top-0 left-0 pointer-events-none";
              overlayCanvas.style.position = "absolute";
              overlayCanvas.style.top = "0";
              overlayCanvas.style.left = "0";
              overlayCanvas.style.width = "100%";
              overlayCanvas.style.height = "auto";
              overlayCanvas.id = `scanner-overlay-${i}`;

              const overlayContext = overlayCanvas.getContext("2d");

              // Create wrapper div for positioning
              const canvasWrapper = document.createElement("div");
              canvasWrapper.className = "relative";
              canvasWrapper.style.position = "relative";
              canvasWrapper.style.width = "100%";
              canvasWrapper.style.overflowX = "hidden";
              canvasWrapper.appendChild(canvas);
              canvasWrapper.appendChild(overlayCanvas);

              pageContainer.appendChild(canvasWrapper);
              viewerHTML.appendChild(pageContainer);

              // Store viewport scale for field highlighting calculations
              const pageTextItems = allTextItems.filter((item) => item.pageNum === i);
              self.highlightFieldsOnPDFPage(
                fieldsWithLocations,
                pageTextItems,
                viewport,
                overlayContext,
                i,
                scale
              );
            }

            container.innerHTML = "";
            container.appendChild(viewerHTML);

            resolve();
          } catch (error) {
            console.error("Error displaying PDF:", error);
            container.innerHTML = `<div class="text-center text-red-500 py-20"><p>Error displaying PDF: ${error.message}</p></div>`;
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    enrichFieldsWithLocations(fields, allTextItems) {
      // Add location data (page number, coordinates) to each field
      const fieldsWithLocations = fields.map((field, fieldIndex) => {
        const fieldValue = field.value?.toString().trim();
        if (!fieldValue) return { ...field, pageNum: null, coordinates: null };

        const fieldValueLower = fieldValue.toLowerCase();
        const fullText = allTextItems
          .map((item) => item.str || "")
          .join(" ")
          .toLowerCase();
        const searchValue = fieldValueLower.replace(/[^\w\s@.-]/g, "");
        const searchIndex = fullText.indexOf(searchValue);

        if (searchIndex === -1) {
          // Try to find first word
          const words = searchValue.split(/\s+/).filter((w) => w.length > 2);
          if (words.length > 0) {
            const wordIndex = fullText.indexOf(words[0]);
            if (wordIndex !== -1) {
              // Find which page and item contains this word
              let charCount = 0;
              for (let i = 0; i < allTextItems.length; i++) {
                const item = allTextItems[i];
                const itemText = item.str || "";
                const itemStart = charCount;
                const itemEnd = charCount + itemText.length;

                if (wordIndex >= itemStart && wordIndex < itemEnd) {
                  return {
                    ...field,
                    pageNum: item.pageNum,
                    coordinates: item.transform
                      ? {
                          x: item.transform[4],
                          y: item.transform[5],
                          width: item.width || 50,
                          height: item.height || 20,
                        }
                      : null,
                  };
                }

                charCount = itemEnd + 1;
              }
            }
          }
          return { ...field, pageNum: null, coordinates: null };
        } else {
          // Find first item in the match
          let charCount = 0;
          for (let i = 0; i < allTextItems.length; i++) {
            const item = allTextItems[i];
            const itemText = item.str || "";
            const itemStart = charCount;
            const itemEnd = charCount + itemText.length;

            if (itemEnd > searchIndex && itemStart < searchIndex + searchValue.length) {
              return {
                ...field,
                pageNum: item.pageNum,
                coordinates: item.transform
                  ? {
                      x: item.transform[4],
                      y: item.transform[5],
                      width: item.width || 50,
                      height: item.height || 20,
                    }
                  : null,
              };
            }

            charCount = itemEnd + 1;
          }
          return { ...field, pageNum: null, coordinates: null };
        }
      });

      return fieldsWithLocations;
    }

    highlightFieldsOnPDFPage(fields, textItems, viewport, overlayContext, pageNum, scale = 1.5) {
      if (!fields || fields.length === 0 || !textItems || textItems.length === 0) return;

      const self = this; // Capture context for nested functions

      // Colors for different field types
      const fieldColors = {
        email: "rgba(255, 235, 59, 0.4)", // Yellow
        phone: "rgba(144, 202, 249, 0.4)", // Blue
        address: "rgba(129, 199, 132, 0.4)", // Green
        date: "rgba(255, 183, 77, 0.4)", // Orange
        default: "rgba(255, 152, 0, 0.4)", // Orange
      };

      // Only highlight fields that are on this page
      const pageFields = fields.filter((f) => f.pageNum === pageNum);

      // Build full text string from items for better matching
      const fullText = textItems
        .map((item) => item.str || "")
        .join(" ")
        .toLowerCase();

      pageFields.forEach((field, fieldIndex) => {
        const fieldValue = field.value?.toString().trim();
        if (!fieldValue) return;

        const fieldValueLower = field.value?.toString().toLowerCase().trim();
        const fieldType = field.type?.toLowerCase() || "default";
        const color = fieldColors[fieldType] || fieldColors.default;

        // Try to find the field value in the text
        const searchValue = fieldValueLower.replace(/[^\w\s@.-]/g, ""); // Clean for matching
        const searchIndex = fullText.indexOf(searchValue);

        if (searchIndex === -1) {
          // Try partial matching - find individual words
          const words = searchValue.split(/\s+/).filter((w) => w.length > 2);
          words.forEach((word) => {
            const wordIndex = fullText.indexOf(word);
            if (wordIndex !== -1) {
              // Find text items that contain this word
              let charCount = 0;
              for (let i = 0; i < textItems.length; i++) {
                const item = textItems[i];
                const itemText = item.str || "";
                const itemStart = charCount;
                const itemEnd = charCount + itemText.length;

                if (wordIndex >= itemStart && wordIndex < itemEnd) {
                  self.highlightTextItem(item, viewport, overlayContext, color, fieldIndex);
                  break;
                }

                charCount = itemEnd + 1; // +1 for space
              }
            }
          });
        } else {
          // Found exact match - highlight all items that are part of this match
          let charCount = 0;
          const matchEnd = searchIndex + searchValue.length;
          const itemsToHighlight = [];

          for (let i = 0; i < textItems.length; i++) {
            const item = textItems[i];
            const itemText = item.str || "";
            const itemStart = charCount;
            const itemEnd = charCount + itemText.length;

            // Check if this item overlaps with the match
            if (itemEnd > searchIndex && itemStart < matchEnd) {
              itemsToHighlight.push(item);
            }

            charCount = itemEnd + 1; // +1 for space

            if (itemStart > matchEnd) break; // Past the match
          }

          // Highlight all items in the match
          itemsToHighlight.forEach((item) => {
            self.highlightTextItem(item, viewport, overlayContext, color, fieldIndex);
          });
        }
      });
    }

    highlightTextItem(item, viewport, overlayContext, color, fieldIndex) {
      if (!item.transform || item.transform.length < 6) return;

      const x = item.transform[4];
      const y = item.transform[5];
      const width = item.width || (item.str ? item.str.length * 6 : 50);
      const height = item.height || (item.transform[0] ? Math.abs(item.transform[0]) : 20);

      // Convert PDF coordinates to canvas coordinates
      // PDF coordinates: bottom-left origin, Y increases upward
      // Canvas coordinates: top-left origin, Y increases downward
      const canvasX = x;
      const canvasY = viewport.height - y - height;

      // Draw highlight rectangle
      overlayContext.fillStyle = color;
      overlayContext.fillRect(canvasX - 1, canvasY - 1, width + 2, height + 2);

      // Draw border
      overlayContext.strokeStyle = color.replace("0.4", "0.7");
      overlayContext.lineWidth = 1.5;
      overlayContext.strokeRect(canvasX - 1, canvasY - 1, width + 2, height + 2);
    }

    displayScannerFields(fields) {
      const fieldsList = document.getElementById("scanner-fields-list");
      if (!fieldsList) return;

      if (!fields || fields.length === 0) {
        fieldsList.innerHTML =
          '<div class="text-sm text-gray-500 dark:text-gray-400 text-center py-8">No fields detected</div>';
        return;
      }

      const self = this;
      fieldsList.innerHTML = fields
        .map((field, index) => {
          const fieldType = field.type?.toLowerCase() || "default";
          const typeColors = {
            email: "bg-primary-100 dark:bg-primary-900 text-primary-800 dark:text-primary-200",
            phone: "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200",
            address: "bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200",
            date: "bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200",
            default: "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200",
          };
          const colorClass = typeColors[fieldType] || typeColors.default;
          const hasLocation = field.pageNum && field.coordinates;
          const clickableClass = hasLocation
            ? "cursor-pointer hover:shadow-md transition-shadow"
            : "";

          return `
          <div 
            class="p-3 rounded-lg border border-gray-200 dark:border-gray-600 ${colorClass} ${clickableClass}"
            data-field-index="${index}"
            ${hasLocation ? `onclick="window.pdfSystem.scrollToScannerField(${index})"` : ""}
          >
            <div class="flex items-start justify-between">
              <div class="flex-1">
                <div class="text-xs font-medium uppercase mb-1 opacity-75">${this.escapeHtml(field.name)}</div>
                <div class="text-sm font-semibold">${this.escapeHtml(field.value)}</div>
              </div>
              ${
                hasLocation
                  ? `
                <div class="ml-2 text-xs text-gray-500 dark:text-gray-400">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                  </svg>
                </div>
              `
                  : ""
              }
            </div>
          </div>
        `;
        })
        .join("");
    }

    scrollToScannerField(fieldIndex) {
      try {
        console.log(`üìç [SCANNER] Scrolling to field index: ${fieldIndex}`);

        // Ensure scannerFields is initialized
        if (!this.scannerFields || !Array.isArray(this.scannerFields)) {
          console.warn("‚ö†Ô∏è [SCANNER] Scanner fields not available");
          return;
        }

        const field = this.scannerFields[fieldIndex];
        if (!field) {
          console.warn(`‚ö†Ô∏è [SCANNER] Field at index ${fieldIndex} not found`);
          return;
        }

        if (!field.pageNum || !field.coordinates) {
          console.warn(`‚ö†Ô∏è [SCANNER] Field location not available for field:`, field);
          return;
        }

        console.log(
          `üìç [SCANNER] Field: ${field.name}, Page: ${field.pageNum}, Coordinates:`,
          field.coordinates
        );

        const pageContainer = document.getElementById(`scanner-page-${field.pageNum}`);
        if (!pageContainer) {
          console.warn(
            `‚ö†Ô∏è [SCANNER] Page container ${field.pageNum} not found. Available page containers:`,
            Array.from(document.querySelectorAll('[id^="scanner-page-"]')).map((el) => el.id)
          );
          return;
        }

        // Find the scrollable container - check multiple possible locations
        const viewerSection = document.getElementById("scanner-viewer-section");
        if (!viewerSection) {
          console.warn("‚ö†Ô∏è [SCANNER] Viewer section not found");
          return;
        }

        // Try to find scrollable container - check the PDF viewer container first
        const pdfViewer = document.getElementById("scanner-pdf-viewer");
        let scrollableElement = null;

        // First, try to find a scrollable parent of the PDF viewer
        if (pdfViewer) {
          let element = pdfViewer;
          while (element && element !== document.body) {
            const style = window.getComputedStyle(element);
            const hasScroll =
              style.overflowY === "auto" ||
              style.overflowY === "scroll" ||
              style.overflow === "auto" ||
              style.overflow === "scroll" ||
              (element.scrollHeight > element.clientHeight && element.clientHeight > 0);

            if (hasScroll) {
              scrollableElement = element;
              break;
            }
            element = element.parentElement;
          }
        }

        // Fallback: look for overflow-y-auto class
        if (!scrollableElement) {
          scrollableElement = viewerSection.querySelector(".overflow-y-auto");
        }

        // Last resort: use window scrolling
        if (!scrollableElement) {
          console.log("üìç [SCANNER] No scrollable container found, using window scroll");
          const pageRect = pageContainer.getBoundingClientRect();
          const fieldY = this.calculateFieldYPosition(field, pageContainer);

          window.scrollTo({
            top: window.scrollY + pageRect.top + fieldY - window.innerHeight / 2,
            behavior: "smooth",
          });

          setTimeout(() => {
            this.pulseFieldHighlight(field.pageNum, field.coordinates);
          }, 300);
          return;
        }

        console.log(
          "üìç [SCANNER] Using scrollable element:",
          scrollableElement.id || scrollableElement.className
        );

        // Get page position relative to scrollable container
        const pageRect = pageContainer.getBoundingClientRect();
        const containerRect = scrollableElement.getBoundingClientRect();

        // Calculate field Y position on the page
        const fieldY = this.calculateFieldYPosition(field, pageContainer);

        // Calculate target scroll position to center the field
        const currentScroll = scrollableElement.scrollTop;
        const pageTopRelative = pageRect.top - containerRect.top + currentScroll;
        const targetScroll = pageTopRelative + fieldY - containerRect.height / 2;

        console.log("üìç [SCANNER] Scroll calculation:", {
          currentScroll,
          pageTopRelative,
          fieldY,
          targetScroll,
          containerHeight: containerRect.height,
        });

        // Smooth scroll
        scrollableElement.scrollTo({
          top: Math.max(0, targetScroll),
          behavior: "smooth",
        });

        // Add visual indicator (pulse animation) after scroll starts
        setTimeout(() => {
          this.pulseFieldHighlight(field.pageNum, field.coordinates);
        }, 300);
      } catch (error) {
        console.error("‚ùå [SCANNER] Error scrolling to scanner field:", error);
      }
    }

    calculateFieldYPosition(field, pageContainer) {
      // Get the actual scale used for rendering this page
      const actualScale = this.scannerPageScales?.[field.pageNum] || 1.0;
      const pageRect = pageContainer.getBoundingClientRect();

      // PDF coordinates use bottom-left origin, but canvas uses top-left
      // Transform[5] is the Y coordinate in PDF space (from bottom)
      // We need to convert to canvas space (from top)
      const pdfY = field.coordinates.y; // Y coordinate from bottom in PDF points
      const pdfHeight = field.coordinates.height || 20; // Height in PDF points

      // Get the canvas element to determine the actual rendered height
      const canvas = pageContainer.querySelector("canvas");
      if (!canvas) {
        // Fallback calculation
        return pageRect.height - pdfY * actualScale - pdfHeight * actualScale;
      }

      const canvasHeight = canvas.height;
      const viewportHeight = canvasHeight / actualScale; // Original PDF viewport height in points

      // Convert PDF Y (from bottom) to canvas Y (from top)
      const canvasY = viewportHeight - pdfY - pdfHeight;
      const scaledY = canvasY * actualScale;

      return scaledY;
    }

    updateScannerField(fieldIndex, newValue) {
      if (!this.scannerFields || !Array.isArray(this.scannerFields)) {
        console.warn("‚ö†Ô∏è [SCANNER] Scanner fields not available");
        return;
      }

      const field = this.scannerFields[fieldIndex];
      if (!field) {
        console.warn(`‚ö†Ô∏è [SCANNER] Field at index ${fieldIndex} not found`);
        return;
      }

      // Update the field value
      field.value = newValue;
      field.editable = false; // Mark as no longer editable (has value now)

      console.log(`‚úÖ [SCANNER] Updated field ${field.name} to: ${newValue}`);

      // Re-render the fields list to update the display
      this.displayScannerFields(this.scannerFields);
    }

    pulseFieldHighlight(pageNum, coordinates) {
      const overlayCanvas = document.getElementById(`scanner-overlay-${pageNum}`);
      if (!overlayCanvas) return;

      const overlayContext = overlayCanvas.getContext("2d");
      const viewport = { height: overlayCanvas.height };

      const canvasX = coordinates.x;
      const canvasY = viewport.height - coordinates.y - coordinates.height;

      // Draw pulsing highlight
      let pulseCount = 0;
      const pulseInterval = setInterval(() => {
        // Clear and redraw
        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        // Redraw all highlights first (we'd need to store them, but for now just pulse)
        pulseCount++;

        if (pulseCount > 6) {
          clearInterval(pulseInterval);
          // Redraw all highlights
          // For now, we'll just leave it - in production you'd redraw all highlights
          return;
        }

        // Draw pulsing highlight
        const opacity = 0.4 + Math.sin((pulseCount * Math.PI) / 2) * 0.3;
        overlayContext.fillStyle = `rgba(255, 0, 0, ${opacity})`;
        overlayContext.fillRect(
          canvasX - 3,
          canvasY - 3,
          coordinates.width + 6,
          coordinates.height + 6
        );

        overlayContext.strokeStyle = `rgba(255, 0, 0, ${opacity + 0.3})`;
        overlayContext.lineWidth = 3;
        overlayContext.strokeRect(
          canvasX - 3,
          canvasY - 3,
          coordinates.width + 6,
          coordinates.height + 6
        );
      }, 200);
    }

    async displayImageWithHighlights(file, container) {
      const self = this;

      // Display image first
      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          // Create image element
          const img = document.createElement("img");
          img.src = e.target.result;
          img.className = "max-w-full h-auto rounded border border-gray-300 dark:border-gray-600";
          img.style.maxHeight = "600px";

          // Create wrapper with relative positioning for overlay
          const wrapper = document.createElement("div");
          wrapper.className = "relative inline-block";
          wrapper.style.position = "relative";

          // Create overlay canvas for highlights
          const overlayCanvas = document.createElement("canvas");
          overlayCanvas.className = "absolute top-0 left-0 pointer-events-none";
          overlayCanvas.style.position = "absolute";
          overlayCanvas.style.top = "0";
          overlayCanvas.style.left = "0";

          img.onload = async function () {
            // Set canvas size to match image
            overlayCanvas.width = img.width;
            overlayCanvas.height = img.height;

            wrapper.appendChild(img);
            wrapper.appendChild(overlayCanvas);
            container.innerHTML = "";
            container.appendChild(wrapper);

            // Process image with OCR to extract fields
            try {
              const result = await self.processImageWithCanvas(file);
              const fields = self.extractFieldsFromText(result.text || "");

              // Display fields
              self.displayScannerFields(fields);

              // Note: For images, we'd need OCR with word positions to highlight accurately
              // This is a simplified version - full implementation would require OCR.space API
              // with WordsOverlay data to get exact coordinates
            } catch (ocrError) {
              console.error("OCR error:", ocrError);
              self.displayScannerFields([]);
            }
          };
        } catch (error) {
          console.error("Error displaying image:", error);
          container.innerHTML = `<div class="text-center text-red-500 py-20"><p>Error: ${error.message}</p></div>`;
        }
      };
      reader.readAsDataURL(file);
    }

    displayImageInViewer(file, container) {
      const reader = new FileReader();
      reader.onload = function (e) {
        container.innerHTML = `
          <div class="flex justify-center">
            <img src="${e.target.result}" alt="${file.name}" class="max-w-full h-auto rounded border border-gray-300 dark:border-gray-600" />
          </div>
        `;
      };
      reader.readAsDataURL(file);
    }

    async processPDFWithOCRForScanner(file) {
      // Similar to processPDFWithOCR but returns text only
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this;
        fileReader.onload = async function (e) {
          try {
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
            const numPages = pdf.numPages;
            let allExtractedText = "";

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const viewport = page.getViewport({ scale: 2.0 });
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;

              const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
              const imageFile = new File([blob], `page-${i}.png`, { type: "image/png" });
              const ocrResult = await self.runOCROnImage(imageFile, i);

              if (ocrResult && ocrResult.text) {
                allExtractedText += `\n--- Page ${i} ---\n${ocrResult.text}\n`;
              }
            }

            resolve({ text: allExtractedText });
          } catch (error) {
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    async processUploadedFile(file) {
      const formData = new FormData();
      formData.append("file", file);

      const response = await fetch("/api/pdf/process-file", {
        method: "POST",
        credentials: "include",
        body: formData,
      });

      return await response.json();
    }

    async displayExtractedContent(content, fields) {
      console.log("üìÑ [PDF-SYSTEM] Displaying extracted content:", {
        contentType: typeof content,
        contentLength: content?.length,
        contentPreview: content?.substring(0, 100),
        fieldsCount: fields?.length,
      });

      // Check if this needs client-side OCR
      console.log("üîç [PDF-SYSTEM] Checking for OCR placeholders...");
      console.log("üîç [PDF-SYSTEM] Content value:", JSON.stringify(content));
      console.log("üîç [PDF-SYSTEM] Is IMAGE_OCR_PLACEHOLDER?", content === "IMAGE_OCR_PLACEHOLDER");
      console.log("üîç [PDF-SYSTEM] Is PDF_OCR_PLACEHOLDER?", content === "PDF_OCR_PLACEHOLDER");

      if (content === "IMAGE_OCR_PLACEHOLDER") {
        console.log("üîç [PDF-SYSTEM] Image detected - running client-side OCR...");
        await this.runClientSideOCR(file);
        return;
      }

      if (content === "PDF_OCR_PLACEHOLDER") {
        console.log("üîç [PDF-SYSTEM] PDF detected - running client-side OCR...");
        await this.runClientSideOCR(file);
        return;
      }

      // Ensure content is a string
      const safeContent = content || "";

      // Set content in editor using Quill's proper method
      if (this.editor) {
        try {
          // Use Quill's clipboard to properly handle HTML content (like contract system)
          const delta = this.editor.clipboard.convert(safeContent);
          this.editor.setContents(delta);
          console.log("‚úÖ [PDF-SYSTEM] Content set in Quill editor using proper method");
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error setting content in editor:", error);
          // Fallback to textarea
          const textarea = document.getElementById("template-content-textarea");
          if (textarea) {
            textarea.value = safeContent;
          }
        }
      } else {
        // Try to find the textarea fallback
        const textarea = document.getElementById("template-content-textarea");
        if (textarea) {
          textarea.value = safeContent;
        } else {
          // If editor isn't ready yet, wait a bit and try again
          setTimeout(() => {
            if (this.editor) {
              try {
                const delta = this.editor.clipboard.convert(safeContent);
                this.editor.setContents(delta);
              } catch (error) {
                console.error("‚ùå [PDF-SYSTEM] Error setting content in delayed editor:", error);
              }
            } else {
              const textarea = document.getElementById("template-content-textarea");
              if (textarea) {
                textarea.value = safeContent;
              }
            }
          }, 200);
        }
      }

      // Display extracted fields
      if (fields && fields.length > 0) {
        this.displayExtractedFields(fields);
      }
    }

    async runClientSideOCR(file) {
      try {
        console.log("üîç [PDF-SYSTEM] Starting client-side PDF processing...");
        console.log("üîç [PDF-SYSTEM] Processing file:", file.name);

        // Use PDF.js like in New.astro
        if (file.type === "application/pdf") {
          await this.processPDFWithPDFJS(file);
        } else if (file.type.startsWith("image/")) {
          await this.processImageWithCanvas(file);
        } else {
          throw new Error("Unsupported file type. Please upload PDF or image files.");
        }

        this.showNotification("File processed successfully!", "success");
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Processing Error:", error);
        this.showNotification("Processing failed: " + error.message, "error");
      }
    }

    async processPDFWithPDFJS(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this; // Capture the class context
        fileReader.onload = async function (e) {
          try {
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;

            let fullText = "";
            const numPages = pdf.numPages;

            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();

              console.log(
                `üîç [PDF-SYSTEM] Page ${i}: ${textContent.items.length} text items found`
              );

              // Debug: Log first few items to see what we're getting
              if (textContent.items.length > 0) {
                console.log(
                  `üîç [PDF-SYSTEM] First 3 items:`,
                  textContent.items.slice(0, 3).map((item) => ({
                    str: item.str?.substring(0, 50),
                    hasText: !!item.str?.trim(),
                  }))
                );
              }

              // Enhanced text extraction with structure detection
              const structuredText = self.extractStructuredText(textContent.items);
              console.log(
                `üîç [PDF-SYSTEM] Page ${i} extracted text length:`,
                structuredText.length
              );
              fullText += structuredText + "\n";
            }

            console.log("üîç [PDF-SYSTEM] PDF text extracted:", fullText.length, "characters");
            console.log("üîç [PDF-SYSTEM] Extracted text preview:", fullText.substring(0, 200));

            // Check if we got meaningful text (more than just whitespace or very few characters)
            const meaningfulText = fullText.trim().length > 50;

            if (!meaningfulText) {
              console.log(
                "‚ö†Ô∏è [PDF-SYSTEM] Minimal text extracted from PDF. PDF may be scanned/image-based. Converting PDF pages to images for OCR..."
              );
              // Convert PDF pages to images and run OCR
              await self.processPDFWithOCR(file);
              resolve({ success: true, text: "", ocrUsed: true });
              return;
            }

            // Replace detected fields with placeholders
            const textWithPlaceholders = self.replaceFieldsWithPlaceholders(fullText);

            // Convert to HTML format with preserved structure and placeholders
            const htmlContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  ${textWithPlaceholders}
                </div>
              </div>
            `;

            // Set content in editor using Quill's proper method
            if (self.editor) {
              const delta = self.editor.clipboard.convert(htmlContent);
              self.editor.setContents(delta);
              console.log("‚úÖ [PDF-SYSTEM] Content set in Quill editor");
            } else {
              const textarea = document.getElementById("template-content-textarea");
              if (textarea) {
                textarea.value = htmlContent;
                console.log("‚úÖ [PDF-SYSTEM] Content set in textarea");
              }
            }

            // Extract fields
            const fields = self.extractFieldsFromText(fullText);
            if (fields && fields.length > 0) {
              self.displayExtractedFields(fields);
            }

            resolve({ success: true, text: fullText });
          } catch (error) {
            console.error("‚ùå [PDF-SYSTEM] PDF processing error:", error);
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    extractStructuredText(items) {
      let result = "";
      let currentList = [];
      let inList = false;
      let listType = null;

      if (!items || items.length === 0) {
        console.log("‚ö†Ô∏è [PDF-SYSTEM] No text items found in PDF page");
        return "";
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        let text = item.str || "";
        const nextItem = items[i + 1];

        // Skip empty items
        if (!text || !text.trim()) continue;

        // Fix word breaks: if text is a single letter followed by space, check if next item completes the word
        // This handles cases where "h" + "istory" should be "history"
        if (text.length === 1 && /^[a-z]$/i.test(text) && nextItem?.str) {
          const nextText = nextItem.str.trim();
          // Check if combining makes a common word
          const combined = text + nextText;
          const commonWords = [
            "history",
            "sheet",
            "name",
            "information",
            "drawing",
            "north",
            "south",
            "east",
            "west",
            "building",
            "construction",
            "classification",
            "district",
            "subdistrict",
            "proposed",
            "existing",
            "permeable",
            "parking",
            "coverage",
            "height",
            "depth",
            "width",
            "plate",
            "area",
            "yard",
            "description",
            "story",
            "stories",
            "type",
            "group",
            "use",
            "lot",
            "parcel",
            "front",
            "side",
            "rear",
            "minimum",
            "maximum",
            "gross",
            "floor",
            "total",
          ];

          if (commonWords.includes(combined.toLowerCase())) {
            // Combine them and skip the next item
            text = combined;
            i++; // Skip next item since we've combined it
          }
        }

        // Detect list items (bullet points, numbers, dashes)
        const isListItem = this.detectListItem(text, item, nextItem);

        if (isListItem) {
          if (!inList) {
            // Start new list
            inList = true;
            listType = this.detectListType(text);
            currentList = [];
          }
          currentList.push(text.trim());
        } else {
          // End current list if we were in one
          if (inList) {
            result += this.formatList(currentList, listType);
            currentList = [];
            inList = false;
            listType = null;
          }

          // Detect headers (all caps, short lines, or specific patterns)
          if (this.detectHeader(text, item)) {
            result += `<h3>${text.trim()}</h3>\n`;
          } else {
            // Regular paragraph
            result += `<p>${text.trim()}</p>\n`;
          }
        }
      }

      // Close any remaining list
      if (inList) {
        result += this.formatList(currentList, listType);
      }

      return result;
    }

    detectListItem(text, currentItem, nextItem) {
      const trimmed = text.trim();

      // Check for bullet points
      if (/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ]/.test(trimmed)) return true;

      // Check for numbered lists (1., 2., etc.)
      if (/^\d+\.\s/.test(trimmed)) return true;

      // Check for lettered lists (a., b., etc.)
      if (/^[a-zA-Z]\.\s/.test(trimmed)) return true;

      // Check for dashes
      if (/^[-‚Äì‚Äî]\s/.test(trimmed)) return true;

      // Check for indentation (if we have position data)
      if (currentItem.transform && nextItem && nextItem.transform) {
        const currentX = currentItem.transform[4];
        const nextX = nextItem.transform[4];
        if (currentX > nextX + 20) return true; // Indented more than next item
      }

      return false;
    }

    detectListType(text) {
      if (/^\d+\.\s/.test(text.trim())) return "ol";
      if (/^[a-zA-Z]\.\s/.test(text.trim())) return "ol";
      return "ul";
    }

    detectHeader(text, item) {
      const trimmed = text.trim();

      // All caps and short
      if (trimmed === trimmed.toUpperCase() && trimmed.length < 50 && trimmed.length > 3)
        return true;

      // Common header patterns
      if (/^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY)/i.test(trimmed))
        return true;

      // Short lines that might be headers
      if (trimmed.length < 30 && /^[A-Z]/.test(trimmed)) return true;

      return false;
    }

    formatList(items, type) {
      if (items.length === 0) return "";

      const listItems = items
        .map((item) => {
          // Clean up the item text
          const cleaned = item.replace(/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ\-\d+\.\s*[a-zA-Z]\.\s*]/, "").trim();
          return `<li>${cleaned}</li>`;
        })
        .join("\n");

      return `<${type}>\n${listItems}\n</${type}>\n\n`;
    }

    extractStructuredTextFromString(text) {
      // Improved OCR text processing - groups single-word lines into sentences/paragraphs
      const lines = text
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l);

      if (lines.length === 0) return "";

      let result = "";
      let currentParagraph = [];
      let currentList = [];
      let inList = false;
      let listType = null;
      let inParagraph = false;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const nextLine = lines[i + 1];
        const prevLine = lines[i - 1];

        // Detect list items (bullet points, numbers, dashes)
        const isListItem = this.detectListItemFromString(line);

        if (isListItem) {
          // End current paragraph if we were in one
          if (inParagraph && currentParagraph.length > 0) {
            result += `<p>${currentParagraph.join(" ")}</p>\n`;
            currentParagraph = [];
            inParagraph = false;
          }

          if (!inList) {
            // Start new list
            inList = true;
            listType = this.detectListTypeFromString(line);
            currentList = [];
          }
          currentList.push(line);
        } else {
          // End current list if we were in one
          if (inList) {
            result += this.formatList(currentList, listType);
            currentList = [];
            inList = false;
            listType = null;
          }

          // Detect headers (all caps, short lines, or specific patterns)
          if (this.detectHeaderFromString(line)) {
            // End current paragraph before header
            if (inParagraph && currentParagraph.length > 0) {
              result += `<p>${currentParagraph.join(" ")}</p>\n`;
              currentParagraph = [];
              inParagraph = false;
            }
            result += `<h3>${line}</h3>\n`;
          } else {
            // Smart paragraph grouping for OCR text
            // If line is very short (likely single word), add to current paragraph
            const isShortLine = line.split(/\s+/).length <= 3 && line.length < 50;
            const endsWithPunctuation = /[.!?;:]$/.test(line);
            const nextIsShort =
              nextLine && nextLine.split(/\s+/).length <= 3 && nextLine.length < 50;
            const nextIsListItem = nextLine && this.detectListItemFromString(nextLine);
            const nextIsHeader = nextLine && this.detectHeaderFromString(nextLine);

            // Start new paragraph if:
            // - Previous line ended with punctuation AND current line starts with capital
            // - Current line is long (likely a full sentence)
            // - Next line is a list item or header
            const shouldStartNewParagraph =
              (inParagraph &&
                currentParagraph.length > 0 &&
                endsWithPunctuation &&
                /^[A-Z]/.test(line)) ||
              (!isShortLine && currentParagraph.length > 5) ||
              nextIsListItem ||
              nextIsHeader;

            if (shouldStartNewParagraph && currentParagraph.length > 0) {
              result += `<p>${currentParagraph.join(" ")}</p>\n`;
              currentParagraph = [line];
              inParagraph = true;
            } else if (
              isShortLine &&
              !endsWithPunctuation &&
              nextLine &&
              !nextIsListItem &&
              !nextIsHeader
            ) {
              // Short line that's likely part of a sentence - add to current paragraph
              currentParagraph.push(line);
              inParagraph = true;
            } else {
              // Regular line - start new paragraph or add to current
              if (!inParagraph) {
                currentParagraph = [line];
                inParagraph = true;
              } else {
                // Check if we should continue or start new paragraph
                if (
                  endsWithPunctuation &&
                  nextLine &&
                  /^[A-Z]/.test(nextLine) &&
                  !nextIsListItem &&
                  !nextIsHeader
                ) {
                  // End of sentence, next starts with capital - likely new paragraph
                  currentParagraph.push(line);
                  result += `<p>${currentParagraph.join(" ")}</p>\n`;
                  currentParagraph = [];
                  inParagraph = false;
                } else {
                  currentParagraph.push(line);
                }
              }
            }
          }
        }
      }

      // Close any remaining paragraph
      if (inParagraph && currentParagraph.length > 0) {
        result += `<p>${currentParagraph.join(" ")}</p>\n`;
      }

      // Close any remaining list
      if (inList) {
        result += this.formatList(currentList, listType);
      }

      return result;
    }

    detectListItemFromString(line) {
      // Check for bullet points
      if (/^[‚Ä¢¬∑‚ñ™‚ñ´‚Ä£‚ÅÉ]/.test(line)) return true;

      // Check for numbered lists (1., 2., etc.)
      if (/^\d+\.\s/.test(line)) return true;

      // Check for lettered lists (a., b., etc.)
      if (/^[a-zA-Z]\.\s/.test(line)) return true;

      // Check for dashes
      if (/^[-‚Äì‚Äî]\s/.test(line)) return true;

      return false;
    }

    detectListTypeFromString(line) {
      if (/^\d+\.\s/.test(line)) return "ol";
      if (/^[a-zA-Z]\.\s/.test(line)) return "ol";
      return "ul";
    }

    detectHeaderFromString(line) {
      // All caps and short
      if (line === line.toUpperCase() && line.length < 50 && line.length > 3) return true;

      // Common header patterns
      if (/^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY)/i.test(line))
        return true;

      // Short lines that might be headers
      if (line.length < 30 && /^[A-Z]/.test(line)) return true;

      return false;
    }

    async processPDFWithOCR(file) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        const self = this;
        fileReader.onload = async function (e) {
          try {
            console.log("üîç [PDF-SYSTEM] Converting PDF to images for OCR...");
            const typedarray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
            const numPages = pdf.numPages;

            let allExtractedText = "";

            // Show loading state
            const loadingContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <h2>Processing PDF with OCR...</h2>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  <p>Converting ${numPages} page(s) to images and running OCR...</p>
                  <p>Please wait...</p>
                </div>
              </div>
            `;

            if (self.editor) {
              const delta = self.editor.clipboard.convert(loadingContent);
              self.editor.setContents(delta);
            }

            // Process each page
            for (let i = 1; i <= numPages; i++) {
              console.log(`üîç [PDF-SYSTEM] Processing page ${i}/${numPages} with OCR...`);

              const page = await pdf.getPage(i);
              const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR

              // Create canvas to render PDF page
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              // Render PDF page to canvas
              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;

              // Convert canvas to blob
              const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));

              // Create a File object from the blob
              const imageFile = new File([blob], `page-${i}.png`, { type: "image/png" });

              // Run OCR on this page
              try {
                const ocrResult = await self.runOCROnImage(imageFile, i);
                if (ocrResult && ocrResult.text) {
                  // Store both text and structured data
                  allExtractedText += `\n--- Page ${i} ---\n${ocrResult.text}\n`;
                  // Store structured OCR data for layout preservation
                  if (!self.ocrResultsByPage) {
                    self.ocrResultsByPage = [];
                  }
                  self.ocrResultsByPage.push({
                    page: i,
                    text: ocrResult.text,
                    words: ocrResult.words,
                    rawResult: ocrResult.rawResult,
                  });
                }
              } catch (ocrError) {
                console.error(`‚ùå [PDF-SYSTEM] OCR failed for page ${i}:`, ocrError);
              }
            }

            if (allExtractedText.trim().length > 0) {
              console.log(
                "üîç [PDF-SYSTEM] OCR completed. Total text length:",
                allExtractedText.length
              );

              // Try to preserve layout using OCR word positions
              let htmlContent = "";

              if (self.ocrResultsByPage && self.ocrResultsByPage.length > 0) {
                // Use structured OCR data with positions
                console.log("üîç [PDF-SYSTEM] Using structured OCR data to preserve layout...");

                let structuredHTML = "";
                self.ocrResultsByPage.forEach((pageData) => {
                  if (pageData.words && pageData.words.length > 0) {
                    const pageHTML = self.convertOCRToStructuredHTML(pageData.words);
                    structuredHTML += `<div class="ocr-page" style="margin-bottom: 2em; page-break-after: always;">
                      <h4 style="color: #666; font-size: 0.9em; margin-bottom: 1em;">Page ${pageData.page}</h4>
                      ${pageHTML}
                    </div>`;
                  } else {
                    // Fallback to plain text if no word positions
                    structuredHTML += `<div class="ocr-page" style="margin-bottom: 2em;">
                      <h4 style="color: #666; font-size: 0.9em; margin-bottom: 1em;">Page ${pageData.page}</h4>
                      <div style="white-space: pre-wrap; font-family: monospace;">${pageData.text.replace(/\n/g, "<br>")}</div>
                    </div>`;
                  }
                });

                // Replace detected fields with placeholders in the structured HTML
                const textWithPlaceholders = self.replaceFieldsWithPlaceholders(allExtractedText);

                // Merge structured layout with placeholders (simplified - could be improved)
                htmlContent = `
               
                      ${structuredHTML}
                  
                `;
              } else {
                // Fallback: Use plain text with structure detection
                const structuredText = self.extractStructuredTextFromString(allExtractedText);
                const textWithPlaceholders = self.replaceFieldsWithPlaceholders(allExtractedText);

                htmlContent = `
                  <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                    <h2>Extracted from PDF (OCR)</h2>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                      ${textWithPlaceholders}
                    </div>
                  </div>
                `;
              }

              // Set content in editor
              if (self.editor) {
                const delta = self.editor.clipboard.convert(htmlContent);
                self.editor.setContents(delta);
                console.log("‚úÖ [PDF-SYSTEM] OCR content set in Quill editor");
              }

              // Extract fields
              const fields = self.extractFieldsFromText(allExtractedText);
              if (fields && fields.length > 0) {
                self.displayExtractedFields(fields);
              }

              resolve({ success: true, text: allExtractedText });
            } else {
              throw new Error("OCR did not extract any text from the PDF");
            }
          } catch (error) {
            console.error("‚ùå [PDF-SYSTEM] PDF OCR processing error:", error);
            reject(error);
          }
        };
        fileReader.readAsArrayBuffer(file);
      });
    }

    async runOCROnImage(imageFile, pageNum = null) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append("file", imageFile);
        formData.append("language", "eng");
        formData.append("isOverlayRequired", "true"); // Get position data for layout preservation
        formData.append("OCREngine", "2");
        formData.append("detectOrientation", "true"); // Better for rotated/scanned documents
        formData.append("scale", "true"); // Scale for better quality

        fetch("https://api.ocr.space/parse/image", {
          method: "POST",
          headers: {
            apikey: "K81932338788957",
          },
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.IsErroredOnProcessing) {
              reject(new Error(data.ErrorMessage || "OCR processing failed"));
              return;
            }

            if (data.ParsedResults && data.ParsedResults[0]) {
              const result = data.ParsedResults[0];
              const extractedText = result.ParsedText ? result.ParsedText.trim() : "";

              // Get structured data with word positions for layout preservation
              // OCR.space returns WordsOverlay with Lines array, each containing Words array
              let wordOverlay = [];
              if (result.WordsOverlay && result.WordsOverlay.Lines) {
                wordOverlay = result.WordsOverlay.Lines;
              } else if (result.WordsOverlay && Array.isArray(result.WordsOverlay)) {
                // Alternative structure
                wordOverlay = result.WordsOverlay;
              }

              console.log("üîç [PDF-SYSTEM] OCR word overlay structure:", {
                hasWordsOverlay: !!result.WordsOverlay,
                hasLines: !!(result.WordsOverlay && result.WordsOverlay.Lines),
                linesCount: wordOverlay.length,
              });

              // Return both text and layout information
              resolve({
                text: extractedText,
                words: wordOverlay,
                rawResult: result,
              });
            } else {
              reject(new Error("No text extracted from OCR"));
            }
          })
          .catch((error) => {
            reject(error);
          });
      });
    }

    // Convert OCR words with positions to HTML with preserved layout
    convertOCRToStructuredHTML(ocrResults) {
      if (!ocrResults || !Array.isArray(ocrResults) || ocrResults.length === 0) {
        return "";
      }

      // Group words by Y position to detect lines
      const lines = [];
      const yTolerance = 5; // Pixels tolerance for same line

      ocrResults.forEach((word, index) => {
        if (!word.Words || word.Words.length === 0) return;

        word.Words.forEach((w) => {
          const wordText = w.WordText || "";
          if (!wordText.trim()) return;

          const y = Math.round(w.Top);
          const x = Math.round(w.Left);

          // Find existing line at similar Y position
          let foundLine = false;
          for (let i = 0; i < lines.length; i++) {
            if (Math.abs(lines[i].y - y) <= yTolerance) {
              lines[i].words.push({ text: wordText, x: x, width: w.Width || 0 });
              foundLine = true;
              break;
            }
          }

          if (!foundLine) {
            lines.push({ y: y, words: [{ text: wordText, x: x, width: w.Width || 0 }] });
          }
        });
      });

      // Sort lines by Y position
      lines.sort((a, b) => a.y - b.y);

      // Sort words within each line by X position
      lines.forEach((line) => {
        line.words.sort((a, b) => a.x - b.x);
      });

      // Convert to HTML with structure detection
      let html = "";
      let currentParagraph = [];
      let lastLineY = null;
      const paragraphSpacing = 15; // Pixels between lines to consider new paragraph

      lines.forEach((line, index) => {
        const lineText = line.words.map((w) => w.text).join(" ");
        const lineY = line.y;

        // Detect paragraph breaks based on Y spacing
        if (lastLineY !== null && lineY - lastLineY > paragraphSpacing) {
          // New paragraph
          if (currentParagraph.length > 0) {
            html += this.formatParagraph(currentParagraph.join(" "));
            currentParagraph = [];
          }
        }

        // Detect headers (all caps, short lines, centered-ish)
        const isHeader = this.detectHeaderFromOCR(line);
        if (isHeader) {
          // Close current paragraph if any
          if (currentParagraph.length > 0) {
            html += this.formatParagraph(currentParagraph.join(" "));
            currentParagraph = [];
          }
          html += `<h3 style="margin-top: 1em; margin-bottom: 0.5em;">${lineText}</h3>\n`;
        } else {
          currentParagraph.push(lineText);
        }

        lastLineY = lineY;
      });

      // Close last paragraph
      if (currentParagraph.length > 0) {
        html += this.formatParagraph(currentParagraph.join(" "));
      }

      return html;
    }

    formatParagraph(text) {
      if (!text || !text.trim()) return "";
      // Detect list items
      if (this.detectListItemFromString(text.trim())) {
        const listType = this.detectListTypeFromString(text.trim());
        return `<li>${text.trim()}</li>\n`;
      }
      return `<p style="margin: 0.5em 0; line-height: 1.6;">${text.trim()}</p>\n`;
    }

    detectHeaderFromOCR(line) {
      const lineText = line.words.map((w) => w.text).join(" ");
      const text = lineText.trim();

      // All caps and short
      if (text === text.toUpperCase() && text.length < 50 && text.length > 3) return true;

      // Common header patterns
      if (
        /^(INTRODUCTION|SUMMARY|CONCLUSION|APPENDIX|REFERENCES|BIBLIOGRAPHY|AFFIDAVIT|CERTIFICATE|DECLARATION)/i.test(
          text
        )
      )
        return true;

      // Short lines that might be headers
      if (text.length < 30 && /^[A-Z]/.test(text)) return true;

      // Check if line is mostly centered (words spread out more)
      if (line.words.length > 0) {
        const firstWordX = line.words[0].x;
        const lastWordX =
          line.words[line.words.length - 1].x + (line.words[line.words.length - 1].width || 0);
        const lineWidth = lastWordX - firstWordX;
        // If words are spread out (centered-ish), might be a header
        // This is a heuristic - headers often have more spacing
      }

      return false;
    }

    async processImageWithCanvas(file) {
      return new Promise((resolve, reject) => {
        const self = this; // Capture the class context

        console.log("üîç [PDF-SYSTEM] Processing image with OCR...");

        // Show loading state
        const loadingContent = `
          <div style="font-family: Arial, sans-serif; line-height: 1.6;">
            <h2>Processing Image...</h2>
            <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
              <p>Running OCR on: ${file.name}</p>
              <p>Please wait while we extract text from the image...</p>
            </div>
          </div>
        `;

        // Set loading content
        if (self.editor) {
          const delta = self.editor.clipboard.convert(loadingContent);
          self.editor.setContents(delta);
        }

        // Send to OCR.space API (like in ocr.astro and New.astro)
        const formData = new FormData();
        formData.append("file", file);
        formData.append("language", "eng");
        formData.append("isOverlayRequired", "false");
        formData.append("OCREngine", "2");

        fetch("https://api.ocr.space/parse/image", {
          method: "POST",
          headers: {
            apikey: "K81932338788957", // Same API key as used in ocr.astro
          },
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("üîç [PDF-SYSTEM] OCR API response:", data);

            if (data.IsErroredOnProcessing) {
              throw new Error(data.ErrorMessage || "OCR processing failed");
            }

            if (data.ParsedResults && data.ParsedResults[0] && data.ParsedResults[0].ParsedText) {
              const extractedText = data.ParsedResults[0].ParsedText;
              console.log("üîç [PDF-SYSTEM] OCR completed. Text length:", extractedText.length);

              // Apply structure detection to the extracted text
              const structuredText = self.extractStructuredTextFromString(extractedText);

              // Replace detected fields with placeholders
              const textWithPlaceholders = self.replaceFieldsWithPlaceholders(extractedText);

              // Convert to HTML format with preserved structure and placeholders
              const htmlContent = `
              <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <h2>Extracted from Image (OCR)</h2>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0;">
                  ${textWithPlaceholders}
                </div>
              </div>
            `;

              // Set content in editor using Quill's proper method
              if (self.editor) {
                const delta = self.editor.clipboard.convert(htmlContent);
                self.editor.setContents(delta);
              } else {
                const textarea = document.getElementById("template-content-textarea");
                if (textarea) {
                  textarea.value = htmlContent;
                }
              }

              // Extract fields from the OCR text
              const fields = self.extractFieldsFromText(extractedText);
              if (fields && fields.length > 0) {
                self.displayExtractedFields(fields);
              }

              resolve({ success: true, text: extractedText });
            } else {
              throw new Error("No text found in image");
            }
          })
          .catch((error) => {
            console.error("‚ùå [PDF-SYSTEM] OCR Error:", error);

            const errorContent = `
            <div style="font-family: Arial, sans-serif; line-height: 1.6;">
              <h2>OCR Processing Failed</h2>
              <div style="background: #ffebee; padding: 15px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #f44336;">
                <p><strong>Error:</strong> ${error.message}</p>
                <p>Image file: ${file.name}</p>
              </div>
            </div>
          `;

            if (self.editor) {
              const delta = self.editor.clipboard.convert(errorContent);
              self.editor.setContents(delta);
            }

            reject(error);
          });
      });
    }

    /**
     * Extract the best address from text using top-down priority
     * Now prioritizes by font size (larger fonts = higher priority)
     * Returns the first complete address found, removes it from text
     * Priority: 1) Font size (larger first), 2) Completeness (complete first), 3) Position (earlier first)
     */
    extractBestAddress(text, textItems = null) {
      // Address patterns ordered by priority (most specific first)
      const addressPatterns = [
        // Labeled addresses (highest priority) - complete with zip
        {
          pattern:
            /(?:address|project\s+location|site\s+address|location)[:\s]+(\d+\s+[A-Za-z0-9\s,.#-]+(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Boulevard|Blvd|Way|Circle|Cir|Court|Ct|Place|Pl|Parkway|Pkwy|Highway|Hwy)[\s,]+[A-Za-z\s]+(?:,\s*)?[A-Z]{2}\s+\d{5}(?:-\d{4})?)/gi,
          isComplete: true,
          priority: 1,
        },
        // Standard complete address (street + city + state + zip)
        {
          pattern:
            /\d+\s+[A-Za-z0-9\s,.#-]+(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Boulevard|Blvd|Way|Circle|Cir|Court|Ct|Place|Pl|Parkway|Pkwy|Highway|Hwy)[\s,]+[A-Za-z\s]+(?:,\s*)?[A-Z]{2}\s+\d{5}(?:-\d{4})?/gi,
          isComplete: true,
          priority: 2,
        },
        // Address with PO Box
        {
          pattern:
            /(?:P\.?O\.?\s*Box|PO\s*Box|Post\s*Office\s*Box)\s+\d+[\s,]+[A-Za-z\s]+(?:,\s*)?[A-Z]{2}\s+\d{5}(?:-\d{4})?/gi,
          isComplete: true,
          priority: 3,
        },
        // Incomplete addresses (no zip) - lower priority
        {
          pattern:
            /(?:address|project\s+location|site\s+address)[:\s]+(\d+\s+[A-Za-z0-9\s,.#-]+(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Boulevard|Blvd|Way|Circle|Cir|Court|Ct|Place|Pl|Parkway|Pkwy)[\s,]+[A-Za-z\s]+)/gi,
          isComplete: false,
          priority: 4,
        },
        {
          pattern:
            /\d+\s+[A-Za-z0-9\s,.#-]+(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Boulevard|Blvd|Way|Circle|Cir|Court|Ct|Place|Pl|Parkway|Pkwy)[\s,]+[A-Za-z\s]+/gi,
          isComplete: false,
          priority: 5,
        },
      ];

      // Find all addresses with their positions, completeness, and font sizes
      const addressMatches = [];

      addressPatterns.forEach(({ pattern, isComplete, priority }) => {
        const regex = new RegExp(pattern.source, pattern.flags);
        let match;
        while ((match = regex.exec(text)) !== null) {
          const fullMatch = match[0];
          const cleaned = fullMatch
            .replace(/^(address|project\s+location|site\s+address|location)[:\s]+/i, "")
            .trim();

          // Validate: must have street number and street name
          if (cleaned.length > 10 && /\d+/.test(cleaned) && /[A-Za-z]/.test(cleaned)) {
            // Calculate average font size for this address match
            let avgFontSize = 12; // Default font size
            let maxFontSize = 12;

            if (textItems && textItems.length > 0) {
              // Find text items that overlap with this address match
              let charCount = 0;
              const matchStart = match.index;
              const matchEnd = match.index + fullMatch.length;
              const fontSizes = [];

              for (let i = 0; i < textItems.length; i++) {
                const item = textItems[i];
                const itemText = item.str || "";
                const itemStart = charCount;
                const itemEnd = charCount + itemText.length;

                // Check if this text item overlaps with the address match
                if (itemEnd > matchStart && itemStart < matchEnd) {
                  const fontSize = item.fontSize || item.height || item.transform?.[0] || 12;
                  fontSizes.push(fontSize);
                }

                charCount = itemEnd + 1; // +1 for space
              }

              if (fontSizes.length > 0) {
                // Use average font size, but weight towards max (larger text is more important)
                avgFontSize = fontSizes.reduce((a, b) => a + b, 0) / fontSizes.length;
                maxFontSize = Math.max(...fontSizes);
                // Use max font size as primary metric (largest text wins)
                avgFontSize = maxFontSize;
              }
            }

            addressMatches.push({
              match: fullMatch,
              cleaned,
              position: match.index,
              isComplete,
              priority,
              fontSize: avgFontSize,
              maxFontSize: maxFontSize,
            });
          }
        }
      });

      if (addressMatches.length === 0) {
        return { address: null, remainingText: text };
      }

      // Sort by: 1) Font size (larger first), 2) completeness (complete first), 3) position (earlier first), 4) priority
      addressMatches.sort((a, b) => {
        // Font size is primary - larger fonts win (project address is typically larger)
        if (Math.abs(a.fontSize - b.fontSize) > 0.5) {
          // Only compare if significantly different (>0.5pt)
          return b.fontSize - a.fontSize; // Larger font size first
        }
        // If font sizes are similar, complete addresses win
        if (a.isComplete !== b.isComplete) {
          return a.isComplete ? -1 : 1;
        }
        // Among same completeness, earlier position wins
        if (a.position !== b.position) {
          return a.position - b.position;
        }
        // Among same position, lower priority number wins
        return a.priority - b.priority;
      });

      const bestAddress = addressMatches[0];

      // Remove the found address from text (use original match to preserve exact formatting)
      const remainingText = text.replace(bestAddress.match, " ").replace(/\s+/g, " ").trim();

      console.log(
        `üìç [SCANNER-ADDRESS] Found address at position ${bestAddress.position}, font size: ${bestAddress.fontSize.toFixed(1)}pt, complete: ${bestAddress.isComplete}, removed from text`
      );

      return {
        address: bestAddress.cleaned,
        remainingText,
      };
    }

    /**
     * Extract fields from text with font size information (for scanner tab)
     * Uses font size to prioritize addresses
     */
    extractFieldsFromTextWithFontInfo(text, textItems = null) {
      const fields = [];

      // ===== PROJECT ADDRESS (FIRST PRIORITY) =====
      // Extract address first with font size info, then remove it from text for other field extraction
      const { address, remainingText } = this.extractBestAddress(text, textItems);
      const textForOtherFields = remainingText; // Use text without address for other extractions

      if (address) {
        fields.push({ name: "Address", type: "address", value: address });
        console.log(`üìç [SCANNER] Extracted address: ${address.substring(0, 50)}...`);
      }

      // Continue with other field extraction...
      return this.extractOtherFields(textForOtherFields, fields);
    }

    /**
     * Fix word breaks caused by line splits in PDF text extraction
     * Handles cases like "istroy" -> "history", "heet" -> "sheet", etc.
     */
    fixWordBreaks(text) {
      // Common word patterns that get broken
      const wordFixes = {
        // Common broken words
        istroy: "history",
        heet: "sheet",
        ame: "name",
        nformation: "information",
        rawing: "drawing",
        orth: "north",
        outh: "south",
        ast: "east",
        est: "west",
        uilding: "building",
        onstruction: "construction",
        lassification: "classification",
        istrict: "district",
        ubdistrict: "subdistrict",
        roposed: "proposed",
        xisting: "existing",
        ermeable: "permeable",
        arking: "parking",
        verage: "coverage",
        eight: "height",
        epth: "depth",
        idth: "width",
        late: "plate",
        rea: "area",
        ard: "yard",
        escription: "description",
      };

      // Fix broken words at word boundaries
      let fixedText = text;

      // First, try to fix common broken word patterns
      Object.keys(wordFixes).forEach((broken, correct) => {
        // Look for broken word at start of word or after space
        const regex = new RegExp(`(^|\\s|\\b)${broken}\\b`, "gi");
        fixedText = fixedText.replace(regex, (match, prefix) => {
          return prefix + correct;
        });
      });

      // Also fix common patterns where letters are split
      // Pattern: single letter followed by lowercase word (likely a break)
      // e.g., "h istory" -> "history", "s heet" -> "sheet"
      fixedText = fixedText.replace(/\b([a-z])\s+([a-z]{2,})\b/gi, (match, letter, rest) => {
        // Check if letter + rest forms a common word
        const combined = letter + rest;
        const commonWords = [
          "history",
          "sheet",
          "name",
          "information",
          "drawing",
          "north",
          "south",
          "east",
          "west",
          "building",
          "construction",
          "classification",
          "district",
          "subdistrict",
          "proposed",
          "existing",
          "permeable",
          "parking",
          "coverage",
          "height",
          "depth",
          "width",
          "plate",
          "area",
          "yard",
          "description",
          "story",
          "stories",
          "type",
          "group",
          "use",
          "lot",
          "parcel",
          "front",
          "side",
          "rear",
          "minimum",
          "maximum",
          "gross",
          "floor",
          "total",
        ];

        if (commonWords.includes(combined.toLowerCase())) {
          return combined;
        }
        return match; // Keep original if not a known word
      });

      // Fix double spaces
      fixedText = fixedText.replace(/\s+/g, " ");

      return fixedText;
    }

    /**
     * Extract other fields (non-address) from text
     */
    extractOtherFields(text, fields = []) {
      // Email pattern
      const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
      const emails = text.match(emailRegex);
      if (emails) {
        emails.forEach((email) => {
          fields.push({ name: "Email", type: "email", value: email });
        });
      }

      // Enhanced phone patterns
      const phonePatterns = [
        /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g, // US format
        /(\+\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g, // International
        /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, // Simple format
        /\(\d{3}\)\s?\d{3}[-.\s]?\d{4}/g, // (123) 456-7890
      ];

      phonePatterns.forEach((pattern) => {
        const phones = text.match(pattern);
        if (phones) {
          phones.forEach((phone) => {
            if (!fields.some((f) => f.type === "phone" && f.value === phone)) {
              fields.push({ name: "Phone", type: "phone", value: phone });
            }
          });
        }
      });

      // Enhanced date patterns
      const datePatterns = [
        /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g, // MM/DD/YYYY or DD/MM/YYYY
        /\b\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b/gi, // DD Month YYYY
        /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi, // Month DD, YYYY
        /\b\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2}\b/g, // YYYY-MM-DD
        /\b\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi, // Full month names
      ];

      datePatterns.forEach((pattern) => {
        const dates = text.match(pattern);
        if (dates) {
          dates.forEach((date) => {
            if (!fields.some((f) => f.type === "date" && f.value === date)) {
              fields.push({ name: "Date", type: "date", value: date });
            }
          });
        }
      });

      // ZIP/Postal codes
      const zipRegex = /\b\d{5}(?:-\d{4})?\b/g;
      const zips = text.match(zipRegex);
      if (zips) {
        zips.forEach((zip) => {
          if (!fields.some((f) => f.type === "zip" && f.value === zip)) {
            fields.push({ name: "ZIP Code", type: "zip", value: zip });
          }
        });
      }

      // ===== BUILDING USE GROUP =====
      // Reusable function for extracting fields with specific allowed values
      // Always adds the field, even if no value found (makes it editable)
      const extractFieldWithValues = (
        fieldName,
        fieldType,
        allowedValues,
        text,
        alwaysShow = true
      ) => {
        const foundValues = [];

        allowedValues.forEach((value) => {
          // Look for exact matches (case-insensitive) with word boundaries
          // Handle multi-word values by allowing flexible whitespace
          // Handle hyphens by using word boundaries that work with hyphens
          const escapedValue = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // Escape special regex chars
          // Replace hyphens with a pattern that allows word boundaries on either side
          const patternValue = escapedValue.replace(/\s+/g, "\\s+").replace(/-/g, "-?");
          // Use word boundaries, but allow hyphens to be part of the word
          const regex = new RegExp(`(?:^|\\s|[^\\w-])${patternValue}(?:$|\\s|[^\\w-])`, "gi");
          if (regex.test(text)) {
            foundValues.push(value);
          }
        });

        if (foundValues.length > 0) {
          // If multiple found, return array; otherwise single value
          const value = foundValues.length === 1 ? foundValues[0] : foundValues;
          fields.push({
            name: fieldName,
            type: fieldType,
            value: value,
            editable: false, // Has a value, not editable
          });
        } else if (alwaysShow) {
          // No value found, but always show this field type (makes it editable)
          fields.push({
            name: fieldName,
            type: fieldType,
            value: "", // Empty value
            editable: true, // No value found, make it editable
            allowedValues: allowedValues, // Store allowed values for dropdown/validation
          });
        }
      };

      // Extract Building use group (always show, editable if not found)
      extractFieldWithValues(
        "Building use group",
        "building_use_group",
        ["Residential", "Lodging House", "Commercial", "Warehouse"],
        text,
        true // alwaysShow = true
      );

      // Extract Construction Type (always show, editable if not found)
      extractFieldWithValues(
        "Construction Type",
        "construction_type",
        ["Type V-A", "Type IV-B", "Type V-B", "Type IV-A"],
        text,
        true // alwaysShow = true
      );

      // ===== KEY-VALUE PAIR EXTRACTION =====
      // Extract all labeled fields (Key: Value pattern)
      // This catches fields like "Construction Use Group: R-2", "Stories: 3", "ADDRESS: 5 Swift Terrace", etc.

      // Common field names to look for (case-insensitive)
      const commonFieldNames = [
        "Construction Use Group",
        "Construction Classification",
        "Stories",
        "Zoning District",
        "Zoning Subdistrict",
        "Existing Use",
        "Proposed Use",
        "Lot Area",
        "Parcel Number",
        "Building Height",
        "Building Width",
        "Building Depth",
        "Floor Plate",
        "Gross Floor Area",
        "Permeable Area",
        "Front Yard",
        "Side Yard",
        "Rear Yard",
        "Parking Spaces",
        "Off-Street Parking",
        "Project Description",
        "Address",
        "ADDRESS",
        "Maximum Building Height",
        "Maximum Building Lot Coverage",
        "Max Building Width",
        "Max Building Depth",
        "Maximum Building Floor Plate",
        "Maximum Total Gross Floor Area",
        "Minimum Permeable Area",
        "Min Side Yard",
        "Min Rear Yard",
        "Off-Street Parking Space",
      ];

      // Extract key-value pairs using multiple patterns
      const extractedKeyValues = new Map();

      // Pattern 1: "KEY: value" (most common format)
      const colonPattern =
        /([A-Z][A-Za-z\s&\/\-]+?)[:\s]+([^\n\r]{1,200}?)(?=\n|$|(?=[A-Z][A-Za-z\s&]+?:))/g;
      let match;
      while ((match = colonPattern.exec(text)) !== null) {
        const key = match[1]?.trim();
        let value = match[2]?.trim();

        // Clean up value (remove trailing punctuation that might be part of next field)
        value = value.replace(/[,\s]+$/, "").trim();

        if (key && value && key.length >= 2 && value.length > 0 && value.length < 200) {
          // Normalize key
          const normalizedKey = key.replace(/\s+/g, " ").trim();

          // Check if this is a relevant field
          const isRelevantField = commonFieldNames.some((fieldName) => {
            const keyLower = normalizedKey.toLowerCase();
            const fieldLower = fieldName.toLowerCase();
            return (
              keyLower === fieldLower ||
              keyLower.includes(fieldLower) ||
              fieldLower.includes(keyLower) ||
              keyLower.replace(/\s+/g, "") === fieldLower.replace(/\s+/g, "")
            );
          });

          // Also extract if key is all caps (like "ADDRESS", "ZONING DISTRICT")
          const isAllCapsField =
            normalizedKey === normalizedKey.toUpperCase() &&
            normalizedKey.length >= 3 &&
            normalizedKey.length <= 50;

          // Extract if it looks like a field (starts with common prefixes)
          const looksLikeField =
            /^(Construction|Zoning|Building|Lot|Parcel|Use|Area|Yard|Parking|Stories|Address|Maximum|Max|Minimum|Min|Existing|Proposed|Project|Off-Street)/i.test(
              normalizedKey
            );

          if (isRelevantField || isAllCapsField || looksLikeField) {
            // Don't overwrite if we already have a better (longer) match
            const existingValue = extractedKeyValues.get(normalizedKey);
            if (!existingValue || existingValue.length < value.length) {
              extractedKeyValues.set(normalizedKey, value);
            }
          }
        }
      }

      // Add extracted key-value pairs as fields
      extractedKeyValues.forEach((value, key) => {
        // Skip if we already have this as a specific field type
        const existingField = fields.find((f) => {
          const fName = f.name?.toLowerCase() || "";
          const keyLower = key.toLowerCase();
          return (
            fName === keyLower ||
            (f.type === "address" && keyLower.includes("address")) ||
            (f.type === "building_use_group" &&
              (keyLower.includes("use group") || keyLower.includes("construction use"))) ||
            (f.type === "construction_type" && keyLower.includes("construction classification"))
          );
        });

        if (!existingField) {
          fields.push({
            name: key,
            type: "key_value",
            value: value,
            editable: false,
          });
        }
      });

      // Names (simple pattern - capitalized words that might be names)
      // const nameRegex = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
      // const names = text.match(nameRegex);
      // if (names) {
      //   names.forEach((name) => {
      //     // Filter out common false positives
      //     const commonWords = [
      //       "The",
      //       "This",
      //       "That",
      //       "There",
      //       "Here",
      //       "Where",
      //       "When",
      //       "What",
      //       "How",
      //       "Why",
      //       "Who",
      //       "Which",
      //     ];
      //     if (!commonWords.some((word) => name.includes(word))) {
      //       if (!fields.some((f) => f.type === "name" && f.value === name)) {
      //         fields.push({ name: "Name", type: "name", value: name });
      //       }
      //     }
      //   });
      // }

      // URLs
      const urlRegex = /https?:\/\/[^\s]+/g;
      const urls = text.match(urlRegex);
      if (urls) {
        urls.forEach((url) => {
          fields.push({ name: "URL", type: "url", value: url });
        });
      }

      // Money amounts
      const moneyRegex = /\$[\d,]+(?:\.\d{2})?/g;
      const amounts = text.match(moneyRegex);
      if (amounts) {
        amounts.forEach((amount) => {
          fields.push({ name: "Amount", type: "money", value: amount });
        });
      }

      // Social Security Numbers
      const ssnRegex = /\b\d{3}-?\d{2}-?\d{4}\b/g;
      const ssns = text.match(ssnRegex);
      if (ssns) {
        ssns.forEach((ssn) => {
          fields.push({ name: "SSN", type: "ssn", value: ssn });
        });
      }

      return fields;
    }

    /**
     * Extract fields from text (fallback for when font info not available)
     */
    extractFieldsFromText(text) {
      const fields = [];

      // ===== PROJECT ADDRESS (FIRST PRIORITY) =====
      // Extract address first, then remove it from text for other field extraction
      const { address, remainingText } = this.extractBestAddress(text);
      const textForOtherFields = remainingText; // Use text without address for other extractions

      if (address) {
        fields.push({ name: "Address", type: "address", value: address });
        console.log(`üìç [SCANNER] Extracted address: ${address.substring(0, 50)}...`);
      }

      // Continue with other field extraction...
      return this.extractOtherFields(textForOtherFields, fields);
    }

    replaceFieldsWithPlaceholders(text) {
      let result = text;
      const detectedFields = [];
      const counters = {
        date: 0,
        phone: 0,
        address: 0,
        name: 0,
        email: 0,
        number: 0,
      };
      // Track unique values to reuse placeholders
      const valueToPlaceholder = {
        date: new Map(),
        phone: new Map(),
        address: new Map(),
        name: new Map(),
        email: new Map(),
        number: new Map(),
      };

      // Replace dates with {{DATE_1}}, {{DATE_2}}, etc.
      const datePatterns = [
        /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g, // MM/DD/YYYY or DD/MM/YYYY
        /\b\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b/gi, // DD Month YYYY
        /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi, // Month DD, YYYY
        /\b\d{4}[-.\/]\d{1,2}[-.\/]\d{1,2}\b/g, // YYYY-MM-DD
        /\b\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi, // Full month names
      ];

      datePatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.date.has(match)) {
            return valueToPlaceholder.date.get(match);
          }

          // New unique value
          counters.date++;
          const placeholder = `{{DATE_${counters.date}}}`;
          valueToPlaceholder.date.set(match, placeholder);
          detectedFields.push({
            name: `DATE_${counters.date}`,
            type: "date",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace phone numbers with {{PHONE_1}}, {{PHONE_2}}, etc.
      const phonePatterns = [
        /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g, // US format
        /(\+\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g, // International
        /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, // Simple format
        /\(\d{3}\)\s?\d{3}[-.\s]?\d{4}/g, // (123) 456-7890
      ];

      phonePatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.phone.has(match)) {
            return valueToPlaceholder.phone.get(match);
          }

          // New unique value
          counters.phone++;
          const placeholder = `{{PHONE_${counters.phone}}}`;
          valueToPlaceholder.phone.set(match, placeholder);
          detectedFields.push({
            name: `PHONE_${counters.phone}`,
            type: "phone",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace addresses with {{ADDRESS_1}}, {{ADDRESS_2}}, etc.
      // Use best address extraction to get the primary address first
      const { address: bestAddress } = this.extractBestAddress(result);

      // Address patterns (for template generation, we may want multiple addresses)
      const addressPatterns = [
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)[\s,]*[A-Za-z\s]*,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/gi, // With city, state, zip (complete addresses first)
        /\b\d+\s+[A-Za-z0-9\s,.-]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln|Way|Place|Pl|Court|Ct|Circle|Cir)\b/gi, // Incomplete addresses
        /\b[A-Za-z\s]+,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?\b/g, // City, State ZIP
      ];

      addressPatterns.forEach((pattern) => {
        result = result.replace(pattern, (match) => {
          // Check if we've seen this value before
          if (valueToPlaceholder.address.has(match)) {
            return valueToPlaceholder.address.get(match);
          }

          // New unique value
          counters.address++;
          const placeholder = `{{ADDRESS_${counters.address}}}`;
          valueToPlaceholder.address.set(match, placeholder);
          detectedFields.push({
            name: `ADDRESS_${counters.address}`,
            type: "address",
            value: match.trim(),
            placeholder: placeholder,
          });
          return placeholder;
        });
      });

      // Replace names with {{NAME_1}}, {{NAME_2}}, etc.
      const nameRegex = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
      const commonWords = [
        "The",
        "This",
        "That",
        "There",
        "Here",
        "Where",
        "When",
        "What",
        "How",
        "Why",
        "Who",
        "Which",
      ];

      result = result.replace(nameRegex, (match) => {
        // Filter out common false positives
        if (!commonWords.some((word) => match.includes(word))) {
          // Check if we've seen this value before
          if (valueToPlaceholder.name.has(match)) {
            return valueToPlaceholder.name.get(match);
          }

          // New unique value
          counters.name++;
          const placeholder = `{{NAME_${counters.name}}}`;
          valueToPlaceholder.name.set(match, placeholder);
          detectedFields.push({
            name: `NAME_${counters.name}`,
            type: "name",
            value: match,
            placeholder: placeholder,
          });
          return placeholder;
        }
        return match;
      });

      // Replace emails with {{EMAIL_1}}, {{EMAIL_2}}, etc.
      const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
      result = result.replace(emailRegex, (match) => {
        // Check if we've seen this value before
        if (valueToPlaceholder.email.has(match)) {
          return valueToPlaceholder.email.get(match);
        }

        // New unique value
        counters.email++;
        const placeholder = `{{EMAIL_${counters.email}}}`;
        valueToPlaceholder.email.set(match, placeholder);
        detectedFields.push({
          name: `EMAIL_${counters.email}`,
          type: "email",
          value: match,
          placeholder: placeholder,
        });
        return placeholder;
      });

      // Replace money amounts with {{NUMBER_1}}, {{NUMBER_2}}, etc.
      const moneyRegex = /\$[\d,]+(?:\.\d{2})?/g;
      result = result.replace(moneyRegex, (match) => {
        // Check if we've seen this value before
        if (valueToPlaceholder.number.has(match)) {
          return valueToPlaceholder.number.get(match);
        }

        // New unique value
        counters.number++;
        const placeholder = `{{NUMBER_${counters.number}}}`;
        valueToPlaceholder.number.set(match, placeholder);
        detectedFields.push({
          name: `NUMBER_${counters.number}`,
          type: "number",
          value: match,
          placeholder: placeholder,
        });
        return placeholder;
      });

      // Store the detected fields for later use
      this.detectedFieldsMappings = detectedFields;

      return result;
    }

    displayExtractedFields(fields) {
      const container = document.getElementById("extracted-fields");
      const fieldsList = document.getElementById("fields-list");

      // Use the detected field mappings from replaceFieldsWithPlaceholders
      // This ensures the placeholders match what's actually in the document
      const fieldsToDisplay = this.detectedFieldsMappings || fields;

      // Add unique IDs and tracking info to fields
      this.trackedFields = fieldsToDisplay.map((field, index) => ({
        id: `field_${Date.now()}_${index}`,
        name: field.name,
        type: field.type,
        value: field.value,
        originalText: field.value,
        placeholder: field.placeholder || `{{${field.name}}}`,
        isReplaced: true, // Assuming fields are already replaced in the text
        isVisible: true, // User can toggle visibility
        position: null, // Will be updated when we find it in the document
      }));

      console.log("üîç [PDF-SYSTEM] Tracked fields:", this.trackedFields);

      if (container && fieldsList) {
        container.classList.remove("hidden");
        fieldsList.innerHTML = this.trackedFields
          .map(
            (field) => `
          <div class="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-600 rounded-md gap-3 hover:bg-gray-100 dark:hover:bg-gray-500 transition-colors" 
               data-field-id="${field.id}">
            <div class="flex-1">
              <div class="flex items-center gap-2">
                <span class="font-medium text-gray-900 dark:text-white">${field.name}</span>
                <span class="text-xs text-gray-500 dark:text-gray-400">(${field.type})</span>
              </div>
              <div class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-xs text-gray-500 dark:text-gray-400">Original:</span>
                  <span class="font-mono text-xs">${field.value}</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">${field.placeholder}</span>
                </div>
              </div>
            </div>
            </div>
            <div class="flex items-center gap-2">
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.revertField(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-yellow-500 hover:bg-yellow-600 text-white rounded transition-colors"
                title="Toggle between original text and placeholder, then locate in document"
              >
                Show Original
              </button>
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.toggleFieldVisibility(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-primary-500 hover:bg-primary-600 text-white rounded transition-colors"
                title="Show/hide in document"
              >
                ${field.isVisible ? "Hide" : "Show"}
              </button>
              <button 
                onclick='event.stopPropagation(); window.pdfSystem.removeField(${JSON.stringify(field.id)})'
                class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition-colors"
                title="Remove this field detection"
              >
                Remove
              </button>
            </div>
          
        `
          )
          .join("");
      }
    }

    // Helper function to find which editor contains the field
    findEditorForField(field) {
      // First check the main editor
      if (this.editor) {
        const mainEditorText = this.editor.getText();
        const searchText = field.isReplaced ? field.placeholder : field.originalText;
        if (mainEditorText.indexOf(searchText) !== -1) {
          return this.editor;
        }
      }

      // Check all template-specific editors
      if (this.templateEditors) {
        for (const [templateId, editor] of Object.entries(this.templateEditors)) {
          if (editor) {
            try {
              const editorText = editor.getText();
              const searchText = field.isReplaced ? field.placeholder : field.originalText;
              if (editorText.indexOf(searchText) !== -1) {
                console.log(`‚úÖ [PDF-SYSTEM] Found field in template editor ${templateId}`);
                return editor;
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è [PDF-SYSTEM] Error checking template editor ${templateId}:`, error);
            }
          }
        }
      }

      // Fallback to main editor if available
      return this.editor || null;
    }

    scrollToField(fieldId) {
      return new Promise((resolve, reject) => {
        const field = this.trackedFields.find((f) => f.id === fieldId);
        if (!field) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Field not found:", fieldId);
          reject(new Error("Field not found"));
          return;
        }

        console.log(
          "üìç [PDF-SYSTEM] Scrolling to field:",
          field.name,
          "isReplaced:",
          field.isReplaced
        );

        // Find the correct editor that contains this field
        const editor = this.findEditorForField(field);
        if (!editor) {
          console.error("‚ùå [PDF-SYSTEM] Editor not found for field");
          reject(new Error("Editor not initialized"));
          return;
        }

        // Get the Quill editor's text content to find the position
        const text = editor.getText();
        // Search for what's currently in the document: placeholder if replaced, original text if not
        const searchText = field.isReplaced ? field.placeholder : field.originalText;
        const textIndex = text.indexOf(searchText);

        console.log("üîç [PDF-SYSTEM] Searching for:", searchText.substring(0, 50));
        console.log("üîç [PDF-SYSTEM] Text index:", textIndex, "Text length:", text.length);

        if (textIndex === -1) {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Search text not found in document:", searchText);
          console.log("üìÑ [PDF-SYSTEM] Editor text (first 500 chars):", text.substring(0, 500));
          reject(new Error(`Text not found: ${searchText.substring(0, 50)}...`));
          return;
        }

        try {
          // Focus the editor first
          editor.focus();

          // Get the bounds of the selection first (before setting selection)
          const searchTextLength = searchText.length;
          const bounds = editor.getBounds(textIndex, searchTextLength);

          if (!bounds) {
            reject(new Error("Could not get bounds"));
            return;
          }

          console.log("üìê [PDF-SYSTEM] Bounds:", bounds);

          // Get the Quill editor's scrolling element (.ql-editor)
          const editorScrollContainer = editor.root.parentElement.querySelector(".ql-editor");

          if (editorScrollContainer) {
            // Calculate the target scroll position - center the selection
            const containerHeight = editorScrollContainer.clientHeight;
            const targetScrollTop = Math.max(
              0,
              bounds.top - containerHeight / 2 + bounds.height / 2
            );

            console.log("üìú [PDF-SYSTEM] Scrolling container:", {
              currentScroll: editorScrollContainer.scrollTop,
              targetScroll: targetScrollTop,
              boundsTop: bounds.top,
              boundsHeight: bounds.height,
              containerHeight: containerHeight,
            });

            // Wait for scroll to complete before setting selection/highlight
            const scrollDistance = Math.abs(editorScrollContainer.scrollTop - targetScrollTop);
            const estimatedScrollTime = Math.min(2000, scrollDistance / 2); // Max 2 seconds, roughly 0.5px per ms

            // Scroll the editor to show the selection smoothly
            editorScrollContainer.scrollTo({
              top: targetScrollTop,
              behavior: "smooth",
            });

            // Wait for scroll animation to complete
            let lastScrollTop = editorScrollContainer.scrollTop;
            let scrollCheckInterval;
            let scrollTimeout;

            const checkScrollComplete = () => {
              const currentScrollTop = editorScrollContainer.scrollTop;
              const isScrolling = Math.abs(currentScrollTop - lastScrollTop) > 1;

              if (isScrolling) {
                lastScrollTop = currentScrollTop;
              } else {
                // Scroll has stopped
                clearInterval(scrollCheckInterval);
                clearTimeout(scrollTimeout);

                console.log("‚úÖ [PDF-SYSTEM] Scroll completed, setting selection");

                // Set selection after scroll completes
                const searchTextLength = searchText.length;
                editor.setSelection(textIndex, searchTextLength);
                console.log(
                  "‚úÖ [PDF-SYSTEM] Selection set at index:",
                  textIndex,
                  "length:",
                  searchTextLength
                );

                // Apply highlight
                this.applyFieldHighlight(textIndex, searchTextLength, editor);
                console.log("‚úÖ [PDF-SYSTEM] Applied highlight");

                resolve();
              }
            };

            // Start checking scroll progress after a short delay
            setTimeout(() => {
              scrollCheckInterval = setInterval(checkScrollComplete, 50);
              // Fallback timeout in case scroll never "completes" (stuck)
              scrollTimeout = setTimeout(() => {
                clearInterval(scrollCheckInterval);
                console.log("‚è±Ô∏è [PDF-SYSTEM] Scroll timeout, applying selection anyway");
                const searchTextLength = searchText.length;
                editor.setSelection(textIndex, searchTextLength);
                this.applyFieldHighlight(textIndex, searchTextLength, editor);
                resolve();
              }, estimatedScrollTime + 500);
            }, 100);
          } else {
            // Fallback: scroll the root element
            const scrollTop = Math.max(0, bounds.top - editor.root.clientHeight / 2);

            editor.root.scrollTo({
              top: scrollTop,
              behavior: "smooth",
            });

            // Wait for scroll to complete (fallback)
            setTimeout(() => {
              const searchTextLength = searchText.length;
              editor.setSelection(textIndex, searchTextLength);
              this.applyFieldHighlight(textIndex, searchTextLength, editor);
              resolve();
            }, 800); // Longer timeout for fallback
          }
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error scrolling to field:", error);
          reject(error);
        }
      });
    }

    applyFieldHighlight(textIndex, length, editor = null) {
      const targetEditor = editor || this.editor;
      if (!targetEditor) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] No editor available for highlight");
        return;
      }

      try {
        // Temporarily highlight the placeholder
        const originalFormat = targetEditor.getFormat(textIndex, length);
        targetEditor.formatText(textIndex, length, {
          background: "#ffeb3b",
          color: "#000",
        });

        console.log("üé® [PDF-SYSTEM] Applied highlight");

        // Remove highlight after 2 seconds
        setTimeout(() => {
          targetEditor.formatText(textIndex, length, originalFormat);
          console.log("üé® [PDF-SYSTEM] Removed highlight");
        }, 2000);
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error applying highlight:", error);
      }
    }

    revertField(fieldId) {
      const field = this.trackedFields.find((f) => f.id === fieldId);
      if (!field) return;

      console.log("üîÑ [PDF-SYSTEM] Toggling field:", field.name, "isReplaced:", field.isReplaced);

      // Find the correct editor that contains this field
      const editor = this.findEditorForField(field);
      if (!editor) {
        console.error("‚ùå [PDF-SYSTEM] Could not find editor for field");
        return;
      }

      // Get current editor content
      const content = editor.root.innerHTML;
      let updatedContent;

      if (field.isReplaced) {
        // Currently showing placeholder, switch to original text
        updatedContent = content.replace(new RegExp(`{{${field.name}}}`, "g"), field.originalText);
        field.isReplaced = false;
        console.log("‚úÖ [PDF-SYSTEM] Field switched to original text");
      } else {
        // Currently showing original text, switch to placeholder
        updatedContent = content.replace(
          new RegExp(field.originalText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
          `{{${field.name}}}`
        );
        field.isReplaced = true;
        console.log("‚úÖ [PDF-SYSTEM] Field switched to placeholder");
      }

      // Update editor
      const delta = editor.clipboard.convert(updatedContent);
      editor.setContents(delta);

      // Update button text to reflect current state
      this.updateRevertButton(fieldId, field.isReplaced);

      // After toggling, locate the field in the document - wait longer for editor to update
      // Quill needs time to update its internal text representation after setContents
      setTimeout(async () => {
        try {
          // Wait a bit more to ensure editor text is fully updated
          await new Promise((resolve) => setTimeout(resolve, 200));

          console.log("üîÑ [PDF-SYSTEM] Attempting to scroll after field revert");
          await this.scrollToField(fieldId);
          console.log("‚úÖ [PDF-SYSTEM] Field revert complete with scroll");
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error scrolling to field after revert:", error);
          // Try one more time with original text search if placeholder search failed
          const field = this.trackedFields.find((f) => f.id === fieldId);
          if (field) {
            // Find the correct editor again (in case it changed)
            const retryEditor = this.findEditorForField(field);
            if (!retryEditor) {
              console.error("‚ùå [PDF-SYSTEM] Could not find editor for retry");
              return;
            }

            console.log("üîÑ [PDF-SYSTEM] Retrying with alternative search...");
            // Try searching for the opposite (what we just switched to)
            const text = retryEditor.getText();
            const alternativeSearch = field.isReplaced ? field.originalText : field.placeholder;
            const altIndex = text.indexOf(alternativeSearch);
            if (altIndex !== -1) {
              console.log("‚úÖ [PDF-SYSTEM] Found text with alternative search, scrolling...");
              // Force a direct scroll to the found text
              try {
                const bounds = retryEditor.getBounds(altIndex, alternativeSearch.length);
                if (bounds) {
                  const editorScrollContainer =
                    retryEditor.root.parentElement.querySelector(".ql-editor");
                  if (editorScrollContainer) {
                    const containerHeight = editorScrollContainer.clientHeight;
                    const targetScrollTop = Math.max(
                      0,
                      bounds.top - containerHeight / 2 + bounds.height / 2
                    );
                    editorScrollContainer.scrollTo({ top: targetScrollTop, behavior: "smooth" });
                    setTimeout(() => {
                      retryEditor.setSelection(altIndex, alternativeSearch.length);
                      this.applyFieldHighlight(altIndex, alternativeSearch.length, retryEditor);
                    }, 800);
                  }
                }
              } catch (retryError) {
                console.error("‚ùå [PDF-SYSTEM] Retry also failed:", retryError);
              }
            }
          }
        }
      }, 300); // Increased delay to ensure editor is updated
    }

    updateRevertButton(fieldId, isReplaced) {
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        const revertButton = fieldElement.querySelector(
          "button[title*='Toggle between original text and placeholder']"
        );
        if (revertButton) {
          revertButton.textContent = isReplaced ? "Show Original" : "Show Placeholder";
          revertButton.title = isReplaced
            ? "Show original text and locate in document"
            : "Show placeholder text and locate in document";
        }
      }
    }

    toggleFieldVisibility(fieldId) {
      const field = this.trackedFields.find((f) => f.id === fieldId);
      if (!field) return;

      field.isVisible = !field.isVisible;

      // Update the UI button
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        const button = fieldElement.querySelector("button:nth-child(2)");
        if (button) {
          button.textContent = field.isVisible ? "Hide" : "Show";
        }
      }

      // Get current editor content
      const content = this.editor.root.innerHTML;

      if (field.isVisible) {
        // Show the field (replace with placeholder)
        const updatedContent = content.replace(
          new RegExp(field.originalText, "g"),
          `{{${field.name}}}`
        );
        const delta = this.editor.clipboard.convert(updatedContent);
        this.editor.setContents(delta);
      } else {
        // Hide the field (replace with empty or original)
        const updatedContent = content.replace(
          new RegExp(`{{${field.name}}}`, "g"),
          field.originalText
        );
        const delta = this.editor.clipboard.convert(updatedContent);
        this.editor.setContents(delta);
      }

      console.log(
        `${field.isVisible ? "üëÅÔ∏è" : "üôà"} [PDF-SYSTEM] Field visibility toggled:`,
        field.name
      );
    }

    removeField(fieldId) {
      const fieldIndex = this.trackedFields.findIndex((f) => f.id === fieldId);
      if (fieldIndex === -1) return;

      const field = this.trackedFields[fieldIndex];
      console.log("üóëÔ∏è [PDF-SYSTEM] Removing field:", field.name);

      // Revert the field before removing
      this.revertField(fieldId);

      // Remove from tracked fields
      this.trackedFields.splice(fieldIndex, 1);

      // Remove from UI
      const fieldElement = document.querySelector(`[data-field-id="${fieldId}"]`);
      if (fieldElement) {
        fieldElement.remove();
      }

      console.log("‚úÖ [PDF-SYSTEM] Field removed");
    }

    async saveTemplate() {
      // Get name directly from DOM (in case templateNameInput wasn't initialized)
      // Try multiple possible IDs: template-name, template-name-${id} for inline editing
      let nameInput = this.templateNameInput;

      if (!nameInput) {
        // Try the main editor input first
        nameInput = document.getElementById("template-name");

        // If not found and we have a selected template, try the dynamic ID
        if (!nameInput && this.selectedTemplate) {
          nameInput = document.getElementById(`template-name-${this.selectedTemplate}`);
        }

        // Also try to find any template-name-* input if we're in an accordion context
        if (!nameInput) {
          const allNameInputs = document.querySelectorAll('[id^="template-name-"]');
          if (allNameInputs.length > 0) {
            // Find the one that's visible (not in a hidden accordion)
            nameInput =
              Array.from(allNameInputs).find(
                (input) => input.offsetParent !== null // Check if element is visible
              ) || allNameInputs[0]; // Fallback to first one
          }
        }
      }

      const name = nameInput?.value?.trim() || "";

      // Get type select - also try dynamic ID
      let typeSelect = this.templateTypeSelect;
      if (!typeSelect) {
        typeSelect = document.getElementById("template-type");
        if (!typeSelect && this.selectedTemplate) {
          typeSelect = document.getElementById(`template-type-${this.selectedTemplate}`);
        }
      }
      const type = typeSelect?.value || "body";

      const content = this.editor
        ? this.editor.root.innerHTML
        : document.getElementById("template-content-textarea")?.value || "";

      // Helper function to check if HTML content is empty (only whitespace/empty tags)
      const isContentEmpty = (html) => {
        if (!html || !html.trim()) return true;
        // Remove HTML tags and check if only whitespace remains
        const textContent = html.replace(/<[^>]*>/g, "").trim();
        // Also check for common empty Quill patterns like <p><br></p> or <p></p>
        const emptyPatterns = /^(<p><br><\/p>|<p><\/p>|<br\s*\/?>|\s*)*$/i;
        return !textContent || emptyPatterns.test(html);
      };

      const saveHtmlCheckbox = document.getElementById("save-html-template-checkbox");
      const saveHtml =
        saveHtmlCheckbox && saveHtmlCheckbox instanceof HTMLInputElement
          ? saveHtmlCheckbox.checked
          : false;

      // Debug logging
      console.log(
        "üíæ [PDF-SYSTEM] Saving template - Name:",
        name,
        "Content length:",
        content?.length || 0
      );

      // Improved validation with specific error messages
      if (!name) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] Validation failed: Template name is empty");
        this.showNotification("Please enter a template name", "error");
        return;
      }

      if (isContentEmpty(content)) {
        console.warn("‚ö†Ô∏è [PDF-SYSTEM] Validation failed: Template content is empty");
        this.showNotification("Please add content to the template", "error");
        return;
      }

      try {
        const response = await fetch("/api/pdf/templates/upsert", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            id: this.selectedTemplate,
            name,
            description: "",
            content,
            templateType: type,
            pageSize: "8.5x11",
            saveHtml: saveHtml, // Include the checkbox value
          }),
        });

        const data = await response.json();
        if (data.success) {
          this.showNotification("Template saved successfully!", "success");
          this.closeTemplateEditor();
          await this.loadTemplates();
        } else {
          this.showNotification("Error saving template: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error saving template:", error);
        this.showNotification("Error saving template", "error");
      }
    }

    async loadTemplatesForGeneration() {
      // Load templates for the generate tab
      await this.loadTemplates();

      const select = document.getElementById("template-select");
      if (select) {
        select.innerHTML =
          '<option value="">Choose a template...</option>' +
          this.templates
            .map(
              (template) =>
                `<option value="${template.id}">${template.name} (${template.templateType})</option>`
            )
            .join("");

        // Set up template selection listener if not already set
        if (!select.dataset.listenerAttached) {
          select.addEventListener("change", (e) => {
            const templateId = e.target.value;
            this.selectedTemplate = templateId || null;

            if (this.selectedTemplate && this.selectedContactData) {
              this.updatePlaceholderMappingUI();

              // Check if both template and user are selected, trigger mapping workflow
              // Use setTimeout to ensure DOM and data are ready
              if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
                setTimeout(() => {
                  this.startPlaceholderMappingWorkflow();
                }, 100);
              }
            } else {
              this.hidePlaceholderMappingUI();
            }
          });
          select.dataset.listenerAttached = "true";
        }
      }
    }

    async searchUsers() {
      const query = document.getElementById("user-search")?.value;
      if (!query) {
        this.showNotification("Please enter a search term", "error");
        return;
      }

      try {
        const response = await fetch("/api/users/search", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({ query }),
        });

        const data = await response.json();
        if (data.success) {
          this.users = data.data || [];
          this.renderUserResults();
        } else {
          this.showNotification("Error searching users: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error searching users:", error);
        this.showNotification("Error searching users", "error");
      }
    }

    setupUserInputWatcher() {
      // Watch for changes to the hidden input value from SlotMachineModalFunction
      // The hidden input has id="user-search-value" (component id + "-value")
      const hiddenInput = document.getElementById("user-search-value");

      if (!hiddenInput) {
        // Retry if input doesn't exist yet (component might not be initialized)
        setTimeout(() => this.setupUserInputWatcher(), 100);
        return;
      }

      // Store initial value to avoid triggering on page load
      const initialValue = hiddenInput.value || "";

      // Use MutationObserver to watch for value changes
      const observer = new MutationObserver(() => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's not the initial value on load
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Watch for changes to the value attribute
      observer.observe(hiddenInput, {
        attributes: true,
        attributeFilter: ["value"],
      });

      // Also watch for direct value property changes using input event
      hiddenInput.addEventListener("input", () => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's different from what we currently have
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Also watch for change events
      hiddenInput.addEventListener("change", () => {
        const value = hiddenInput.value;
        // Only trigger if value changed AND it's different from what we currently have
        if (value && value !== this.selectedUser && value !== initialValue) {
          this.selectUser(value);
        }
      });

      // Don't do initial check - only trigger on actual changes
      // The slot-select event will handle the initial selection

      console.log("‚úÖ [PDF-SYSTEM] User input watcher set up for user-search-value");
    }

    selectUser(userId) {
      this.selectedUser = userId;
      this.showNotification("User selected", "success");

      // Check if both template and user are selected, trigger mapping workflow
      // Use setTimeout to ensure DOM and data are ready
      if (this.selectedTemplate && this.selectedUser && this.selectedContactData) {
        setTimeout(() => {
          this.startPlaceholderMappingWorkflow();
        }, 100);
      }
    }

    async previewPDF() {
      if (!this.selectedTemplate || !this.selectedUser) {
        this.showNotification("Please select a template and user", "error");
        return;
      }

      // Open preview in new window
      const previewUrl = `/api/pdf/preview?templateId=${this.selectedTemplate}&userId=${this.selectedUser}`;
      window.open(previewUrl, "_blank");
    }

    // Extract all placeholders from template content
    extractPlaceholdersFromTemplate(template) {
      if (!template) return [];

      // Get content from template (could be HTML or plain text)
      let content = template.html_content || template.content || "";

      // If content is HTML, extract text content to find placeholders
      // Placeholders might be in HTML attributes or text nodes
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = content;

      // Get all text content including from HTML
      const textContent = tempDiv.textContent || tempDiv.innerText || content;

      // Also check the raw HTML for placeholders in attributes
      const fullContent = textContent + " " + content;

      // Match placeholders: {{PLACEHOLDER_NAME}}
      const placeholderRegex = /\{\{([^}]+)\}\}/g;
      const placeholders = new Set();
      let match;

      // Search in both text content and raw HTML
      while ((match = placeholderRegex.exec(fullContent)) !== null) {
        const placeholder = match[1].trim();
        // Skip empty placeholders
        if (placeholder) {
          placeholders.add(placeholder);
        }
      }

      return Array.from(placeholders);
    }

    // Start the interactive placeholder mapping workflow
    async startPlaceholderMappingWorkflow() {
      console.log("üéØ [PDF-SYSTEM] Starting placeholder mapping workflow");

      // Ensure templates are loaded
      if (!this.templates || this.templates.length === 0) {
        console.log("üîÑ [PDF-SYSTEM] Templates not loaded, loading now...");
        await this.loadTemplatesForGeneration();
      }

      // Find the selected template - try both string and number comparison
      let template = this.templates.find((t) => t.id === this.selectedTemplate);

      // If not found, try converting IDs to strings for comparison
      if (!template) {
        template = this.templates.find((t) => String(t.id) === String(this.selectedTemplate));
      }

      // If still not found, try loading template directly from API
      if (!template && this.selectedTemplate) {
        console.log("üîÑ [PDF-SYSTEM] Template not in cache, fetching from API...");
        try {
          const response = await fetch(`/api/pdf/templates/get?id=${this.selectedTemplate}`, {
            credentials: "include",
          });
          const data = await response.json();
          if (data.success && data.data && data.data.templates && data.data.templates.length > 0) {
            template = data.data.templates[0];
            // Add to templates array if not already there
            if (!this.templates.find((t) => String(t.id) === String(template.id))) {
              this.templates.push(template);
            }
          }
        } catch (error) {
          console.error("‚ùå [PDF-SYSTEM] Error fetching template:", error);
        }
      }

      if (!template) {
        console.error("‚ùå [PDF-SYSTEM] Template not found:", {
          selectedTemplate: this.selectedTemplate,
          templatesCount: this.templates?.length || 0,
          templateIds: this.templates?.map((t) => ({ id: t.id, type: typeof t.id })) || [],
        });
        this.showNotification(
          "Template not found. Please try selecting the template again.",
          "error"
        );
        return;
      }

      // Extract placeholders
      const placeholders = this.extractPlaceholdersFromTemplate(template);
      if (placeholders.length === 0) {
        this.showNotification("No placeholders found in template", "info");
        return;
      }

      // Store placeholders for workflow
      this.placeholdersList = placeholders;
      this.currentPlaceholderIndex = 0;

      // Show template preview section
      const previewSection = document.getElementById("template-preview-section");
      if (previewSection) {
        previewSection.classList.remove("hidden");
      }

      // Render template with highlighted placeholders
      await this.renderTemplatePreview(template);

      // Setup tooltip event listeners
      this.setupPlaceholderTooltipListeners();

      // Handle already-mapped placeholders (show them as green)
      Object.keys(this.placeholderMappings).forEach((placeholderName) => {
        const mapping = this.placeholderMappings[placeholderName];
        const elements = this.placeholderElements.filter(
          (el) => el.dataset.placeholder === placeholderName
        );
        elements.forEach((el) => {
          el.classList.remove(
            "bg-yellow-200",
            "dark:bg-yellow-900",
            "border-yellow-400",
            "dark:border-yellow-600"
          );
          el.classList.add(
            "bg-green-200",
            "dark:bg-green-900",
            "border-green-400",
            "dark:border-green-600"
          );
          el.textContent = mapping.value;
          el.title = `Mapped from ${mapping.source === "contact" ? "contact field" : "manual entry"}`;
        });
      });

      // Start with first placeholder
      this.highlightNextPlaceholder();
    }

    // Render template preview with placeholders highlighted
    async renderTemplatePreview(template) {
      const container = document.getElementById("template-preview-container");
      if (!container) return;

      let content = template.html_content || template.content || "";

      // Create a temporary div to parse HTML
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = content;

      // Find and replace placeholders with highlighted spans
      const placeholderRegex = /\{\{([^}]+)\}\}/g;
      const processedContent = content.replace(placeholderRegex, (match, placeholderName) => {
        const trimmedName = placeholderName.trim();
        return `<span 
          class="placeholder-highlight bg-yellow-200 dark:bg-yellow-900 border-2 border-yellow-400 dark:border-yellow-600 rounded px-1 cursor-pointer" 
          data-placeholder="${trimmedName}"
          data-placeholder-raw="${match}"
        >${match}</span>`;
      });

      container.innerHTML = processedContent;

      // Store placeholder elements
      this.placeholderElements = Array.from(container.querySelectorAll(".placeholder-highlight"));

      // Update progress
      this.updatePlaceholderProgress();
    }

    // Highlight next placeholder and scroll to it
    highlightNextPlaceholder() {
      if (!this.placeholdersList || this.currentPlaceholderIndex >= this.placeholdersList.length) {
        // All placeholders processed
        const unmappedCount = this.placeholdersList.filter(
          (p) => !this.placeholderMappings[p]
        ).length;

        if (unmappedCount === 0) {
          this.showNotification("All placeholders mapped!", "success");
        } else {
          this.showNotification(`${unmappedCount} placeholders skipped`, "info");
        }
        this.finishPlaceholderMapping();
        return;
      }

      const currentPlaceholder = this.placeholdersList[this.currentPlaceholderIndex];

      // Skip if already mapped
      if (this.placeholderMappings[currentPlaceholder]) {
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
        return;
      }

      const placeholderElement = this.placeholderElements.find(
        (el) => el.dataset.placeholder === currentPlaceholder
      );

      if (!placeholderElement) {
        // Move to next if element not found
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
        return;
      }

      // Remove previous highlights
      this.placeholderElements.forEach((el) => {
        el.classList.remove("ring-4", "ring-primary-500", "ring-offset-2");
      });

      // Highlight current placeholder
      placeholderElement.classList.add("ring-4", "ring-primary-500", "ring-offset-2");

      // Scroll to placeholder, then show tooltip after scroll completes
      this.scrollToPlaceholder(placeholderElement);

      // Wait for scroll to complete before showing tooltip
      setTimeout(() => {
        this.showPlaceholderTooltip(placeholderElement, currentPlaceholder);
      }, 500); // Wait for smooth scroll animation to complete
    }

    // Scroll to placeholder element
    scrollToPlaceholder(element) {
      if (!element) return;

      // Calculate position relative to viewport
      const elementRect = element.getBoundingClientRect();
      const viewportHeight = window.innerHeight;

      // Calculate scroll position to center the element in the viewport
      const scrollY =
        window.scrollY + elementRect.top - viewportHeight / 2 + elementRect.height / 2;

      // Scroll the page to center the element
      window.scrollTo({
        top: Math.max(0, scrollY),
        behavior: "smooth",
      });
    }

    // Show tooltip with contact field options
    async showPlaceholderTooltip(element, placeholderName) {
      console.log("üîç [PDF-SYSTEM] Showing tooltip for placeholder:", placeholderName);
      const tooltip = document.getElementById("placeholder-tooltip");
      if (!tooltip) {
        console.error("‚ùå [PDF-SYSTEM] Tooltip element not found!");
        return;
      }

      // Set placeholder name
      const nameSpan = document.getElementById("tooltip-placeholder-name");
      if (nameSpan) {
        nameSpan.textContent = `{{${placeholderName}}}`;
      }

      // Get contact fields and default values
      const contactFields = this.getAvailableContactFields(this.selectedContactData);
      const defaultFields = await this.getDefaultPlaceholderFields();
      const allFields = [...defaultFields, ...contactFields];
      console.log("üîç [PDF-SYSTEM] All fields:", allFields);

      // Render contact field options
      const fieldsContainer = document.getElementById("tooltip-contact-fields");
      if (fieldsContainer) {
        if (allFields.length === 0) {
          fieldsContainer.innerHTML =
            '<p class="text-sm text-gray-500 dark:text-gray-400">No fields available</p>';
        } else {
          fieldsContainer.innerHTML = allFields
            .map(
              (field) => `
            <button
              class="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors border border-gray-200 dark:border-gray-700 placeholder-field-btn ${field.isDefault ? "bg-primary-50 dark:bg-primary-900/20" : ""}"
              data-field-key="${field.key}"
              data-field-value="${field.value || ""}"
              data-is-default="${field.isDefault || false}"
            >
              <div class="font-medium text-sm text-gray-900 dark:text-white">
                ${field.label}
                ${field.isDefault ? '<span class="ml-2 text-xs text-primary-600 dark:text-primary-400">(default)</span>' : ""}
              </div>
              <div class="text-xs text-gray-500 dark:text-gray-400 mt-1 truncate">${field.value || "No value"}</div>
            </button>
          `
            )
            .join("");
        }
      }

      // Show tooltip first (but hidden) to get its dimensions
      tooltip.classList.remove("hidden");
      tooltip.style.display = "block";
      tooltip.style.visibility = "hidden"; // Hide but keep in layout

      // Position tooltip near the placeholder element
      this.positionTooltip(tooltip, element);

      // Make tooltip visible
      tooltip.style.visibility = "visible";

      // Store current placeholder being mapped
      this.currentMappingPlaceholder = placeholderName;
      console.log("‚úÖ [PDF-SYSTEM] Tooltip shown");
    }

    // Position tooltip relative to placeholder element
    positionTooltip(tooltip, element) {
      if (!element || !tooltip) return;

      const rect = element.getBoundingClientRect();

      // Force a layout recalculation to get accurate tooltip dimensions
      tooltip.offsetHeight; // Trigger reflow
      const tooltipRect = tooltip.getBoundingClientRect();

      // Try to position below, fallback to above if not enough space
      let top = rect.bottom + 10;
      let left = rect.left;

      // Check if tooltip would go off screen
      if (top + tooltipRect.height > window.innerHeight) {
        top = rect.top - tooltipRect.height - 10;
      }

      // Ensure tooltip doesn't go above viewport
      if (top < 10) {
        top = 10;
      }

      if (left + tooltipRect.width > window.innerWidth) {
        left = window.innerWidth - tooltipRect.width - 20;
      }

      // Ensure tooltip doesn't go off left edge
      if (left < 10) {
        left = 10;
      }

      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;

      console.log("üìç [PDF-SYSTEM] Tooltip positioned at:", {
        top,
        left,
        elementRect: rect,
        tooltipRect,
      });
    }

    // Setup tooltip event listeners (only once)
    setupPlaceholderTooltipListeners() {
      // Check if already set up
      if (this.tooltipListenersSetup) return;
      this.tooltipListenersSetup = true;

      // Close tooltip button
      document.getElementById("close-tooltip-btn")?.addEventListener("click", () => {
        this.closePlaceholderTooltip();
        this.currentPlaceholderIndex++;
        this.highlightNextPlaceholder();
      });

      // Skip mapping button
      document.getElementById("skip-mapping-btn")?.addEventListener("click", () => {
        this.closePlaceholderTooltip();
        this.finishPlaceholderMapping();
      });

      // Contact field buttons (use event delegation)
      document.addEventListener("click", (e) => {
        if (e.target.closest(".placeholder-field-btn")) {
          const btn = e.target.closest(".placeholder-field-btn");
          const fieldKey = btn.dataset.fieldKey;
          const fieldValue = btn.dataset.fieldValue;
          this.applyPlaceholderMapping(fieldKey, fieldValue, "contact");
        }
      });

      // Manual input apply button
      document.getElementById("tooltip-apply-btn")?.addEventListener("click", () => {
        const manualInput = document.getElementById("tooltip-manual-input");
        if (manualInput && manualInput.value.trim()) {
          this.applyPlaceholderMapping(null, manualInput.value.trim(), "manual");
          manualInput.value = "";
        }
      });

      // Allow Enter key in manual input
      document.getElementById("tooltip-manual-input")?.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          document.getElementById("tooltip-apply-btn")?.click();
        }
      });

      // Make tooltip draggable
      this.setupTooltipDrag();
    }

    // Setup drag functionality for tooltip
    setupTooltipDrag() {
      const tooltip = document.getElementById("placeholder-tooltip");
      const dragHandle = document.getElementById("tooltip-drag-handle");

      if (!tooltip || !dragHandle) return;

      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let initialX = 0;
      let initialY = 0;

      // Prevent dragging when clicking on buttons or inputs
      const preventDrag = (e) => {
        // Don't drag if clicking on close button or any button/input
        if (
          e.target.closest("#close-tooltip-btn") ||
          e.target.closest("button") ||
          e.target.closest("input") ||
          e.target.tagName === "BUTTON" ||
          e.target.tagName === "INPUT"
        ) {
          return true;
        }
        return false;
      };

      dragHandle.addEventListener("mousedown", (e) => {
        if (preventDrag(e)) return;

        // Get current tooltip position
        const rect = tooltip.getBoundingClientRect();
        initialX = rect.left;
        initialY = rect.top;

        // Get mouse position relative to viewport
        startX = e.clientX;
        startY = e.clientY;

        isDragging = true;
        tooltip.style.cursor = "grabbing";
        dragHandle.style.cursor = "grabbing";
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        e.preventDefault();

        // Calculate new position
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        let newX = initialX + deltaX;
        let newY = initialY + deltaY;

        // Get tooltip dimensions
        const tooltipRect = tooltip.getBoundingClientRect();
        const maxX = window.innerWidth - tooltipRect.width;
        const maxY = window.innerHeight - tooltipRect.height;

        // Constrain to viewport
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));

        tooltip.style.top = `${newY}px`;
        tooltip.style.left = `${newX}px`;
        tooltip.style.transform = "none"; // Remove any transform
      });

      document.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          tooltip.style.cursor = "";
          dragHandle.style.cursor = "move";
        }
      });

      // Touch support for mobile
      dragHandle.addEventListener("touchstart", (e) => {
        if (preventDrag(e)) return;

        const touch = e.touches[0];

        // Get current tooltip position
        const rect = tooltip.getBoundingClientRect();
        initialX = rect.left;
        initialY = rect.top;

        // Get touch position relative to viewport
        startX = touch.clientX;
        startY = touch.clientY;

        isDragging = true;
        e.preventDefault();
      });

      document.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        e.preventDefault();

        const touch = e.touches[0];

        // Calculate new position
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;

        let newX = initialX + deltaX;
        let newY = initialY + deltaY;

        // Get tooltip dimensions
        const tooltipRect = tooltip.getBoundingClientRect();
        const maxX = window.innerWidth - tooltipRect.width;
        const maxY = window.innerHeight - tooltipRect.height;

        // Constrain to viewport
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));

        tooltip.style.top = `${newY}px`;
        tooltip.style.left = `${newX}px`;
        tooltip.style.transform = "none";
      });

      document.addEventListener("touchend", () => {
        isDragging = false;
      });
    }

    // Apply placeholder mapping
    applyPlaceholderMapping(fieldKey, value, source) {
      if (!this.currentMappingPlaceholder) return;

      // Store mapping
      this.placeholderMappings[this.currentMappingPlaceholder] = {
        source,
        fieldKey: fieldKey || null,
        value: value,
      };

      // Update template preview to show mapped value
      const placeholderElements = this.placeholderElements.filter(
        (el) => el.dataset.placeholder === this.currentMappingPlaceholder
      );

      placeholderElements.forEach((el) => {
        el.classList.remove(
          "bg-yellow-200",
          "dark:bg-yellow-900",
          "border-yellow-400",
          "dark:border-yellow-600"
        );
        el.classList.add(
          "bg-green-200",
          "dark:bg-green-900",
          "border-green-400",
          "dark:border-green-600"
        );
        el.textContent = value;
        el.title = `Mapped from ${source === "contact" ? "contact field" : "manual entry"}`;
      });

      // Close tooltip
      this.closePlaceholderTooltip();

      // Update progress
      this.updatePlaceholderProgress();

      // Move to next placeholder
      this.currentPlaceholderIndex++;
      setTimeout(() => {
        this.highlightNextPlaceholder();
      }, 300);
    }

    // Close placeholder tooltip
    closePlaceholderTooltip() {
      const tooltip = document.getElementById("placeholder-tooltip");
      if (tooltip) {
        tooltip.classList.add("hidden");
        tooltip.style.display = "none";
      }
      this.currentMappingPlaceholder = null;
    }

    // Update placeholder progress
    updatePlaceholderProgress() {
      const progressEl = document.getElementById("placeholder-progress");
      if (progressEl && this.placeholdersList) {
        const mappedCount = Object.keys(this.placeholderMappings).length;
        progressEl.textContent = `${mappedCount} of ${this.placeholdersList.length}`;
      }
    }

    // Finish placeholder mapping workflow
    finishPlaceholderMapping() {
      this.closePlaceholderTooltip();
      const previewSection = document.getElementById("template-preview-section");
      if (previewSection) {
        previewSection.classList.add("hidden");
      }

      // Update the old mapping UI as well
      if (this.selectedTemplate && this.selectedContactData) {
        this.updatePlaceholderMappingUI();
      }

      this.showNotification("Placeholder mapping complete", "success");
    }

    // Get default placeholder fields (currentDate, companyName, companyPhone)
    async getDefaultPlaceholderFields() {
      const defaultFields = [];

      // Current Date
      const currentDate = new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
      defaultFields.push({
        key: "currentDate",
        label: "Current Date",
        value: currentDate,
        isDefault: true,
      });

      // Fetch company data
      try {
        const response = await fetch("/api/global/company-data", {
          credentials: "include",
        });

        if (response.ok) {
          const data = await response.json();

          // Company Name
          if (data.company?.name) {
            defaultFields.push({
              key: "companyName",
              label: "Company Name",
              value: data.company.name,
              isDefault: true,
            });
          }

          // Company Phone
          if (data.company?.contact?.phone) {
            defaultFields.push({
              key: "companyPhone",
              label: "Company Phone",
              value: data.company.contact.phone,
              isDefault: true,
            });
          }
        } else {
          console.warn("‚ö†Ô∏è [PDF-SYSTEM] Could not fetch company data for default fields");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error fetching company data:", error);
      }

      return defaultFields;
    }

    // Get available Google contact fields for mapping
    getAvailableContactFields(contactData) {
      if (!contactData) return [];

      const fields = [
        { key: "name", label: "Full Name", value: contactData.name || contactData.fullName },
        { key: "firstName", label: "First Name", value: contactData.firstName },
        { key: "lastName", label: "Last Name", value: contactData.lastName },
        { key: "email", label: "Email", value: contactData.email || contactData.emailAddress },
        { key: "phone", label: "Phone", value: contactData.phone || contactData.phoneNumber },
        {
          key: "organization",
          label: "Organization",
          value: contactData.organization || contactData.company,
        },
        {
          key: "address",
          label: "Address",
          value: contactData.address || contactData.streetAddress,
        },
        { key: "jobTitle", label: "Job Title", value: contactData.jobTitle },
        { key: "biography", label: "Biography", value: contactData.biography },
      ];

      // Filter out fields with no value
      return fields.filter((field) => field.value);
    }

    // Show placeholder mapping UI
    async updatePlaceholderMappingUI() {
      if (!this.selectedTemplate || !this.selectedContactData) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Find the selected template
      const template = this.templates.find((t) => t.id === this.selectedTemplate);
      if (!template) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Extract placeholders from template
      const placeholders = this.extractPlaceholdersFromTemplate(template);
      if (placeholders.length === 0) {
        this.hidePlaceholderMappingUI();
        return;
      }

      // Get available contact fields
      const contactFields = this.getAvailableContactFields(this.selectedContactData);

      // Show the mapping section
      const mappingSection = document.getElementById("placeholder-mapping-section");
      const mappingsList = document.getElementById("placeholder-mappings-list");
      if (!mappingSection || !mappingsList) return;

      mappingSection.classList.remove("hidden");

      // Render mapping UI for each placeholder
      mappingsList.innerHTML = placeholders
        .map((placeholder) => {
          const currentMapping = this.placeholderMappings[placeholder];
          const isManual = currentMapping?.source === "manual";
          const manualValue = isManual ? currentMapping.value : "";

          // Try to auto-match placeholder to contact field
          let autoMatch = null;
          const placeholderUpper = placeholder.toUpperCase();
          if (!currentMapping) {
            // Try to find a matching field
            if (
              placeholderUpper.includes("NAME") &&
              !placeholderUpper.includes("FIRST") &&
              !placeholderUpper.includes("LAST")
            ) {
              autoMatch = "name";
            } else if (
              placeholderUpper.includes("FIRST") ||
              placeholderUpper.includes("FIRSTNAME")
            ) {
              autoMatch = "firstName";
            } else if (placeholderUpper.includes("LAST") || placeholderUpper.includes("LASTNAME")) {
              autoMatch = "lastName";
            } else if (placeholderUpper.includes("EMAIL")) {
              autoMatch = "email";
            } else if (placeholderUpper.includes("PHONE") || placeholderUpper.includes("TEL")) {
              autoMatch = "phone";
            } else if (
              placeholderUpper.includes("ADDRESS") ||
              placeholderUpper.includes("STREET")
            ) {
              autoMatch = "address";
            } else if (
              placeholderUpper.includes("COMPANY") ||
              placeholderUpper.includes("ORGANIZATION") ||
              placeholderUpper.includes("ORG")
            ) {
              autoMatch = "organization";
            } else if (placeholderUpper.includes("TITLE") || placeholderUpper.includes("JOB")) {
              autoMatch = "jobTitle";
            }
          }

          const selectedField =
            currentMapping?.source === "contact" ? currentMapping.fieldKey : autoMatch || "";
          const selectedValue =
            currentMapping?.source === "contact"
              ? contactFields.find((f) => f.key === currentMapping.fieldKey)?.value || ""
              : autoMatch
                ? contactFields.find((f) => f.key === autoMatch)?.value || ""
                : "";

          return `
          <div class="border border-gray-200 dark:border-gray-700 rounded-md p-3" data-placeholder="${placeholder}">
            <div class="flex items-start justify-between mb-2">
              <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  <span class="font-mono text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">{{${placeholder}}}</span>
                </label>
                <div class="mt-2 space-y-2">
                  <!-- Source selection: Contact field or manual -->
                  <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                      <input 
                        type="radio" 
                        name="source-${placeholder}" 
                        value="contact" 
                        class="mr-2"
                        ${!isManual ? "checked" : ""}
                        onchange="window.pdfSystem?.setPlaceholderSource('${placeholder}', 'contact')"
                      >
                      <span class="text-sm text-gray-700 dark:text-gray-300">From Contact</span>
                    </label>
                    <label class="flex items-center">
                      <input 
                        type="radio" 
                        name="source-${placeholder}" 
                        value="manual" 
                        class="mr-2"
                        ${isManual ? "checked" : ""}
                        onchange="window.pdfSystem?.setPlaceholderSource('${placeholder}', 'manual')"
                      >
                      <span class="text-sm text-gray-700 dark:text-gray-300">Manual Entry</span>
                    </label>
                  </div>
                  
                  <!-- Contact field dropdown (shown when source is contact) -->
                  <div id="contact-field-${placeholder}" class="${isManual ? "hidden" : ""}">
                    <select 
                      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-primary-500 focus:border-primary-500 text-sm"
                      onchange="window.pdfSystem?.setPlaceholderField('${placeholder}', this.value)"
                    >
                      <option value="">Select a contact field...</option>
                      ${contactFields
                        .map(
                          (field) => `
                        <option value="${field.key}" ${selectedField === field.key ? "selected" : ""}>
                          ${field.label}${field.value ? ` (${field.value.substring(0, 30)}${field.value.length > 30 ? "..." : ""})` : ""}
                        </option>
                      `
                        )
                        .join("")}
                    </select>
                    ${
                      selectedValue
                        ? `
                      <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        Preview: ${selectedValue.substring(0, 50)}${selectedValue.length > 50 ? "..." : ""}
                      </p>
                    `
                        : ""
                    }
                  </div>
                  
                  <!-- Manual entry input (shown when source is manual) -->
                  <div id="manual-field-${placeholder}" class="${!isManual ? "hidden" : ""}">
                    <input 
                      type="text" 
                      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-primary-500 focus:border-primary-500 text-sm"
                      placeholder="Enter value manually..."
                      value="${manualValue}"
                      onchange="window.pdfSystem?.setPlaceholderManual('${placeholder}', this.value)"
                    >
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        })
        .join("");

      // Initialize mappings with auto-matched values
      placeholders.forEach((placeholder) => {
        if (!this.placeholderMappings[placeholder]) {
          const placeholderUpper = placeholder.toUpperCase();
          let autoMatch = null;

          if (
            placeholderUpper.includes("NAME") &&
            !placeholderUpper.includes("FIRST") &&
            !placeholderUpper.includes("LAST")
          ) {
            autoMatch = "name";
          } else if (placeholderUpper.includes("FIRST") || placeholderUpper.includes("FIRSTNAME")) {
            autoMatch = "firstName";
          } else if (placeholderUpper.includes("LAST") || placeholderUpper.includes("LASTNAME")) {
            autoMatch = "lastName";
          } else if (placeholderUpper.includes("EMAIL")) {
            autoMatch = "email";
          } else if (placeholderUpper.includes("PHONE") || placeholderUpper.includes("TEL")) {
            autoMatch = "phone";
          } else if (placeholderUpper.includes("ADDRESS") || placeholderUpper.includes("STREET")) {
            autoMatch = "address";
          } else if (
            placeholderUpper.includes("COMPANY") ||
            placeholderUpper.includes("ORGANIZATION") ||
            placeholderUpper.includes("ORG")
          ) {
            autoMatch = "organization";
          } else if (placeholderUpper.includes("TITLE") || placeholderUpper.includes("JOB")) {
            autoMatch = "jobTitle";
          }

          if (autoMatch) {
            const field = contactFields.find((f) => f.key === autoMatch);
            if (field && field.value) {
              this.placeholderMappings[placeholder] = {
                source: "contact",
                fieldKey: autoMatch,
                value: field.value,
              };
            }
          }
        }
      });

      // Update the UI to reflect initialized mappings
      this.refreshPlaceholderMappingUI();
    }

    // Set placeholder source (contact or manual)
    setPlaceholderSource(placeholder, source) {
      if (!this.placeholderMappings[placeholder]) {
        this.placeholderMappings[placeholder] = { source, value: "" };
      } else {
        this.placeholderMappings[placeholder].source = source;
      }

      // Show/hide appropriate inputs
      const contactDiv = document.getElementById(`contact-field-${placeholder}`);
      const manualDiv = document.getElementById(`manual-field-${placeholder}`);

      if (contactDiv) contactDiv.classList.toggle("hidden", source === "manual");
      if (manualDiv) manualDiv.classList.toggle("hidden", source === "contact");

      // Update radio buttons
      const radios = document.querySelectorAll(`input[name="source-${placeholder}"]`);
      radios.forEach((radio) => {
        radio.checked = radio.value === source;
      });
    }

    // Set placeholder field from contact
    setPlaceholderField(placeholder, fieldKey) {
      if (!fieldKey) {
        if (this.placeholderMappings[placeholder]) {
          this.placeholderMappings[placeholder].value = "";
        }
        this.refreshPlaceholderMappingUI();
        return;
      }

      const contactFields = this.getAvailableContactFields(this.selectedContactData);
      const field = contactFields.find((f) => f.key === fieldKey);

      if (field) {
        this.placeholderMappings[placeholder] = {
          source: "contact",
          fieldKey: fieldKey,
          value: field.value || "",
        };
        this.refreshPlaceholderMappingUI();
      }
    }

    // Set placeholder manual value
    setPlaceholderManual(placeholder, value) {
      if (!this.placeholderMappings[placeholder]) {
        this.placeholderMappings[placeholder] = { source: "manual", value: "" };
      }
      this.placeholderMappings[placeholder].source = "manual";
      this.placeholderMappings[placeholder].value = value;
    }

    // Refresh the mapping UI to show current values
    refreshPlaceholderMappingUI() {
      if (!this.selectedTemplate || !this.selectedContactData) return;

      const template = this.templates.find((t) => t.id === this.selectedTemplate);
      if (!template) return;

      const placeholders = this.extractPlaceholdersFromTemplate(template);
      const contactFields = this.getAvailableContactFields(this.selectedContactData);

      placeholders.forEach((placeholder) => {
        const mapping = this.placeholderMappings[placeholder];
        if (!mapping) return;

        // Update preview text if source is contact
        if (mapping.source === "contact" && mapping.fieldKey) {
          const field = contactFields.find((f) => f.key === mapping.fieldKey);
          if (field && field.value) {
            const preview = document.querySelector(`[data-placeholder="${placeholder}"] p.text-xs`);
            if (preview) {
              const previewText =
                field.value.substring(0, 50) + (field.value.length > 50 ? "..." : "");
              preview.textContent = `Preview: ${previewText}`;
            }
          }
        }
      });
    }

    // Hide placeholder mapping UI
    hidePlaceholderMappingUI() {
      const mappingSection = document.getElementById("placeholder-mapping-section");
      if (mappingSection) {
        mappingSection.classList.add("hidden");
      }
    }

    async generatePDF() {
      if (!this.selectedTemplate || !this.selectedUser) {
        this.showNotification("Please select a template and user", "error");
        return;
      }

      try {
        const pageSize = document.getElementById("page-size")?.value || "8.5x11";
        const orientation = document.getElementById("orientation")?.value || "portrait";

        const response = await fetch("/api/pdf/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            templateId: this.selectedTemplate,
            userId: this.selectedUser,
            pageSize,
            orientation,
          }),
        });

        const data = await response.json();
        if (data.success) {
          this.showNotification("PDF generated successfully!", "success");
          // Download the PDF
          if (data.downloadUrl) {
            window.open(data.downloadUrl, "_blank");
          }
        } else {
          this.showNotification("Error generating PDF: " + data.error, "error");
        }
      } catch (error) {
        console.error("‚ùå [PDF-SYSTEM] Error generating PDF:", error);
        this.showNotification("Error generating PDF", "error");
      }
    }

    showNotification(message, type = "info") {
      // Simple notification system
      const notification = document.createElement("div");
      notification.className = `fixed top-4 right-4 p-4 rounded-md text-white z-50 ${
        type === "success" ? "bg-green-600" : type === "error" ? "bg-red-600" : "bg-primary-600"
      }`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    resetTemplateForm() {
      if (this.templateNameInput) {
        this.templateNameInput.value = "";
      }
      if (this.templateTypeSelect) {
        this.templateTypeSelect.value = "body";
      }
      if (this.editor) {
        this.editor.setText("");
      } else {
        const textarea = document.getElementById("template-content-textarea");
        if (textarea) {
          textarea.value = "";
        }
      }
      document.getElementById("extracted-fields")?.classList.add("hidden");
    }

    editTemplate(templateId) {
      console.log("üìÑ [PDF-SYSTEM] Editing template:", templateId);
      this.openTemplateEditor(templateId);
    }

    // openUserSearchModal() {
    //   // Trigger the SlotMachineModal
    //   const searchButton = document.getElementById("user-search");
    //   if (searchButton) {
    //     searchButton.click();
    //   } else {
    //     console.error("‚ùå [PDF-SYSTEM] Could not find user search modal trigger");
    //     this.showNotification("Error opening search modal", "error");
    //   }
    // }
  }

  // Initialize PDF System
  document.addEventListener("DOMContentLoaded", () => {
    window.pdfSystem = new PDFSystem();
  });
</script>

<style>
  .pdf-tab {
    transition: all 0.2s ease-in-out;
  }

  .pdf-tab:hover {
    border-color: #d1d5db;
  }

  .pdf-tab-content {
    animation: fadeIn 0.3s ease-in-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<!-- PDF.js Scripts (like in New.astro) -->
<script src="/js/pdf.worker.min.js" defer></script>
<script src="/js/pdf.min.js" defer></script>

<!-- Quill WYSIWYG Editor - Loaded dynamically to avoid conflicts -->
