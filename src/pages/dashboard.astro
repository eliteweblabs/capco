---
console.log("üìä [DASHBOARD] Page loading started...");

import App from "../components/common/App.astro";
import DashboardComponent from "../components/common/Dashboard.astro";
import SectionContainer from "../components/common/SectionContainer.astro";
import ProjectNav from "../components/project/ProjectNav.astro";
import Hero from "../components/common/Hero.astro";
import "../lib/refresh-manager.ts";

// Get auth data directly since App component handles auth requirements
import { checkAuth } from "../lib/auth";
import { supabase } from "../lib/supabase";
import { supabaseAdmin } from "../lib/supabase-admin";
const { isAuth, currentUser, currentRole } = await checkAuth(Astro.cookies);

// Debug information
console.log("üîç [DASHBOARD] Auth check results:", {
  isAuth,
  currentRole,
});

// Test database access if authenticated

// // Additional debugging - check cookies directly
// const accessToken = Astro.cookies.get("sb-access-token");
// const refreshToken = Astro.cookies.get("sb-refresh-token");

// console.log("üç™ [DASHBOARD] Cookie status:", {
//   hasAccessToken: !!accessToken,
//   hasRefreshToken: !!refreshToken,
//   accessTokenLength: accessToken?.value?.length || 0,
//   refreshTokenLength: refreshToken?.value?.length || 0,
// });

// Fetch projects, statuses, and client data from API
let projects: any[] = [];
let project_statuses: any[] = [];
let project_statuses_object: any = {};
let clientProfiles: any[] = [];

try {
  // Fetch projects directly from database to avoid DNS issues
  if (supabase) {
    console.log("üèóÔ∏è [DASHBOARD] Fetching projects directly from database");

    if (!supabaseAdmin) {
      console.error("üèóÔ∏è [DASHBOARD] SupabaseAdmin not available");
      return;
    }
    // Use admin client to bypass RLS policies
    const { data: allProjects, error } = supabaseAdmin
      ? await supabaseAdmin
          .from("projects")
          .select(
            `
            id,
            title,
            description,
            address,
            author_id,
            status,
            sq_ft,
            new_construction,
            created_at,
            updated_at,
            assigned_to_id
          `
          )
          .neq("id", 0) // Exclude system log project
          .order("updated_at", { ascending: false })
      : await supabase
          .from("projects")
          .select(
            `
            id,
            title,
            description,
            address,
            author_id,
            status,
            sq_ft,
            new_construction,
            created_at,
            updated_at,
            assigned_to_id
          `
          )
          .neq("id", 0) // Exclude system log project
          .order("updated_at", { ascending: false });

    if (error) {
      console.error("üèóÔ∏è [DASHBOARD] Database error:", error);
    } else {
      console.log("üèóÔ∏è [DASHBOARD] Projects fetched:", allProjects?.length || 0);
      console.log("üèóÔ∏è [DASHBOARD] Current role:", currentRole);
      console.log("üèóÔ∏è [DASHBOARD] Current user ID:", currentUser?.id);

      // Filter projects based on user currentRole
      if (currentRole === "Admin") {
        // Admin sees all projects
        projects = allProjects || [];
        console.log("üèóÔ∏è [DASHBOARD] Admin - showing all projects:", projects.length);
      } else if (currentRole === "Staff") {
        // Staff only sees projects where they are assigned
        projects = (allProjects || []).filter(
          (project: any) => project.assigned_to_id === currentUser?.id
        );
        console.log("üèóÔ∏è [DASHBOARD] Staff - showing assigned projects:", projects.length);
      } else {
        // Clients only see projects they authored
        projects = (allProjects || []).filter(
          (project: any) => project.author_id === currentUser?.id
        );
        console.log("üèóÔ∏è [DASHBOARD] Client - showing authored projects:", projects.length);
        console.log("üèóÔ∏è [DASHBOARD] Client projects:", projects);
      }

      // Fetch and attach profile data to projects
      if (projects && projects.length > 0) {
        console.log("üèóÔ∏è [DASHBOARD] Fetching profiles for projects...");
        const uniqueAuthorIds = [...new Set(projects.map((p) => p.author_id).filter(Boolean))];
        const uniqueAssignedIds = [
          ...new Set(projects.map((p) => p.assigned_to_id).filter(Boolean)),
        ];
        const allUserIds = [...new Set([...uniqueAuthorIds, ...uniqueAssignedIds])];

        console.log("üèóÔ∏è [DASHBOARD] Unique author IDs:", uniqueAuthorIds);
        console.log("üèóÔ∏è [DASHBOARD] All user IDs to fetch:", allUserIds);

        let profilesMap = new Map();
        if (allUserIds.length > 0) {
          const { data: profiles, error: profilesError } = await supabaseAdmin
            .from("profiles")
            .select("id, company_name, first_name, last_name")
            .in("id", allUserIds);

          if (!profilesError && profiles) {
            profiles.forEach((profile) => {
              profilesMap.set(profile.id, profile);
            });
            console.log("üèóÔ∏è [DASHBOARD] Successfully fetched profiles:", profiles.length);
            console.log("üèóÔ∏è [DASHBOARD] Sample profile:", profiles[0]);
          } else {
            console.error("üèóÔ∏è [DASHBOARD] Error fetching profiles:", profilesError);
          }
        }

        // Attach profile data to projects
        projects.forEach((project: any) => {
          if (project.author_id) {
            const authorProfile = profilesMap.get(project.author_id);
            project.profiles = authorProfile || null;

            if (authorProfile) {
              console.log("üèóÔ∏è [DASHBOARD] Attached profile to project:", {
                projectId: project.id,
                authorId: project.author_id,
                companyName: authorProfile.company_name,
                profile: authorProfile,
              });
            } else {
              console.log("üèóÔ∏è [DASHBOARD] No profile found for author:", project.author_id);
            }
          }

          if (project.assigned_to_id) {
            project.assigned_profiles = profilesMap.get(project.assigned_to_id) || null;
          }
        });
      }
    }
  } else {
    console.error("üèóÔ∏è [DASHBOARD] Supabase client not available");
  }

  // Fetch status labels directly from database to avoid DNS issues
  let statusLabels: Record<number, { status_name: string; [key: string]: any }> = {};
  if (isAuth && supabase) {
    try {
      console.log("üèóÔ∏è [DASHBOARD] Fetching statuses directly from database");

      // Fetch project statuses directly from database
      const { data: statusesData, error: statusesError } = supabaseAdmin
        ? await supabaseAdmin
            .from("project_statuses")
            .select(
              "status_code, admin_status_name, project_action, client_status_name, client_status_tab, admin_status_tab"
            )
            .neq("status_code", 0)
            .order("status_code")
        : await supabase
            .from("project_statuses")
            .select(
              "status_code, admin_status_name, project_action, client_status_name, client_status_tab, admin_status_tab"
            )
            .neq("status_code", 0)
            .order("status_code");

      if (statusesError) {
        console.error("üèóÔ∏è [DASHBOARD] Statuses database error:", statusesError);
      } else {
        // Convert array to object for easier lookup
        statusLabels = (statusesData || []).reduce((acc: any, status: any) => {
          acc[status.status_code] = status;
          return acc;
        }, {});

        console.log("üèóÔ∏è [DASHBOARD] Statuses fetched:", statusesData?.length || 0);
      }
    } catch (error) {
      console.error("üèóÔ∏è [DASHBOARD] Error fetching statuses:", error);
    }
  }

  // Convert to array format for existing components - preserve all properties
  project_statuses = Object.values(statusLabels || {});
  // Keep object format for project actions (make it global for script)
  project_statuses_object = statusLabels || {};

  // Fetch client profiles for dropdowns and forms
  if (isAuth && supabase) {
    try {
      console.log("üë• [DASHBOARD] Fetching client profiles for forms...");

      const { data: profiles, error: profilesError } = supabaseAdmin
        ? await supabaseAdmin
            .from("profiles")
            .select("id, company_name, role")
            .eq("role", "Client")
            .order("company_name")
        : await supabase
            .from("profiles")
            .select("id, company_name, role")
            .eq("role", "Client")
            .order("company_name");

      if (profilesError) {
        console.error("üë• [DASHBOARD] Client profiles error:", profilesError);
      } else {
        clientProfiles = profiles || [];
        console.log(`üë• [DASHBOARD] Loaded ${clientProfiles.length} client profiles`);
      }
    } catch (error) {
      console.error("üë• [DASHBOARD] Error fetching client profiles:", error);
    }
  }

  // Debug: Log the converted array to see if client_status_name is preserved
  console.log("üîç [DASHBOARD] Converted project_statuses array:", project_statuses.slice(0, 3));
  console.log(
    "üîç [DASHBOARD] First status with client_status_name:",
    project_statuses.find((s) => s.client_status_name)
  );
} catch (error) {
  console.error("Error fetching data:", error);
}
---

<App requireAuth={true}>
  <Hero
    title={currentUser?.company_name || "Dashboard"}
    authorProfile={currentUser}
    description={""}
    currentRole={currentRole || "Client"}
  />

  <!-- <DebugComponent/> -->

  <!-- Navigation -->
  <SectionContainer class="mx-6 flex flex-col gap-y-6">
    <ProjectNav
      currentRole={currentRole || "Client"}
      projects={projects}
      statuses={project_statuses}
    />
  </SectionContainer>

  <!-- Main Dashboard -->
  <SectionContainer id="dashboard" class="mx-6 mb-0 mt-0 flex">
    <DashboardComponent
      currentRole={currentRole || "Client"}
      currentUser={currentUser}
      projects={projects}
      statuses={project_statuses}
    />
  </SectionContainer>
</App>

<script
  define:vars={{
    projects,
    project_statuses,
    project_statuses_object,
    currentRole,
    currentUser,
    clientProfiles,
  }}
>
  // Make client profiles available globally for components
  window.globalClientProfiles = clientProfiles;
  console.log("üë• [DASHBOARD] Made client profiles available globally:", clientProfiles.length);

  // Project Action Notification System - Only for Clients
  document.addEventListener("DOMContentLoaded", async function () {
    console.log("üîî [PROJECT-ACTIONS] Initializing project action notifications...");
    console.log("üîî [PROJECT-ACTIONS] Current user currentRole:", currentRole);
    console.log("üîî [PROJECT-ACTIONS] Projects data:", projects);

    // Only run for clients
    if (currentRole !== "Client") {
      console.log("üîî [PROJECT-ACTIONS] Skipping - user is not a client");
      return;
    }

    if (!projects || !Array.isArray(projects) || projects.length === 0) {
      console.log("üîî [PROJECT-ACTIONS] No projects found for client");
      return;
    }

    // Use project statuses data that's already available from server-side
    // console.log("üîî [PROJECT-ACTIONS] Using project statuses data from server-side variables");
    // console.log("üîî [PROJECT-ACTIONS] Project statuses data:", project_statuses_object);

    if (!project_statuses_object || typeof project_statuses_object !== "object") {
      console.log("üîî [PROJECT-ACTIONS] No project statuses found");
      return;
    }

    // console.log("üîî [PROJECT-ACTIONS] Processing projects:", projects.length);
    // console.log("üîî [PROJECT-ACTIONS] Available statuses:", Object.keys(project_statuses_object));

    // Check each project for action notifications
    for (let index = 0; index < projects.length; index++) {
      const project = projects[index];
      const projectStatus = project.status;
      const statusConfig = project_statuses_object[projectStatus];

      console.log(`üîî [PROJECT-ACTIONS] Checking project ${index + 1}:`, {
        id: project.id,
        title: project.title,
        status: projectStatus,
        hasStatusConfig: !!statusConfig,
        statusConfig: statusConfig,
      });

      if (statusConfig && statusConfig.project_action) {
        console.log(
          `üîî [PROJECT-ACTIONS] Found project action for project "${project.title}":`,
          statusConfig.project_action
        );

        // Replace placeholders in the project action message using centralized API
        const actionMessage = await replacePlaceholders(
          statusConfig.project_action,
          project,
          statusConfig
        );

        console.log(`üîî [PROJECT-ACTIONS] Showing for project "${project.title}":`, actionMessage);

        // Show dismissible modal notification with proper initialization check
        const showNotificationWithRetry = (retryCount = 0) => {
          if (window.showModal && window.unifiedNotificationManager) {
            console.log("üîî [PROJECT-ACTIONS] Notification system available, showing modal...");
            window.showModal("info", "Project Action Required", actionMessage, 8000); // 8 seconds with progress bar
          } else if (retryCount < 5) {
            console.log(
              `üîî [PROJECT-ACTIONS] Notification system not ready, retrying in ${(retryCount + 1) * 500}ms... (attempt ${retryCount + 1}/5)`
            );
            setTimeout(
              () => {
                showNotificationWithRetry(retryCount + 1);
              },
              (retryCount + 1) * 500
            );
          } else {
            console.error(
              "üîî [PROJECT-ACTIONS] Notification system failed to initialize after 5 attempts"
            );
            console.error(
              "üîî [PROJECT-ACTIONS] Available window methods:",
              Object.keys(window).filter((key) => key.includes("show"))
            );

            // Fallback to alert if notification system fails
            alert(`Project Action Required: ${actionMessage}`);
          }
        };

        showNotificationWithRetry();
      } else {
        console.log(`üîî [PROJECT-ACTIONS] No project action for project "${project.title}"`);
      }
    }
  });

  // Function to replace placeholders in project action messages using centralized API
  async function replacePlaceholders(message, project, statusConfig) {
    if (!message) return "";

    console.log("üîÑ [PLACEHOLDER] Original message:", message);

    // Get client name from currentUser data - use company_name consistently
    const clientName = currentUser?.company_name || "Client";

    // Prepare data for centralized placeholder API
    const mergedData = {
      statusConfig: {
        project_action: message,
      },
    };

    const placeholderData = {
      projectAddress: project.address || "N/A",
      clientName: clientName,
      clientEmail: currentUser?.email || "",
      statusName: statusConfig?.status_name || "Status Update",
      estTime: statusConfig?.est_time || "2-3 business days",
      projectId: project.id,
      siteUrl: window.location.origin,
    };

    try {
      // Call centralized placeholder API
      const response = await fetch("/api/replace-placeholders", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          mergedData,
          placeholderData,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        const processedMessage = result.processedMessages?.project_action || message;

        console.log("üîÑ [PLACEHOLDER] Final processed message:", processedMessage);
        return processedMessage;
      } else {
        console.error("üîÑ [PLACEHOLDER] API call failed, falling back to local processing");
        throw new Error("API call failed");
      }
    } catch (error) {
      console.error("üîÑ [PLACEHOLDER] Error calling centralized API:", error);
    }
  }
</script>
