---
import App from "../components/App.astro";
import SectionContainer from "../components/SectionContainer.astro";
import Hero from "../components/index/Hero.astro";
import ProjectsNav from "../components/ProjectsNav.astro"; 
import Dashboard from "../components/Dashboard.astro";
// import Project from "../components/Project.astro";
import Invoice from "../components/Invoice.astro";
import Delivery from "../components/Delivery.astro";
import AuthForm from "../components/AuthForm.astro";
// Check authentication
import { checkAuth } from "../lib/auth";
const { isAuth, session, user, role } = await checkAuth(Astro.cookies);


---

<App>
    
    {isAuth ? (

        
        <Hero title={'' + user.user_metadata.name} description={role || 'No role'}/>


        <SectionContainer id="sub-nav" class="flex flex-col gap-y-6">
          <ProjectsNav role={role}/>
        </SectionContainer>

<SectionContainer id="dashboard" class="tab-content mb-0 mt-0 mx-6">
  <Dashboard role={role} />
</SectionContainer>



      
    ) : (
      <!-- Non-authenticated content -->
      <SectionContainer id="auth" class="flex flex-col gap-y-6 mx-6">
        <AuthForm />
      </SectionContainer>
    
    )}






  </App>
  


<script define:vars={{ role }}>
  // Pass role to global scope for use in the main script
  window.USER_ROLE = role || "Client";
</script>

<script>
  // Import necessary functions and types
  import {
    PROJECT_STATUS_LABELS,
    PROJECT_STATUS_DATA,
    loadProjectStatuses,
    getStatusData,
    formatTimeSinceUpdate,
    showNotification,
    type ProjectStatusCode,
  } from "../lib/global-services";

  // Import form generation function
  import { generateEditFormHTML } from "../lib/project-form-config";
  // import Tooltip from "./Tooltip.astro";
  import { StatusQuerySystem } from "../lib/status-query-system";

  // Extend window interface for USER_ROLE
  declare global {
    interface Window {
      USER_ROLE: string;
    }
  }

  // Projects List Management Class
  class ProjectsList {
    private currentProjectId: string | null = null;
    private currentProjectStatus: number | null = null;
    private staffUsers: any[] = [];
    private projects: any[] = [];
    private currentUserRole: string = window.USER_ROLE || "Client"; // Add user role

    constructor() {
      this.setupAutoSave();
      this.setupAssignmentHandlers();
      this.setupRefreshButton();
      this.exposeGlobalMethods();
      this.initializeProjectStatuses().catch(console.error);
      // Load staff users first, then projects
      this.initializeData();
      // Apply role-based UI changes
      this.applyRoleBasedChanges();
    }

    // Initialize data in the correct order
    async initializeData() {
      await this.loadStaffUsers();
      await this.loadProjects();
    }

    // Apply role-based UI changes
    applyRoleBasedChanges() {
      const isClient = this.currentUserRole === "Client";
      
      if (isClient) {
        console.log("Applying client-specific UI changes");
        
        // Hide project owner avatars for client users (redundant since they only see their own projects)
        setTimeout(() => {
          const avatars = document.querySelectorAll('.project-owner-avatar');
          avatars.forEach(avatar => {
            (avatar as HTMLElement).style.display = 'none';
          });
          
          // Also adjust spacing since avatar is hidden
          const projectInfoDivs = document.querySelectorAll('.project-owner-avatar + div');
          projectInfoDivs.forEach(div => {
            (div as HTMLElement).style.paddingLeft = '0';
          });
        }, 100); // Small delay to ensure DOM is updated
      }
    }

    // Function to automatically load projects
    async loadProjects() {
      try {
        const response = await fetch("/api/get-user-projects");
        const result = await response.json();

        if (result.success && result.projects) {
          this.displayUserProjects(result.projects);

          showNotification({
            type: "success",
            title: "Projects Loaded",
            message: `Found ${result.projects.length} project(s)`,
            duration: 3000,
          });

          console.log(`Loaded ${result.projects.length} projects`);
        } else {
          console.error("Failed to load projects:", result.error);
          showNotification({
            type: "error",
            title: "Failed to Load Projects",
            message: result.error || "Could not fetch your projects",
            duration: 5000,
          });
        }
      } catch (error) {
        console.error("Error loading projects:", error);
        showNotification({
          type: "error",
          title: "Failed to Load Projects",
          message: "Could not connect to server",
          duration: 5000,
        });
      }
    }

    // Function to load staff users from API
    async loadStaffUsers() {
      try {
        console.log("Loading staff users...");
        const response = await fetch("/api/get-staff-users");
        const result = await response.json();

        console.log("Staff users API response:", result);

        if (result.success) {
          this.staffUsers = result.staffUsers || [];
          console.log(
            `Loaded ${this.staffUsers.length} staff users:`,
            this.staffUsers
          );
        } else {
          console.error("Failed to load staff users:", result.error);
          console.log("Full error response:", result);
          this.staffUsers = [];
        }
      } catch (error) {
        console.error("Error loading staff users:", error);
        this.staffUsers = [];
      }
    }

    // Function to setup refresh button event listener
    private setupRefreshButton() {
      // Use event delegation since the button might not exist yet
      document.addEventListener("click", async (e) => {
        const target = e.target as HTMLElement;
        if (
          target.id === "refresh-staff-btn" ||
          target.closest("#refresh-staff-btn")
        ) {
          e.preventDefault();
          await this.refreshStaffUsers();
        }

        if (
          target.id === "debug-staff-btn" ||
          target.closest("#debug-staff-btn")
        ) {
          e.preventDefault();
          await this.debugStaffUsers();
        }

        if (target.id === "test-db-btn" || target.closest("#test-db-btn")) {
          e.preventDefault();
          await this.testDatabase();
        }
      });
    }

    // Function to debug staff users
    async debugStaffUsers() {
      try {
        console.log("Debugging staff users...");
        const response = await fetch("/api/debug-staff-users");
        const result = await response.json();

        console.log("Debug response:", result);

        if (result.success) {
          showNotification({
            type: "info",
            title: "Debug Info",
            message: `Check console for detailed debug information`,
            duration: 5000,
          });
        } else {
          showNotification({
            type: "error",
            title: "Debug Failed",
            message: result.error || "Could not get debug info",
            duration: 5000,
          });
        }
      } catch (error) {
        console.error("Error debugging staff users:", error);
        showNotification({
          type: "error",
          title: "Debug Error",
          message: "Could not connect to debug endpoint",
          duration: 5000,
        });
      }
    }

    // Function to test database queries
    async testDatabase() {
      try {
        console.log("Testing database queries...");
        const response = await fetch("/api/test-database");
        const result = await response.json();

        console.log("Database test response:", result);

        if (result.success) {
          showNotification({
            type: "info",
            title: "Database Test",
            message: `Check console for database test results`,
            duration: 5000,
          });
        } else {
          showNotification({
            type: "error",
            title: "Database Test Failed",
            message: result.error || "Could not test database",
            duration: 5000,
          });
        }
      } catch (error) {
        console.error("Error testing database:", error);
        showNotification({
          type: "error",
          title: "Database Test Error",
          message: "Could not connect to test endpoint",
          duration: 5000,
        });
      }
    }

    // Function to refresh staff users and update all dropdowns
    async refreshStaffUsers() {
      console.log("Refreshing staff users...");
      await this.loadStaffUsers();

      // Re-populate all staff assignment dropdowns with updated data
      const staffSelects = document.querySelectorAll(
        ".staff-assignment-select"
      );
      staffSelects.forEach((select) => {
        const selectElement = select as HTMLSelectElement;
        const projectId = selectElement.dataset.projectId;
        const currentValue = selectElement.value;

        // Clear and repopulate options
        selectElement.innerHTML = '<option value="">Unassigned</option>';

        this.staffUsers.forEach((staff) => {
          const option = document.createElement("option");
          option.value = staff.id;
          option.textContent = staff.name;

          // Restore previous selection if it still exists
          if (staff.id === currentValue) {
            option.selected = true;
          }

          selectElement.appendChild(option);
        });
      });

      showNotification({
        type: "success",
        title: "Staff List Updated",
        message: `Refreshed staff list - found ${this.staffUsers.length} staff members`,
        duration: 3000,
      });
    }

    // Function to populate staff assignment dropdowns
    private populateStaffAssignments(projects: any[]) {
      projects.forEach((project) => {
        const selectElement = document.getElementById(
          `staff-assignment-${project.id}`
        ) as HTMLSelectElement;
        if (!selectElement) return;

        // Clear existing options except "Unassigned"
        selectElement.innerHTML = '<option value="">Unassigned</option>';

        // Add staff users as options
        this.staffUsers.forEach((staff) => {
          const option = document.createElement("option");
          option.value = staff.id;
          option.textContent = staff.name;

          // Select current assignment if it matches
          if (project.assigned_to_id === staff.id) {
            option.selected = true;
          }

          selectElement.appendChild(option);
        });

        // Update the assigned user span (only for non-Client users)
        if (this.currentUserRole !== "Client") {
          const assignedUserSpan = document.getElementById(
            `assigned-user-${project.id}`
          );
          if (assignedUserSpan) {
            if (project.assigned_to_id) {
              const assignedStaff = this.staffUsers.find(
                (s) => s.id === project.assigned_to_id
              );
              if (assignedStaff) {
                assignedUserSpan.textContent = assignedStaff.name;
                assignedUserSpan.className =
                  "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-600 text-white";
              } else {
                assignedUserSpan.textContent = "Loading...";
                assignedUserSpan.className =
                  "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500 text-white";
              }
            } else {
              assignedUserSpan.textContent = "Unassigned";
              assignedUserSpan.className =
                "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500 text-white";
            }
          }
        }
      });
    }

    // Function to handle staff assignment changes
    private setupAssignmentHandlers() {
      document.addEventListener("change", async (e) => {
        const target = e.target as HTMLSelectElement;
        if (!target.classList.contains("staff-assignment-select")) return;

        const projectId = target.dataset.projectId;
        const assignedToId = target.value || null;

        if (!projectId) return;

        try {
          const response = await fetch("/api/assign-project", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              projectId,
              assignedToId,
            }),
          });

          const result = await response.json();

          if (result.success) {
            const assignedName = assignedToId
              ? this.staffUsers.find((s) => s.id === assignedToId)?.name ||
                "Unknown"
              : "Unassigned";

            // Update the assigned user span (only for non-Client users)
            if (this.currentUserRole !== "Client") {
              const assignedUserSpan = document.getElementById(
                `assigned-user-${projectId}`
              );
              if (assignedUserSpan) {
                assignedUserSpan.textContent = assignedName;
                if (assignedToId) {
                  assignedUserSpan.className =
                    "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-600 text-white";
                } else {
                  assignedUserSpan.className =
                    "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500 text-white";
                }
              }
            }

            showNotification({
              type: "success",
              title: "Assignment Updated",
              message: `Project ${projectId} assigned to ${assignedName}`,
              duration: 3000,
            });

            console.log("Assignment updated:", result);
          } else {
            showNotification({
              type: "error",
              title: "Assignment Failed",
              message: result.error || "Could not update assignment",
              duration: 5000,
            });

            // Reset dropdown to previous value on error
            target.selectedIndex = 0;
          }
        } catch (error) {
          console.error("Error updating assignment:", error);
          showNotification({
            type: "error",
            title: "Assignment Error",
            message: "Could not connect to server",
            duration: 5000,
          });

          // Reset dropdown to previous value on error
          target.selectedIndex = 0;
        }
      });
    }

    // Function to display user projects in the projects list
    displayUserProjects(projects: any[]) {
    // Store projects data for use in other methods
    this.projects = projects;
      // Find or create the projects list container
      let projectsList = document.getElementById("projects-list");

      if (!projectsList) {
        // Create the container if it doesn't exist
        const projectListContainer = document.querySelector(
          "[data-project-list-container]"
        );
        if (projectListContainer) {
          projectListContainer.innerHTML = `
            <div id="projects-list">
              <!-- Search Filter for Projects -->
              <div class="mb-4 relative">
                <input
                  type="text"
                  id="project-search-input"
                  placeholder="Search your projects..."
                  class="w-full pr-10 px-4 py-2 text-sm border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                />
                <button
                  id="clear-search-btn"
                  class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 transition-colors hidden"
                  title="Clear search"
                >
                  <i class="bx bx-x text-lg"></i>
                </button>
              </div>
            </div>
          `;
          projectsList = document.getElementById("projects-list");
        }
      }

      if (!projectsList) return;

      // Preserve the search input if it exists
      const existingSearchInput = projectsList.querySelector(
        "#project-search-input"
      );
      const searchInputHTML = existingSearchInput
        ? existingSearchInput.outerHTML
        : "";

      if (projects.length === 0) {
        projectsList.innerHTML = `
          ${searchInputHTML}
          <div class="p-4 text-center text-gray-500 dark:text-gray-400">
            <p>No projects found</p>
            <p class="text-sm mt-1">Create a test project to see it listed here</p>
          </div>
        `;
        return;
      }

      // Sort projects by update time (most recent first)
      const sortedProjects = [...projects].sort((a, b) => {
        const timeA = new Date(a.updated_at || a.created).getTime();
        const timeB = new Date(b.updated_at || b.created).getTime();
        return timeB - timeA; // Descending order (newest first)
      });

      // Generate accordion HTML for projects
      const accordionId = "projects-accordion";
      projectsList.innerHTML = `
        ${searchInputHTML}
        <div id="${accordionId}" data-accordion="collapse">
          ${sortedProjects
            .map((project, index) => {
              // Calculate time since last update
              const timeSinceUpdate = formatTimeSinceUpdate(
                project.updated_at || project.created
              );

              const isFirst = index === 0;
              const isLast = index === sortedProjects.length - 1;
              const projectTitle =
                project.address || project.title || `Project ${project.id}`;

              const projectDescription =
                project.description || "Project created from PDF upload";

              return `
                <!-- Accordion Item ${index} -->
                <div class="status-${project.status || 10}" data-project-status="${project.status || 10}" data-project-id="${project.id}">
                  <!-- Accordion Header -->
                  <div id="accordion-collapse-heading-${index}" class="accordion-header">
                    <button
                      class="relative flex items-center justify-between w-full p-5 font-medium rtl:text-right text-gray-500 border ${isLast ? "" : "border-b-0"} ${isFirst ? "rounded-t-xl" : ""} border-gray-200 focus:ring-1 focus:ring-gray-200 dark:focus:ring-gray-800 dark:border-gray-700 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800 gap-3"
                      data-accordion-target="#accordion-collapse-body-${index}"
                      aria-expanded="false"
                      aria-controls="accordion-collapse-body-${index}"
                      type="button"
                    >
                      <!-- Project Owner Avatar with Tooltip (hidden for Client users) -->
                      <div class="project-owner-avatar rounded-lg border size-9 flex items-center justify-center border-gray-600 dark:border-gray-500 dark:bg-gray-800 overflow-hidden text-white dark:text-gray-300 bg-gray-700" 
                           title="${project.author_name || "Unknown Owner"}${project.author_email ? ` - ${project.author_email}` : ""}${project.owner ? ` (${project.owner})` : ""}">
                        ${
                          project.author_id
                            ? `<div class="w-full h-full flex items-center justify-center bg-blue-500 text-white">
                              <i class="bx bx-user bx-sm"></i>
                            </div>`
                            : '<i class="bx bx-file-blank"></i>'
                        }
                      </div>

                      <!-- Project Info -->
                      <div class="pl-4 flex flex-col justify-start flex-1 text-left">
                        <h2 class="font-medium text-base text-gray-800 dark:text-gray-200" data-search-text>
                          ${projectTitle}
                        </h2>
                    

                       
                        <div class="flex items-center gap-2 mt-1">
                             

                          <!-- Status badge -->
                          <span id="project-status-label-${project.id}" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-cyan-600 text-white"  data-search-text>
                            ${PROJECT_STATUS_LABELS[(project.status || 10) as unknown as ProjectStatusCode] || "Unknown"}
                          </span>
                          <!-- Assigned user name (hidden for Client users) -->
                          ${
                            this.currentUserRole !== "Client" ? (
                              project.assigned_to_id && project.assigned_to_name
                                ? `<span id="assigned-user-${project.id}" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-600 text-white" data-search-text>
                              ${project.assigned_to_name}
                            </span>`
                                : project.assigned_to_id
                                  ? `<span id="assigned-user-${project.id}" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500 text-white">
                              Loading...
                            </span>`
                                  : `<span id="assigned-user-${project.id}" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500 text-white">
                              Unassigned
                            </span>`
                            ) : ""
                          }
                                <i class="bx bx-time"></i>${timeSinceUpdate}

                        </div>
                      </div>

                      <!-- Accordion Arrow -->
                      <svg
                        data-accordion-icon
                        class="w-3 h-3 rotate-180 shrink-0"
                        aria-hidden="true"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 10 6"
                      >
                        <path
                          stroke="currentColor"
                          stroke-linecap="round"
                          stroke-linejoin="round"
                          stroke-width="2"
                          d="M9 5 5 1 1 5"></path>
                      </svg>
                    </button>
                  </div>

                  <!-- Accordion Body -->
                  <div
                    id="accordion-collapse-body-${index}"
                    class="hidden"
                    aria-labelledby="accordion-collapse-heading-${index}"
                  >
                                      <div class="p-5 border ${isLast ? "rounded-b-xl border-t-0" : "border-b-0"} border-gray-200 dark:border-gray-700 dark:bg-gray-900">
                      <!-- Project Edit Form -->
                      <form class="space-y-4" data-project-id="${project.id}">
                        <div class="project-form-container" data-project-index="${index}"></div>



                        <!-- Project Metadata (readonly) -->
                        <div class="grid grid-cols-2 gap-4 pt-2 border-t border-gray-200 dark:border-gray-600">
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Project ID:</span>
                            <div class="text-sm text-gray-800 dark:text-gray-200">${project.id}</div>
                          </div>
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Project Status:</span>
                            <div id="project-status-${project.id}" class="text-sm text-gray-800 dark:text-gray-200">${project.status || 10}</div>
                          </div>
                          <!-- Change Status -->
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Change Status:</span>
                            <select
                              class="text-sm bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 border border-gray-300 dark:border-gray-600 rounded px-2 py-1 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 project-status-select"
                              data-project-id="${project.id}"
                            >
                              ${Object.entries(PROJECT_STATUS_LABELS)
                                .map(
                                  ([code, label]) => `
                                  <option value="${code}" ${String(project.status || 10) === String(code) ? "selected" : ""}>
                                    ${code} - ${label}
                                  </option>
                                `
                                )
                                .join("")}
                            </select>
                          </div>
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Last Updated:</span>
                            <div class="text-sm text-gray-800 dark:text-gray-200">${timeSinceUpdate}</div>
                          </div>
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Assigned to:</span>
                            <select
                              id="staff-assignment-${project.id}"
                              data-project-id="${project.id}"
                              class="text-sm bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 border border-gray-300 dark:border-gray-600 rounded px-2 py-1 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 staff-assignment-select"
                            >
                              <option value="">Unassigned</option>
                              <!-- Staff options will be populated dynamically -->
                            </select>
                          </div>
                          <div>
                            <span class="text-xs text-gray-500 dark:text-gray-400">Created:</span>
                            <div class="text-sm text-gray-800 dark:text-gray-200">${new Date(project.created || project.created_at).toLocaleDateString()}</div>
                          </div>
                        </div>

                        <!-- Media Links -->
                        <div class="pt-4 border-t border-gray-200 dark:border-gray-600">
                          <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Attached Media</span>
                            <button 
                              type="button"
                              class="text-xs text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300 transition-colors"
                              onclick="window.projectsList.loadProjectFiles('${project.id}')"
                              data-project-id="${project.id}"
                            >
                              <i class="bx bx-refresh mr-1"></i>
                              Refresh
                            </button>
                          </div>
                          <div id="media-links-${project.id}" class="space-y-2">
                            <div class="text-xs text-gray-500 dark:text-gray-400 italic">Loading media...</div>
                          </div>
                        </div>

                        <!-- Media Upload Dropzone -->
                        <div class="pt-4 border-t border-gray-200 dark:border-gray-600">
                          <div class="mb-2">
                            <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Add Media Files</span>
                          </div>
                          <div 
                            id="media-dropzone-${project.id}" 
                            class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-4 text-center cursor-pointer hover:border-blue-400 dark:hover:border-blue-500 transition-colors"
                            data-project-id="${project.id}"
                            ondrop="window.projectsList.handleMediaDrop(event, '${project.id}')"
                            ondragover="window.projectsList.handleMediaDragOver(event)"
                            ondragleave="window.projectsList.handleMediaDragLeave(event)"
                            onclick="document.getElementById('media-file-input-${project.id}').click()"
                          >
                            <input 
                              type="file" 
                              id="media-file-input-${project.id}" 
                              class="hidden" 
                              multiple 
                              accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.txt,.dwg"
                              onchange="window.projectsList.handleMediaFileSelect(event, '${project.id}')"
                            />
                            <div class="flex flex-col items-center space-y-2">
                              <i class="bx bx-upload text-2xl text-gray-400 dark:text-gray-500"></i>
                              <div class="text-sm text-gray-600 dark:text-gray-400">
                                <span class="font-medium text-blue-600 dark:text-blue-400">Click to upload</span> or drag and drop
                              </div>
                              <div class="text-xs text-gray-500 dark:text-gray-400">
                                Images, videos, documents, DWG files (max 10MB each)
                              </div>
                            </div>
                          </div>
                          <div id="media-upload-progress-${project.id}" class="mt-2 hidden">
                            <div class="text-xs text-gray-600 dark:text-gray-400 mb-1">Uploading...</div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                              <div id="media-upload-bar-${project.id}" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                          </div>
                        </div>
                      </form>
                      
                      <!-- Action Buttons (Outside Form) -->
                      <div class="flex flex-wrap gap-2 pt-4 border-t border-gray-200 dark:border-gray-600">
                          <button 
                            type="button"
                            class="px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors"
                            onclick="window.projectsList.deleteProject('${project.id}')"
                          >
                            <i class="bx bx-trash mr-1"></i>
                          </button>
                         

                         
                      
                          
                          

                          <button 
                            type="button"
                            class="px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors estimate-btn"
                            data-project-id="${project.id}"
                            data-template-type="estimate"
                            data-status-show="0"
                            data-status-hide="20"
                            data-project-data='${JSON.stringify({
                              title: project.title || project.address,
                              address: project.address,
                              owner: project.owner,
                              architect: project.architect,
                              description: project.description,
                              sq_ft: project.sq_ft,
                              status:
                                PROJECT_STATUS_LABELS[
                                  (project.status ||
                                    10) as unknown as ProjectStatusCode
                                ] || "Unknown",
                            }).replace(/'/g, "&#39;")}'
                          >
                            <i class="bx bx-file-pdf mr-1"></i>
                            Build Estimate
                          </button>

                          <button 
                            type="button"
                            class="px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors edit-estimate-btn"
                            data-project-id="${project.id}"
                            data-template-type="edit-estimate"
                            data-status-show="25"
                            data-status-hide="90"
                            data-project-data='${JSON.stringify({
                              title: project.title || project.address,
                              address: project.address,
                              owner: project.owner,
                              architect: project.architect,
                              description: project.description,
                              sq_ft: project.sq_ft,
                              status:
                                PROJECT_STATUS_LABELS[
                                  (project.status ||
                                    10) as unknown as ProjectStatusCode
                                ] || "Unknown",
                            }).replace(/'/g, "&#39;")}'
                          >
                            <i class="bx bx-edit mr-1"></i>
                            Edit Estimate
                          </button>

          

                          <!-- Invoice Link Placeholder -->
                          <div id="invoice-link-${project.id}" class="hidden">
                            <!-- Invoice link will be populated here -->
                          </div>

                          <button 
                            type="button"
                            class="hidden px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors pdf-generate-btn"
                            data-project-id="${project.id}"
                            data-template-type="project-agreement"
                            data-project-data='${JSON.stringify({
                              title: project.title || project.address,
                              address: project.address,
                              owner: project.owner,
                              architect: project.architect,
                              description: project.description,
                              sq_ft: project.sq_ft,
                              status:
                                PROJECT_STATUS_LABELS[
                                  (project.status ||
                                    10) as unknown as ProjectStatusCode
                                ] || "Unknown",
                            }).replace(/'/g, "&#39;")}'
                          >
                            <i class="bx bx-file-pdf mr-1"></i>
                            PDF gen - auto-trigger
                          </button>

                          <button 
                            type="button"
                            class="hidden px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors pdf-generate-btn"
                            data-project-id="${project.id}"
                            data-template-type="affidavit"
                            data-project-data='${JSON.stringify({
                              title: project.title || project.address,
                              address: project.address,
                              owner: project.owner,
                              architect: project.architect,
                              description: project.description,
                              sq_ft: project.sq_ft,
                              status:
                                PROJECT_STATUS_LABELS[
                                  (project.status ||
                                    10) as unknown as ProjectStatusCode
                                ] || "Unknown",
                            }).replace(/'/g, "&#39;")}'
                          >
                            <i class="bx bx-file-pdf mr-1"></i>
                            Generate Affidavit
                          </button>

                          <button 
                            type="button"
                            class="hidden px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors pdf-generate-btn"
                            data-project-id="${project.id}"
                            data-template-type="project-agreement"
                            data-project-data='${JSON.stringify({
                              title: project.title || project.address,
                              address: project.address,
                              owner: project.owner,
                              architect: project.architect,
                              description: project.description,
                              sq_ft: project.sq_ft,
                              status:
                                PROJECT_STATUS_LABELS[
                                  (project.status ||
                                    10) as unknown as ProjectStatusCode
                                ] || "Unknown",
                            }).replace(/'/g, "&#39;")}'
                          >
                            <i class="bx bx-file-pdf mr-1"></i>
                            Narrative
                          </button>
                          ${
                            (() => {
                              const hasEmail =
                                project.assigned_to_email ||
                                project.author_email;
                              // Debug: Log project email data
                              console.log(`Project ${project.id} email data:`, {
                                assigned_to_email: project.assigned_to_email,
                                author_email: project.author_email,
                                hasAssignedEmail: !!project.assigned_to_email,
                                hasAuthorEmail: !!project.author_email,
                                finalEmail: hasEmail,
                                willShowButton: !!hasEmail,
                              });

                              return !!hasEmail;
                            })()
                              ? `
                          <button
                            type="button"
                            class="px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-lg hover:bg-green-700 transition-colors notify-client-btn"
                            data-project-id="${project.id}"
                            data-author-email="${project.assigned_to_email || project.author_email}"
                            onclick="window.projectsList.clientEmailHandler('${project.id}', '${project.assigned_to_email || project.author_email}')"
                          >
                            <i class="bx bx-envelope mr-1"></i>
                            Notify ${project.assigned_to_email || project.author_email}
                          </button>
                          `
                              : ""
                          }
                        </div>
                      </form>
                    </div>
                  </div>
                </div>
              `;
            })
            .join("")}
        </div>
      `;

      // Initialize accordion functionality
      setTimeout(() => {
        this.initializeAccordion(accordionId);
        this.populateFormContainers(sortedProjects);
        this.populateStaffAssignments(sortedProjects);
        
        // Apply role-based UI changes after projects are rendered
        this.applyRoleBasedChanges();

        // Initialize button groups AFTER form containers are populated
        console.log("Initializing button groups after form population");

        // Debug: Check if form containers were populated
        const formContainers = document.querySelectorAll(
          ".project-form-container"
        );
        console.log(`Found ${formContainers.length} form containers`);
        formContainers.forEach((container, index) => {
          console.log(`Form container ${index}:`, {
            hasContent: container.innerHTML.length > 0,
            contentLength: container.innerHTML.length,
            hasButtons: container.querySelectorAll("button").length,
          });
        });

        this.initializeButtonGroups(accordionId);

        // Load media files and invoice links for each project
        sortedProjects.forEach((project) => {
          setTimeout(() => {
            this.loadProjectFiles(project.id.toString());
            this.loadProjectInvoices(project.id.toString());
          }, 200); // Small delay to ensure DOM is ready
        });
      }, 100);

      // Show the project filter after projects are loaded
      if ((window as any).projectFilter) {
        (window as any).projectFilter.show();
        (window as any).projectFilter.updateCountBubbles();
        (window as any).projectFilter.updateProjectCount();
      }

      // Initialize text filter functionality
      this.initializeTextFilter(accordionId);

      // Re-initialize search filter in ProjectsNav if it exists
      if ((window as any).projectSearchFilter) {
        // Add a small delay to ensure DOM is updated
        setTimeout(() => {
          (window as any).projectSearchFilter.setupEventListeners();
        }, 200);
      }
    }

    // Function to initialize accordion functionality
    private initializeAccordion(accordionId: string) {
      const accordionElement = document.getElementById(accordionId);
      if (!accordionElement) return;

      // Find all accordion buttons
      const buttons = accordionElement.querySelectorAll(
        "[data-accordion-target]"
      );

      buttons.forEach((button) => {
        button.addEventListener("click", function (this: HTMLElement) {
          const targetId = this.getAttribute("data-accordion-target");
          const targetElement = document.querySelector(targetId as string);
          const icon = this.querySelector("[data-accordion-icon]");

          if (!targetElement) return;

          // Check if this accordion is currently open
          const isOpen = !targetElement.classList.contains("hidden");

          if (isOpen) {
            // Close this accordion
            targetElement.classList.add("hidden");
            this.setAttribute("aria-expanded", "false");
            // Remove sticky class from header
            const header = this.closest(".accordion-header");
            if (header) {
              header.classList.remove(
                "sticky",
                "top-16",
                "z-20",
                "bg-white",
                "dark:bg-gray-800"
              );
            }
            if (icon) {
              icon.classList.add("rotate-180");
            }
          } else {
            // Close all other accordions first (optional - remove if you want multiple open)
            buttons.forEach((otherButton) => {
              if (otherButton !== this) {
                const otherTargetId = otherButton.getAttribute(
                  "data-accordion-target"
                );
                const otherTarget = document.querySelector(
                  otherTargetId as string
                );
                const otherIcon = otherButton.querySelector(
                  "[data-accordion-icon]"
                );

                if (otherTarget && !otherTarget.classList.contains("hidden")) {
                  otherTarget.classList.add("hidden");
                  (otherButton as HTMLElement).setAttribute(
                    "aria-expanded",
                    "false"
                  );
                  // Remove sticky class from other headers
                  const otherHeader = otherButton.closest(".accordion-header");
                  if (otherHeader) {
                    otherHeader.classList.remove(
                      "sticky",
                      "top-16",
                      "z-20",
                      "bg-white",
                      "dark:bg-gray-800"
                    );
                  }
                  if (otherIcon) {
                    otherIcon.classList.add("rotate-180");
                  }
                }
              }
            });

            // Open this accordion
            targetElement.classList.remove("hidden");
            this.setAttribute("aria-expanded", "true");
            // Add sticky class to header when opened
            const header = this.closest(".accordion-header");
            if (header) {
              header.classList.add(
                "sticky",
                "top-16",
                "z-20",
                "bg-white",
                "dark:bg-gray-800"
              );
            }
            if (icon) {
              icon.classList.remove("rotate-180");
            }
          }
        });
      });

      console.log(`Initialized accordion with ${buttons.length} items`);
    }

    // Function to initialize text filter functionality
    private initializeTextFilter(accordionId: string) {
      const searchInput = document.getElementById(
        "project-search-input"
      ) as HTMLInputElement;
      const accordionElement = document.getElementById(accordionId);
      const clearButton = document.getElementById(
        "clear-search-btn"
      ) as HTMLButtonElement;

      if (!searchInput || !accordionElement) return;

      let debounceTimer: ReturnType<typeof setTimeout>;

      // Show/hide clear button based on input value
      const updateClearButton = () => {
        if (clearButton) {
          if (searchInput.value.trim() !== "") {
            clearButton.classList.remove("hidden");
          } else {
            clearButton.classList.add("hidden");
          }
        }
      };

      // Clear button click handler
      if (clearButton) {
        clearButton.addEventListener("click", () => {
          searchInput.value = "";
          this.filterAccordionItems(accordionId, "");
          updateClearButton();
          searchInput.focus();
        });
      }

      searchInput.addEventListener("input", (e) => {
        clearTimeout(debounceTimer);

        debounceTimer = setTimeout(() => {
          const searchTerm = (e.target as HTMLInputElement).value
            .trim()
            .toLowerCase();

          // Filter immediately on any input
          this.filterAccordionItems(accordionId, searchTerm);
          updateClearButton();
        }, 300); // Small debounce delay for better performance
      });

      // Initial state
      updateClearButton();

      console.log("Initialized text filter for accordion");
    }

    // Function to filter accordion items based on search term
    private filterAccordionItems(accordionId: string, searchTerm: string) {
      const accordionElement = document.getElementById(accordionId);
      if (!accordionElement) return;

      const accordionItems = accordionElement.querySelectorAll(
        "[data-project-status]"
      );
      let visibleCount = 0;

      accordionItems.forEach((item) => {
        const htmlItem = item as HTMLElement;

        if (searchTerm === "") {
          // When search is empty, restore visibility based on current status filter
          this.applyStatusFilter(htmlItem);
          if (htmlItem.style.display !== "none") {
            visibleCount++;
          }
        } else {
          // First check if item should be visible based on status filter
          const shouldBeVisibleByStatus =
            this.isVisibleByStatusFilter(htmlItem);

          if (!shouldBeVisibleByStatus) {
            // If hidden by status filter, keep it hidden regardless of search
            htmlItem.style.display = "none";
          } else {
            // Only search within items that pass the status filter
            const textElements =
              htmlItem.querySelectorAll("[data-search-text]");
            let textContent = "";
            textElements.forEach((el) => {
              textContent += " " + (el.textContent || "").toLowerCase();
            });

            // Check if the search term is found in the text content
            if (textContent.includes(searchTerm)) {
              htmlItem.style.display = "block";
              visibleCount++;
            } else {
              htmlItem.style.display = "none";
            }
          }
        }
      });

      // Update the search input placeholder with results count
      const searchInput = document.getElementById(
        "project-search-input"
      ) as HTMLInputElement;
      if (searchInput && searchTerm !== "") {
        searchInput.placeholder = `Showing ${visibleCount} of ${accordionItems.length} projects`;
      } else if (searchInput) {
        searchInput.placeholder = "Search your projects...";
      }

      console.log(
        `Text filter applied: "${searchTerm}" - ${visibleCount}/${accordionItems.length} items visible`
      );
    }

    // Function to load a project from the list
    loadProject(projectId: string, status: number) {
      this.currentProjectId = projectId;
      this.currentProjectStatus = status;

      // Call updateProjectButtons if it exists globally
      if ((window as any).updateProjectButtons) {
        (window as any).updateProjectButtons();
      }

      showNotification({
        type: "info",
        title: "Project Loaded",
        message: `Project ${projectId} is now active`,
        duration: 3000,
      });

      // Log event if available
      if ((window as any).logEvent) {
        (window as any).logEvent("project:loaded", { projectId, status });
      }
    }

    // Function to view project details (placeholder for future implementation)
    viewProjectDetails(projectId: string) {
      showNotification({
        type: "info",
        title: "Project Details",
        message: `Viewing details for project ${projectId}`,
        duration: 3000,
      });

      // Log event if available
      if ((window as any).logEvent) {
        (window as any).logEvent("project:details-viewed", { projectId });
      }
    }

    // Function to reset project form to original values
    resetProjectForm(projectId: string) {
      const form = document.querySelector(
        `form[data-project-id="${projectId}"]`
      ) as HTMLFormElement;
      if (!form) return;

      // Find the original project data and repopulate
      showNotification({
        type: "info",
        title: "Form Reset",
        message: `Form reset to original values for project ${projectId}`,
        duration: 2000,
      });

      // Log event if available
      if ((window as any).logEvent) {
        (window as any).logEvent("project:form-reset", { projectId });
      }
    }

    // Function to populate form containers with generated HTML
    private populateFormContainers(projects: any[]) {
      projects.forEach((project, index) => {
        const container = document.querySelector(
          `[data-project-index="${index}"]`
        ) as HTMLElement;
        if (container) {
          try {
            console.log(`Generating form for project ${project.id}:`, {
              building: project.building,
              project: project.project,
              service: project.service,
              requested_docs: project.requested_docs,
              description: project.description,
              units: project.units,
            });
            container.innerHTML = generateEditFormHTML(index, project);
            console.log(
              `Form populated for project ${project.id} at index ${index}`
            );

            // Debug: Check if units slider was created properly
            const unitsSlider = container.querySelector(
              'input[name="units"]'
            ) as HTMLInputElement;
            if (unitsSlider) {
              console.log(
                `Units slider for project ${project.id} (index ${index}):`,
                {
                  value: unitsSlider.value,
                  min: unitsSlider.min,
                  max: unitsSlider.max,
                  projectIndex: unitsSlider.dataset.projectIndex,
                  id: unitsSlider.id,
                  name: unitsSlider.name,
                  projectUnits: project.units,
                }
              );
            } else {
              console.warn(
                `No units slider found for project ${project.id} (index ${index})`
              );
            }
          } catch (error) {
            console.error("Failed to generate form HTML:", error);
            container.innerHTML =
              '<div class="text-red-500">Failed to load form</div>';
          }
        }
      });
    }

    // Function to load project statuses from database
    private async initializeProjectStatuses() {
      try {
        await loadProjectStatuses();
        console.log("Project statuses loaded successfully");
      } catch (error) {
        console.error("Failed to load project statuses:", error);
      }
    }

    // Function to handle estimate button clicks
    private async handleEstimateClick(
      projectId: string,
      projectData: any,
      isEditMode: boolean = false
    ) {
      try {
        // Check if an invoice already exists for this project
        const invoicesResponse = await fetch("/api/list-invoices");
        const invoicesData = await invoicesResponse.json();
        const existingInvoice = invoicesData.invoices?.find(
          (invoice: any) =>
            invoice.project_id.toString() === projectId.toString()
        );

        if (isEditMode || existingInvoice) {
          // Edit mode or invoice exists - go to edit
          if (existingInvoice) {
            console.log("Editing existing invoice:", existingInvoice.id);

            showNotification({
              type: "success",
              title: "Opening Invoice",
              message: `Opening invoice ${existingInvoice.invoice_number} for editing`,
              duration: 3000,
            });

            // Redirect to edit existing invoice
            setTimeout(() => {
              window.location.href = `/invoice/${existingInvoice.id}`;
            }, 500);
            return;
          } else {
            // Edit mode but no invoice exists - show error
            showNotification({
              type: "error",
              title: "No Invoice Found",
              message:
                "No invoice exists for this project yet. Use 'Build Estimate' first.",
              duration: 5000,
            });
            return;
          }
        }

        // Create mode - create new invoice
        console.log("Creating new invoice for project:", projectId);

        const response = await fetch("/api/create-invoice", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId,
            projectData,
          }),
        });

        const result = await response.json();

        if (result.success) {
          // Update project status to 20 (Estimate Created)
          try {
            const statusResponse = await fetch("/api/update-project-status", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                projectId,
                status: 20,
              }),
            });

            if (!statusResponse.ok) {
              console.warn(
                "Failed to update project status:",
                await statusResponse.text()
              );
            } else {
              console.log("Project status updated to 20");
              // Update the status query system
              StatusQuerySystem.getInstance().updateProjectStatus(
                projectId,
                20
              );
            }
          } catch (statusError) {
            console.warn("Error updating project status:", statusError);
          }

          // Refresh invoice links for this project
          setTimeout(() => {
            this.loadProjectInvoices(projectId);
          }, 500);

          showNotification({
            type: "success",
            title: "Invoice Created",
            message: `Invoice ${result.invoice.invoice_number} created successfully. Click the invoice link to view it.`,
            duration: 5000,
          });

          // Redirect to invoice page after a short delay to prevent page refresh interference
          setTimeout(() => {
            window.location.href = `/invoice/${result.invoice.id}`;
          }, 1000);
        } else {
          throw new Error(result.error || "Failed to create invoice");
        }
      } catch (error) {
        console.error("Error creating invoice:", error);
        const errorMessage =
          error instanceof Error ? error.message : "Failed to create invoice";
        showNotification({
          type: "error",
          title: "Invoice Creation Failed",
          message: errorMessage,
          duration: 5000,
        });
      }
    }

    // Function to handle client email notifications
    private async clientEmailHandler(projectId: string, authorEmail: string) {
      console.log(
        `Client email handler called for project ${projectId} and email ${authorEmail}`
      );

      // Debug: Log the email data
      console.log("Email data:", {
        projectId,
        authorEmail,
        hasEmail: !!authorEmail,
        emailLength: authorEmail?.length,
      });

      try {
        // Call the API endpoint to send magic link
        const response = await fetch("/api/send-magic-link", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: projectId,
            authorEmail: authorEmail,
          }),
        });

        const result = await response.json();

        if (!response.ok || !result.success) {
          throw new Error(result.error || "Failed to send magic link");
        }

        showNotification({
          type: "success",
          title: "Magic Link Sent",
          message: `Login link sent to ${authorEmail}`,
          duration: 3000,
        });

        console.log("Magic link sent successfully:", result);
      } catch (error) {
        console.error("Failed to send magic link:", error);
        showNotification({
          type: "error",
          title: "Failed to Send Link",
          message: "Could not send magic link. Please try again.",
          duration: 3000,
        });
      }
    }

    // Function to handle auto-save functionality
    private setupAutoSave() {

      // Debounce function to prevent too many API calls
      const debounce = (func: Function, wait: number) => {
        let timeout: NodeJS.Timeout;
        return function executedFunction(...args: any[]) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      // Auto-save function with debounced toast
      let saveToastTimeout: NodeJS.Timeout | undefined;
      const autoSaveProject = debounce(
        async (projectId: string, form: HTMLFormElement) => {
          try {
            // Clear any existing toast timeout
            if (saveToastTimeout) {
              clearTimeout(saveToastTimeout);
            }

            // Collect form data
            const formData = new FormData(form);
            const projectData: any = {};

            for (const [key, value] of formData.entries()) {
              if (key === "new_construction") {
                projectData[key] = true;
              } else if (
                key === "sq_ft" ||
                key === "units" ||
                key === "status"
              ) {
                projectData[key] = parseInt(value as string) || 0;
              } else {
                projectData[key] = value;
              }
            }

            // Handle unchecked checkbox
            if (!formData.has("new_construction")) {
              projectData.new_construction = false;
            }

            // Convert units slider to actual value
            const unitsSlider = form.querySelector(
              `input[name="units"]`
            ) as HTMLInputElement;
            if (unitsSlider) {
              const values = [
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30, 40, 50,
              ];
              const sliderIndex = parseInt(unitsSlider.value);
              projectData.units = values[sliderIndex] || 1;
            }

            // Collect button group data
            const buttonGroups = [
              "building",
              "project",
              "service",
              "requested_docs",
            ];

            buttonGroups.forEach((groupName) => {
              const groupButtons = form.querySelectorAll(
                `[data-group="${groupName}"]`
              );
              const groupType =
                groupButtons.length > 0
                  ? (groupButtons[0] as HTMLElement).dataset.type
                  : null;

              if (groupType === "radio") {
                const selectedButton = Array.from(groupButtons).find((btn) =>
                  btn.classList.contains("bg-blue-500")
                );
                if (selectedButton) {
                  projectData[groupName] = (
                    selectedButton as HTMLElement
                  ).dataset.value;
                }
              } else if (groupType === "multi-select") {
                const selectedButtons = Array.from(groupButtons).filter((btn) =>
                  btn.classList.contains("bg-blue-500")
                );
                if (selectedButtons.length > 0) {
                  projectData[groupName] = selectedButtons.map(
                    (btn) => (btn as HTMLElement).dataset.value
                  );
                }
              }
            });

            // Make API call to update project
            const requestPayload = {
              projectId,
              ...projectData,
            };

            const response = await fetch("/api/update-project-status", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(requestPayload),
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error("Auto-save API Error:", errorText);
              throw new Error(`Auto-save failed: ${errorText}`);
            }

            const result = await response.json();
            console.log("Auto-save successful:", result);

            // Show success toast after 500ms delay
            saveToastTimeout = setTimeout(() => {
              showNotification({
                type: "success",
                title: "Changes Saved",
                message: "Your project changes have been saved automatically",
                duration: 3000,
              });
            }, 500);

            // Log event if available
            if ((window as any).logEvent) {
              (window as any).logEvent("project:auto-saved", {
                projectId,
                changes: projectData,
              });
            }
          } catch (error: unknown) {
            console.error("Auto-save error:", error);

            // Show error toast immediately
            showNotification({
              type: "error",
              title: "Save Failed",
              message: "Could not save changes. Please try again.",
              duration: 5000,
            });
          }
        },
        1000
      ); // 1 second debounce

      // Listen for form changes
      document.addEventListener("input", (e) => {
        const target = e.target as HTMLElement;
        const form = target.closest("form[data-project-id]") as HTMLFormElement;
        if (!form) return;

        const projectId = form.dataset.projectId;
        if (!projectId) return;

        // Trigger auto-save
        autoSaveProject(projectId, form);
      });

      // Listen for button group changes
      document.addEventListener("click", (e) => {
        const button = (e.target as HTMLElement).closest(
          ".building-type-radio, .consulting-service-btn, .fire-service-radio, .fire-safety-service-btn"
        );
        if (!button) return;

        const form = button.closest("form[data-project-id]") as HTMLFormElement;
        if (!form) return;

        const projectId = form.dataset.projectId;
        if (!projectId) return;

        // Trigger auto-save
        autoSaveProject(projectId, form);
      });

      // Handle units slider changes
      document.addEventListener("input", (e) => {
        const slider = e.target as HTMLInputElement;
        console.log("Units slider input event:", {
          element: slider,
          name: slider.name,
          matches: slider.matches('input[name="units"]'),
          value: slider.value,
          type: slider.type,
        });

        if (!slider.matches('input[name="units"]')) return;

        const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30, 40, 50];
        const sliderIndex = parseInt(slider.value);
        const actualValue = values[sliderIndex] || 1;

        console.log("Units slider changed:", {
          sliderIndex,
          actualValue,
          projectIndex: slider.dataset.projectIndex,
          sliderValue: slider.value,
          sliderMin: slider.min,
          sliderMax: slider.max,
        });

        const projectIndex = slider.dataset.projectIndex;
        const valueDisplay = document.getElementById(
          `units-value-${projectIndex}`
        );
        if (valueDisplay) {
          valueDisplay.textContent = actualValue.toString();
        }

        // Trigger auto-save for units slider
        const form = slider.closest("form[data-project-id]") as HTMLFormElement;
        if (form) {
          const projectId = form.dataset.projectId;
          if (projectId) {
            console.log("Triggering auto-save for units slider");
            autoSaveProject(projectId, form);
          }
        }
      });

      // Handle estimate button clicks (both create and edit)
      document.addEventListener("click", (e) => {
        console.log("Click event detected:", e.target);
        const buildTarget = (e.target as HTMLElement).closest(
          ".estimate-btn, [data-template-type='estimate']"
        );
        const editTarget = (e.target as HTMLElement).closest(
          ".edit-estimate-btn, [data-template-type='edit-estimate']"
        );

        const target = buildTarget || editTarget;
        console.log("Estimate button target:", target);

        if (target) {
          console.log("Estimate button found, preventing default");
          e.preventDefault();
          e.stopPropagation();
          const projectId = (target as HTMLElement).dataset.projectId;
          const projectData = JSON.parse(
            (target as HTMLElement).dataset.projectData || "{}"
          );
          const isEditMode =
            target.classList.contains("edit-estimate-btn") ||
            (target as HTMLElement).dataset.templateType === "edit-estimate";

          console.log(
            "Project ID:",
            projectId,
            "Project Data:",
            projectData,
            "Edit Mode:",
            isEditMode
          );

          if (projectId) {
            console.log("Calling handleEstimateClick");
            this.handleEstimateClick(projectId, projectData, isEditMode);
          }
        }
      });

      // Handle project status change
      document.addEventListener("change", async (e) => {
        const target = e.target as HTMLSelectElement;
        if (!target.classList.contains("project-status-select")) return;

        const projectId = target.dataset.projectId;
        const newStatus = parseInt(target.value, 10);
        if (!projectId || Number.isNaN(newStatus)) return;

        try {
          const res = await fetch("/api/update-project-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ projectId, status: newStatus }),
          });

          if (!res.ok) {
            console.error("Failed to update project status", await res.text());
            showNotification({
              type: "error",
              title: "Update Failed",
              message: "Could not update project status.",
              duration: 2500,
            });
            return;
          }

          // Update numeric and label displays
          const numEl = document.getElementById(`project-status-${projectId}`);
          if (numEl) numEl.textContent = String(newStatus);
          const labelEl = document.getElementById(
            `project-status-label-${projectId}`
          );
          if (labelEl) {
            const label =
              PROJECT_STATUS_LABELS[
                newStatus as unknown as ProjectStatusCode
              ] || "Unknown";
            labelEl.textContent = label;
          }

          // Update visibility rules
          StatusQuerySystem.getInstance().updateProjectStatus(
            projectId,
            newStatus
          );

          showNotification({
            type: "success",
            title: "Status Updated",
            message: `Project moved to ${newStatus}`,
            duration: 2000,
          });

          // Check notification settings and send emails
          const projectsList = (window as any).projectsList;
          if (projectsList && projectsList.handleStatusChangeNotifications) {
            await projectsList.handleStatusChangeNotifications(projectId, newStatus);
          }
        } catch (err) {
          console.error("Status change error", err);
        }
      });

      // Handle status refresh button clicks
      document.addEventListener("click", (e) => {
        const target = (e.target as HTMLElement).closest(
          ".status-refresh-btn"
        ) as HTMLElement;
        if (target) {
          e.preventDefault();
          const projectId = target.dataset.projectId;
          const newStatus = parseInt(target.dataset.status || "20");
          if (projectId) {
            StatusQuerySystem.getInstance().updateProjectStatus(
              projectId,
              newStatus
            );
          }
          showNotification({
            type: "success",
            title: "Status Updated",
            message: `Project status updated to ${newStatus}`,
            duration: 2000,
          });
        }
      });
    }

    // Function to initialize button group functionality
    private initializeButtonGroups(accordionId: string) {
      const accordionElement = document.getElementById(accordionId);
      if (!accordionElement) {
        console.error("Accordion element not found:", accordionId);
        return;
      }

      // Check how many buttons we found
      const allButtons = accordionElement.querySelectorAll(
        ".building-type-radio, .consulting-service-btn, .fire-service-radio, .fire-safety-service-btn"
      );
      // console.log(`Found ${allButtons.length} form buttons in accordion`);

      // Log details about each button found (debug)
      // allButtons.forEach((button, index) => {
      //   const htmlButton = button as HTMLElement;
      //   console.log(`Button ${index}:`, {
      //     value: htmlButton.dataset.value,
      //     group: htmlButton.dataset.group,
      //     type: htmlButton.dataset.type,
      //     classes: htmlButton.className,
      //     text: htmlButton.textContent?.trim(),
      //   });
      // });

      // Handle button group clicks
      accordionElement.addEventListener("click", (e) => {
        const button = (e.target as HTMLElement).closest(
          ".building-type-radio, .consulting-service-btn, .fire-service-radio, .fire-safety-service-btn"
        );

        // Only proceed if we found a matching button
        if (!button) {
          return;
        }

        e.preventDefault();

        const value = (button as HTMLElement).dataset.value;
        const group = (button as HTMLElement).dataset.group;
        const type = (button as HTMLElement).dataset.type;

        if (!value || !group || !type) {
          return;
        }

        if (type === "radio") {
          // Single select - clear all other buttons in this group
          const groupButtons = accordionElement.querySelectorAll(
            `[data-group="${group}"]`
          );
          groupButtons.forEach((btn) => {
            btn.classList.remove(
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            btn.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600"
            );
          });

          // Set this button as selected
          button.classList.add("bg-blue-500", "text-white", "border-blue-500");
          button.classList.remove(
            "bg-white",
            "dark:bg-gray-700",
            "text-gray-700",
            "dark:text-gray-300",
            "border-gray-300",
            "dark:border-gray-600"
          );

          // Store the value for form submission
          (button as any)._selectedValue = value;
        } else if (type === "multi-select") {
          // Multi-select - toggle this button's selection
          const isSelected = button.classList.contains("bg-blue-500");

          if (isSelected) {
            // Deselect
            button.classList.remove(
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.add(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600"
            );
            (button as any)._selectedValue = null;
          } else {
            // Select
            button.classList.add(
              "bg-blue-500",
              "text-white",
              "border-blue-500"
            );
            button.classList.remove(
              "bg-white",
              "dark:bg-gray-700",
              "text-gray-700",
              "dark:text-gray-300",
              "border-gray-300",
              "dark:border-gray-600"
            );
            (button as any)._selectedValue = value;
          }
        }

        console.log(`Button ${type} selection changed:`, {
          group,
          value,
          selected: button.classList.contains("bg-blue-500"),
        });

        // Add visual feedback
        (button as HTMLElement).style.transform = "scale(1.05)";
        setTimeout(() => {
          (button as HTMLElement).style.transform = "";
        }, 150);
      });
    }

    // Helper method to check if item should be visible based on current status filter
    isVisibleByStatusFilter(htmlItem: HTMLElement): boolean {
      // Get current status filter from global projectFilter instance
      const currentFilter =
        (window as any).projectFilter?.currentFilter || "all";
      const projectStatus = htmlItem.dataset.projectStatus;

      return currentFilter === "all" || projectStatus === currentFilter;
    }

    // Helper method to apply status filter to an item
    applyStatusFilter(htmlItem: HTMLElement): void {
      if (this.isVisibleByStatusFilter(htmlItem)) {
        htmlItem.style.display = "block";
      } else {
        htmlItem.style.display = "none";
      }
    }

    // Delete project method
    async deleteProject(projectId: string) {
      if (
        !confirm(
          "Are you sure you want to delete this project? This action cannot be undone."
        )
      ) {
        return;
      }

      try {
        // Show loading state
        const deleteButton = document.querySelector(
          `button[onclick*="deleteProject('${projectId}')"]`
        ) as HTMLButtonElement;
        if (deleteButton) {
          deleteButton.disabled = true;
          deleteButton.innerHTML =
            '<i class="bx bx-loader-alt bx-spin mr-1"></i>Deleting...';
        }

        // Call the delete project API
        const response = await fetch(`/api/delete-project`, {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ projectId }),
        });

        if (!response.ok) {
          throw new Error(`Failed to delete project: ${response.statusText}`);
        }

        // Remove the project from the UI
        const projectElement = document.querySelector(
          `[data-project-id="${projectId}"]`
        );
        if (projectElement) {
          projectElement.remove();
        }

        // Show success notification
        if ((window as any).globalServices) {
          (window as any).globalServices.showNotification({
            type: "success",
            title: "Project Deleted",
            message: "Project has been successfully deleted.",
            duration: 3000,
          });
        }

        // Refresh the projects list by reloading from server
        await this.loadProjects();
      } catch (error: unknown) {
        console.error("Error deleting project:", error);

        // Show error notification
        if ((window as any).globalServices) {
          (window as any).globalServices.showNotification({
            type: "error",
            title: "Delete Failed",
            message:
              error instanceof Error
                ? error.message
                : "Failed to delete project. Please try again.",
            duration: 5000,
          });
        }

        // Reset button state
        const deleteButton = document.querySelector(
          `button[onclick*="deleteProject('${projectId}')"]`
        ) as HTMLButtonElement;
        if (deleteButton) {
          deleteButton.disabled = false;
          deleteButton.innerHTML =
            '<i class="bx bx-trash mr-1"></i>Delete Project';
        }
      }
    }

    // Load project files method
    async loadProjectFiles(projectId: string) {
      try {
        const mediaContainer = document.getElementById(
          `media-links-${projectId}`
        );
        if (!mediaContainer) {
          console.error(`Media container not found for project ${projectId}`);
          return;
        }

        // Show loading state
        mediaContainer.innerHTML =
          '<div class="text-xs text-gray-500 dark:text-gray-400 italic">Loading media...</div>';

        // Call the API to get project files
        const response = await fetch("/api/get-project-files", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ projectId }),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to fetch project files: ${response.statusText}`
          );
        }

        const data = await response.json();
        const files = data.files || [];

        if (files.length === 0) {
          mediaContainer.innerHTML =
            '<div class="text-xs text-gray-500 dark:text-gray-400 italic">No media files attached</div>';
          return;
        }

        // Generate HTML for media links
        const mediaLinksHTML = files
          .map((file: any) => {
            const fileName = file.file_name || file.name || "Unknown file";
            const fileSize = file.file_size
              ? this.formatFileSize(file.file_size)
              : "";
                    const uploadDate = file.uploaded_at
              ? this.formatTimestamp(file.uploaded_at)
              : "";
            const fileType = file.file_type || "application/pdf";

            // Determine icon based on file type
            let iconClass = "bx bx-file-pdf text-red-500";
            if (fileType.includes("image")) {
              iconClass = "bx bx-image text-green-500";
            } else if (
              fileType.includes("document") ||
              fileType.includes("word")
            ) {
              iconClass = "bx bx-file-doc text-blue-500";
            } else if (
              fileType.includes("spreadsheet") ||
              fileType.includes("excel")
            ) {
              iconClass = "bx bx-file-spreadsheet text-green-600";
            }

            return `
            <div class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded border">
              <div class="flex items-center flex-1 min-w-0">
                <i class="${iconClass} mr-2 flex-shrink-0"></i>
                <div class="flex-1 min-w-0">
                  <div class="text-sm font-medium text-gray-800 dark:text-gray-200 truncate" title="${fileName}">
                    ${fileName}
                  </div>
                  <div class="text-xs text-gray-500 dark:text-gray-400">
                    ${fileSize}${uploadDate ? `  ${uploadDate}` : ""}
                  </div>
                </div>
              </div>
              <div class="flex items-center gap-2 ml-2">
                ${
                  file.public_url
                    ? `
                <a 
                  href="${file.public_url}" 
                  target="_blank" 
                  rel="noopener noreferrer"
                  class="text-xs px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                  title="View file"
                >
                  <i class="bx bx-external-link mr-1"></i>
                  View
                </a>
                <a 
                  href="${file.public_url}" 
                  download="${fileName}"
                  class="text-xs px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition-colors"
                  title="Download file"
                >
                  <i class="bx bx-download mr-1"></i>
                  Download
                </a>
                <button 
                  onclick="window.projectsList.deleteMediaFile('${file.id}', '${fileName}', '${projectId}')"
                  class="text-xs px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
                  title="Delete file"
                >
                  <i class="bx bx-trash mr-1"></i>
                  Delete
                </button>
                `
                    : `
                <span class="text-xs text-gray-500 dark:text-gray-400 italic">File not accessible</span>
                `
                }
              </div>
            </div>
          `;
          })
          .join("");

        mediaContainer.innerHTML = mediaLinksHTML;
      } catch (error) {
        console.error("Error loading project files:", error);
        const mediaContainer = document.getElementById(
          `media-links-${projectId}`
        );
        if (mediaContainer) {
          mediaContainer.innerHTML =
            '<div class="text-xs text-red-500 dark:text-red-400 italic">Error loading media files</div>';
        }
      }
    }

    // Helper method to format file size
    private formatFileSize(bytes: number): string {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // Helper method to format timestamps with timezone
    private formatTimestamp(timestamp: string): string {
      // Configure your timezone here - change this to your local timezone
      const APP_TIMEZONE = "America/New_York"; // Examples: "America/Chicago", "America/Los_Angeles", "Europe/London", etc.
      
      const date = new Date(timestamp);
      const dateStr = date.toLocaleDateString("en-US", {timeZone: APP_TIMEZONE});
      const timeStr = date.toLocaleTimeString("en-US", {
        timeZone: APP_TIMEZONE,
        hour: '2-digit', 
        minute:'2-digit',
        timeZoneName: 'short'
      });
      
      return `${dateStr} ${timeStr}`;
    }

    // Delete media file method
    async deleteMediaFile(fileId: string, fileName: string, projectId: string) {
      // Show confirmation dialog
      const confirmed = confirm(`Are you sure you want to delete "${fileName}"? This action cannot be undone.`);
      if (!confirmed) {
        return;
      }

      // Find and disable the delete button to prevent double-clicks
      const deleteButton = document.querySelector(`button[onclick*="${fileId}"]`) as HTMLButtonElement;
      if (deleteButton) {
        deleteButton.disabled = true;
        deleteButton.innerHTML = '<i class="bx bx-loader-alt animate-spin mr-1"></i>Deleting...';
      }

      try {
        // Call delete API
        const response = await fetch("/api/delete-media-file", {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ fileId }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `Failed to delete file: ${response.statusText}`);
        }

        const result = await response.json();
        console.log("File deleted successfully:", result);

        // Refresh the media files list
        await this.loadProjectFiles(projectId);

        // Show success notification
        showNotification({
          type: "success",
          title: "File Deleted",
          message: `"${fileName}" has been deleted successfully.`,
          duration: 3000,
        });

      } catch (error) {
        console.error("Error deleting media file:", error);
        
        // Re-enable the button if there was an error
        if (deleteButton) {
          deleteButton.disabled = false;
          deleteButton.innerHTML = '<i class="bx bx-trash mr-1"></i>Delete';
        }
        
        // Show error notification
        showNotification({
          type: "error",
          title: "Delete Failed",
          message: `Failed to delete "${fileName}". Please try again.`,
          duration: 5000,
        });
      }
    }

    // Load project invoices method
    async loadProjectInvoices(projectId: string) {
      try {
        const invoiceContainer = document.getElementById(
          `invoice-link-${projectId}`
        );
        if (!invoiceContainer) {
          console.error(`Invoice container not found for project ${projectId}`);
          return;
        }

        // Call the API to get all invoices and filter by project
        const response = await fetch("/api/list-invoices");
        if (!response.ok) {
          throw new Error(`Failed to fetch invoices: ${response.statusText}`);
        }

        const data = await response.json();
        const allInvoices = data.invoices || [];

        // Filter invoices for this project
        const projectInvoices = allInvoices.filter(
          (invoice: any) =>
            invoice.project_id.toString() === projectId.toString()
        );

        if (projectInvoices.length === 0) {
          invoiceContainer.classList.add("hidden");
          return;
        }

        // Generate HTML for invoice links
        const invoiceLinksHTML = projectInvoices
          .map((invoice: any) => {
            const statusColor =
              invoice.status === "paid"
                ? "bg-green-500"
                : invoice.status === "sent"
                  ? "bg-blue-500"
                  : "bg-gray-500";

            return `
              <a 
                href="/invoice/${invoice.id}" 
                target="_blank"
                class="inline-flex items-center px-3 py-1 text-xs font-medium text-white ${statusColor} rounded-lg hover:opacity-80 transition-opacity mr-2 mb-2"
                title="Invoice ${invoice.invoice_number} - ${invoice.status}"
              >
                <i class="bx bx-receipt mr-1"></i>
                ${invoice.invoice_number}
              </a>
            `;
          })
          .join("");

        invoiceContainer.innerHTML = invoiceLinksHTML;
        invoiceContainer.classList.remove("hidden");

        // Link the Edit Estimate button directly to the latest invoice
        const editBtn = document.querySelector(
          `.edit-estimate-btn[data-project-id="${projectId}"]`
        ) as HTMLElement | null;
        if (editBtn) {
          // sort invoices by created_at descending if present, else use array order
          const latest = projectInvoices[0];
          if (latest?.id) {
            editBtn.addEventListener(
              "click",
              (e) => {
                e.preventDefault();
                e.stopPropagation();
                window.location.href = `/invoice/${latest.id}`;
              },
              { once: true }
            );
          }
        }
      } catch (error) {
        console.error("Error loading project invoices:", error);
      }
    }

    // Media upload methods
    async handleMediaDrop(event: DragEvent, projectId: string) {
      event.preventDefault();
      const files = event.dataTransfer?.files;
      if (files && files.length > 0) {
        await this.uploadMediaFiles(Array.from(files), projectId);
      }
    }

    handleMediaDragOver(event: DragEvent) {
      event.preventDefault();
      const dropzone = event.currentTarget as HTMLElement;
      dropzone.classList.add(
        "border-blue-500",
        "bg-blue-50",
        "dark:bg-blue-900/20"
      );
    }

    handleMediaDragLeave(event: DragEvent) {
      event.preventDefault();
      const dropzone = event.currentTarget as HTMLElement;
      dropzone.classList.remove(
        "border-blue-500",
        "bg-blue-50",
        "dark:bg-blue-900/20"
      );
    }

    async handleMediaFileSelect(event: Event, projectId: string) {
      const input = event.target as HTMLInputElement;
      const files = input.files;
      if (files && files.length > 0) {
        await this.uploadMediaFiles(Array.from(files), projectId);
        // Reset the input
        input.value = "";
      }
    }

    async uploadMediaFiles(files: File[], projectId: string) {
      console.log(
        `Uploading ${files.length} media files for project ${projectId}`
      );

      const progressContainer = document.getElementById(
        `media-upload-progress-${projectId}`
      );
      const progressBar = document.getElementById(
        `media-upload-bar-${projectId}`
      );

      if (progressContainer && progressBar) {
        progressContainer.classList.remove("hidden");
      }

      try {
        for (let i = 0; i < files.length; i++) {
          const file = files[i];

          // Update progress
          if (progressBar) {
            const progress = ((i + 1) / files.length) * 100;
            progressBar.style.width = `${progress}%`;
          }

          // Check file size (10MB limit)
          if (file.size > 10 * 1024 * 1024) {
            console.warn(
              `File ${file.name} is too large (${this.formatFileSize(file.size)})`
            );
            continue;
          }

          // Create FormData for upload
          const formData = new FormData();
          formData.append("file", file);
          formData.append("projectId", projectId);
          formData.append("fileType", "media");

          // Upload file
          const response = await fetch("/api/upload", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(
              `Upload failed for ${file.name}: ${response.statusText}`
            );
          }

          const result = await response.json();
          console.log(`Uploaded ${file.name}:`, result);
        }

        // Hide progress bar
        if (progressContainer) {
          progressContainer.classList.add("hidden");
          progressBar!.style.width = "0%";
        }

        // Refresh media files list
        await this.loadProjectFiles(projectId);

        // Show success message
        showNotification({
          type: "success",
          title: "Upload Complete",
          message: `Successfully uploaded ${files.length} file(s)`,
          duration: 3000,
        });
      } catch (error) {
        console.error("Error uploading media files:", error);

        // Hide progress bar
        if (progressContainer) {
          progressContainer.classList.add("hidden");
          progressBar!.style.width = "0%";
        }

        // Show error message
        showNotification({
          type: "error",
          title: "Upload Failed",
          message: "Failed to upload one or more files. Please try again.",
          duration: 5000,
        });
      }
    }

    // Generate user avatar with Google profile image or fallback
    private generateUserAvatar(
      userName: string | null,
      userId: string | null,
      avatarUrl: string | null = null
    ): string {
      if (!userId) {
        return '<i class="bx bx-file-blank"></i>';
      }

      // For client users, skip avatars entirely to prevent 429 errors
      if (this.currentUserRole === "Client") {
        return this.generateInitialsAvatar(userName, userId);
      }

      if (avatarUrl) {
        return `
          <img 
            src="${avatarUrl}" 
            alt="${userName || "User"} avatar" 
            class="h-full w-full object-cover"
            loading="lazy"
            onerror="this.handleAvatarError(this)"
          />
          <i class="bx bx-user bx-sm" style="display:none;"></i>
        `;
      } else {
        return this.generateInitialsAvatar(userName, userId);
      }
    }

    // Generate initials-based avatar
    private generateInitialsAvatar(userName: string | null, userId: string | null): string {
      if (userName) {
        // Generate initials from name
        const initials = userName
          .split(" ")
          .map((word) => word.charAt(0).toUpperCase())
          .join("")
          .slice(0, 2);

        const colors = [
          "bg-blue-500",
          "bg-green-500",
          "bg-purple-500",
          "bg-pink-500",
          "bg-indigo-500",
          "bg-yellow-500",
          "bg-red-500",
          "bg-teal-500",
          "bg-orange-500",
          "bg-cyan-500",
          "bg-lime-500",
          "bg-emerald-500",
        ];

        const colorIndex = userId
          ? parseInt(userId.replace(/[^0-9]/g, "")) % colors.length
          : userName.length % colors.length;
        const bgColor = colors[colorIndex];

        return `
          <div class="w-full h-full flex items-center justify-center ${bgColor} text-white font-semibold text-sm">
            ${initials}
          </div>
        `;
      } else {
        // Fallback to user icon with color based on userId
        const colors = [
          "bg-blue-500",
          "bg-green-500",
          "bg-purple-500",
          "bg-pink-500",
          "bg-indigo-500",
          "bg-yellow-500",
          "bg-red-500",
          "bg-teal-500",
          "bg-orange-500",
          "bg-cyan-500",
          "bg-lime-500",
          "bg-emerald-500",
        ];

        const colorIndex = userId
          ? parseInt(userId.replace(/[^0-9]/g, "")) % colors.length
          : 0;
        const bgColor = colors[colorIndex];

        return `
          <div class="w-full h-full flex items-center justify-center ${bgColor} text-white">
            <i class="bx bx-user bx-sm"></i>
          </div>
        `;
      }
    }

    // Handle avatar loading errors (prevent 429 rate limiting)
    handleAvatarError(imgElement: HTMLImageElement) {
      console.log("Avatar failed to load, falling back to icon");
      imgElement.style.display = 'none';
      const fallbackIcon = imgElement.nextElementSibling as HTMLElement;
      if (fallbackIcon) {
        fallbackIcon.style.display = 'block';
      }
      
      // Add a class to prevent retrying this avatar
      imgElement.classList.add('avatar-failed');
    }

    // Expose methods globally for external access
    private exposeGlobalMethods() {
      // Create global instance
      (window as any).projectsList = this;

      // Expose individual methods for backward compatibility
      (window as any).displayUserProjects = this.displayUserProjects.bind(this);
      (window as any).loadProject = this.loadProject.bind(this);
      (window as any).viewProjectDetails = this.viewProjectDetails.bind(this);
      (window as any).resetProjectForm = this.resetProjectForm.bind(this);
      (window as any).refreshStaffUsers = this.refreshStaffUsers.bind(this);
      (window as any).deleteProject = this.deleteProject.bind(this);
      (window as any).clientEmailHandler = this.clientEmailHandler.bind(this);
      (window as any).loadProjectFiles = this.loadProjectFiles.bind(this);
      (window as any).loadProjectInvoices = this.loadProjectInvoices.bind(this);

      // Expose media upload methods
      (window as any).handleMediaDrop = this.handleMediaDrop.bind(this);
      (window as any).handleMediaDragOver = this.handleMediaDragOver.bind(this);
      (window as any).handleMediaDragLeave =
        this.handleMediaDragLeave.bind(this);
      (window as any).handleMediaFileSelect =
        this.handleMediaFileSelect.bind(this);
    }

    // Handle status change notifications
    async handleStatusChangeNotifications(projectId: string, newStatus: number) {
      try {
        console.log(`Checking notifications for project ${projectId}, status ${newStatus}`);
        
        // Check who should be notified for this status
        const notificationResponse = await fetch("/api/check-notifications", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ projectId }),
        });

        if (!notificationResponse.ok) {
          console.error("Failed to check notifications");
          return;
        }

        const notificationData = await notificationResponse.json();
        console.log("Notification data:", notificationData);

        if (!notificationData.success || !notificationData.notify || notificationData.notify.length === 0) {
          console.log("No notifications configured for this status");
          return;
        }

        // Get project details for email content
        const project = this.projects.find((p: any) => p.id.toString() === projectId);
        if (!project) {
          console.error("Project not found");
          return;
        }

        // Get status information
        const statusLabel = PROJECT_STATUS_LABELS[newStatus as ProjectStatusCode] || `Status ${newStatus}`;
        const statusData = (window as any).PROJECT_STATUS_DATA?.[newStatus];
        
        // Send notifications to each target type
        for (const target of notificationData.notify) {
          await this.sendStatusNotification(project, newStatus, statusLabel, statusData, target);
        }

      } catch (error) {
        console.error("Error handling status change notifications:", error);
      }
    }

    // Send notification to specific target (admin, client, staff)
    async sendStatusNotification(project: any, newStatus: number, statusLabel: string, statusData: any, target: string) {
      try {
        let recipients: string[] = [];
        let recipientType = target;

        // Determine recipients based on target type
        if (target === "client") {
          // Send to project owner/author
          // Check multiple possible email fields
          const clientEmail = project.author_email || project.owner_email || project.email;
          if (clientEmail) {
            recipients = [clientEmail];
          } else {
            console.log("No client email found for project:", {
              author_email: project.author_email,
              owner_email: project.owner_email,
              email: project.email,
              owner: project.owner,
              project: project
            });
            return;
          }
        } else if (target === "admin") {
          // Send to all admin users
          const adminUsers = this.staffUsers.filter(user => user.role === "Admin");
          recipients = adminUsers.map(user => user.email).filter(email => email);
        } else if (target === "staff") {
          // Send to assigned staff member
          if (project.assigned_to_id) {
            const assignedStaff = this.staffUsers.find(s => s.id === project.assigned_to_id);
            if (assignedStaff && assignedStaff.email) {
              recipients = [assignedStaff.email];
            }
          }
        }

        if (recipients.length === 0) {
          console.log(`No recipients found for target type: ${target}`);
          return;
        }

        // Use the new sendReactEmail function for styled notifications
        await (window as any).globalServices.sendReactEmail({
          to: recipients,
          type: "project-notification",
          recipientName: target === "client" ? (project.owner || "Client") : "Team Member",
          projectTitle: project.title || project.address || `Project ${project.id}`,
          projectId: project.id.toString(),
          statusMessage: statusData?.email_content || `Your project status has been updated to "${statusLabel}".`,
          actionRequired: false,
          actionUrl: `${window.location.origin}/project/${project.id}/view`,
          actionText: "View Project",
        });

        console.log(`Status notification sent to ${recipients.join(", ")} for ${target}`);

      } catch (error) {
        console.error(`Error sending ${target} notification:`, error);
        
        // Show error toast
        showNotification({
          type: "error",
          title: "Notification Failed",
          message: `Failed to send ${target} notification`,
          duration: 5000,
        });
      }
    }
  }

  // Initialize the projects list when DOM is loaded (single instance)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      (window as any).projectsList = new ProjectsList();
    });
  } else {
    (window as any).projectsList = new ProjectsList();
  }
</script>





<script>
  import {
    PROJECT_STATUS,
    PROJECT_STATUS_LABELS,
    loadProjectStatuses,
    type ProjectStatusCode,
  } from "../lib/global-services";

  // Type definitions
  declare global {
    interface Window {
      projectFilter: ProjectFilter;
    }
  }

  class ProjectFilter {
    private container: HTMLElement | null;
    private buttonsContainer: HTMLElement | null;
    public currentFilter: string;

    constructor() {
      this.container = document.getElementById("project-filter-container");
      this.buttonsContainer = document.getElementById("status-filter-buttons");
      this.currentFilter = "all";

      this.initializeFilter();
    }

    async initializeFilter() {
      // Load project statuses first
      await loadProjectStatuses();
      
      // Then setup the filter buttons
      this.setupFilterButtons();
      this.setupEventListeners();
    }

    setupFilterButtons() {
      if (!this.buttonsContainer) return;

      // Check if status labels are loaded
      const statusEntries = Object.entries(PROJECT_STATUS_LABELS);
      
      if (statusEntries.length === 0) {
        // If no status labels loaded, show loading state
        this.buttonsContainer.innerHTML = `
          <button 
            data-status="all"
            data-count="0"
            class="filter-btn selected px-3 py-2 text-xs font-medium rounded-full border transition-colors relative
                   bg-blue-500 text-white border-blue-500"
          >
            All Projects
            <span class="ml-1 text-xs opacity-60">all</span>
          </button>
          <div class="px-3 py-2 text-xs text-gray-500">
            Loading status filters...
          </div>
        `;
        return;
      }

      // Generate filter buttons for each status
      const statusButtons = statusEntries
        .map(
          ([statusCode, label]) => `
          <button 
            data-status="${statusCode}"
            data-count="0"
            class="filter-btn px-3 py-2 text-xs font-medium rounded-full border transition-colors relative
                   bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 
                   border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-600"
          >
            ${label}
            <span class="ml-1 text-xs opacity-60">${statusCode}</span>
          </button>
        `
        )
        .join("");

      // Insert status buttons after the "All Projects" button
      this.buttonsContainer.innerHTML = `
        <button 
          data-status="all"
          data-count="0"
          class="filter-btn selected px-3 py-2 text-xs font-medium rounded-full border transition-colors relative
                 bg-blue-500 text-white border-blue-500"
        >
          All Projects
          <span class="ml-1 text-xs opacity-60">all</span>
        </button>
        ${statusButtons}
      `;
    }

    setupEventListeners() {
      if (!this.buttonsContainer) return;

      this.buttonsContainer.addEventListener("click", (event: Event) => {
        const button = (event.target as HTMLElement).closest(
          ".filter-btn"
        ) as HTMLButtonElement;
        if (!button) return;

        const status = button.dataset.status;
        if (status) {
          this.setActiveFilter(status);
          this.filterProjects(status);
        }
           button.scrollIntoView({
        behavior: "smooth", // Deslizamiento suave
        block: "nearest", // Mantiene la posicin vertical
        inline: "center", // Centra horizontalmente
      });
      });
    }

    setActiveFilter(status: string) {
      // Update visual state of buttons
      const buttons = this.buttonsContainer?.querySelectorAll(".filter-btn");

      buttons?.forEach((btn) => {
        const htmlBtn = btn as HTMLButtonElement;

        if (htmlBtn.dataset.status === status) {
          // Selected state
          htmlBtn.classList.remove(
            "bg-white",
            "dark:bg-gray-700",
            "text-gray-700",
            "dark:text-gray-300",
            "border-gray-300",
            "dark:border-gray-600",
            "hover:bg-gray-50",
            "dark:hover:bg-gray-600"
          );
          htmlBtn.classList.add(
            "selected",
            "bg-blue-500",
            "text-white",
            "border-blue-500"
          );
        } else {
          // Unselected state
          htmlBtn.classList.remove(
            "selected",
            "bg-blue-500",
            "text-white",
            "border-blue-500"
          );
          htmlBtn.classList.add(
            "bg-white",
            "dark:bg-gray-700",
            "text-gray-700",
            "dark:text-gray-300",
            "border-gray-300",
            "dark:border-gray-600",
            "hover:bg-gray-50",
            "dark:hover:bg-gray-600"
          );
        }
      });

      this.currentFilter = status;
    }

    filterProjects(status: string) {
      const projectsList = document.getElementById("projects-list");
      if (!projectsList) return;

      const projectItems = projectsList.querySelectorAll(
        "[data-project-status]"
      );

      projectItems.forEach((item) => {
        const htmlItem = item as HTMLElement;
        const projectStatus = htmlItem.dataset.projectStatus;

        if (status === "all" || projectStatus === status) {
          htmlItem.style.display = "block";
        } else {
          htmlItem.style.display = "none";
        }
      });

      // Update visible count
      this.updateProjectCount();
      
      // Re-apply any active search filter to respect the new status filter
      this.reapplySearchFilter();
    }

    updateProjectCount() {
      const projectsList = document.getElementById("projects-list");
      if (!projectsList) return;

      const visibleItems = projectsList.querySelectorAll(
        '[data-project-status]:not([style*="display: none"])'
      );
      const totalItems = projectsList.querySelectorAll("[data-project-status]");

      // Update count bubbles for each status
      this.updateCountBubbles();

      // Create or update count display
      let countDisplay = document.getElementById("filter-count");
      if (!countDisplay) {
        countDisplay = document.createElement("p");
        countDisplay.id = "filter-count";
        countDisplay.className =
          "text-sm text-gray-600 dark:text-gray-400 mt-2";
        this.container?.appendChild(countDisplay);
      }

      const filterText =
        this.currentFilter === "all"
          ? "All"
          : PROJECT_STATUS_LABELS[
              this.currentFilter as unknown as ProjectStatusCode
            ] || "Unknown";
      countDisplay.textContent = `Showing ${visibleItems.length} of ${totalItems.length} projects (${filterText})`;
    }

    updateCountBubbles() {
      const projectsList = document.getElementById("projects-list");
      if (!projectsList || !this.buttonsContainer) return;

      const allProjects = projectsList.querySelectorAll(
        "[data-project-status]"
      );
      const statusCounts: Record<string, number> = {};

      // Count projects by status
      allProjects.forEach((project) => {
        const htmlProject = project as HTMLElement;
        const status = htmlProject.dataset.projectStatus || "10";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      });

      // Update each filter button's data-count attribute
      const filterButtons =
        this.buttonsContainer.querySelectorAll(".filter-btn");
      filterButtons.forEach((button) => {
        const htmlButton = button as HTMLButtonElement;
        const status = htmlButton.dataset.status;

        if (status) {
          let count = 0;

          if (status === "all") {
            // Count all projects for "All Projects" button
            count = allProjects.length;
          } else {
            // Count projects with specific status
            count = statusCounts[status] || 0;
          }

          // Update data-count attribute (CSS will handle showing/hiding)
          htmlButton.dataset.count = count.toString();
        }
      });
    }

    show() {
      if (this.container) {
        this.container.classList.remove("hidden");
      }
    }

    hide() {
      if (this.container) {
        this.container.classList.add("hidden");
      }
    }

    reset() {
      this.setActiveFilter("all");
      this.filterProjects("all");
    }

    // Re-apply any active search filter when status filter changes
    reapplySearchFilter() {
      const searchInput = document.getElementById("project-search-input") as HTMLInputElement;
      if (searchInput && searchInput.value.trim() !== "") {
        // There's an active search, re-apply it with the new status filter
        const searchTerm = searchInput.value.trim().toLowerCase();
        (window as any).projectSearchFilter?.filterProjects(searchTerm, "projects-list");
      }
    }
  }

  // Search Filter Class for Text-based Filtering
  class ProjectSearchFilter {
    private searchInputAdmin: HTMLInputElement | null;
    private searchInputClient: HTMLInputElement | null;
    private searchInputNew: HTMLInputElement | null;

    constructor() {
      this.searchInputAdmin = document.getElementById("project-search-input") as HTMLInputElement;
      this.searchInputClient = document.getElementById("project-search-input-client") as HTMLInputElement;
              this.searchInputNew = document.getElementById("project-search") as HTMLInputElement; // Dashboard.astro search input
      this.setupEventListeners();
    }

    setupEventListeners() {
      if (this.searchInputAdmin) {
        this.setupSearchInput(this.searchInputAdmin, "projects-list");
      }
      if (this.searchInputClient) {
        this.setupSearchInput(this.searchInputClient, "client-projects-container");
      }
              // Note: Dashboard.astro search is handled by the global ProjectSearchFilter
      // and will be set up when the component loads
    }

    setupSearchInput(searchInput: HTMLInputElement, containerId: string) {
      let debounceTimer: ReturnType<typeof setTimeout>;
      let clearButtonId: string;
      
      // Determine clear button ID based on container and search input ID
      if (containerId === "projects-list") {
        clearButtonId = searchInput.id === "project-search-input" ? "clear-search-btn" : "clear-search-btn-new";
      } else {
        clearButtonId = "clear-search-btn-client";
      }
      
      const clearButton = document.getElementById(clearButtonId) as HTMLButtonElement;

      // Show/hide clear button based on input value
      const updateClearButton = () => {
        if (clearButton) {
          if (searchInput.value.trim() !== "") {
            clearButton.classList.remove("hidden");
          } else {
            clearButton.classList.add("hidden");
          }
        }
      };

      // Clear button click handler
      if (clearButton) {
        clearButton.addEventListener("click", () => {
          searchInput.value = "";
          this.filterProjects("", containerId);
          updateClearButton();
          searchInput.focus();
        });
      }

      searchInput.addEventListener("input", (e) => {
        clearTimeout(debounceTimer);

        debounceTimer = setTimeout(() => {
          const searchTerm = (e.target as HTMLInputElement).value
            .trim()
            .toLowerCase();

          this.filterProjects(searchTerm, containerId);
          updateClearButton();
        }, 300);
      });

      // Initial state
      updateClearButton();
    }

    filterProjects(searchTerm: string, containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Look for projects in various possible containers
      let projectItems: NodeListOf<Element> | Element[] = container.querySelectorAll("[data-project-status]");
      
      // If no projects found, try looking in nested accordions or lists
      if (projectItems.length === 0) {
        const hasSearchText = container.querySelectorAll("[data-search-text]").length > 0;
        if (hasSearchText) {
          projectItems = Array.from(container.querySelectorAll("*")).filter(el => el.closest("[data-search-text]"));
        } else {
          projectItems = container.querySelectorAll(".project-item, .accordion-item, [class*='project']");
        }
      }

      let visibleCount = 0;

      projectItems.forEach((item) => {
        const htmlItem = item as HTMLElement;

        if (searchTerm === "") {
          // When search is empty, restore visibility based on current status filter
          this.applyStatusFilter(htmlItem);
          if (htmlItem.style.display !== "none") {
            visibleCount++;
          }
        } else {
          // First check if item should be visible based on status filter
          const shouldBeVisibleByStatus = this.isVisibleByStatusFilter(htmlItem);
          
          if (!shouldBeVisibleByStatus) {
            // If hidden by status filter, keep it hidden regardless of search
            htmlItem.style.display = "none";
          } else {
            // Only search within items that pass the status filter
            let textContent = "";
            
            // Try data-search-text elements first
            const searchTextElements = htmlItem.querySelectorAll("[data-search-text]");
            if (searchTextElements.length > 0) {
              searchTextElements.forEach((el) => {
                textContent += " " + (el.textContent || "").toLowerCase();
              });
            } else {
              // Fallback to all text content
              textContent = (htmlItem.textContent || "").toLowerCase();
            }

            if (textContent.includes(searchTerm)) {
              htmlItem.style.display = "block";
              visibleCount++;
            } else {
              htmlItem.style.display = "none";
            }
          }
        }
      });

      // Update placeholder with results count
      const searchInput = containerId === "projects-list" ? this.searchInputAdmin : this.searchInputClient;
      if (searchInput && searchTerm !== "") {
        searchInput.placeholder = `Showing ${visibleCount} of ${projectItems.length} projects`;
      } else if (searchInput) {
        searchInput.placeholder = "Search your projects...";
      }

      console.log(`Search filter applied in ${containerId}: "${searchTerm}" - ${visibleCount}/${projectItems.length} items visible`);
    }

    reset() {
      if (this.searchInputAdmin) {
        this.searchInputAdmin.value = "";
        this.filterProjects("", "projects-list");
      }
      if (this.searchInputClient) {
        this.searchInputClient.value = "";
        this.filterProjects("", "client-projects-container");
      }
    }

    // Helper method to check if item should be visible based on current status filter
    isVisibleByStatusFilter(htmlItem: HTMLElement): boolean {
      // Get current status filter from global projectFilter instance
      const currentFilter = window.projectFilter?.currentFilter || "all";
      const projectStatus = htmlItem.dataset.projectStatus;
      
      return currentFilter === "all" || projectStatus === currentFilter;
    }

    // Helper method to apply status filter to an item
    applyStatusFilter(htmlItem: HTMLElement): void {
      if (this.isVisibleByStatusFilter(htmlItem)) {
        htmlItem.style.display = "block";
      } else {
        htmlItem.style.display = "none";
      }
    }
  }

  // Global instances
  const projectFilter = new ProjectFilter();
  const projectSearchFilter = new ProjectSearchFilter();

  // Make them globally accessible
  window.projectFilter = projectFilter;
  (window as any).projectSearchFilter = projectSearchFilter;
</script>

