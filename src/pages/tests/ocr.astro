---
import SimpleIcon from "../../components/common/SimpleIcon.astro";
import Button from "../../components/common/Button.astro";
import { globalClasses } from "../api/global/global-classes";

const { globalCardStyle } = globalClasses();

// Get environment variables for client-side use
const PUBLIC_SUPABASE_URL = import.meta.env.PUBLIC_SUPABASE_URL;
const PUBLIC_SUPABASE_ANON_KEY = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;
---

<!-- <div class="rounded-lg bg-white p-8 shadow-lg color-background"> --><!-- <h2 class="mb-6 text-2xl font-bold text-gray-900 dark:text-white">
    Create New Project from PDF
  </h2> --><!-- <div class="mb-6 rounded-lg bg-primary-50 p-4 dark:bg-primary-900/20">
    <p class="text-sm text-primary-800 dark:text-primary-200">
      <SimpleIcon name="info-circle" class="mr-2" />
      <strong>Step 2:</strong> Upload a PDF to create a new project. The project
      will be created with basic information and linked to the uploaded PDF file.
    </p>
  </div> --><!-- Dropzone -->
<div
  id="dropzone-landing"
  class="rounded-lg border-2 border-dashed border-gray-300 p-8 text-center transition-colors hover:border-sky-500 dark:border-gray-600 dark:hover:border-sky-400"
>
  <div class="space-y-4">
    <SimpleIcon name="upload" class="text-2xl text-gray-400 dark:text-gray-500" />
    <div>
      <p class="text-lg font-medium text-gray-900 dark:text-white">Drop PDF or click to browse</p>
      <p class="text-sm text-gray-500 dark:text-gray-400">Supports PDF files up to 10MB</p>
    </div>
    <input type="file" id="file-input" accept=".pdf" multiple class="hidden" />
    <Button
      id="browse-btn"
      variant="secondary"
      size="md"
      icon="upload"
      iconPosition="left"
      class="w-full"
    >
      Browse Files
    </Button>
  </div>
</div>

<!-- Upload Progress -->
<div id="upload-progress" class="mt-6 hidden">
  <h3 class="mb-4 text-lg font-medium text-gray-900 dark:text-white">Uploading...</h3>
  <div id="progress-list" class="space-y-3"></div>
</div>

<!-- Created Projects -->
<div id="uploaded-files" class="mt-6">
  <div id="files-list" class="space-y-3"></div>
</div>

<div id="pdf-meta-extractor-preview-container">
  <div style="position:relative; display:inline-block;">
    <!-- <canvas
      id="pdf-meta-extractor-canvas"
      style="width:100%;height:auto;display:block;margin:0 auto;"></canvas>
    <canvas
      id="pdf-meta-extractor-overlay"
      style="position:absolute; left:0; top:0;width: 100%;"></canvas> -->
  </div>
  <br />
  <div style="margin-top:10px;">
    <button class="pdf-meta-extractor-select-field" data-field="address" type="button"
      >Select Address</button
    >
    <button class="pdf-meta-extractor-select-field" data-field="owner" type="button"
      >Select Owner</button
    >
    <button class="pdf-meta-extractor-select-field" data-field="square_foot" type="button"
      >Select Square Foot</button
    >
    <button class="pdf-meta-extractor-select-field" data-field="image" type="button"
      >Select Image</button
    >
  </div>
</div>

<!-- PDF.js -->
<div id="pdf-viewer-container" class="mt-6" style="display:none;">
  <div class={`${globalCardStyle} p-4`}>
    <div class="mb-4 flex items-center justify-between">
      <div class="flex items-center space-x-2">
        <button
          id="pdf-prev-page"
          class="rounded bg-gray-100 px-3 py-1 text-sm text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
        >
          <SimpleIcon name="chevron-left" class="mr-1" /> Previous
        </button>
        <span id="pdf-page-info" class="text-sm text-gray-600 dark:text-gray-400">Page 1 of 1</span>
        <button
          id="pdf-next-page"
          class="rounded bg-gray-100 px-3 py-1 text-sm text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
        >
          Next <SimpleIcon name="chevron-right" class="ml-1" />
        </button>

        <button
          id="pdf-delete"
          class="rounded bg-red-500 px-3 py-1 text-sm text-white hover:bg-red-600"
        >
          <SimpleIcon name="trash" class="mr-1" /> Delete
        </button>
      </div>
    </div>
    <div
      id="pdf-canvas-container"
      class="relative flex justify-center overflow-auto rounded border border-gray-200 dark:border-gray-600"
    >
      <canvas id="pdf-canvas" style="width:100%;height:auto;display:block;margin:0 auto;"></canvas>
      <canvas id="pdf-meta-extractor-overlay" style="position:absolute; left:0; top:0;width: 100%;"
      ></canvas>
    </div>
  </div>
</div>

<div id="pdf-meta-extractor-ocr-result" style="margin-top:20px;"></div>
<div id="pdf-meta-extractor-save-container" style="margin-top:10px; display:none;">
  <span id="pdf-meta-extractor-save-status"></span>
</div>
<!-- </div> -->
<script src="../public/js/pdf.worker.min.js" defer is:inline></script>
<script src="../public/js/pdf.min.js" defer is:inline></script>

<script type="module" is:inline define:vars={{ PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY }}>
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

  class PDFMetaExtractor {
    constructor() {
      // Use environment variables passed from Astro
      this.supabaseUrl = PUBLIC_SUPABASE_URL;
      this.supabaseAnonKey = PUBLIC_SUPABASE_ANON_KEY;

      if (!this.supabaseUrl || !this.supabaseAnonKey) {
        console.error("âŒ Missing Supabase configuration");
        return;
      }

      this.supabase = createClient(this.supabaseUrl, this.supabaseAnonKey);
      this.pdfjsLib = window.pdfjsLib;

      this.dropzone = document.getElementById("dropzone-landing");
      this.fileInput = document.getElementById("file-input");
      this.browseBtn = document.getElementById("browse-btn");
      //   this.uploadProgress = document.getElementById("upload-progress");
      this.progressList = document.getElementById("progress-list");
      this.filesList = document.getElementById("files-list");
      this.previewContainer = document.getElementById("pdf-meta-extractor-preview-container");
      this.canvas = document.getElementById("pdf-meta-extractor-canvas");
      this.overlay = document.getElementById("pdf-meta-extractor-overlay");
      this.saveContainer = document.getElementById("pdf-meta-extractor-save-container");
      this.setupEventListeners();
      // if (this.uploadContainer) this.setupDragListeners();
    }

    setupEventListeners() {
      // Browse button
      this.browseBtn.addEventListener("click", () => {
        console.log("browseBtn click event triggered");
        this.fileInput.click();
      });

      // File input change
      this.fileInput.addEventListener("change", (e) => {
        console.log("fileInput change event triggered");
        handleFiles(e.target.files);
      });

      // Drag and drop events
      this.dropzone.addEventListener("dragover", (e) => {
        console.log("dropzone dragover event triggered");
        e.preventDefault();
        this.dropzone.classList.add("border-sky-500", "bg-sky-50");
        this.dropzone.classList.remove("border-gray-300");
      });

      this.dropzone.addEventListener("dragleave", (e) => {
        console.log("dropzone dragleave event triggered");
        e.preventDefault();
        this.dropzone.classList.remove("border-sky-500", "bg-sky-50");
        this.dropzone.classList.add("border-gray-300");
      });

      this.dropzone.addEventListener("drop", (e) => {
        console.log("dropzone drop event triggered");
        e.preventDefault();
        this.dropzone.classList.remove("border-sky-500", "bg-sky-50");
        this.dropzone.classList.add("border-gray-300");

        const files = e.dataTransfer.files;
        handleFiles(files);
      });
    }
  }

  // Initialize the uploader when the DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    new PDFMetaExtractor();
  });

  // Load PDF.js

  function handleFiles(files) {
    console.log("handleFiles function called");
    const pdfFiles = Array.from(files).filter(
      (file) => file.type === "application/pdf" && file.size <= 10 * 1024 * 1024 // 10MB limit
    );

    if (pdfFiles.length === 0) {
      alert("Please select valid PDF files under 10MB");
      return;
    }

    uploadFiles(pdfFiles);
  }

  async function uploadFiles(files) {
    console.log("uploadFiles function called");
    // uploadProgress.classList.remove("hidden");
    progressList.innerHTML = "";

    for (const file of files) {
      const progressItem = createProgressItem(file.name);
      progressList.appendChild(progressItem);

      try {
        // Get current user
        const {
          data: { user },
        } = await supabase.auth.getUser();
        if (!user) {
          throw new Error("User not authenticated");
        }

        // Step 1: Create new project with minimal data
        const { data: project, error: projectError } = await supabase
          .from("projects")
          .insert({
            title: `New Project - ${file.name}`,
            description: "Project created from PDF upload",
            author_id: user.id, // Temporary admin as author
            status: 0,
            sq_ft: 0,
            new_construction: false,
          })
          .select()
          .single();

        if (projectError) throw projectError;

        // Step 2: Upload PDF to storage
        const timestamp = Date.now();
        // Sanitize file name: replace spaces with underscores and remove special characters
        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, "_");
        const fileName = `${user.id}/${timestamp}_${sanitizedFileName}`;

        const { data: uploadData, error: uploadError } = await supabase.storage
          .from("project-documents")
          .upload(fileName, file, {
            cacheControl: "3600",
            upsert: false,
          });

        if (uploadError) throw uploadError;

        // Step 3: Get public URL
        const {
          data: { publicUrl },
        } = supabase.storage.from("project-documents").getPublicUrl(fileName);

        // Step 4: Create file record in database
        const { error: fileError } = await supabase.from("files").insert({
          project_id: project.id, // Using 'project_id' (integer) to link to projects table
          author_id: user.id,
          name: file.name,
          file_name: file.name,
          file_path: fileName,
          file_type: "application/pdf",
          file_size: file.size,
          status: "active",
        });

        if (fileError) throw fileError;

        // Update progress
        updateProgress(progressItem, "success", "Project created successfully");

        // Add to uploaded files list with project link
        // addToFilesList(
        //   file.name,
        //   publicUrl,
        //   uploadData.path,
        //   project.id,
        //   project.title,
        // );

        // Replace dropzone with PDF viewer
        replaceDropzoneWithPDF(file, publicUrl);
      } catch (error) {
        console.error("Upload error:", error);
        updateProgress(progressItem, "error", error.message || "Upload failed");
      }
    }

    // Hide progress after a delay
    setTimeout(() => {
      //   uploadProgress.classList.add("hidden");
    }, 3000);
  }

  function createProgressItem(fileName) {
    console.log("createProgressItem function called");
    const div = document.createElement("div");
    div.className =
      "flex items-center justify-between rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-700";
    div.innerHTML = `
      <div class="flex items-center space-x-3">
        <SimpleIcon name="pdf" class="text-sm text-red-500" />
        <span class="text-sm font-medium text-gray-900 dark:text-white">${fileName}</span>
      </div>
      <div class="flex items-center space-x-2">
        <div class="h-2 w-20 rounded-full bg-gray-200 dark:bg-gray-600">
          <div class="progress-bar h-2 rounded-full bg-sky-500 transition-all duration-300" style="width: 0%"></div>
        </div>
        <span class="progress-text text-xs text-gray-500 dark:text-gray-400">0%</span>
      </div>
    `;
    return div;
  }

  function updateProgress(progressItem, status, message) {
    console.log("updateProgress function called");
    const progressBar = progressItem.querySelector(".progress-bar");
    const progressText = progressItem.querySelector(".progress-text");

    if (status === "success") {
      progressBar.style.width = "100%";
      progressBar.className =
        "progress-bar h-2 rounded-full bg-green-500 transition-all duration-300";
      progressText.textContent = "100%";
      progressText.className = "progress-text text-xs text-green-500";
    } else if (status === "error") {
      progressBar.className =
        "progress-bar h-2 rounded-full bg-red-500 transition-all duration-300";
      progressText.textContent = "Failed";
      progressText.className = "progress-text text-xs text-red-500";
    }
  }

  // function addToFilesList(fileName, url, path, projectId, projectTitle) {
  //   const div = document.createElement("div");
  //   div.className =
  //     "flex items-center justify-between rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-700";
  //   div.innerHTML = `
  //   <div class="flex items-center space-x-3">
  //     <i class="bx bx-file-pdf bx-sm text-red-500"></i>
  //     <div>
  //       <p class="text-sm font-medium text-gray-900 dark:text-white">${fileName}</p>
  //       <p class="text-xs text-gray-500 dark:text-gray-400">Project: ${projectTitle}</p>
  //       <p class="text-xs text-gray-500 dark:text-gray-400">${new Date().toLocaleDateString()}</p>
  //     </div>
  //   </div>
  //   <div class="flex items-center space-x-2">
  //     <a href="/project/${projectId}" class="text-green-600 hover:text-green-500 dark:text-green-400 dark:hover:text-green-300" title="View Project">
  //       <i class="bx bx-folder-open bx-sm"></i>
  //     </a>
  //     <a href="${url}" target="_blank" class="text-sky-600 hover:text-sky-500 dark:text-sky-400 dark:hover:text-sky-300" title="Download PDF">
  //       <i class="bx bx-external-link bx-sm"></i>
  //     </a>
  //     <button onclick="deleteFile('${path}', ${projectId})" class="text-red-600 hover:text-red-500 dark:text-red-400 dark:hover:text-red-300" title="Delete File">
  //       <i class="bx bx-trash bx-sm"></i>
  //     </button>
  //   </div>
  // `;
  //   filesList.appendChild(div);
  // }

  // Make deleteFile function global
  window.deleteFile = async function (path, projectId) {
    console.log("deleteFile function called");
    if (confirm("Are you sure you want to delete this file and project?")) {
      try {
        // Delete file from storage
        const { error: storageError } = await supabase.storage
          .from("project-documents")
          .remove([path]);

        if (storageError) throw storageError;

        // Delete file record from database
        const { error: fileError } = await supabase.from("files").delete().eq("file_path", path);

        if (fileError) throw fileError;

        // Delete project from database
        const { error: projectError } = await supabase
          .from("projects")
          .delete()
          .eq("id", projectId);

        if (projectError) throw projectError;

        // Remove from UI
        const fileElement = document
          .querySelector(`[onclick="deleteFile('${path}', ${projectId})"]`)
          .closest("div");
        fileElement.remove();
      } catch (error) {
        console.error("Delete error:", error);
        alert("Failed to delete file and project");
      }
    }
  };

  function waitForPDFJS() {
    console.log("waitForPDFJS function called");
    return new Promise((resolve) => {
      function check() {
        if (window.pdfjsLib) {
          resolve();
        } else {
          setTimeout(check, 50);
        }
      }
      check();
    });
  }

  function replaceDropzoneWithPDF(file, pdfUrl) {
    console.log("replaceDropzoneWithPDF function called");
    // Hide the dropzone
    dropzone.style.display = "none";
    // Initialize PDF.js viewer
    waitForPDFJS().then(() => {
      initPDFViewer(file, pdfUrl);
    });
    const deleteBtn = document.getElementById("pdf-delete");
    const pdfContainer = document.getElementById("pdf-viewer-container");

    // Add event listener to show dropzone again
    deleteBtn.addEventListener("click", function () {
      dropzone.style.display = "block";
      pdfContainer.style.display = "none";
    });
  }

  function initPDFViewer(file, pdfUrl) {
    console.log("initPDFViewer function called");
    const canvas = document.getElementById("pdf-canvas");
    const prevBtn = document.getElementById("pdf-prev-page");
    const nextBtn = document.getElementById("pdf-next-page");
    const pageInfo = document.getElementById("pdf-page-info");
    // const downloadBtn = document.getElementById("pdf-download");
    // const printBtn = document.getElementById("pdf-print");
    const deleteBtn = document.getElementById("pdf-delete");
    const pdfContainer = document.getElementById("pdf-viewer-container");
    const overlay = document.getElementById("pdf-meta-extractor-overlay");
    const ocrResultDiv = document.getElementById("pdf-meta-extractor-ocr-result");

    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 1;
    let pageRendering = false;
    let pageNumPending = null;
    let scale = 1.5;

    // Load PDF.js
    const pdfjsLib = window.pdfjsLib;
    if (!pdfjsLib) {
      console.error("PDF.js not loaded");
      return;
    }

    // Set worker source if not already set
    if (!pdfjsLib.GlobalWorkerOptions || !pdfjsLib.GlobalWorkerOptions.workerSrc) {
      if (!pdfjsLib.GlobalWorkerOptions) {
        pdfjsLib.GlobalWorkerOptions = {};
      }

      pdfjsLib.GlobalWorkerOptions.workerSrc = "../js/pdf.worker.min.js";
    }

    function loadPDF() {
      console.log("loadPDF function called");
      // Use the file object directly for better compatibility
      const reader = new FileReader();
      reader.onload = function (ev) {
        const pdfData = new Uint8Array(ev.target.result);
        pdfjsLib
          .getDocument({ data: pdfData })
          .promise.then(function (pdf) {
            pdfDoc = pdf;
            totalPages = pdf.numPages;
            currentPage = 1;
            renderPage(currentPage);
            pdfContainer.style.display = "";
          })
          .catch(function (error) {
            console.error("Error loading PDF:", error);
          });
      };
      reader.readAsArrayBuffer(file);
    }

    function clearOverlay() {
      console.log("clearOverlay function called");
      const ctx = overlay.getContext("2d");
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function renderPage(num) {
      console.log("renderPage function called");
      pageRendering = true;
      pdfDoc.getPage(num).then(function (page) {
        const viewport = page.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        overlay.width = viewport.width;
        overlay.height = viewport.height;

        // clearOverlay();
        // updatePageInfo();

        const context = canvas.getContext("2d");
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
        };

        const renderTask = page.render(renderContext);
        renderTask.promise.then(function () {
          pageRendering = false;
          pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
          prevBtn.disabled = currentPage === 1;
          nextBtn.disabled = currentPage === totalPages;

          if (pageNumPending !== null) {
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });
    }

    prevBtn.addEventListener("click", function () {
      console.log("prevBtn click event triggered");
      if (currentPage <= 1) return;
      if (pageRendering) {
        pageNumPending = currentPage - 1;
      } else {
        currentPage--;
        renderPage(currentPage);
      }
    });

    nextBtn.addEventListener("click", function () {
      console.log("nextBtn click event triggered");
      if (currentPage >= totalPages) return;
      if (pageRendering) {
        pageNumPending = currentPage + 1;
      } else {
        currentPage++;
        renderPage(currentPage);
      }
    });

    deleteBtn.addEventListener("click", function () {
      console.log("deleteBtn click event triggered");
      if (confirm("Are you sure you want to delete this PDF and project?")) {
        // Remove the PDF viewer

        if (pdfContainer) {
          pdfContainer.style.display = "none";
        }

        // Show the dropzone again
        dropzone.style.display = "block";

        // Note: The actual file deletion would need to be handled separately
        // since we don't have the project ID and file path stored in this context
        // You might want to add these as data attributes to the container
        console.log("PDF viewer removed - file deletion would need additional context");
      }
    });

    // Load the PDF
    loadPDF();
  }

  // pdfjsLib.GlobalWorkerOptions.workerSrc = PDFMetaExtractorSettings.workerSrc;

  // Remove the uploadForm submit event and instead trigger upload on file input change
  // uploadForm.addEventListener('submit', function (e) {
  //     e.preventDefault();
  //     const file = fileInputPDF.files[0];
  //     if (!file) return;
  //     const reader = new FileReader();
  //     reader.onload = function (ev) {
  //         pdfData = new Uint8Array(ev.target.result);
  //         renderPDF(pdfData);
  //     };
  //     reader.readAsArrayBuffer(file);
  // });

  // fileInputPDF.addEventListener("change", function () {
  //   const file = fileInputPDF.files[0];
  //   if (!file) return;
  //   const reader = new FileReader();
  //   reader.onload = function (ev) {
  //     pdfData = new Uint8Array(ev.target.result);
  //     renderPDF(pdfData);
  //   };
  //   reader.readAsArrayBuffer(file);
  // });

  // function XXrenderPDF(data) {
  //   pdfjsLib.getDocument({ data }).promise.then(function (pdf) {
  //     pdfDoc = pdf;
  //     currentPage = 1;
  //     totalPages = pdf.numPages;
  //     renderPage(currentPage);
  //     previewContainer.style.display = "block";
  //   });
  // }

  // function XXrenderPage(num) {
  //   pdfDoc.getPage(num).then(function (page) {
  //     const viewport = page.getViewport({ scale });
  //     canvas.width = viewport.width;
  //     canvas.height = viewport.height;
  //     overlay.width = viewport.width;
  //     overlay.height = viewport.height;
  //     const ctx = canvas.getContext("2d");
  //     const renderContext = {
  //       canvasContext: ctx,
  //       viewport: viewport,
  //     };
  //     page.render(renderContext);
  //     clearOverlay();
  //     updatePageInfo();
  //     // Debug: draw a test rectangle to verify overlay visibility
  //     // const octx = overlay.getContext('2d');
  //     // octx.strokeStyle = 'blue';
  //     // octx.lineWidth = 2;
  //     // octx.setLineDash([6]);
  //     // octx.strokeRect(20, 20, 120, 80);
  //     // console.log('Overlay test rectangle drawn');
  //   });
  // }

  // function updatePageInfo() {
  //   pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
  //   prevPageBtn.disabled = currentPage === 1;
  //   nextPageBtn.disabled = currentPage === totalPages;
  // }

  // prevPageBtn.addEventListener("click", function () {
  //   if (currentPage > 1) {
  //     currentPage--;
  //     renderPage(currentPage);
  //   }
  // });

  // nextPageBtn.addEventListener("click", function () {
  //   if (currentPage < totalPages) {
  //     currentPage++;
  //     renderPage(currentPage);
  //   }
  // });
</script>

<script type="module" is:inline>
  window.addEventListener("DOMContentLoaded", () => {
    function waitForPDFJS() {
      console.log("waitForPDFJS function called (second script)");
      return new Promise((resolve) => {
        function check() {
          if (window["pdfjsLib"]) resolve();
          else setTimeout(check, 50);
        }
        check();
      });
    }

    waitForPDFJS().then(() => {
      const pdfjsLib = window["pdfjsLib"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "../js/pdf.worker.min.js";

      document.querySelectorAll("[data-pdf-holder]").forEach((container) => {
        const PDF_URL = container.getAttribute("data-pdf-holder");
        console.log("PDF_URL", PDF_URL);
        if (!PDF_URL) return;

        // Find controls relative to this container
        const parent = container.parentElement;
        const controls = parent.querySelector(".controls");
        const prevBtn = controls.querySelector(".pdf-prev-page");
        const nextBtn = controls.querySelector(".pdf-next-page");
        const pageInfo = controls.querySelector(".pdf-page-info");
        const downloadBtn = controls.querySelector(".pdf-download");
        const fieldBtns = document.querySelectorAll(".pdf-meta-extractor-select-field");
        const overlay = document.getElementById("pdf-meta-extractor-overlay");
        const ocrResultDiv = document.getElementById("pdf-meta-extractor-ocr-result");

        const saveStatus = document.getElementById("pdf-meta-extractor-save-status");

        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let canvas = null;

        let isSelecting = false;
        let startX, startY, endX, endY;
        let selectedField = null;
        let ocrText = "";
        let imageBlob = null;
        let pdfData = null;

        function loadPDF(url) {
          console.log("loadPDF function called (second script)");
          pdfjsLib.getDocument(url).promise.then(function (pdf) {
            pdfDoc = pdf;
            totalPages = pdf.numPages;
            currentPage = 1;
            renderPage(currentPage);
          });
        }

        function renderPage(num) {
          console.log("renderPage function called (second script)");
          pageRendering = true;
          pdfDoc.getPage(num).then(function (page) {
            // Responsive scaling
            const containerWidth = container.parentElement.offsetWidth || 300;
            const viewport = page.getViewport({ scale: 1 });
            const scale = containerWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });
            if (!canvas) {
              canvas = document.createElement("canvas");
              container.innerHTML = "";
              container.appendChild(canvas);
            }
            const context = canvas.getContext("2d");
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;
            const renderContext = {
              canvasContext: context,
              viewport: scaledViewport,
            };
            const renderTask = page.render(renderContext);
            renderTask.promise.then(function () {
              pageRendering = false;
              pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
              prevBtn.disabled = currentPage === 1;
              nextBtn.disabled = currentPage === totalPages;
              if (pageNumPending !== null) {
                renderPage(pageNumPending);
                pageNumPending = null;
              }
            });
          });
        }

        function clearOverlay() {
          console.log("clearOverlay function called (second script)");
          const ctx = overlay.getContext("2d");
          ctx.clearRect(0, 0, overlay.width, overlay.height);
        }
        fieldBtns.forEach((btn) => {
          btn.addEventListener("click", function () {
            console.log("fieldBtn click event triggered");
            selectedField = btn.getAttribute("data-field");
            overlay.style.pointerEvents = "auto";
            overlay.style.cursor = "crosshair";
            ocrResultDiv.textContent = "";
            // saveContainer.style.display = "none";
            clearOverlay();
            isSelecting = false;
            if (selectedField === "image") {
              // Show image preview area
              // if (!document.getElementById('pdf-meta-extractor-image-preview')) {
              const img = document.createElement("img");
              img.id = "pdf-meta-extractor-image-preview";
              img.style.maxWidth = "100%";
              img.style.display = "block";
              img.style.marginTop = "10px";
              ocrResultDiv.appendChild(img);
              // }
            } else {
              // const img = document.getElementById('pdf-meta-extractor-image-preview');
              // if (img) img.remove();
            }
          });
        });

        overlay.addEventListener("mousedown", function (e) {
          console.log("overlay mousedown event triggered");
          if (overlay.style.pointerEvents !== "auto") return;
          isSelecting = true;
          const rect = overlay.getBoundingClientRect();
          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;
          // console.log('mousedown', { startX, startY });
        });

        overlay.addEventListener("mousemove", function (e) {
          console.log("overlay mousemove event triggered");
          if (!isSelecting) return;
          const rect = overlay.getBoundingClientRect();
          endX = e.clientX - rect.left;
          endY = e.clientY - rect.top;
          // console.log('mousemove', { endX, endY });
          drawSelection();
        });

        overlay.addEventListener("mouseup", function (e) {
          console.log("overlay mouseup event triggered");
          if (!isSelecting) return;
          isSelecting = false;
          overlay.style.pointerEvents = "none";
          overlay.style.cursor = "default";
          // console.log('mouseup', { endX, endY });
          cropAndOCR();
        });

        function drawSelection() {
          console.log("drawSelection function called");
          clearOverlay();
          const ctx = overlay.getContext("2d");
          ctx.strokeStyle = "red";
          ctx.lineWidth = 6;
          ctx.setLineDash([6]);

          // Scale coordinates from CSS pixels to canvas pixels
          const overlayRect = overlay.getBoundingClientRect();
          const scaleX = overlay.width / overlayRect.width;
          const scaleY = overlay.height / overlayRect.height;

          const x = Math.min(startX, endX) * scaleX;
          const y = Math.min(startY, endY) * scaleY;
          const w = Math.abs(endX - startX) * scaleX;
          const h = Math.abs(endY - startY) * scaleY;

          ctx.strokeRect(x, y, w, h);
          // console.log('drawSelection', { x, y, w, h });
        }

        function cropAndOCR() {
          console.log("cropAndOCR function called");
          // Map overlay selection to actual canvas pixel coordinates
          const overlayRect = overlay.getBoundingClientRect();
          const scaleX = canvas.width / overlayRect.width;
          const scaleY = canvas.height / overlayRect.height;
          const sx = Math.min(startX, endX) * scaleX;
          const sy = Math.min(startY, endY) * scaleY;
          const sw = Math.abs(endX - startX) * scaleX;
          const sh = Math.abs(endY - startY) * scaleY;
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = sw;
          tempCanvas.height = sh;
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
          // document.body.appendChild(tempCanvas); // Remove or comment out after debugging
          if (selectedField === "image") {
            tempCanvas.toBlob(function (blob) {
              imageBlob = blob;
              // Show preview
              const img = document.getElementById("pdf-meta-extractor-image-preview");
              if (img) {
                img.src = URL.createObjectURL(blob);
              }
              ocrResultDiv.append(img);
              // saveContainer.style.display = 'block';
            }, "image/png");

            clearOverlay();
            return;
          }
          tempCanvas.toBlob(function (blob) {
            sendToOCR(blob);
          }, "image/png");
          clearOverlay();
        }

        function sendToOCR(blob) {
          console.log("sendToOCR function called");
          ocrResultDiv.textContent = "Processing...";
          // saveContainer.style.display = "none";
          saveStatus.textContent = "";
          const formData = new FormData();
          formData.append("file", blob, "selection.png");
          formData.append("language", "eng");
          formData.append("isOverlayRequired", "false");
          formData.append("OCREngine", "2");
          fetch("https://api.ocr.space/parse/image", {
            method: "POST",
            headers: {
              apikey: "K81932338788957", // Replace with your own key for production
            },
            body: formData,
          })
            .then((response) => response.json())
            .then((data) => {
              // console.log('OCR API response:', data);
              if (data.IsErroredOnProcessing) {
                ocrResultDiv.textContent = "OCR error: " + (data.ErrorMessage || "Unknown error");
                return;
              }
              if (data.ParsedResults && data.ParsedResults[0].ParsedText) {
                ocrText = data.ParsedResults[0].ParsedText;
                ocrResultDiv.textContent = ocrText;
                // Use the correct settings object for is_logged_in
                // if (
                //   (typeof PDFMetaExtractor !== "undefined" &&
                //     PDFMetaExtractor.is_logged_in &&
                //     selectedField) ||
                //   (typeof PDFMetaExtractorSettings !== "undefined" &&
                //     PDFMetaExtractorSettings.is_logged_in &&
                //     selectedField)
                // ) {
                //   saveContainer.style.display = "block";
                // }
              } else {
                ocrResultDiv.textContent = "No text found.";
              }
            })
            .catch((err) => {
              ocrResultDiv.textContent = "OCR failed.";
              console.error("OCR error:", err);
            });
        }

        prevBtn.addEventListener("click", function () {
          console.log("prevBtn click event triggered (second script)");
          if (currentPage <= 1) return;
          if (pageRendering) {
            pageNumPending = currentPage - 1;
          } else {
            currentPage--;
            renderPage(currentPage);
          }
        });

        nextBtn.addEventListener("click", function () {
          console.log("nextBtn click event triggered (second script)");
          if (currentPage >= totalPages) return;
          if (pageRendering) {
            pageNumPending = currentPage + 1;
          } else {
            currentPage++;
            renderPage(currentPage);
          }
        });

        downloadBtn.addEventListener("click", function () {
          console.log("downloadBtn click event triggered");
          const link = document.createElement("a");
          link.href = PDF_URL;
          link.download = PDF_URL.split("/").pop() || "document.pdf";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

        loadPDF(PDF_URL);
      });
    });
  });
</script>
