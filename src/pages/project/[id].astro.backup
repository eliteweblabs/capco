---
import App from "../../components/common/App.astro";
import SectionContainer from "../../components/common/SectionContainer.astro";
import Hero from "../../components/common/Hero.astro";
import BoxIcon from "../../components/common/BoxIcon.astro";
import ProjectForm from "../../components/project/ProjectForm.astro";
import PDFUpload from "../../components/project/PDFUpload.astro";
import SimpleProjectLog from "../../components/project/SimpleProjectLog.astro";
import ProposalManager from "../../components/project/ProposalManager.astro";
import PaymentForm from "../../components/project/PaymentForm.astro";
import Discussions from "../../components/project/Discussions.astro";
// Para cambiar idioma de textos
import { getI18N } from "@/i18n";
const { currentLocale } = Astro;
const i18n = getI18N({ currentLocale });

// Get the project ID from the URL parameter
const { id } = Astro.params;

// Check authentication
import { checkAuth } from "../../lib/auth";
import { supabase } from "../../lib/supabase";
import { supabaseAdmin } from "../../lib/supabase-admin";

const { isAuth, session, user, role } = await checkAuth(Astro.cookies);



// Server-side function to get user info directly from database
async function getUserInfoServer(userId: string) {
  // Get user metadata from auth.users table
  if (!supabaseAdmin) {
  console.error("Supabase Admin not available");
  return null;
}

  const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.getUserById(userId);

  if (authError || !authUser.user) {
    console.error("Error fetching auth user:", authError);
    return null;
  }

  if (!supabase) {
    console.error("Supabase not available");
    return null;
  }

  // Get user profile from profiles table
  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", userId)
    .single();

  // Combine auth user data with profile data
  const userInfo = {
    id: authUser.user.id,
    email: authUser.user.email,
    profile: profile || null,
    // Computed fields for easy access
    display_name:
      profile?.company_name ||
      profile?.name ||
      authUser.user.user_metadata?.full_name ||
      authUser.user.email?.split("@")[0] ||
      "Unknown User",
    company_name: profile?.company_name || null,
    name: profile?.name || null,
    role: profile?.role || "Unknown",
  };

  return userInfo;
}

// Get the tab parameter from URL query string
const tabParam = Astro.url.searchParams.get("tab");
const validTabs = [
  "project-form",
  "discussion",
  "documents",
  "proposal",
  "deliverables",
  "final-invoice",
  "activity-log",
];
const defaultTab = validTabs.includes(tabParam || "") ? tabParam : "project-form";

console.log("üåê [PROJECT] Project ID:", id);
console.log("üåê [PROJECT] Authentication check:", { isAuth, hasUser: !!user, role });
console.log("üåê [PROJECT] Request URL:", Astro.url.href);
console.log("üåê [PROJECT] Cookies:", {
  hasAccessToken: !!Astro.cookies.get("sb-access-token")?.value,
  hasRefreshToken: !!Astro.cookies.get("sb-refresh-token")?.value,
});

// Redirect if not authenticated
if (!isAuth) {
  console.log("üåê [PROJECT] Not authenticated, redirecting to login");
  return Astro.redirect("/login");
}

console.log("üåê [PROJECT] User authenticated:", { userId: user?.id, userEmail: user?.email, role });

// Fetch project data and project author profile - RLS will handle authorization
let project = null;
let projectAuthorProfile = null;
let statusLabels: Record<number, { status_name: string; [key: string]: any }> = {};

if (supabase && user) {
  // Get project data
  const { data: projectData, error: projectError } = await supabase
    .from("projects")
    .select("*")
    .eq("id", id)
    .single();

  if (projectError) {
    console.error("Error fetching project:", projectError);
    console.log("üåê [PROJECT] Project not found or no access, redirecting to dashboard");
    return Astro.redirect("/dashboard");
  } else {
    project = projectData;
    console.log("üåê [PROJECT] Project loaded:", project.title);

    // Get project author's profile data (not current user's profile)
    if (project.author_id) {
      try {
        projectAuthorProfile = await getUserInfoServer(project.author_id);
        console.log(
          "üåê [PROJECT] Project author profile loaded:",
          projectAuthorProfile?.company_name,
          "Email:",
          projectAuthorProfile?.email
        );
      } catch (error) {
        console.error("Error fetching project author profile:", error);
      }
    }

    // Get assigned user's profile data if project has an assigned user
    if (project.assigned_to_id) {
      const { data: assignedProfileData, error: assignedProfileError } = await supabase
        .from("profiles")
        .select("id, name, company_name")
        .eq("id", project.assigned_to_id)
        .single();

      if (assignedProfileError) {
        console.error("Error fetching assigned user profile:", assignedProfileError);
      } else {
        // Add assigned user name to the project data
        project.assigned_to_name = assignedProfileData.company_name || assignedProfileData.name;
        console.log("üåê [PROJECT] Assigned user profile loaded:", project.assigned_to_name);
      }
    } else {
      project.assigned_to_name = null;
    }
  }

  // Fetch status labels using API
  try {
    const statusesResponse = await fetch(`${Astro.url.origin}/api/get-project-statuses`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "X-User-Role": role || "Client",
        Cookie: `sb-access-token=${Astro.cookies.get("sb-access-token")?.value}; sb-refresh-token=${Astro.cookies.get("sb-refresh-token")?.value}`,
      },
    });

    if (statusesResponse.ok) {
      const statusesResult = await statusesResponse.json();
      if (statusesResult.success) {
        statusLabels = statusesResult.statuses || {};
        console.log("üåê [PROJECT] Status labels loaded:", Object.keys(statusLabels).length);
        console.log("üåê [PROJECT] Status labels object:", statusLabels);
        console.log("üåê [PROJECT] Current project status:", project?.status);
        console.log("üåê [PROJECT] Status label for current status:", statusLabels[project?.status]);
      }
    }
  } catch (error) {
    console.error("üåê [PROJECT] Error fetching status labels:", error);
  }
}

// Safety check - if no project was found, redirect to dashboard
if (!project) {
  console.log("üåê [PROJECT] No project data available, redirecting to dashboard");
  return Astro.redirect("/dashboard");
}

// Add debug logging for project data and Hero props
console.log("üåê [PROJECT] Project data loaded:", {
  hasProject: !!project,
  projectId: project?.id,
  projectStatus: project?.status,
  projectTitle: project?.title || project?.address,
  hasAuthorProfile: !!projectAuthorProfile,
});

console.log("üåê [PROJECT] Hero component props being passed:", {
  statusLabel: project?.status ? (statusLabels[project.status] || `Status ${project.status}`) : undefined,
  projectId: project?.id,
  userRole: role || "Client",
  hasProject: !!project,
});

// Get status color based on status code
function getStatusColor(status: number): string {
  if (status <= 50) return "blue"; // Early stages
  if (status <= 100) return "yellow"; // Invoice stages
  if (status <= 140) return "purple"; // Submittals
  if (status <= 180) return "orange"; // Final invoice
  if (status <= 220) return "green"; // Deliverables and complete
  return "gray"; // Unknown
}
---

<App title={i18n.SEO_TITLE} description={i18n.SEO_DESCRIPTION}>
  <script>
    // Client-side debugging
    console.log("üåê [PROJECT-CLIENT] Page loaded");
    console.log(
      "üåê [PROJECT-CLIENT] Project ID from URL:",
      window.location.pathname.split("/").pop()
    );
    console.log(
      "üåê [PROJECT-CLIENT] Current tab:",
      new URLSearchParams(window.location.search).get("tab")
    );
  </script>
  <Hero
    title={project?.address || project?.title || "Untitled Project"}
    description={`<span class="inline-flex items-center"><i class="bx bx-user mr-2 text-gray-500"></i>${
      projectAuthorProfile?.company_name || projectAuthorProfile?.name || "Unknown Author"
    }</span>`}
    statusLabel={project?.status
      ? (statusLabels[project.status]?.status_name || `Status ${project.status}`)
      : undefined}
    statusColor={project?.status ? getStatusColor(project.status) : undefined}
    projectId={project?.id}
    currentStatus={project?.status}
    userRole={role || "Client"}
    projectTitle={project?.title || project?.address || "Project"}
    clientEmail={(projectAuthorProfile?.email || user?.email || "Client") as string}
    project={project}
    statuses={Object.values(statusLabels)}
  />
  <SectionContainer>
    <div class="flex items-center justify-between">
      <a
        href="/dashboard"
        class="inline-flex items-center rounded-lg bg-gray-500 px-3 py-2 text-sm font-medium text-white transition-colors hover:bg-gray-600"
      >
        <BoxIcon name="arrow-back" class="mr-2" />
        Back to Projects
      </a>
    </div>

    <!-- Tab Navigation -->
    <nav
      id="project-tab-nav"
      class="scrollbar-hide relative my-4 flex gap-1 overflow-x-auto whitespace-nowrap dark:border-gray-700"
      aria-label="Tabs"
    >
      <button
        id="tab-project-form"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('project-form')"
      >
        <BoxIcon name="edit" class="mr-2 inline h-4 w-4" />
        Project Form
      </button>
      <button
        id="tab-discussion"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('discussion')"
        data-count="0"
      >
        <BoxIcon name="message-rounded-dots" class="mr-2 inline h-4 w-4" />
        Discussion
        <span class="incomplete-comments-count absolute -right-2 -top-2 flex h-5 w-5 items-center justify-center rounded-full border border-blue-500 bg-white text-xs font-medium text-blue-500 hidden">
          0
        </span>
      </button>
      <!-- {
        role === "Admin" || role === "Staff" ? (
          <button
            id="tab-comments"
            class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
            onclick="switchTab('comments')"
          >
            <BoxIcon name="file" class="mr-2 inline h-4 w-4" />
            Comments
          </button>
        ) : (
          ""
        )
      } -->
      <button
        id="tab-documents"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('documents')"
      >
        <BoxIcon name="file" class="mr-2 inline h-4 w-4" />
        Documents
      </button>
      <button
        id="tab-proposal"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('proposal')"
      >
        <BoxIcon name="grid" class="mr-2 inline h-4 w-4" />
        Proposal
      </button>
      <button
        id="tab-deliverables"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('deliverables')"
      >
        <BoxIcon name="package" class="mr-2 inline h-4 w-4" />
        Deliverables
      </button>
      <button
        id="tab-final-invoice"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('final-invoice')"
      >
        <BoxIcon name="receipt" class="mr-2 inline h-4 w-4" />
        Final Invoice
      </button>
      {role === "Admin" || role === "Staff" ? (

      <button
        id="tab-activity-log"
        class="tab-button relative mt-2 w-auto rounded-full px-4 py-2 text-sm font-medium text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        onclick="switchTab('activity-log')"
      >
        <BoxIcon name="history" class="mr-2 inline h-4 w-4" />
        Activity Log
      </button>
      ) : (
        ""
      )}
    </nav>

    <!-- Tab Content -->
    <div class="grid grid-cols-1 gap-6 lg:grid-cols-1">
      <!-- Project Form Tab -->
      <div
        id="content-project-form"
        class="tab-content rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
      >
        <ProjectForm
          project={project}
          projectId={id ?? ""}
          isNewProject={false}
          role={role}
          projectStatus={project?.status}
        />
      </div>

      <!-- Discussion Tab -->
      <div
        id="content-discussion"
        class="tab-content hidden rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
      >
        <Discussions 
          projectId={id} 
          userRole={role || "Client"} 
          userId={user?.id || ""} 
          userName={user?.user_metadata?.name || user?.email || "Unknown User"} 
        />
      </div>

      <!-- Documents Tab -->
      <div id="content-documents" class="tab-content hidden">
        <PDFUpload
          projectId={id ?? ""}
          fileType="media"
          role={role || undefined}
          projectAuthorEmail={projectAuthorProfile?.email || user?.email || "admin@capco.com"}
          status={project?.status}
        />
      </div>

      <!-- Proposal Tab -->
      <div id="content-proposal" class="tab-content hidden">
        <ProposalManager 
          projectId={id ?? ""} 
          project={project} 
          projectAuthor={projectAuthorProfile} 
          role={role || undefined}
        />
      </div>

      <!-- Deliverables Tab -->
      <div
        id="content-deliverables"
        class="tab-content hidden rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
      >
        <div class="py-8 text-center">
          <BoxIcon name="package" class="mx-auto mb-4 h-12 w-12 text-gray-400" />
          <h3 class="mb-2 text-lg font-medium text-gray-900 dark:text-white">Deliverables</h3>
          <p class="text-gray-500 dark:text-gray-400">
            Final project deliverables will be displayed here.
          </p>
        </div>
      </div>

      <!-- Final Invoice Tab -->
      <div
        id="content-final-invoice"
        class="tab-content hidden rounded-lg border border-gray-200 bg-white p-6 dark:border-gray-700 dark:bg-gray-800"
      >
        <div class="mb-6">
          <h3 class="mb-2 text-lg font-medium text-gray-900 dark:text-white">Final Invoice - Balance Due</h3>
          <p class="text-gray-500 dark:text-gray-400">
            Pay the remaining balance for your project.
          </p>
        </div>
        
        <!-- Payment Form for Final Invoice (Balance) -->
        <PaymentForm 
          invoiceId={parseInt(id ?? "0")} 
          amount={2000}
          currency="usd"
          paymentType="balance"
          clientProfile={projectAuthorProfile}
        />
      </div>

      {role === "Admin" || role === "Staff" ? (
      <!-- Activity Log Tab -->
      <div id="content-activity-log" class="tab-content hidden">
        <SimpleProjectLog projectId={parseInt(id ?? "0")} />
      </div>
      ) : (
        ""
      )}
    </div>
  </SectionContainer>
</App>

<script define:vars={{ userRole: role }}>
window.PROJECT_USER_ROLE = userRole;</script>

<script>
  // Tab switching functionality
  function switchTab(tabName: string) {
    // Hide all tab contents
    const tabContents = document.querySelectorAll(".tab-content");
    tabContents.forEach((content) => {
      content.classList.add("hidden");
    });

    // Remove active class from all tab buttons
    const tabButtons = document.querySelectorAll(".tab-button");
    tabButtons.forEach((button) => {
      button.classList.remove("active", "bg-red-500", "text-white", "border-red-500");
      button.classList.add(
        "text-gray-500",
        "hover:text-gray-700",
        "dark:text-gray-400",
        "dark:hover:text-gray-300"
      );
    });

    // Show selected tab content
    const selectedContent = document.getElementById(`content-${tabName}`);
    if (selectedContent) {
      selectedContent.classList.remove("hidden");
    }

    // Add active class to selected tab button
    const selectedButton = document.getElementById(`tab-${tabName}`);
    if (selectedButton) {
      selectedButton.classList.remove(
        "text-gray-500",
        "hover:text-gray-700",
        "dark:text-gray-400",
        "dark:hover:text-gray-300"
      );
      selectedButton.classList.add("active", "bg-red-500", "text-white", "border-red-500");

      // Center the active button in the navigation
      selectedButton.scrollIntoView({
        behavior: "smooth",
        block: "nearest",
        inline: "center",
      });
    }

    // Update URL with tab parameter (without page reload)
    const currentUrl = new URL(window.location.href);
    if (tabName === "project-form") {
      // Remove tab parameter for default tab
      currentUrl.searchParams.delete("tab");
    } else {
      // Add or update tab parameter
      currentUrl.searchParams.set("tab", tabName);
    }

    // Update browser history without reloading the page
    window.history.replaceState({}, "", currentUrl.toString());
  }

  // Initialize tabs on page load
  document.addEventListener("DOMContentLoaded", function () {
    // Get tab from URL parameter or use default
    const urlParams = new URLSearchParams(window.location.search);
    const tabFromUrl = urlParams.get("tab");
    const validTabs = [
      "project-form",
      "discussion",
      "documents",
      "proposal",
      "deliverables",
      "final-invoice",
      "activity-log",
    ];
    const initialTab = validTabs.includes(tabFromUrl || "") ? tabFromUrl! : "project-form";

    console.log("üìã [Tabs] Initializing with tab:", initialTab);

    // Switch to the initial tab
    switchTab(initialTab);
  });

  // Form handling functions - proposal functions moved to ProposalManager component

  // Discussion functionality moved to Discussions.astro component



  // All discussion functionality moved to Discussions.astro component
    const commentsList = document.getElementById("comments-list");
    if (!commentsList) return;

    console.log("üîç [DEBUG] renderDiscussions called with:", {
      userRole,
      discussionsCount: discussions.length,
      discussions: discussions.map(d => ({ id: d.id, internal: d.internal, author_id: d.author_id, parent_id: d.parent_id }))
    });

    if (discussions.length === 0) {
      commentsList.innerHTML = `
        <div class="text-center py-8 text-gray-500 dark:text-gray-400">
          <i class="bx bx-message-rounded-dots mx-auto mb-4 text-4xl"></i>
          <p>No comments yet. Be the first to start the discussion!</p>
        </div>
      `;
      return;
    }

    // Separate top-level comments and replies
    const topLevelComments = discussions.filter(d => !d.parent_id);
    const replies = discussions.filter(d => d.parent_id);

    console.log("üîç [DEBUG] Threading:", {
      topLevel: topLevelComments.length,
      replies: replies.length,
      topLevelIds: topLevelComments.map(c => c.id),
      replyParents: replies.map(r => r.parent_id)
    });

    // Debug the first few replies to see their structure
    if (replies.length > 0) {
      console.log("üîç [DEBUG] First reply structure:", replies[0]);
      console.log("üîç [DEBUG] Reply profiles:", replies.map(r => ({ id: r.id, author_id: r.author_id, profiles: r.profiles })));
    }

    // Render top-level comments with their replies
    commentsList.innerHTML = topLevelComments
      .map(
        (discussion) => {
          // Find replies for this comment
          const commentReplies = replies.filter(reply => reply.parent_id === discussion.id);
          
          return `
      <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
        <div class="flex items-start justify-between mb-3">
          <div class="flex items-center space-x-3">
            <div class="w-8 h-8 bg-red-100 dark:bg-red-900/30 rounded-full flex items-center justify-center">
              <i class="bx bx-user text-red-600 dark:text-red-400 text-sm"></i>
            </div>
            <div>
              <h4 class="font-medium text-gray-900 dark:text-white text-sm">
                ${discussion.profiles?.company_name || discussion.profiles?.display_name || discussion.profiles?.name || discussion.profiles?.email?.split("@")[0] || `User ${discussion.author_id?.slice(0, 8)}...`}
              </h4>
              <p class="text-xs text-gray-500 dark:text-gray-400">
                ${new Date(discussion.created_at).toLocaleDateString("en-US", {
                  year: "numeric",
                  month: "short",
                  day: "numeric",
                  hour: "2-digit",
                  minute: "2-digit",
                })}
              </p>
            </div>
          </div>
          ${(() => {
            const shouldShow = (userRole === "Admin" || userRole === "Staff") && discussion.internal;
            console.log("üîç [DEBUG] Badge condition:", { userRole, discussionInternal: discussion.internal, shouldShow });
            return shouldShow ? `
              <div class="flex items-center space-x-2">
                <div class="inline-flex items-center px-2 py-1 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300 text-xs font-medium rounded-full" title="Internal Comment - Only visible to Admin and Staff">
                  <i class="bx bx-lock-alt mr-1"></i>
                  Internal
                </div>
              </div>
            ` : '';
          })()}
        </div>
        <div class="prose dark:prose-invert max-w-none">
          <p class="text-gray-700 dark:text-gray-300 text-sm whitespace-pre-wrap">
            ${discussion.message}
          </p>
        </div>
        
        <!-- Admin/Staff Only: Mark Completed Toggle -->
        ${(() => {
          const shouldShowToggle = (userRole === "Admin" || userRole === "Staff");
          console.log("üîî [DISCUSSION] Toggle visibility check:", { userRole, shouldShowToggle, discussionId: discussion.id });
          return shouldShowToggle ? `
            <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-600">
              <label class="flex items-center gap-3 cursor-pointer">
                <div class="relative">
                  <input
                    type="checkbox"
                    id="completed-toggle-${discussion.id}"
                    class="sr-only peer completed-toggle"
                    data-discussion-id="${discussion.id}"
                    ${discussion.mark_completed ? 'checked' : ''}
                  />
                  <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 dark:peer-focus:ring-green-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                </div>
                <span class="text-sm text-gray-700 dark:text-gray-300">
                  <i class="bx bx-check-circle mr-1"></i>
                  Mark completed
                </span>
              </label>
            </div>
          ` : '<div class="mt-3 pt-3 text-xs text-gray-500">Toggle hidden - Admin/Staff only</div>';
        })()}
        
        <!-- Reply Button -->
        <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-600">
          <button
            class="reply-button inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300"
            data-discussion-id="${discussion.id}"
          >
            <i class="bx bx-reply mr-1"></i>
            Reply
          </button>
        </div>
        
        <!-- Render replies underneath this comment -->
        ${commentReplies.length > 0 ? `
          <div class="mt-4 space-y-3">
            ${commentReplies.map(reply => `
              <div class="ml-6 pl-4 border-l-2 border-blue-200 dark:border-blue-700 bg-blue-50 dark:bg-blue-900/20 rounded-r-lg p-3">
                <div class="flex items-start justify-between mb-2">
                  <div class="flex items-center space-x-3">
                    <div class="w-6 h-6 bg-blue-100 dark:bg-blue-900/30 rounded-full flex items-center justify-center">
                      <i class="bx bx-reply text-blue-600 dark:text-blue-400 text-xs"></i>
                    </div>
                    <div>
                      <h5 class="font-medium text-gray-900 dark:text-white text-sm">
                        ${reply.profiles?.company_name || reply.profiles?.display_name || reply.profiles?.name || reply.profiles?.email?.split("@")[0] || `User ${reply.author_id?.slice(0, 8)}...`}
                      </h5>
                      <p class="text-xs text-gray-500 dark:text-gray-400">
                        ${new Date(reply.created_at).toLocaleDateString("en-US", {
                          year: "numeric",
                          month: "short",
                          day: "numeric",
                          hour: "2-digit",
                          minute: "2-digit",
                        })}
                      </p>
                    </div>
                  </div>
                  ${(() => {
                    const shouldShow = (userRole === "Admin" || userRole === "Staff") && reply.internal;
                    return shouldShow ? `
                      <div class="flex items-center space-x-2">
                        <div class="inline-flex items-center px-2 py-1 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300 text-xs font-medium rounded-full" title="Internal Reply - Only visible to Admin and Staff">
                          <i class="bx bx-lock-alt mr-1"></i>
                          Internal
                        </div>
                      </div>
                    ` : '';
                  })()}
                </div>
                <div class="prose dark:prose-invert max-w-none">
                  <p class="text-gray-700 dark:text-gray-300 text-sm whitespace-pre-wrap">
                    ${reply.message}
                  </p>
                  <p class="text-xs text-blue-600 mt-2">‚Ü≥ Reply to comment #${reply.parent_id}</p>
                </div>
                
                <!-- Admin/Staff Only: Mark Completed Toggle for Reply -->
                ${(() => {
                  const shouldShowToggle = (userRole === "Admin" || userRole === "Staff");
                  return shouldShowToggle ? `
                    <div class="mt-2 pt-2 border-t border-gray-200 dark:border-gray-600">
                      <label class="flex items-center gap-3 cursor-pointer">
                        <div class="relative">
                          <input
                            type="checkbox"
                            id="completed-toggle-${reply.id}"
                            class="sr-only peer completed-toggle"
                            data-discussion-id="${reply.id}"
                            ${reply.mark_completed ? 'checked' : ''}
                          />
                          <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 dark:peer-focus:ring-green-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                        </div>
                        <span class="text-sm text-gray-700 dark:text-gray-300">
                          <i class="bx bx-check-circle mr-1"></i>
                          Mark completed
                        </span>
                      </label>
                    </div>
                  ` : '';
                })()}
              </div>
            `).join('')}
          </div>
        ` : ''}
      </div>
    `;
        }
      )
      .join("");
  }

  function showDiscussionError(message: string) {
    const commentsList = document.getElementById("comments-list");
    if (commentsList) {
      commentsList.innerHTML = `
        <div class="text-center py-8 text-red-500">
          <i class="bx bx-error-circle mx-auto mb-4 text-4xl"></i>
          <p>${message}</p>
        </div>
      `;
    }
  }

  function toggleCommentForm() {
    console.log("üîî [DISCUSSION] toggleCommentForm called");
    const commentForm = document.getElementById("comment-form");
    const newCommentBtn = document.getElementById("new-comment-btn");

    console.log("üîî [DISCUSSION] Elements found:", {
      commentForm: !!commentForm,
      newCommentBtn: !!newCommentBtn,
    });

    if (commentForm && newCommentBtn) {
      const isHidden = commentForm.classList.contains("hidden");
      console.log("üîî [DISCUSSION] Form is hidden:", isHidden);

      if (isHidden) {
        // Reset reply state for new comment
        (window as any).currentReplyTo = null;
        
        commentForm.classList.remove("hidden");
        newCommentBtn.textContent = "Cancel";
        newCommentBtn.innerHTML = '<i class="bx bx-x mr-2 h-4 w-4"></i>Cancel';
        
        // Reset placeholder for new comment
        const messageInput = document.getElementById("comment-message") as HTMLTextAreaElement;
        if (messageInput) {
          messageInput.placeholder = "Write your comment here... (Use @ to mention users)";
        }
        
        document.getElementById("comment-message")?.focus();
        console.log("üîî [DISCUSSION] Form shown for new comment");
      } else {
        commentForm.classList.add("hidden");
        newCommentBtn.textContent = "New Comment";
        newCommentBtn.innerHTML = '<i class="bx bx-plus mr-2 h-4 w-4"></i>New Comment';
        (document.getElementById("comment-message") as HTMLTextAreaElement).value = "";
        
        // Reset toggles if they exist
        const internalToggle = document.getElementById("internal-toggle") as HTMLInputElement;
        const smsAlertToggle = document.getElementById("sms-alert-toggle") as HTMLInputElement;
        if (internalToggle) internalToggle.checked = false;
        if (smsAlertToggle) smsAlertToggle.checked = false;
        
        console.log("üîî [DISCUSSION] Form hidden");
      }
    }
  }

  // Cancel reply form
  function cancelReply(parentCommentId: number) {
    console.log("üîî [DISCUSSION] Canceling reply for comment:", parentCommentId);
    
    // Remove the inline reply form
    const replyForm = document.querySelector('.inline-reply-form');
    if (replyForm) {
      replyForm.remove();
    }
    
    // Reset the reply state
    (window as any).currentReplyTo = null;
    
    console.log("üîî [DISCUSSION] Reply form canceled");
  }

  // Submit reply
  async function submitReply(parentCommentId: number) {
    console.log("üîî [DISCUSSION] Submitting reply for comment:", parentCommentId);
    
    const replyTextarea = document.querySelector('.reply-message-input') as HTMLTextAreaElement;
    const message = replyTextarea?.value?.trim();
    
    if (!message) {
      alert("Please enter a reply message");
      return;
    }
    
    // Get internal toggle state
    const internalToggle = document.querySelector('.reply-internal-toggle') as HTMLInputElement;
    const isInternal = internalToggle?.checked || false;
    
    try {
      // Submit the reply using the same API
      const response = await fetch("/api/add-discussion", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          projectId: currentProjectId,
          message: message,
          internal: isInternal,
          sms_alert: false, // Replies don't have SMS alerts
          parent_id: parentCommentId,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        console.log("üîî [DISCUSSION] Reply submitted successfully:", result);
        
        // Remove the reply form
        const replyForm = document.querySelector('.inline-reply-form');
        if (replyForm) {
          replyForm.remove();
        }
        
        // Reset reply state
        (window as any).currentReplyTo = null;
        
        // Reload discussions to show the new reply
        const reloadResult = await loadDiscussions(currentProjectId);
        console.log("üîî [DISCUSSION] Discussions reloaded:", reloadResult);
        
        // Show success message
        if ((window as any).showSuccess) {
          (window as any).showSuccess("Reply posted successfully!");
        }
      } else {
        const errorData = await response.json();
        console.error("üîî [DISCUSSION] Failed to submit reply:", errorData);
        
        if ((window as any).showError) {
          (window as any).showError("Failed to post reply. Please try again.");
        }
      }
    } catch (error) {
      console.error("üîî [DISCUSSION] Error submitting reply:", error);
      
      if ((window as any).showError) {
        (window as any).showError("Error posting reply. Please try again.");
      }
    }
  }

  // Make functions globally available
  (window as any).cancelReply = cancelReply;
  (window as any).submitReply = submitReply;

  async function submitComment() {
    const messageInput = document.getElementById("comment-message") as HTMLTextAreaElement;
    const message = messageInput?.value?.trim();

    if (!message) {
      alert("Please enter a message");
      return;
    }

    // Get toggle values (only if elements exist - for Admin/Staff only)
    const internalToggle = document.getElementById("internal-toggle") as HTMLInputElement;
    const smsAlertToggle = document.getElementById("sms-alert-toggle") as HTMLInputElement;
    
    const isInternal = internalToggle?.checked || false;
    const smsAlert = smsAlertToggle?.checked || false;

    const submitBtn = document.getElementById("submit-comment-btn") as HTMLButtonElement;
    if (submitBtn) {
      submitBtn.disabled = true;
      const buttonText = submitBtn.querySelector('.button-text') as HTMLElement;
      const loadingSpinner = submitBtn.querySelector('.loading-spinner') as HTMLElement;
      
      if (buttonText) buttonText.textContent = "Posting...";
      if (loadingSpinner) loadingSpinner.classList.remove('hidden');
    }

    try {
      console.log("üîî [DISCUSSION] Submitting comment:", {
        projectId: currentProjectId,
        message: message.substring(0, 50) + "...",
        internal: isInternal,
        sms_alert: smsAlert,
      });

              // Check if this is a reply
        const parentId = (window as any).currentReplyTo || null;
        
        console.log("üîî [DISCUSSION] Submitting comment with parent_id:", parentId);
        
        const response = await fetch("/api/add-discussion", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId: currentProjectId,
            message: message,
            internal: isInternal,
            sms_alert: smsAlert,
            parent_id: parentId,
          }),
        });

      console.log("üîî [DISCUSSION] Response status:", response.status);
      console.log("üîî [DISCUSSION] Response ok:", response.ok);

      const data = await response.json();

      if (data.success) {
        // Add new comment to the beginning of the list
        discussions.unshift(data.discussion);
        renderDiscussions();
        updateIncompleteCommentsCount(); // Update count after adding new comment

        // Reset form
        if (messageInput) messageInput.value = "";
        
        // Reset reply state
        (window as any).currentReplyTo = null;
        
        // Reset toggles if they exist
        const internalToggle = document.getElementById("internal-toggle") as HTMLInputElement;
        const smsAlertToggle = document.getElementById("sms-alert-toggle") as HTMLInputElement;
        if (internalToggle) internalToggle.checked = false;
        if (smsAlertToggle) smsAlertToggle.checked = false;
        
        toggleCommentForm();
      } else {
        alert("Failed to post comment: " + data.error);
      }
    } catch (error) {
      console.error("Error posting comment:", error);
      alert("Failed to post comment");
    } finally {
      if (submitBtn) {
        submitBtn.disabled = false;
        const buttonText = submitBtn.querySelector('.button-text') as HTMLElement;
        const loadingSpinner = submitBtn.querySelector('.loading-spinner') as HTMLElement;
        
        if (buttonText) buttonText.textContent = "Post Comment";
        if (loadingSpinner) loadingSpinner.classList.add('hidden');
      }
    }
  }

  // Mention system variables
  let mentionableUsers: Array<{id: string, name: string, role: string}> = [];
  let currentMentionStart = -1;
  let currentMentionQuery = "";

  // Load mentionable users
  
  async function loadMentionableUsers() {
    if (!currentProjectId) return;
    
    try {
      const response = await fetch(`/api/get-mentionable-users?projectId=${currentProjectId}`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      const data = await response.json();
      
      if (data.success) {
        mentionableUsers = data.users;
        console.log("üîç [MENTIONS] Loaded users:", mentionableUsers);
      } else {
        console.error("üîç [MENTIONS] API error:", data.error);
      }
    } catch (error) {
      console.error("Failed to load mentionable users:", error);
    }
  }

  // Show mention dropdown
  function showMentionDropdown(query: string, position: number) {
    const dropdown = document.getElementById("mention-dropdown");
    const textarea = document.getElementById("comment-message") as HTMLTextAreaElement;
    
    if (!dropdown || !textarea) return;

    const filteredUsers = mentionableUsers.filter(user => 
      user.name.toLowerCase().includes(query.toLowerCase())
    );

    if (filteredUsers.length === 0) {
      hideMentionDropdown();
      return;
    }

    dropdown.innerHTML = filteredUsers.map((user, index) => `
      <div 
        class="mention-item cursor-pointer px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 ${index === 0 ? 'bg-gray-50 dark:bg-gray-600' : ''}"
        data-user-id="${user.id}"
        data-user-name="${user.name}"
        data-index="${index}"
      >
        <span class="font-medium">${user.name}</span>
        <span class="ml-2 text-sm text-gray-500 dark:text-gray-400">(${user.role})</span>
      </div>
    `).join("");

    dropdown.classList.remove("hidden");

    // Add click handlers
    dropdown.querySelectorAll(".mention-item").forEach(item => {
      item.addEventListener("click", () => {
        const userName = item.getAttribute("data-user-name");
        insertMention(userName || "");
      });
    });
  }

  // Hide mention dropdown
  function hideMentionDropdown() {
    const dropdown = document.getElementById("mention-dropdown");
    if (dropdown) {
      dropdown.classList.add("hidden");
    }
    currentMentionStart = -1;
    currentMentionQuery = "";
  }

  // Insert mention into textarea
  function insertMention(userName: string) {
    const textarea = document.getElementById("comment-message") as HTMLTextAreaElement;
    if (!textarea || currentMentionStart === -1) return;

    const value = textarea.value;
    const beforeMention = value.substring(0, currentMentionStart);
    const afterMention = value.substring(textarea.selectionStart);
    
    const newValue = beforeMention + `@${userName} ` + afterMention;
    textarea.value = newValue;
    
    // Set cursor position after the mention
    const newCursorPos = beforeMention.length + userName.length + 2;
    textarea.setSelectionRange(newCursorPos, newCursorPos);
    
    hideMentionDropdown();
    textarea.focus();
  }

  // Handle mention input
  function handleMentionInput() {
    const textarea = document.getElementById("comment-message") as HTMLTextAreaElement;
    if (!textarea) return;

    const value = textarea.value;
    const cursorPos = textarea.selectionStart;
    
    // Find @ symbol before cursor
    let atPos = -1;
    for (let i = cursorPos - 1; i >= 0; i--) {
      if (value[i] === "@") {
        atPos = i;
        break;
      }
      if (value[i] === " " || value[i] === "\n") {
        break;
      }
    }

    if (atPos !== -1) {
      const query = value.substring(atPos + 1, cursorPos);
      if (query.length >= 0 && !query.includes(" ") && !query.includes("\n")) {
        currentMentionStart = atPos;
        currentMentionQuery = query;
        showMentionDropdown(query, cursorPos);
        return;
      }
    }

    hideMentionDropdown();
  }

  // Initialize discussion functionality when discussion tab is shown
  function initializeDiscussion() {
    // Set user role from server-side data (already set via define:vars)
    userRole = (window as any).PROJECT_USER_ROLE || 'Client';
    console.log("üîî [DISCUSSION] User role set to:", userRole);
    
    // Make user role available globally for reply forms
    (window as any).currentUserRole = userRole;
    
    const discussionContainer = document.getElementById("discussion-container");
    if (discussionContainer) {
      currentProjectId = discussionContainer.dataset.projectId || "";
      if (currentProjectId) {
        loadDiscussions(currentProjectId);
        loadMentionableUsers();
      }
    }

    // Remove existing event listeners to prevent duplicates
    const newCommentBtn = document.getElementById("new-comment-btn");
    const cancelCommentBtn = document.getElementById("cancel-comment-btn");
    const submitCommentBtn = document.getElementById("submit-comment-btn");
    const commentTextarea = document.getElementById("comment-message") as HTMLTextAreaElement;

    if (newCommentBtn) {
      // Remove all existing event listeners by cloning the node
      const newBtn = newCommentBtn.cloneNode(true) as HTMLButtonElement;
      newCommentBtn.parentNode?.replaceChild(newBtn, newCommentBtn);
      
      // Add single clean event listener
      newBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log("üîî [DISCUSSION] New comment button clicked!");
        toggleCommentForm();
      });
    }

    if (cancelCommentBtn) {
      cancelCommentBtn.removeEventListener("click", toggleCommentForm);
      cancelCommentBtn.addEventListener("click", toggleCommentForm);
    }

    if (submitCommentBtn) {
      submitCommentBtn.removeEventListener("click", submitComment);
      submitCommentBtn.addEventListener("click", submitComment);
    }

    // Add mention functionality to textarea
    if (commentTextarea) {
      commentTextarea.addEventListener("input", handleMentionInput);
      commentTextarea.addEventListener("keydown", (e) => {
        const dropdown = document.getElementById("mention-dropdown");
        if (!dropdown || dropdown.classList.contains("hidden")) return;

        const items = dropdown.querySelectorAll(".mention-item");
        const selected = dropdown.querySelector(".mention-item.bg-gray-50, .mention-item.dark\\:bg-gray-600");
        let selectedIndex = 0;
        
        if (selected) {
          selectedIndex = parseInt(selected.getAttribute("data-index") || "0");
        }

        if (e.key === "ArrowDown") {
          e.preventDefault();
          const nextIndex = Math.min(selectedIndex + 1, items.length - 1);
          items.forEach((item, i) => {
            item.classList.toggle("bg-gray-50", i === nextIndex);
            item.classList.toggle("dark:bg-gray-600", i === nextIndex);
          });
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          const prevIndex = Math.max(selectedIndex - 1, 0);
          items.forEach((item, i) => {
            item.classList.toggle("bg-gray-50", i === prevIndex);
            item.classList.toggle("dark:bg-gray-600", i === prevIndex);
          });
        } else if (e.key === "Enter" || e.key === "Tab") {
          e.preventDefault();
          const selectedItem = items[selectedIndex];
          if (selectedItem) {
            const userName = selectedItem.getAttribute("data-user-name");
            if (userName) insertMention(userName);
          }
        } else if (e.key === "Escape") {
          e.preventDefault();
          hideMentionDropdown();
        }
      });

      // Hide dropdown when clicking outside
      document.addEventListener("click", (e) => {
        const dropdown = document.getElementById("mention-dropdown");
        const textarea = document.getElementById("comment-message");
        if (dropdown && !dropdown.contains(e.target as Node) && e.target !== textarea) {
          hideMentionDropdown();
        }
      });
    }

    // Add event delegation for completed toggles
    document.addEventListener("change", (e) => {
      const target = e.target as HTMLElement;
      if (target.classList.contains("completed-toggle")) {
        const discussionId = parseInt(target.getAttribute("data-discussion-id") || "0");
        const isCompleted = (target as HTMLInputElement).checked;
        if (discussionId) {
          toggleDiscussionCompleted(discussionId, isCompleted);
        }
      }
    });

    // Add event delegation for reply buttons
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      
      // Only log clicks on buttons or elements that might be reply-related
      if (target.tagName === 'BUTTON' || target.closest('button') || target.classList.contains('reply-button')) {
        console.log("üîî [DISCUSSION] Click event on:", target.tagName, target.className, target.textContent?.trim());
      }
      
      if (target.classList.contains("reply-button") || target.closest(".reply-button")) {
        console.log("üîî [DISCUSSION] Reply button clicked!");
        const button = target.classList.contains("reply-button") ? target : target.closest(".reply-button");
        if (button) {
          const discussionId = parseInt(button.getAttribute("data-discussion-id") || "0");
          console.log("üîî [DISCUSSION] Discussion ID from button:", discussionId);
          if (discussionId) {
            showReplyForm(discussionId);
          }
        }
      }
    });

    console.log("üîî [DISCUSSION] Event listeners attached");
  }

  // Create enhanced switchTab function that initializes discussion
  function enhancedSwitchTab(tabName: string) {
    switchTab(tabName);

    if (tabName === "discussion") {
      // Small delay to ensure DOM is ready
      setTimeout(initializeDiscussion, 100);
    }
  }

  // Also initialize discussion functionality on page load if discussion tab is active
  document.addEventListener("DOMContentLoaded", function () {
    const urlParams = new URLSearchParams(window.location.search);
    const tabFromUrl = urlParams.get("tab");

    if (tabFromUrl === "discussion") {
      console.log("üîî [DISCUSSION] Discussion tab active on page load, initializing...");
      setTimeout(initializeDiscussion, 200);
    }
  });

  // Make functions globally available
  (window as any).switchTab = enhancedSwitchTab;
  
  // Show reply form for a specific comment
  function showReplyForm(parentCommentId: number) {
    console.log("üîî [DISCUSSION] showReplyForm called with:", parentCommentId);
    
    // First, hide any existing inline reply forms
    const existingReplyForms = document.querySelectorAll('.inline-reply-form');
    existingReplyForms.forEach(form => form.remove());
    
    // Find the comment element to reply to
    const commentElement = document.querySelector(`[data-discussion-id="${parentCommentId}"]`);
    if (!commentElement) {
      console.error("üîî [DISCUSSION] Comment element not found for ID:", parentCommentId);
      return;
    }
    
    // Create inline reply form
    const replyFormHTML = `
      <div class="inline-reply-form mt-3 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-600">
        <!-- Textarea -->
        <div class="relative">
          <textarea
            class="reply-message-input w-full resize-none rounded-lg border border-gray-300 p-3 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            placeholder="Write your reply here... (Use @ to mention users)"
            rows="3"
          ></textarea>
        </div>
        
        <!-- Admin/Staff Only Toggles for Reply -->
        ${(() => {
          const userRole = (window as any).currentUserRole || 'Client';
          return (userRole === "Admin" || userRole === "Staff") ? `
            <div class="mt-3 flex flex-wrap gap-6 border-t border-gray-200 pt-3 dark:border-gray-600">
              <!-- Internal Only Toggle -->
              <label class="flex items-center gap-3 cursor-pointer">
                <div class="relative">
                  <input
                    type="checkbox"
                    class="reply-internal-toggle sr-only peer"
                  />
                  <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-red-300 dark:peer-focus:ring-red-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                </div>
                <span class="text-sm text-gray-700 dark:text-gray-300">
                  <i class="bx bx-lock mr-1"></i>
                  Internal Only
                </span>
              </label>
            </div>
          ` : '';
        })()}
        
        <!-- Buttons Row -->
        <div class="mt-3 flex items-center justify-between">
          <button
            class="cancel-reply-btn px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
            onclick="window.cancelReply(${parentCommentId})"
          >
            Cancel
          </button>
          <button
            class="submit-reply-btn rounded-lg bg-blue-600 px-4 py-2 text-white transition-colors hover:bg-blue-700"
            onclick="window.submitReply(${parentCommentId})"
          >
            <i class="bx bx-send mr-2"></i>
            Post Reply
          </button>
        </div>
      </div>
    `;
    
    // Insert the reply form after the comment
    commentElement.insertAdjacentHTML('afterend', replyFormHTML);
    
    // Set the parent comment ID for the reply
    (window as any).currentReplyTo = parentCommentId;
    
    // Focus on the reply textarea
    const replyTextarea = document.querySelector('.reply-message-input') as HTMLTextAreaElement;
    if (replyTextarea) {
      replyTextarea.focus();
    }
    
    console.log("üîî [DISCUSSION] Inline reply form created for comment:", parentCommentId);
    console.log("üîî [DISCUSSION] currentReplyTo set to:", (window as any).currentReplyTo);
  }

  // Toggle discussion completed status
  async function toggleDiscussionCompleted(discussionId: number, isCompleted: boolean) {
    try {
      console.log("üîî [DISCUSSION] Toggling completed status:", { discussionId, isCompleted });
      
      const response = await fetch("/api/update-discussion-completed", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          discussionId: discussionId,
          mark_completed: isCompleted,
        }),
      });

      const data = await response.json();

      if (data.success) {
        console.log("‚úÖ [DISCUSSION] Discussion completed status updated successfully");
        // Update the local discussion data
        const discussion = discussions.find(d => d.id === discussionId);
        if (discussion) {
          discussion.mark_completed = isCompleted;
        }
        // Update the incomplete comments count
        updateIncompleteCommentsCount();
        // Show success notification
        if (window.showSuccess) {
          window.showSuccess("Discussion status updated", `Marked as ${isCompleted ? 'completed' : 'incomplete'}`);
        }
      } else {
        console.error("‚ùå [DISCUSSION] Failed to update discussion status:", data.error);
        // Revert the toggle if the API call failed
        const toggle = document.getElementById(`completed-toggle-${discussionId}`) as HTMLInputElement;
        if (toggle) {
          toggle.checked = !isCompleted;
        }
        // Show error notification
        if (window.showError) {
          window.showError("Update Failed", "Failed to update discussion status");
        }
      }
    } catch (error) {
      console.error("‚ùå [DISCUSSION] Error updating discussion status:", error);
      // Revert the toggle if there was an error
      const toggle = document.getElementById(`completed-toggle-${discussionId}`) as HTMLInputElement;
      if (toggle) {
        toggle.checked = !isCompleted;
      }
      // Show error notification
      if (window.showError) {
        window.showError("Update Failed", "Error updating discussion status");
      }
    }
  }
</script>
  