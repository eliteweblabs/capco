---
const requireAuthRedirect = "/auth/login";
import { checkAuth } from "../../lib/auth";
const { currentUser, session, supabase, refreshToken, accessToken } = await checkAuth(
  Astro.cookies
);
const currentRole = currentUser?.profile?.role || "Client";

// Handle auth redirect first
if (requireAuthRedirect && (!session || !currentUser)) {
  return Astro.redirect(requireAuthRedirect);
}

import { globalCompanyData } from "../api/global/global-company-data.ts";
import { globalClasses } from "../api/global/global-classes.ts";
import App from "../../components/ui/App.astro";
import DashboardContent from "../../components/project/Dashboard.astro";
import type { Project } from "../../lib/api/_projects.ts";

// âš¡ OPTIMIZATION: Run all data fetches in PARALLEL
console.time("ğŸ—ï¸ [DASHBOARD] Total data fetch");

const [companyData, statusData, projectsData] = await Promise.all([
  // Fetch 1: Company data
  globalCompanyData().catch((err) => {
    console.error("ğŸ—ï¸ [DASHBOARD] âŒ Company data fetch failed:", err);
    return {
      globalCompanyName: "",
      globalCompanySlogan: "",
      globalCompanyAddress: "",
      globalCompanyPhone: "",
      globalCompanyEmail: "",
      globalCompanyWebsite: "",
      globalCompanyLogo: "",
    };
  }),

  // Fetch 2: Status data
  fetch(new URL("/api/status/get", Astro.url.origin).toString(), {
    method: "GET",
    headers: { Cookie: Astro.request.headers.get("Cookie") || "" },
  })
    .then((r) => {
      console.log(`ğŸ—ï¸ [DASHBOARD] Status API response: ${r.status}`);
      return r.json();
    })
    .then((d) => {
      console.log(`ğŸ—ï¸ [DASHBOARD] Status data:`, d);
      return d.statuses || [];
    })
    .catch((err) => {
      console.error("ğŸ—ï¸ [DASHBOARD] âŒ Status fetch failed:", err);
      return [];
    }),

  // Fetch 3: Projects (with timeout)
  (async () => {
    if (!currentUser?.id) {
      console.log("ğŸ—ï¸ [DASHBOARD] No user ID, skipping project fetch");
      return [];
    }

    try {
      const apiUrl = new URL("/api/projects/get", Astro.url.origin);
      if (currentRole === "Client") {
        apiUrl.searchParams.set("authorId", currentUser.id);
      }
      apiUrl.searchParams.set("limit", "50");

      console.log(`ğŸ—ï¸ [DASHBOARD] ğŸ“¡ Fetching projects from: ${apiUrl.toString()}`);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout

      const startTime = Date.now();
      const response = await fetch(apiUrl.toString(), {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Cookie: Astro.request.headers.get("Cookie") || "",
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);
      const elapsed = Date.now() - startTime;

      console.log(`ğŸ—ï¸ [DASHBOARD] ğŸ“¦ Response status: ${response.status}, took ${elapsed}ms`);

      if (response.ok) {
        const data = await response.json();
        const projectCount = data.projects?.length || 0;
        console.log(`ğŸ—ï¸ [DASHBOARD] âœ… Successfully loaded ${projectCount} projects`);
        console.log(`ğŸ—ï¸ [DASHBOARD] ğŸ“‹ Response structure:`, Object.keys(data));
        console.log(
          `ğŸ—ï¸ [DASHBOARD] ğŸ“‹ Projects array type:`,
          Array.isArray(data.projects),
          "length:",
          data.projects?.length
        );
        return data.projects || [];
      }

      console.error(`ğŸ—ï¸ [DASHBOARD] âŒ API returned error status: ${response.status}`);
      const errorText = await response.text();
      console.error(`ğŸ—ï¸ [DASHBOARD] âŒ Error response:`, errorText);
      return [];
    } catch (error) {
      if (error.name === "AbortError") {
        console.error("ğŸ—ï¸ [DASHBOARD] â±ï¸  Request timeout after 5s - returning empty array");
      } else {
        console.error("ğŸ—ï¸ [DASHBOARD] âŒ Fetch error:", error);
      }
      return [];
    }
  })(),
]);

console.timeEnd("ğŸ—ï¸ [DASHBOARD] Total data fetch");
console.log(
  `ğŸ—ï¸ [DASHBOARD] ğŸ¯ Final projectsData:`,
  Array.isArray(projectsData),
  "length:",
  projectsData?.length
);

const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
} = companyData;

const { globalInputClasses, primaryTextClasses, secondaryTextClasses } = globalClasses();
const projects = projectsData;
---

<App
  title="Global Dashboard"
  description="View all projects."
  {currentUser}
  {session}
  {supabase}
  {projects}
  {globalCompanyName}
  {globalCompanySlogan}
  {primaryTextClasses}
  {secondaryTextClasses}
  {globalInputClasses}
  {globalCompanyAddress}
  {globalCompanyPhone}
  {globalCompanyEmail}
  {globalCompanyWebsite}
  {globalCompanyLogo}
  {statusData}
  horizontalScroll={false}
  layout="fullwidth"
>
  <!-- use the full width wrapper -->

  <DashboardContent
    {projects}
    {statusData}
    {currentUser}
    {globalInputClasses}
    {secondaryTextClasses}
    {primaryTextClasses}
  />
</App>

<script src="../../lib/refresh-manager.ts"></script>

<script
  define:vars={{ currentUserId: currentUser?.id, currentUserRole: currentUser?.profile?.role }}
  is:inline
  data-astro-rerun
>
  console.log("ğŸ”„ [DASHBOARD-SCRIPT] ====== SCRIPT IS RUNNING ======");
  console.log("ğŸ”„ [DASHBOARD-SCRIPT] currentUserId:", currentUserId);
  console.log("ğŸ”„ [DASHBOARD-SCRIPT] currentUserRole:", currentUserRole);
  console.log("ğŸ”„ [DASHBOARD-SCRIPT] window.refreshManager:", window.refreshManager);
  console.log("ğŸ”„ [DASHBOARD-SCRIPT] document.readyState:", document.readyState);

  // Start the refresh manager with safe settings
  console.log("ğŸ”„ [DASHBOARD] Starting refresh manager initialization...");

  // Wait for refreshManager to be available
  function waitForRefreshManager() {
    return new Promise((resolve, reject) => {
      if (window.refreshManager) {
        console.log("ğŸ”„ [DASHBOARD] RefreshManager already available");
        resolve(window.refreshManager);
        return;
      }

      console.log("ğŸ”„ [DASHBOARD] Waiting for RefreshManager...");
      let attempts = 0;
      const maxAttempts = 100; // 5 seconds max (100 * 50ms)

      const checkInterval = setInterval(() => {
        attempts++;

        if (window.refreshManager) {
          console.log("ğŸ”„ [DASHBOARD] RefreshManager now available after", attempts, "attempts");
          clearInterval(checkInterval);
          resolve(window.refreshManager);
        } else if (attempts >= maxAttempts) {
          console.error(
            "ğŸ”„ [DASHBOARD] âŒ RefreshManager not available after",
            attempts,
            "attempts"
          );
          clearInterval(checkInterval);
          reject(new Error("RefreshManager not available"));
        } else if (attempts % 20 === 0) {
          // Log every second
          console.log("ğŸ”„ [DASHBOARD] Still waiting... attempt", attempts);
        }
      }, 50);
    });
  }

  // Run init on both first load and SPA navigation (astro:page-load)
  async function runDashboardInit() {
    if (!window.location.pathname.startsWith("/project")) return;
    console.log("ğŸ”„ [DASHBOARD] runDashboardInit (path:", window.location.pathname + ")");
    try {
      const refreshManager = await waitForRefreshManager();
      await initializeRefreshSystem(refreshManager);
    } catch (error) {
      console.error("ğŸ”„ [DASHBOARD] âŒ Failed to initialize refresh system:", error);
      console.error(
        "ğŸ”„ [DASHBOARD] Polling will not work. Please check that refresh-manager.ts is loaded."
      );
    }
  }

  if (document.readyState === "loading") {
    console.log("ğŸ”„ [DASHBOARD] Document is loading, adding DOMContentLoaded listener");
    document.addEventListener("DOMContentLoaded", runDashboardInit);
  } else {
    console.log("ğŸ”„ [DASHBOARD] DOM already loaded or SPA nav, running init now");
    runDashboardInit();
  }
  document.addEventListener("astro:page-load", runDashboardInit);
  window["__initProjectDashboard"] = runDashboardInit;

  // Clear any previous global count interval so SPA re-init doesn't stack
  if (window.__projectDashboardPollInterval) {
    clearInterval(window.__projectDashboardPollInterval);
    window.__projectDashboardPollInterval = null;
  }

  async function initializeRefreshSystem(refreshManager) {
    // Fetch the actual count from the database immediately
    console.log(`ğŸŒ [DASHBOARD] Fetching initial project count from database...`);

    // The API endpoint uses the session to determine what projects to count
    // Clients see only their projects, Admins see all - handled server-side
    const countUrl = "/api/projects/get?count=true";

    console.log(`ğŸŒ [DASHBOARD] Count URL: ${countUrl}`);

    try {
      const response = await fetch(countUrl);
      if (response.ok) {
        const data = await response.json();
        const databaseCount = data.count || 0;
        console.log(`ğŸŒ [DASHBOARD] âœ… Database count: ${databaseCount}`);

        // Set initial global state from database
        refreshManager.setGlobalState("projectCount", databaseCount);
      } else {
        console.error(`ğŸŒ [DASHBOARD] âŒ Failed to fetch count: ${response.status}`);
        // Fallback: set to 0 and let polling update it
        refreshManager.setGlobalState("projectCount", 0);
      }
    } catch (error) {
      console.error(`ğŸŒ [DASHBOARD] âŒ Error fetching initial count:`, error);
      // Fallback: set to 0 and let polling update it
      refreshManager.setGlobalState("projectCount", 0);
    }

    // Start the refresh manager for project-level updates
    refreshManager.startAutoRefreshWithInterval(5); // Poll every 5 seconds

    console.log("ğŸ”„ [DASHBOARD] Refresh manager started:", refreshManager.getRefreshStats());

    // Start polling for global counts (check every 10 seconds)
    if (window.__projectDashboardPollInterval) clearInterval(window.__projectDashboardPollInterval);
    window.__projectDashboardPollInterval = setInterval(async () => {
      console.log(`ğŸŒ [DASHBOARD] â° Polling for global counts... (every 10s)`);
      await refreshManager.refreshGlobalCounts();
    }, 10000);

    console.log(`ğŸŒ [DASHBOARD] Global count polling started (every 10 seconds)`);

    // Make refresh manager globally accessible for debugging
    window.refreshManager = refreshManager;
    window.manualRefreshCounts = async () => {
      console.log(`ğŸŒ [DASHBOARD] ğŸ”§ Manual refresh triggered`);
      await refreshManager.refreshGlobalCounts();
    };

    console.log(`ğŸŒ [DASHBOARD] Debug: Run window.manualRefreshCounts() to manually check counts`);
  }

  // Listen for project deletions to update global count
  document.addEventListener("projectDeleted", (event) => {
    console.log("ğŸ—‘ï¸  [DASHBOARD] Project deleted, updating global count");
    const currentCount = refreshManager.getGlobalState("projectCount") || 0;
    const newCount = Math.max(0, currentCount - 1);
    refreshManager.setGlobalState("projectCount", newCount);
    console.log(`ğŸŒ [DASHBOARD] Updated count: ${currentCount} -> ${newCount}`);
  });

  // Listen for project creations to update global count
  document.addEventListener("projectCreated", (event) => {
    console.log("â• [DASHBOARD] Project created, updating global count");
    const currentCount = refreshManager.getGlobalState("projectCount") || 0;
    const newCount = currentCount + 1;
    refreshManager.setGlobalState("projectCount", newCount);
    console.log(`ğŸŒ [DASHBOARD] Updated count: ${currentCount} -> ${newCount}`);
  });
</script>
