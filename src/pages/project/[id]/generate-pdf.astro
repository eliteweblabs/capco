---
import App from "../../../components/common/App.astro";
import PDFPreview from "../../../components/common/PDFPreview.astro";
import LucideIcon from "../../../components/common/LucideIcon.astro";
import { checkAuth } from "../../../lib/auth";

const { id } = Astro.params;

// Get auth data directly since App component handles auth requirements
const { currentUser = undefined } = await checkAuth(Astro.cookies);
const currentRole = currentUser?.profile?.role || "Client";

console.log("üèóÔ∏è [GENERATE-PDF] Current user:", currentUser);
console.log("üèóÔ∏è [GENERATE-PDF] Current role:", currentRole);
console.log("üèóÔ∏è [GENERATE-PDF] Project ID:", id);
console.log("üèóÔ∏è [GENERATE-PDF] API URL:", `${Astro.url.origin}/api/get-project?id=${id}`);

if (!currentUser) {
  console.error("üèóÔ∏è [GENERATE-PDF] No authenticated user, redirecting to login");
  return Astro.redirect("/auth/login");
}

import { globalCompanyData } from "../../api/global/global-company-data.ts";
const {
  globalCompanyName,
  globalCompanySlogan,
  globalCompanyAddress,
  globalCompanyPhone,
  globalCompanyEmail,
  globalCompanyWebsite,
  globalCompanyLogo,
  globalCompanyLogoDark,
  globalCompanyLogoLight,
} = globalCompanyData();

import { globalClasses } from "../../api/global/global-classes.ts";
const { globalInputClasses, globalPrimaryTextClasses, globalSecondaryTextClasses } =
  globalClasses();

import "../../../lib/refresh-manager.ts";
// Fetch project data using existing API
let projectResponse;
try {
  projectResponse = await fetch(`${Astro.url.origin}/api/get-project?id=${id}`, {
    headers: {
      Cookie: Astro.request.headers.get("cookie") || "",
    },
  });
} catch (error) {
  console.error("üèóÔ∏è [GENERATE-PDF] Fetch error:", error);
  return Astro.redirect("/dashboard");
}

if (!projectResponse.ok) {
  console.error(
    "üèóÔ∏è [GENERATE-PDF] API response not OK:",
    projectResponse.status,
    projectResponse.statusText
  );
  // Try to get the error response body
  try {
    const errorBody = await projectResponse.text();
    console.error("üèóÔ∏è [GENERATE-PDF] Error response body:", errorBody);
  } catch (e) {
    console.error("üèóÔ∏è [GENERATE-PDF] Could not read error response body:", e);
  }
  return Astro.redirect("/dashboard");
}

console.log("üèóÔ∏è [GENERATE-PDF] Project response:", projectResponse);
const projectResult = await projectResponse.json();
console.log("üèóÔ∏è [GENERATE-PDF] Project result:", projectResult);

if (!projectResult.success || !projectResult.project) {
  console.error("üèóÔ∏è [GENERATE-PDF] Project result failed:", projectResult);
  return Astro.redirect("/dashboard");
}

const project = projectResult.project;
const projectAuthor = projectResult.projectAuthor;

// Check if user has access to this project
const isAdmin = currentUser?.profile?.role === "Admin" || currentUser?.profile?.role === "Staff";
const isOwner = project.authorId === currentUser.id;

// if (!isAdmin && !isOwner) {
//   return Astro.redirect("/dashboard");
// }

const projectId = id;
const title = project.title || "Untitled Project";
---

<App
  title={`Generate PDF - ${title}`}
  {currentUser}
  {globalCompanyName}
  {globalCompanySlogan}
  {globalCompanyAddress}
  {globalCompanyPhone}
  {globalCompanyEmail}
  {globalCompanyWebsite}
  {globalCompanyLogo}
  {globalCompanyLogoDark}
  {globalCompanyLogoLight}
  {globalPrimaryTextClasses}
  {globalSecondaryTextClasses}
  {globalInputClasses}
>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900">
    <div class="container mx-auto px-4 py-8">
      <!-- Header -->
      <div class="mb-8">
        <div class="flex items-center justify-between">
          <div>
            <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Generate PDF Document</h1>
            <p class="mt-2 text-gray-600 dark:text-gray-400">
              Create a custom PDF document for <strong>{title}</strong>
            </p>
          </div>
          <a
            href={`/project/${projectId}`}
            class="inline-flex items-center rounded-lg bg-gray-600 px-4 py-2 text-white transition-colors hover:bg-gray-700"
          >
            <LucideIcon name="arrow-left" class="mr-2" />
            Back to Project
          </a>
        </div>
      </div>

      <!-- Main Content -->
      <div class="grid grid-cols-1 gap-8 lg:grid-cols-3">
        <!-- Left Panel - Configuration -->
        <div class="lg:col-span-1">
          <div class="rounded-lg bg-gray-100 p-6 shadow-lg dark:bg-gray-800">
            <h2 class="mb-6 text-xl font-semibold text-gray-900 dark:text-white">
              Document Configuration
            </h2>

            <!-- Document Name -->
            <div class="mb-6">
              <label
                for="documentName"
                class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Document Name
              </label>
              <input
                type="text"
                id="documentName"
                class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-transparent focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="e.g., Fire Protection Plan"
                value="Fire Protection System Plan"
              />
            </div>

            <!-- Template Selection -->
            <div class="mb-6">
              <label
                for="templateSelect"
                class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Select Template
              </label>
              <select
                id="templateSelect"
                class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-transparent focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
              >
                <option value="">Loading templates...</option>
              </select>
            </div>

            <!-- Component Selection -->
            <div class="mb-6">
              <label class="mb-3 block text-sm font-medium text-gray-700 dark:text-gray-300">
                Add Components
              </label>
              <div id="componentList" class="max-h-64 space-y-3 overflow-y-auto">
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  Select a template to see available components
                </div>
              </div>
            </div>

            <!-- Generate Button -->
            <button
              id="generateBtn"
              class="w-full rounded-lg bg-blue-600 px-4 py-3 font-medium text-white transition-colors hover:bg-blue-700 disabled:cursor-not-allowed disabled:opacity-50"
              disabled
            >
              <LucideIcon name="file-blank" class="mr-2" />
              Generate PDF
            </button>
          </div>
        </div>

        <!-- Right Panel - Preview -->
        <div class="lg:col-span-2">
          <div class="rounded-lg bg-gray-100 p-6 shadow-lg dark:bg-gray-800">
            <div class="mb-6 flex items-center justify-between">
              <h2 class="text-xl font-semibold text-gray-900 dark:text-white">Document Preview</h2>
              <div class="flex space-x-2">
                <button
                  id="refreshPreview"
                  class="rounded bg-gray-100 px-3 py-1 text-gray-700 transition-colors hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
                >
                  <LucideIcon name="refresh-cw" class="mr-1" />
                  Refresh
                </button>
                <button
                  id="saveToDocumentsBtn"
                  class="hidden rounded bg-blue-100 px-3 py-1 text-blue-700 transition-colors hover:bg-blue-200 dark:bg-blue-900 dark:text-blue-300 dark:hover:bg-blue-800"
                >
                  <LucideIcon name="save" class="mr-1" />
                  Save to Documents
                </button>
                <button
                  id="downloadBtn"
                  class="hidden rounded bg-green-100 px-3 py-1 text-green-700 transition-colors hover:bg-green-200 dark:bg-green-900 dark:text-green-300 dark:hover:bg-green-800"
                >
                  <LucideIcon name="download" class="mr-1" />
                  Download PDF
                </button>
              </div>
            </div>

            <!-- PDF Preview Component -->
            <PDFPreview
              htmlContent=""
              documentName="PDF Preview"
              showZoomControls={true}
              containerClass="min-h-96 rounded-lg border border-gray-300 bg-gray-50 dark:border-gray-600 dark:bg-gray-900"
              iframeClass="border-0"
              height="600px"
            />
          </div>
        </div>
      </div>

      <!-- Loading Overlay -->
      <div
        id="loadingOverlay"
        class="z-60 fixed inset-0 hidden items-center justify-center bg-black bg-opacity-50"
      >
        <div class="rounded-lg bg-gray-100 p-8 text-center dark:bg-gray-800">
          <div class="mx-auto mb-4 h-12 w-12 animate-spin rounded-full border-b-2 border-blue-600">
          </div>
          <p class="text-gray-700 dark:text-gray-300">Generating PDF...</p>
        </div>
      </div>
    </div>
  </div>

  <script define:vars={{ projectId, title, currentUser }} is:inline>
    let selectedTemplate = null;
    let selectedComponents = [];
    let generatedDocument = null;

    // Load templates on page load
    document.addEventListener("DOMContentLoaded", async () => {
      await loadTemplates();
    });

    async function loadTemplates() {
      try {
        console.log("üîß [PDF-TEMPLATES] Loading templates...");
        const response = await fetch("/api/pdf/templates");
        const result = await response.json();

        console.log("üîß [PDF-TEMPLATES] API response:", result);

        if (result.success) {
          const templateSelect = document.getElementById("templateSelect");
          if (!templateSelect) {
            console.error("üîß [PDF-TEMPLATES] Template select element not found!");
            return;
          }

          templateSelect.innerHTML = '<option value="">Select a template...</option>';

          result.templates.forEach((template) => {
            console.log("üîß [PDF-TEMPLATES] Adding template:", template.name, template.id);
            const option = document.createElement("option");
            option.value = template.id;
            option.textContent = template.name;
            templateSelect.appendChild(option);
          });

          console.log("üîß [PDF-TEMPLATES] Templates loaded successfully");
        } else {
          console.error("üîß [PDF-TEMPLATES] API returned error:", result.message);
        }
      } catch (error) {
        console.error("üîß [PDF-TEMPLATES] Error loading templates:", error);
      }
    }

    // Template selection handler
    document.addEventListener("DOMContentLoaded", () => {
      const templateSelect = document.getElementById("templateSelect");
      if (templateSelect) {
        templateSelect.addEventListener("change", async (e) => {
          const templateId = e.target.value;
          console.log(`üîß [PDF-TEMPLATE] Template changed to: ${templateId}`);
          if (templateId) {
            selectedTemplate = templateId;
            await loadComponents(templateId);
            updateGenerateButton();
          } else {
            selectedTemplate = null;
            selectedComponents = [];
            const componentList = document.getElementById("componentList");
            if (componentList) {
              componentList.innerHTML =
                '<div class="text-gray-500 dark:text-gray-400 text-sm">Select a template to see available components</div>';
            }
            updateGenerateButton();
          }
        });
      } else {
        console.error("üîß [PDF-TEMPLATE] Template select element not found for event listener!");
      }
    });

    async function loadComponents(templateId) {
      try {
        console.log(`üîß [PDF-COMPONENTS] Loading components for template ${templateId}`);
        const response = await fetch(`/api/pdf/components?templateId=${templateId}`);
        const result = await response.json();

        if (result.success) {
          console.log(
            `üîß [PDF-COMPONENTS] Found ${result.components.length} components for template ${templateId}`
          );
          const componentList = document.getElementById("componentList");
          componentList.innerHTML = "";

          if (result.components.length === 0) {
            componentList.innerHTML =
              '<div class="text-gray-500 dark:text-gray-400 text-sm">No components available for this template</div>';
            return;
          }

          result.components.forEach((component) => {
            const componentDiv = document.createElement("div");
            componentDiv.className =
              "flex items-center space-x-3 p-3 border border-gray-200 dark:border-gray-600 rounded-lg";

            componentDiv.innerHTML = `
              <input 
                type="checkbox" 
                id="component-${component.id}" 
                value="${component.id}"
                class="component-checkbox rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <div class="flex-1">
                <label for="component-${component.id}" class="text-sm font-medium text-gray-900 dark:text-white cursor-pointer">
                  ${component.name}
                </label>
                <p class="text-xs text-gray-500 dark:text-gray-400">${component.component_type}</p>
                ${component.description ? `<p class="text-xs text-gray-600 dark:text-gray-300 mt-1">${component.description}</p>` : ""}
              </div>
            `;

            componentList.appendChild(componentDiv);
          });

          // Remove any existing event listeners first
          document.querySelectorAll(".component-checkbox").forEach((checkbox) => {
            checkbox.removeEventListener("change", updateSelectedComponents);
          });

          // Add event listeners to checkboxes
          document.querySelectorAll(".component-checkbox").forEach((checkbox) => {
            checkbox.addEventListener("change", updateSelectedComponents);
          });
        }
      } catch (error) {
        console.error("Error loading components:", error);
      }
    }

    function updateSelectedComponents() {
      selectedComponents = Array.from(document.querySelectorAll(".component-checkbox:checked")).map(
        (cb) => parseInt(cb.value)
      );
      updateGenerateButton();
    }

    function updateGenerateButton() {
      const generateBtn = document.getElementById("generateBtn");
      const documentName = document.getElementById("documentName").value.trim();

      generateBtn.disabled = !selectedTemplate || !documentName;
    }

    // Document name change handler
    document.getElementById("documentName").addEventListener("input", updateGenerateButton);

    // Generate PDF handler
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const documentName = document.getElementById("documentName").value.trim();

      if (!selectedTemplate || !documentName) {
        alert("Please select a template and enter a document name");
        return;
      }

      const loadingOverlay = document.getElementById("loadingOverlay");
      loadingOverlay.classList.remove("hidden");
      loadingOverlay.classList.add("flex");

      try {
        const response = await fetch("/api/pdf/generate", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            type: "general",
            templateUrl: selectedTemplate,
            projectId: parseInt(projectId),
            documentName,
            selectedComponents,
            userId: currentUser?.id || null,
          }),
        });

        const result = await response.json();

        if (result.success) {
          generatedDocument = result.document;

          // Show preview
          showPreview(result.document.htmlContent);

          // Show download and save buttons
          document.getElementById("downloadBtn").classList.remove("hidden");
          document.getElementById("saveToDocumentsBtn").classList.remove("hidden");

          // Show success message
          if (window.showModal) {
            window.showModal(
              "success",
              "PDF Generated",
              "Your document has been generated! You can now preview, download, or save it to documents.",
              4000
            );
          }
        } else {
          throw new Error(result.message || "Failed to generate PDF");
        }
      } catch (error) {
        console.error("Error generating PDF:", error);
        if (window.showModal) {
          window.showModal("error", "Generation Failed", error.message, 5000);
        }
      } finally {
        loadingOverlay.classList.add("hidden");
        loadingOverlay.classList.remove("flex");
      }
    });

    let currentZoom = 100;
    let previewIframe = null;

    function showPreview(htmlContent) {
      console.log("üîß [PDF-PREVIEW] Showing preview with HTML content length:", htmlContent.length);

      // Use the PDFPreview component's API
      if (window.PDFPreview) {
        window.PDFPreview.setContent(htmlContent);
      } else {
        console.error("üîß [PDF-PREVIEW] PDFPreview component not available");
      }
    }

    // Zoom functions are now handled by the PDFPreview component

    // Download handler
    document.getElementById("downloadBtn").addEventListener("click", async () => {
      if (generatedDocument) {
        const downloadBtn = document.getElementById("downloadBtn");
        const originalText = downloadBtn.innerHTML;

        // Show loading state
        downloadBtn.disabled = true;
        downloadBtn.innerHTML =
          '<i data-lucide="loader-2" class="animate-spin mr-1"></i>Generating PDF...';

        try {
          const response = await fetch("/api/files/download", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              type: "pdf",
              htmlContent: generatedDocument.htmlContent,
              documentName: generatedDocument.name,
            }),
          });

          if (response.ok) {
            // Get the PDF blob
            const pdfBlob = await response.blob();

            // Create download link
            const url = URL.createObjectURL(pdfBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${generatedDocument.name.replace(/[^a-zA-Z0-9]/g, "_")}.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Show success message
            if (window.showModal) {
              window.showModal(
                "success",
                "PDF Downloaded",
                "Your PDF has been downloaded successfully!",
                3000
              );
            }
          } else {
            const errorData = await response.json();
            throw new Error(errorData.message || "Failed to generate PDF");
          }
        } catch (error) {
          console.error("Error downloading PDF:", error);
          if (window.showModal) {
            window.showModal("error", "Download Failed", error.message, 5000);
          }
        } finally {
          // Reset button state
          downloadBtn.disabled = false;
          downloadBtn.innerHTML = originalText;
        }
      }
    });

    // Refresh preview handler
    document.getElementById("refreshPreview").addEventListener("click", () => {
      if (generatedDocument) {
        showPreview(generatedDocument.htmlContent);
      }
    });

    // Save to Documents handler
    document.getElementById("saveToDocumentsBtn").addEventListener("click", async () => {
      if (!generatedDocument) {
        window.showModal("error", "No Document", "Please generate a document first", 3000);
        return;
      }

      const saveBtn = document.getElementById("saveToDocumentsBtn");
      const originalText = saveBtn.innerHTML;

      // Show loading state
      saveBtn.disabled = true;
      saveBtn.innerHTML = '<i data-lucide="loader-2" class="animate-spin mr-1"></i>Saving...';

      try {
        const response = await fetch("/api/pdf/generate", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            type: "general",
            templateUrl: selectedTemplate,
            projectId: parseInt(projectId),
            documentName: generatedDocument.name,
            htmlContent: generatedDocument.htmlContent,
            userId: currentUser?.id || null,
          }),
        });

        const result = await response.json();

        if (result.success) {
          window.showModal("success", "Document Saved", "PDF has been saved to documents", 3000);
          // Hide the save button since it's now saved
          saveBtn.classList.add("hidden");
        } else {
          throw new Error(result.message || "Failed to save document");
        }
      } catch (error) {
        console.error("Error saving document:", error);
        window.showModal("error", "Save Failed", error.message, 5000);
      } finally {
        // Reset button state
        saveBtn.disabled = false;
        saveBtn.innerHTML = originalText;
      }
    });

    // Zoom control event listeners are now managed by the PDFPreview component

    // Keyboard shortcuts for zoom
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case "=":
          case "+":
            e.preventDefault();
            zoomIn();
            break;
          case "-":
            e.preventDefault();
            zoomOut();
            break;
          case "0":
            e.preventDefault();
            resetZoom();
            break;
        }
      }
    });
  </script>
</App>
