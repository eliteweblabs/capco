---
// Client-side OAuth callback handler for PKCE flow
// This page runs in the browser where the code verifier is stored in localStorage
import SimpleIcon from "../../components/common/SimpleIcon.astro";
import LoadingSpinner from "../../components/ui/LoadingSpinner.astro";
import LayoutAuthCallback from "../../components/layouts/LayoutAuthCallback.astro";
---

<LayoutAuthCallback title="Signing you in" description="Please wait while we complete authentication">
  <div
    id="loading-container"
    class="flex w-full flex-col items-center justify-center gap-6"
    data-dynamic-height="true"
  >
    <LoadingSpinner size="lg" color="primary" loadingText="Signing you in" />
    <div id="taking-too-long" class="hidden max-w-sm text-center">
      <p class="text-sm text-gray-600 dark:text-gray-400">
        Taking longer than expected? This can happen if the server is starting up or the network is
        slow.
      </p>
      <a
        href="/auth/login"
        class="mt-3 inline-flex items-center gap-2 rounded-full border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
      >
        <SimpleIcon name="arrow-left" />
        Back to Login
      </a>
    </div>
  </div>

  <div
    id="error"
    class="mt-8 hidden max-w-md rounded-lg border-2 border-red-200 bg-red-50 p-5 text-left dark:border-red-800 dark:bg-red-950/30"
    role="alert"
  >
    <div class="mb-2 flex items-center gap-2 text-lg font-semibold text-red-800 dark:text-red-200">
      <SimpleIcon name="alert-circle" class="h-6 w-6 shrink-0" />
      Authentication Failed
    </div>
    <div id="error-message" class="text-[0.9375rem] leading-relaxed text-red-700 dark:text-red-300">
    </div>
    <div id="error-redirect" class="mt-2 text-sm italic text-gray-600 dark:text-gray-400">
      Redirecting to login page...
    </div>
  </div>

  <div id="back-link" class="mt-8 hidden">
    <div class="flex flex-wrap content-center items-center justify-center gap-3">
      <a
        id="retry-google-link"
        href="/auth/google"
        class="inline-flex items-center gap-2 rounded-full bg-primary-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-primary-700"
      >
        <SimpleIcon name="google" size="sm" />
        Try again with Google
      </a>
      <a
        href="/auth/login"
        class="inline-flex items-center gap-2 rounded-full bg-gray-500 px-3 py-2 text-sm font-medium text-white transition-colors hover:bg-gray-600"
      >
        <SimpleIcon name="arrow-left" />
        Back to Login
      </a>
    </div>
  </div>
</LayoutAuthCallback>

{
  /* Inline: show OAuth errors and detect when main script never runs (module load failure) so we never fail silently. */
}
<script is:inline>
  (function () {
    var params = new URLSearchParams(window.location.search);
    var hashParams = new URLSearchParams((window.location.hash || "").substring(1));
    var err = params.get("error") || hashParams.get("error");
    var errDesc =
      params.get("error_description") ||
      hashParams.get("error_description") ||
      params.get("message") ||
      hashParams.get("message");
    var code = params.get("code") || hashParams.get("code");

    function showFallbackError(msg) {
      var loading = document.getElementById("loading-container");
      var errEl = document.getElementById("error");
      var errMsg = document.getElementById("error-message");
      var redirectNote = document.getElementById("error-redirect");
      var back = document.getElementById("back-link");
      if (loading) loading.classList.add("hidden");
      if (errEl && errMsg) {
        errMsg.textContent = msg;
        errEl.classList.remove("hidden");
        if (redirectNote) redirectNote.textContent = "";
        if (back) back.classList.remove("hidden");
      }
    }

    if (err) {
      var msg = errDesc || err;
      if (err === "access_denied") msg = "You cancelled sign-in or access was denied.";
      else if (err === "session_expired") msg = "Your session expired. Please sign in again.";
      showFallbackError(msg);
      setTimeout(function () {
        window.location.href = "/auth/login?error=oauth_failed&message=" + encodeURIComponent(msg);
      }, 3000);
      return;
    }

    if (code) {
      setTimeout(function () {
        var errEl = document.getElementById("error");
        var loading = document.getElementById("loading-container");
        if (
          loading &&
          !loading.classList.contains("hidden") &&
          errEl &&
          errEl.classList.contains("hidden")
        ) {
          showFallbackError("Sign-in did not complete. Please try again from the login page.");
        }
      }, 12000);
    }
  })();
</script>
<script>
  // Show "Taking too long?" escape hatch after 8s (avoids stuck loading when DB/network is slow)
  const slowTimeout = setTimeout(() => {
    const el = document.getElementById("taking-too-long");
    if (el) el.classList.remove("hidden");
  }, 8000);

  // CRITICAL: Capture and restore code IMMEDIATELY before ANY imports or client initialization
  // Supabase's detectSessionInUrl checks the URL when the client is created, so the code MUST be present
  const initialUrl = window.location.href;
  const initialSearch = window.location.search;
  const initialHash = window.location.hash;

  // Parse code and redirect parameter immediately
  const initialUrlParams = new URLSearchParams(initialSearch);
  const initialHashParams = new URLSearchParams(initialHash.substring(1));
  const capturedCode = initialUrlParams.get("code") || initialHashParams.get("code");
  const capturedError = initialUrlParams.get("error") || initialHashParams.get("error");
  const capturedErrorDescription =
    initialUrlParams.get("error_description") || initialHashParams.get("error_description");
  const capturedRedirect = initialUrlParams.get("redirect") || initialHashParams.get("redirect");

  console.log("[AUTH-CALLBACK] IMMEDIATE CAPTURE on page load:");
  console.log("[AUTH-CALLBACK] Initial URL:", initialUrl);
  console.log("[AUTH-CALLBACK] Initial search:", initialSearch);
  console.log("[AUTH-CALLBACK] Initial hash:", initialHash);
  console.log(
    "[AUTH-CALLBACK] Captured code:",
    capturedCode ? `${capturedCode.substring(0, 20)}...` : null
  );
  console.log("[AUTH-CALLBACK] Captured error:", capturedError);
  console.log("[AUTH-CALLBACK] Captured redirect:", capturedRedirect);

  // CRITICAL: Restore code to URL IMMEDIATELY if it was stripped
  // This MUST happen before Supabase client is imported/initialized
  // Supabase's detectSessionInUrl only checks the URL once during client creation
  if (capturedCode && !initialSearch.includes("code=") && !initialHash.includes("code=")) {
    console.log("[AUTH-CALLBACK] ⚠️ Code was stripped from URL, restoring BEFORE client init...");
    const restoreUrl = new URL(window.location.href);
    restoreUrl.searchParams.set("code", capturedCode);
    window.history.replaceState({}, "", restoreUrl.toString());
    console.log("[AUTH-CALLBACK] ✅ URL restored:", restoreUrl.toString());
  }

  // NOW import Supabase client - it will see the code in the URL
  // Use singleton Supabase client to avoid multiple instances
  // IMPORTANT: Import happens synchronously, but client creation happens when getSupabaseClient() is called
  import { getSupabaseClient } from "../../lib/supabase-client";

  // CRITICAL: Create Supabase client IMMEDIATELY (synchronously) to ensure detectSessionInUrl runs
  // This must happen before any async operations
  const supabase = getSupabaseClient();

  if (!supabase) {
    console.error("[AUTH-CALLBACK] Failed to create Supabase client");
  } else {
    console.log("[AUTH-CALLBACK] Supabase client created, detectSessionInUrl should process URL");
  }

  async function handleCallback() {
    // Client-side logging (no prefix needed for browser console)
    console.log("[AUTH-CALLBACK] Environment check:", {
      hasPublicUrl: !!import.meta.env.PUBLIC_SUPABASE_URL,
      hasPublishableKey: !!import.meta.env.PUBLIC_SUPABASE_PUBLISHABLE,
    });

    // Supabase client was already created at top of script
    // This ensures detectSessionInUrl runs immediately when client is created
    if (!supabase) {
      showError("Supabase configuration missing");
      return;
    }

    console.log("[AUTH-CALLBACK] Using pre-initialized Supabase client");

    // CRITICAL: Set up auth state change listener BEFORE doing anything else
    // This will catch when Supabase automatically exchanges the code
    let sessionReceived = false;
    let authStateSubscription: any = null;

    const authStatePromise = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        if (authStateSubscription) {
          authStateSubscription.unsubscribe();
        }
        reject(new Error("Auth state change timeout"));
      }, 15000); // Increased timeout to 15 seconds

      const {
        data: { subscription },
      } = supabase.auth.onAuthStateChange((event, session) => {
        console.log(
          "[AUTH-CALLBACK] Auth state changed:",
          event,
          "INITIAL_SESSION",
          session?.user?.email || "undefined"
        );
        if (event === "SIGNED_IN" && session) {
          clearTimeout(timeout);
          sessionReceived = true;
          if (authStateSubscription) {
            authStateSubscription.unsubscribe();
          }
          resolve(session);
        } else if (event === "TOKEN_REFRESHED" && session) {
          // Also handle token refresh as a sign-in event
          clearTimeout(timeout);
          sessionReceived = true;
          if (authStateSubscription) {
            authStateSubscription.unsubscribe();
          }
          resolve(session);
        }
      });

      authStateSubscription = subscription;
    });

    // Give Supabase client time to initialize and detect the code in URL
    // Code should already be in URL (restored at top of script if needed)
    // With detectSessionInUrl: true, Supabase should automatically handle the exchange
    // Wait a bit longer to ensure Supabase has time to process the URL
    await new Promise((resolve) => setTimeout(resolve, 800));

    // Manually trigger a session check to ensure Supabase processes the URL
    // This helps if detectSessionInUrl didn't catch it on initialization
    console.log("[AUTH-CALLBACK] Manually checking for session...");
    const { data: initialSession } = await supabase.auth.getSession();
    if (initialSession?.session) {
      console.log("[AUTH-CALLBACK] ✅ Session already exists from automatic detection!");
      // Session already exists, proceed to success flow
      const response = await fetch("/api/auth/callback", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({
          access_token: initialSession.session.access_token,
          refresh_token: initialSession.session.refresh_token,
          expires_in: initialSession.session.expires_in,
          token_type: initialSession.session.token_type || "bearer",
        }),
      });

      if (response.ok) {
        clearTimeout(slowTimeout);
        console.log("[AUTH-CALLBACK] Authentication successful, redirecting...");
        await new Promise((resolve) => setTimeout(resolve, 300));
        const redirectUrl = capturedRedirect || "/project/dashboard";
        console.log("[AUTH-CALLBACK] Redirecting to:", redirectUrl);
        window.location.replace(redirectUrl);
        return;
      }
    }

    try {
      console.log("[AUTH-CALLBACK] Starting PKCE flow...");
      console.log("[AUTH-CALLBACK] Current URL:", window.location.href);
      console.log("[AUTH-CALLBACK] Current search params:", window.location.search);
      console.log("[AUTH-CALLBACK] Current hash:", window.location.hash);

      // Use the captured code from initial page load, fallback to current URL if needed
      // Get the code from URL parameters (check both query params and hash)
      const urlParams = new URLSearchParams(window.location.search);
      const hashParams = new URLSearchParams(window.location.hash.substring(1)); // Remove # from hash

      // Prefer captured code from initial load, then check current URL as fallback
      // This ensures we have the code even if something strips it from the URL later
      let code = capturedCode || urlParams.get("code") || hashParams.get("code");
      let error = capturedError || urlParams.get("error") || hashParams.get("error");
      let errorDescription =
        capturedErrorDescription ||
        urlParams.get("error_description") ||
        hashParams.get("error_description");

      // Also check for Supabase-specific error formats (fallback check)
      if (!error) {
        const errorParam = urlParams.get("error") || hashParams.get("error");
        if (errorParam) error = errorParam;
      }

      console.log("[AUTH-CALLBACK] Extracted params:", {
        code: code ? `${code.substring(0, 20)}...` : null,
        error,
        errorDescription,
        hasQueryCode: !!urlParams.get("code"),
        hasHashCode: !!hashParams.get("code"),
      });

      if (error) {
        console.error("[AUTH-CALLBACK] OAuth error:", error, errorDescription);
        showError(`Authentication failed: ${errorDescription || error}`);
        setTimeout(() => {
          window.location.href = "/auth/login?error=oauth_failed";
        }, 3000);
        return;
      }

      if (!code) {
        console.error("[AUTH-CALLBACK] No authorization code in URL");
        console.error("[AUTH-CALLBACK] Debug info:", {
          fullUrl: window.location.href,
          search: window.location.search,
          hash: window.location.hash,
          allSearchParams: Object.fromEntries(urlParams.entries()),
          allHashParams: Object.fromEntries(hashParams.entries()),
        });
        showError("No authorization code received. Please check the browser console for details.");
        setTimeout(() => {
          window.location.href = "/auth/login?error=no_code";
        }, 5000);
        return;
      }

      // Restore code to URL if stripped (Supabase detectSessionInUrl reads from URL)
      if (
        code &&
        !window.location.search.includes("code=") &&
        !window.location.hash.includes("code=")
      ) {
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.set("code", code);
        window.history.replaceState({}, "", newUrl.toString());
        await new Promise((resolve) => setTimeout(resolve, 100));
      }

      let data: { session?: any } | undefined;
      let exchangeError: any = null;

      // Try explicit exchange first (more reliable than relying on detectSessionInUrl timing)
      console.log("[AUTH-CALLBACK] Exchanging code for session...");
      try {
        const exchangeResult = await supabase.auth.exchangeCodeForSession(code);
        data = exchangeResult.data;
        exchangeError = exchangeResult.error;
        if (data?.session && !exchangeError) {
          console.log("[AUTH-CALLBACK] ✅ Exchange succeeded immediately");
          // Skip to POST + redirect below (same path as success)
        } else if (exchangeError) {
          console.warn("[AUTH-CALLBACK] Initial exchange failed:", exchangeError.message);
        }
      } catch (err) {
        console.warn("[AUTH-CALLBACK] Initial exchange exception:", err);
        exchangeError = err instanceof Error ? err : new Error(String(err));
      }

      // If explicit exchange didn't succeed, try automatic detection (auth state / getSession)
      if (!data?.session) {
        console.log("[AUTH-CALLBACK] Trying automatic session detection...");
        try {
          const autoSession = await Promise.race([
            authStatePromise,
            new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 8000)),
          ]).catch(() => null);
          if (autoSession) {
            data = { session: autoSession };
            exchangeError = null;
            console.log("[AUTH-CALLBACK] ✅ Session from auth state change");
          }
        } catch (_) {
          /* ignore */
        }

        if (!data?.session) {
          const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
          if (sessionData?.session && !sessionError) {
            data = sessionData;
            exchangeError = null;
            console.log("[AUTH-CALLBACK] ✅ Session from getSession()");
          }
        }

        if (!data?.session && !exchangeError) {
          // Last resort: try manual exchange again (e.g. after automatic detection ran)
          console.log("[AUTH-CALLBACK] Attempting manual exchangeCodeForSession...");
          try {
            const exchangeResult = await supabase.auth.exchangeCodeForSession(code);
            data = exchangeResult.data;
            exchangeError = exchangeResult.error;
          } catch (err) {
            exchangeError = err instanceof Error ? err : new Error(String(err));
          }
        }
      }

      // If we still don't have a session, run the previous manual exchange + code_verifier check path for a clear error
      if (!data?.session && !exchangeError) {
        console.log(
          "[AUTH-CALLBACK] Checking getSession() and code verifier for manual exchange..."
        );
        const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
        if (sessionData?.session && !sessionError) {
          data = sessionData;
          exchangeError = null;
        } else {
          // If automatic detection failed, try manual exchange as last resort
          console.warn("[AUTH-CALLBACK] Automatic detection failed, attempting manual exchange...");
          console.warn("[AUTH-CALLBACK] This requires code_verifier to be stored by Supabase");

          // Check if code verifier exists in localStorage before attempting exchange
          const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "";
          if (supabaseUrl) {
            const supabaseProjectRef = supabaseUrl.split("//")[1].split(".")[0];

            // Try multiple possible key formats for the code verifier
            const possibleKeys = [
              `sb-${supabaseProjectRef}-auth-token-code-verifier`,
              `sb-${supabaseProjectRef}-code-verifier`,
              `supabase.auth.token.code_verifier`,
              `supabase-auth-token-code-verifier`,
            ];

            let codeVerifier = null;
            let foundKey = null;

            for (const key of possibleKeys) {
              const value = localStorage.getItem(key);
              if (value) {
                codeVerifier = value;
                foundKey = key;
                break;
              }
            }

            console.log("[AUTH-CALLBACK] Code verifier check:", {
              checkedKeys: possibleKeys,
              foundKey: foundKey,
              found: !!codeVerifier,
              codeLength: code?.length || 0,
            });

            if (!codeVerifier) {
              console.error("[AUTH-CALLBACK] ❌ Code verifier not found in localStorage!");
              const allAuthKeys = Object.keys(localStorage).filter(
                (k) => k.includes("supabase") || k.includes("sb-") || k.includes("auth")
              );
              console.error("[AUTH-CALLBACK] Available localStorage keys:", allAuthKeys);

              // Don't set an error here - let Supabase try to handle it
              // The verifier might be stored internally by Supabase
              console.warn(
                "[AUTH-CALLBACK] Proceeding anyway - Supabase may have stored verifier internally"
              );
            } else {
              console.log("[AUTH-CALLBACK] ✅ Code verifier found at key:", foundKey);
            }
          }

          if (!exchangeError) {
            try {
              // Supabase's exchangeCodeForSession should retrieve the code_verifier automatically
              // from its internal storage (not necessarily localStorage)
              // But we've verified it exists in localStorage above
              console.log(
                "[AUTH-CALLBACK] Calling exchangeCodeForSession with code:",
                code?.substring(0, 20) + "..."
              );
              const exchangeResult = await supabase.auth.exchangeCodeForSession(code);
              data = exchangeResult.data;
              exchangeError = exchangeResult.error;

              if (exchangeError) {
                console.error("[AUTH-CALLBACK] Manual exchange failed:", exchangeError);
                console.error("[AUTH-CALLBACK] Error:", exchangeError.message);
                console.error("[AUTH-CALLBACK] Error details:", {
                  message: exchangeError.message,
                  status: exchangeError.status,
                  code: exchangeError.code,
                });
              } else if (data?.session) {
                console.log("[AUTH-CALLBACK] ✅ Manual exchange succeeded!");
                console.log("[AUTH-CALLBACK] User:", data.session.user?.email);
              }
            } catch (err) {
              console.error("[AUTH-CALLBACK] Manual exchange exception:", err);
              exchangeError = err instanceof Error ? err : new Error("Unknown error");
            }
          }
        }
      }

      if (exchangeError) {
        console.error("[AUTH-CALLBACK] Session exchange error:", exchangeError);
        console.error("[AUTH-CALLBACK] Error details:", {
          message: exchangeError.message,
          status: exchangeError.status,
          code: exchangeError.code,
        });

        // Handle specific error cases
        const errorMsg = exchangeError.message || "";

        if (errorMsg.includes("code verifier") || errorMsg.includes("Code verifier")) {
          // Code verifier issue - sign-in started in another tab/window or storage was cleared
          console.warn(
            "[AUTH-CALLBACK] Code verifier missing - clearing auth state and redirecting"
          );

          // Clear any stale localStorage items
          const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "";
          if (supabaseUrl) {
            const supabaseProjectRef = supabaseUrl.split("//")[1].split(".")[0];
            const keysToRemove = Object.keys(localStorage).filter(
              (k) => k.includes(`sb-${supabaseProjectRef}`) || k.includes("supabase")
            );
            keysToRemove.forEach((k) => localStorage.removeItem(k));
            console.log("[AUTH-CALLBACK] Cleared stale localStorage keys:", keysToRemove);
          }

          showError(
            "Sign-in could not be completed (security code missing). Use “Try again with Google” below in this same tab, or start from the login page in one tab only."
          );
          const redirectNote = document.getElementById("error-redirect");
          if (redirectNote) redirectNote.textContent = "";
          const backLink = document.getElementById("back-link");
          if (backLink) backLink.classList.remove("hidden");
          return;
        }

        showError(`Session exchange failed: ${exchangeError.message}`);
        setTimeout(() => {
          window.location.href =
            "/auth/login?error=session_exchange_failed&message=" +
            encodeURIComponent(exchangeError.message || "");
        }, 5000);
        return;
      }

      if (!data?.session) {
        console.error("[AUTH-CALLBACK] No session created");
        showError("No session created");
        setTimeout(() => {
          window.location.href = "/auth/login?error=no_session";
        }, 3000);
        return;
      }

      console.log("[AUTH-CALLBACK] Session created successfully:", {
        userId: data.session.user?.id,
        email: data.session.user?.email,
      });

      // Send session tokens to server to set cookies
      console.log("[AUTH-CALLBACK] Sending tokens to server...");
      const response = await fetch("/api/auth/callback", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include", // Ensure cookies are sent and received
        body: JSON.stringify({
          access_token: data.session.access_token,
          refresh_token: data.session.refresh_token,
          expires_in: data.session.expires_in,
          token_type: data.session.token_type || "bearer",
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("[AUTH-CALLBACK] Server callback error:", response.status, errorText);
        let serverMsg = "Failed to set authentication cookies.";
        try {
          const j = JSON.parse(errorText);
          if (j && typeof j.error === "string") serverMsg = j.error;
        } catch (_) {
          /* ignore */
        }
        showError(serverMsg);
        setTimeout(() => {
          window.location.href =
            "/auth/login?error=cookie_set_failed&message=" + encodeURIComponent(serverMsg);
        }, 3000);
        return;
      }

      console.log("[AUTH-CALLBACK] Authentication successful, redirecting to dashboard...");
      console.log("[AUTH-CALLBACK] Response status:", response.status);
      console.log(
        "[AUTH-CALLBACK] Response headers:",
        Object.fromEntries(response.headers.entries())
      );

      clearTimeout(slowTimeout);
      // Small delay to ensure cookies are set before redirect
      // This is especially important for localhost development
      // Increased delay to ensure browser has time to process Set-Cookie headers
      await new Promise((resolve) => setTimeout(resolve, 300));

      // Use replace instead of href to ensure proper navigation with cookies
      // This ensures the browser includes cookies in the redirect
      const redirectUrl = capturedRedirect || "/project/dashboard";
      console.log("[AUTH-CALLBACK] Final redirect to:", redirectUrl);
      window.location.replace(redirectUrl);
    } catch (err) {
      console.error("[AUTH-CALLBACK] Unexpected error:", err);
      showError(`Unexpected error: ${err instanceof Error ? err.message : "Unknown error"}`);
      setTimeout(() => {
        window.location.href = "/auth/login?error=unexpected_error";
      }, 3000);
    }
  }

  function showError(message: string) {
    clearTimeout(slowTimeout);
    const errorContainer = document.getElementById("error");
    const errorMessage = document.getElementById("error-message");
    const backLink = document.getElementById("back-link");

    if (errorContainer && errorMessage) {
      errorMessage.textContent = message;
      errorContainer.classList.remove("hidden");

      // Show back link after a delay
      setTimeout(() => {
        if (backLink) {
          backLink.classList.remove("hidden");
        }
      }, 2000);
    }
  }

  // Handle callback when page loads; catch any unhandled rejection so we never fail silently
  handleCallback().catch((err) => {
    console.error("[AUTH-CALLBACK] Unhandled error:", err);
    showError(err instanceof Error ? err.message : "Sign-in failed. Please try again.");
    setTimeout(() => {
      window.location.href = "/auth/login?error=unexpected_error";
    }, 3000);
  });
</script>
