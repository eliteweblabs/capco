---
// Client-side OAuth callback handler for PKCE flow
// This page runs in the browser where the code verifier is stored in localStorage
import LoadingSpinner from "../../components/common/LoadingSpinner.astro";
---

<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Signing you in...</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: #f5f5f5;
      }
      .container {
        text-align: center;
        padding: 2rem;
      }
      /* .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      } */
      .error {
        color: #dc3545;
        padding: 1rem;
        background: #f8d7da;
        border-radius: 4px;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <LoadingSpinner size="lg" color="primary" loadingText="signing you in..." />
      <div id="error" class="error" style="display: none;"></div>
    </div>

    <script>
      // Use singleton Supabase client to avoid multiple instances
      import { getSupabaseClient } from "../../lib/supabase-client";

      async function handleCallback() {
        // Client-side logging (no prefix needed for browser console)
        console.log("[AUTH-CALLBACK] Environment check:", {
          hasPublicUrl: !!import.meta.env.PUBLIC_SUPABASE_URL,
          hasPublishableKey: !!import.meta.env.PUBLIC_SUPABASE_PUBLISHABLE,
        });

        // Get singleton Supabase client (prevents multiple GoTrueClient instances)
        const supabase = getSupabaseClient();

        if (!supabase) {
          showError("Supabase configuration missing");
          return;
        }

        // Give Supabase client a moment to initialize and ensure storage is ready
        // This is critical for PKCE flow where code verifier must be accessible
        // Increased delay for first attempt to handle race conditions
        await new Promise((resolve) => setTimeout(resolve, 200));

        try {
          console.log("[AUTH-CALLBACK] Starting PKCE flow...");
          console.log("[AUTH-CALLBACK] Full URL:", window.location.href);
          console.log("[AUTH-CALLBACK] Search params:", window.location.search);
          console.log("[AUTH-CALLBACK] Hash:", window.location.hash);

          // Get the code from URL parameters (check both query params and hash)
          const urlParams = new URLSearchParams(window.location.search);
          const hashParams = new URLSearchParams(window.location.hash.substring(1)); // Remove # from hash
          
          // Check query params first, then hash
          let code = urlParams.get("code") || hashParams.get("code");
          let error = urlParams.get("error") || hashParams.get("error");
          let errorDescription = urlParams.get("error_description") || hashParams.get("error_description");
          
          // Also check for Supabase-specific error formats
          if (!error) {
            const errorParam = urlParams.get("error") || hashParams.get("error");
            if (errorParam) error = errorParam;
          }

          console.log("[AUTH-CALLBACK] Extracted params:", {
            code: code ? `${code.substring(0, 20)}...` : null,
            error,
            errorDescription,
            hasQueryCode: !!urlParams.get("code"),
            hasHashCode: !!hashParams.get("code"),
          });

          if (error) {
            console.error("[AUTH-CALLBACK] OAuth error:", error, errorDescription);
            showError(`Authentication failed: ${errorDescription || error}`);
            setTimeout(() => {
              window.location.href = "/auth/login?error=oauth_failed";
            }, 3000);
            return;
          }

          if (!code) {
            console.error("[AUTH-CALLBACK] No authorization code in URL");
            console.error("[AUTH-CALLBACK] Debug info:", {
              fullUrl: window.location.href,
              search: window.location.search,
              hash: window.location.hash,
              allSearchParams: Object.fromEntries(urlParams.entries()),
              allHashParams: Object.fromEntries(hashParams.entries()),
            });
            showError("No authorization code received. Please check the browser console for details.");
            setTimeout(() => {
              window.location.href = "/auth/login?error=no_code";
            }, 5000);
            return;
          }

          console.log("[AUTH-CALLBACK] Exchanging code for session (client-side)...");
          console.log("[AUTH-CALLBACK] Current URL:", window.location.href);
          console.log("[AUTH-CALLBACK] Code from URL:", code);

          // Check if code verifier exists in localStorage (PKCE requirement)
          const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "";
          if (!supabaseUrl) {
            console.error("[AUTH-CALLBACK] PUBLIC_SUPABASE_URL not configured");
            showError("Configuration error: Supabase URL not found");
            setTimeout(() => {
              window.location.href = "/auth/login?error=config_missing";
            }, 3000);
            return;
          }
          const supabaseProjectRef = supabaseUrl.split("//")[1].split(".")[0];
          const codeVerifierKey = `sb-${supabaseProjectRef}-auth-token-code-verifier`;

          // Wait for code verifier to be available (with retry logic)
          // This handles race conditions where localStorage might not be ready yet
          // Also handles cases where OAuth was initiated server-side (code verifier won't exist)
          let codeVerifier = localStorage.getItem(codeVerifierKey);
          const maxRetries = 20; // Increased retries
          const retryDelay = 150; // Increased delay

          for (let attempt = 0; attempt < maxRetries && !codeVerifier; attempt++) {
            console.log(
              `[AUTH-CALLBACK] Waiting for code verifier (attempt ${attempt + 1}/${maxRetries})...`
            );
            await new Promise((resolve) => setTimeout(resolve, retryDelay * (attempt + 1)));
            codeVerifier = localStorage.getItem(codeVerifierKey);
          }

          console.log("[AUTH-CALLBACK] Code verifier key:", codeVerifierKey);
          console.log(
            "[AUTH-CALLBACK] Code verifier in localStorage:",
            codeVerifier ? "found" : "missing"
          );
          console.log("[AUTH-CALLBACK] Code verifier length:", codeVerifier?.length || 0);
          console.log(
            "[AUTH-CALLBACK] All localStorage keys:",
            Object.keys(localStorage).filter((k) => k.includes("supabase") || k.includes("sb-"))
          );

          // If code verifier is still missing, try alternative storage locations
          // Supabase might store it under a different key format
          if (!codeVerifier) {
            console.warn(
              "[AUTH-CALLBACK] Code verifier still missing, checking alternative storage keys..."
            );
            
            // Try alternative key formats
            const alternativeKeys = [
              codeVerifierKey,
              `sb-${supabaseProjectRef}-auth-code-verifier`,
              `sb-${supabaseProjectRef}-code-verifier`,
            ];
            
            for (const altKey of alternativeKeys) {
              codeVerifier = localStorage.getItem(altKey);
              if (codeVerifier) {
                console.log(`[AUTH-CALLBACK] Found code verifier under alternative key: ${altKey}`);
                break;
              }
            }
            
            // Also check sessionStorage as fallback
            if (!codeVerifier) {
              for (const altKey of alternativeKeys) {
                codeVerifier = sessionStorage.getItem(altKey);
                if (codeVerifier) {
                  console.log(`[AUTH-CALLBACK] Found code verifier in sessionStorage: ${altKey}`);
                  // Move to localStorage for consistency
                  localStorage.setItem(codeVerifierKey, codeVerifier);
                  break;
                }
              }
            }
            
            // Final wait if still not found
            if (!codeVerifier) {
              console.warn(
                "[AUTH-CALLBACK] Code verifier still missing after checking alternatives, waiting additional time..."
              );
              await new Promise((resolve) => setTimeout(resolve, 1000));
              codeVerifier = localStorage.getItem(codeVerifierKey);
            }
          }

          // Try automatic session detection first (with detectSessionInUrl: true, Supabase should handle this)
          // If that doesn't work, fall back to manual exchange
          let data, exchangeError;

          // Wait a moment for automatic detection to work
          await new Promise((resolve) => setTimeout(resolve, 100));

          // Try getting session (automatic detection)
          const { data: autoData, error: autoError } = await supabase.auth.getSession();

          if (autoData?.session && !autoError) {
            console.log("[AUTH-CALLBACK] Session detected automatically");
            data = autoData;
          } else {
            console.log("[AUTH-CALLBACK] Automatic detection failed, trying manual exchange...");
            console.log("[AUTH-CALLBACK] Auto error:", autoError?.message);

            // Manual exchange - Try with explicit code verifier if available
            // The code verifier key format is: sb-{project-ref}-auth-token-code-verifier
            if (codeVerifier) {
              console.log("[AUTH-CALLBACK] Using code verifier from localStorage");
              // Note: Supabase's exchangeCodeForSession should automatically find the verifier,
              // but if it doesn't, we might need to pass it explicitly (though the API doesn't support this)
              // So we rely on Supabase's internal retrieval
            }

            // If code verifier is missing, try to use Supabase's automatic session detection
            // Supabase v2+ can sometimes handle PKCE automatically even without explicit verifier
            if (!codeVerifier) {
              console.warn("[AUTH-CALLBACK] Code verifier missing - attempting exchange anyway");
              console.warn("[AUTH-CALLBACK] Supabase may handle PKCE automatically");
              console.warn("[AUTH-CALLBACK] This can happen if:");
              console.warn("[AUTH-CALLBACK] 1. OAuth was initiated server-side");
              console.warn("[AUTH-CALLBACK] 2. localStorage was cleared");
              console.warn("[AUTH-CALLBACK] 3. Different browser/tab was used");
              
              // Try exchange anyway - Supabase might have the verifier internally
              // The exchangeCodeForSession method should handle this automatically
            }

            if (!exchangeError) {
              // Attempt exchange - Supabase should handle PKCE automatically
              // Even if we don't have the verifier in localStorage, Supabase's internal
              // storage might have it, or it might use a different mechanism
              console.log("[AUTH-CALLBACK] Attempting code exchange...");
              const exchangeResult = await supabase.auth.exchangeCodeForSession(code);
              data = exchangeResult.data;
              exchangeError = exchangeResult.error;

              // If exchange fails, provide helpful error message
              if (exchangeError) {
                if (codeVerifier) {
                  console.error("[AUTH-CALLBACK] Exchange failed even with code verifier present");
                  console.error("[AUTH-CALLBACK] Code length:", code.length);
                  console.error("[AUTH-CALLBACK] Code verifier length:", codeVerifier.length);
                } else {
                  console.error("[AUTH-CALLBACK] Exchange failed - code verifier was missing");
                  console.error("[AUTH-CALLBACK] This usually means OAuth was initiated server-side");
                  console.error("[AUTH-CALLBACK] Solution: Always initiate OAuth client-side");
                }
                console.error("[AUTH-CALLBACK] Error:", exchangeError);
                
                // If it's a code verifier error, provide specific guidance
                if (exchangeError.message?.toLowerCase().includes("verifier")) {
                  exchangeError.message = "Code verifier not found. Please try signing in again from the login page.";
                }
              }
            }
          }

          if (exchangeError) {
            console.error("[AUTH-CALLBACK] Session exchange error:", exchangeError);
            console.error("[AUTH-CALLBACK] Error details:", {
              message: exchangeError.message,
              status: exchangeError.status,
              code: exchangeError.code,
            });
            showError(`Session exchange failed: ${exchangeError.message}`);
            setTimeout(() => {
              window.location.href = "/auth/login?error=session_exchange_failed";
            }, 3000);
            return;
          }

          if (!data?.session) {
            console.error("[AUTH-CALLBACK] No session created");
            showError("No session created");
            setTimeout(() => {
              window.location.href = "/auth/login?error=no_session";
            }, 3000);
            return;
          }

          console.log("[AUTH-CALLBACK] Session created successfully:", {
            userId: data.session.user?.id,
            email: data.session.user?.email,
          });

          // Send session tokens to server to set cookies
          console.log("[AUTH-CALLBACK] Sending tokens to server...");
          const response = await fetch("/api/auth/callback", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            credentials: "include", // Ensure cookies are sent and received
            body: JSON.stringify({
              access_token: data.session.access_token,
              refresh_token: data.session.refresh_token,
              expires_in: data.session.expires_in,
              token_type: data.session.token_type || "bearer",
            }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error("[AUTH-CALLBACK] Server callback error:", response.status, errorText);
            showError("Failed to set authentication cookies");
            setTimeout(() => {
              window.location.href = "/auth/login?error=cookie_set_failed";
            }, 3000);
            return;
          }

          console.log("[AUTH-CALLBACK] Authentication successful, redirecting to dashboard...");
          console.log("[AUTH-CALLBACK] Response status:", response.status);
          console.log(
            "[AUTH-CALLBACK] Response headers:",
            Object.fromEntries(response.headers.entries())
          );

          // Small delay to ensure cookies are set before redirect
          // This is especially important for localhost development
          // Increased delay to ensure browser has time to process Set-Cookie headers
          await new Promise((resolve) => setTimeout(resolve, 300));

          // Use replace instead of href to ensure proper navigation with cookies
          // This ensures the browser includes cookies in the redirect
          window.location.replace("/project/dashboard");
        } catch (err) {
          console.error("[AUTH-CALLBACK] Unexpected error:", err);
          showError(`Unexpected error: ${err instanceof Error ? err.message : "Unknown error"}`);
          setTimeout(() => {
            window.location.href = "/auth/login?error=unexpected_error";
          }, 3000);
        }
      }

      function showError(message: string) {
        const errorDiv = document.getElementById("error");
        if (errorDiv) {
          errorDiv.textContent = message;
          errorDiv.style.display = "block";
        }
      }

      // Handle callback when page loads
      handleCallback();
    </script>
  </body>
</html>
