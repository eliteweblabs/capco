---
// Client-side OAuth callback handler for PKCE flow
// This page runs in the browser where the code verifier is stored in localStorage
import LoadingSpinner from "../../components/common/LoadingSpinner.astro";
---

<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Signing you in...</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: #f5f5f5;
      }
      .container {
        text-align: center;
        padding: 2rem;
      }
      /* .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      } */
      .error {
        color: #dc3545;
        padding: 1rem;
        background: #f8d7da;
        border-radius: 4px;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <LoadingSpinner size="lg" color="primary" loadingText="signing you in..." />
      <div id="error" class="error" style="display: none;"></div>
    </div>

    <script>
      // Use singleton Supabase client to avoid multiple instances
      import { getSupabaseClient } from "../../lib/supabase-client";

      // CRITICAL: Capture the code IMMEDIATELY on page load before anything else can modify the URL
      // Supabase's automatic session detection or other scripts might clear the URL parameters
      const initialUrl = window.location.href;
      const initialSearch = window.location.search;
      const initialHash = window.location.hash;

      // Parse code immediately before any redirects or URL modifications
      const initialUrlParams = new URLSearchParams(initialSearch);
      const initialHashParams = new URLSearchParams(initialHash.substring(1));
      const capturedCode = initialUrlParams.get("code") || initialHashParams.get("code");
      const capturedError = initialUrlParams.get("error") || initialHashParams.get("error");
      const capturedErrorDescription =
        initialUrlParams.get("error_description") || initialHashParams.get("error_description");

      console.log("[AUTH-CALLBACK] IMMEDIATE CAPTURE on page load:");
      console.log("[AUTH-CALLBACK] Initial URL:", initialUrl);
      console.log("[AUTH-CALLBACK] Initial search:", initialSearch);
      console.log("[AUTH-CALLBACK] Initial hash:", initialHash);
      console.log(
        "[AUTH-CALLBACK] Captured code:",
        capturedCode ? `${capturedCode.substring(0, 20)}...` : null
      );
      console.log("[AUTH-CALLBACK] Captured error:", capturedError);

      async function handleCallback() {
        // Client-side logging (no prefix needed for browser console)
        console.log("[AUTH-CALLBACK] Environment check:", {
          hasPublicUrl: !!import.meta.env.PUBLIC_SUPABASE_URL,
          hasPublishableKey: !!import.meta.env.PUBLIC_SUPABASE_PUBLISHABLE,
        });

        // Get singleton Supabase client (prevents multiple GoTrueClient instances)
        const supabase = getSupabaseClient();

        if (!supabase) {
          showError("Supabase configuration missing");
          return;
        }

        // CRITICAL: Set up auth state change listener BEFORE doing anything else
        // This will catch when Supabase automatically exchanges the code
        let sessionReceived = false;
        const authStatePromise = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            supabase.auth.onAuthStateChange(() => {}); // Cleanup
            reject(new Error("Auth state change timeout"));
          }, 10000); // 10 second timeout

          const {
            data: { subscription },
          } = supabase.auth.onAuthStateChange((event, session) => {
            console.log("[AUTH-CALLBACK] Auth state changed:", event, session?.user?.email);
            if (event === "SIGNED_IN" && session) {
              clearTimeout(timeout);
              sessionReceived = true;
              resolve(session);
            }
          });

          // Cleanup subscription after timeout
          setTimeout(() => {
            subscription.unsubscribe();
          }, 10000);
        });

        // Give Supabase client a moment to initialize and ensure storage is ready
        // This is critical for PKCE flow where code verifier must be accessible
        await new Promise((resolve) => setTimeout(resolve, 200));

        try {
          console.log("[AUTH-CALLBACK] Starting PKCE flow...");
          console.log("[AUTH-CALLBACK] Current URL:", window.location.href);
          console.log("[AUTH-CALLBACK] Current search params:", window.location.search);
          console.log("[AUTH-CALLBACK] Current hash:", window.location.hash);

          // Use the captured code from initial page load, fallback to current URL if needed
          // Get the code from URL parameters (check both query params and hash)
          const urlParams = new URLSearchParams(window.location.search);
          const hashParams = new URLSearchParams(window.location.hash.substring(1)); // Remove # from hash

          // Prefer captured code from initial load, then check current URL as fallback
          // This ensures we have the code even if something strips it from the URL later
          let code = capturedCode || urlParams.get("code") || hashParams.get("code");
          let error = capturedError || urlParams.get("error") || hashParams.get("error");
          let errorDescription =
            capturedErrorDescription ||
            urlParams.get("error_description") ||
            hashParams.get("error_description");

          // Also check for Supabase-specific error formats (fallback check)
          if (!error) {
            const errorParam = urlParams.get("error") || hashParams.get("error");
            if (errorParam) error = errorParam;
          }

          console.log("[AUTH-CALLBACK] Extracted params:", {
            code: code ? `${code.substring(0, 20)}...` : null,
            error,
            errorDescription,
            hasQueryCode: !!urlParams.get("code"),
            hasHashCode: !!hashParams.get("code"),
          });

          if (error) {
            console.error("[AUTH-CALLBACK] OAuth error:", error, errorDescription);
            showError(`Authentication failed: ${errorDescription || error}`);
            setTimeout(() => {
              window.location.href = "/auth/login?error=oauth_failed";
            }, 3000);
            return;
          }

          if (!code) {
            console.error("[AUTH-CALLBACK] No authorization code in URL");
            console.error("[AUTH-CALLBACK] Debug info:", {
              fullUrl: window.location.href,
              search: window.location.search,
              hash: window.location.hash,
              allSearchParams: Object.fromEntries(urlParams.entries()),
              allHashParams: Object.fromEntries(hashParams.entries()),
            });
            showError(
              "No authorization code received. Please check the browser console for details."
            );
            setTimeout(() => {
              window.location.href = "/auth/login?error=no_code";
            }, 5000);
            return;
          }

          console.log("[AUTH-CALLBACK] Exchanging code for session (client-side)...");
          console.log("[AUTH-CALLBACK] Current URL:", window.location.href);
          console.log("[AUTH-CALLBACK] Code from URL:", code);

          // Check if code verifier exists in localStorage (PKCE requirement)
          const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "";
          if (!supabaseUrl) {
            console.error("[AUTH-CALLBACK] PUBLIC_SUPABASE_URL not configured");
            showError("Configuration error: Supabase URL not found");
            setTimeout(() => {
              window.location.href = "/auth/login?error=config_missing";
            }, 3000);
            return;
          }
          const supabaseProjectRef = supabaseUrl.split("//")[1].split(".")[0];
          const codeVerifierKey = `sb-${supabaseProjectRef}-auth-token-code-verifier`;

          // Wait for code verifier to be available (with retry logic)
          // This handles race conditions where localStorage might not be ready yet
          // Also handles cases where OAuth was initiated server-side (code verifier won't exist)
          let codeVerifier = localStorage.getItem(codeVerifierKey);
          const maxRetries = 20; // Increased retries
          const retryDelay = 150; // Increased delay

          for (let attempt = 0; attempt < maxRetries && !codeVerifier; attempt++) {
            console.log(
              `[AUTH-CALLBACK] Waiting for code verifier (attempt ${attempt + 1}/${maxRetries})...`
            );
            await new Promise((resolve) => setTimeout(resolve, retryDelay * (attempt + 1)));
            codeVerifier = localStorage.getItem(codeVerifierKey);
          }

          console.log("[AUTH-CALLBACK] Code verifier key:", codeVerifierKey);
          console.log(
            "[AUTH-CALLBACK] Code verifier in localStorage:",
            codeVerifier ? "found" : "missing"
          );
          console.log("[AUTH-CALLBACK] Code verifier length:", codeVerifier?.length || 0);

          // Debug: Log ALL localStorage keys to see what Supabase actually stored
          const allLocalStorageKeys = Object.keys(localStorage);
          console.log("[AUTH-CALLBACK] ALL localStorage keys:", allLocalStorageKeys);
          console.log(
            "[AUTH-CALLBACK] Supabase-related keys:",
            allLocalStorageKeys.filter((k) => k.includes("supabase") || k.includes("sb-"))
          );

          // Also check what values are in those keys (first 50 chars)
          allLocalStorageKeys
            .filter((k) => k.includes("supabase") || k.includes("sb-"))
            .forEach((key) => {
              const value = localStorage.getItem(key);
              console.log(
                `[AUTH-CALLBACK] ${key}: ${value ? value.substring(0, 50) + "..." : "null"}`
              );
            });

          // If code verifier is still missing, try alternative storage locations
          // Supabase might store it under a different key format
          if (!codeVerifier) {
            console.warn(
              "[AUTH-CALLBACK] Code verifier still missing, checking alternative storage keys..."
            );

            // Try alternative key formats
            const alternativeKeys = [
              codeVerifierKey,
              `sb-${supabaseProjectRef}-auth-code-verifier`,
              `sb-${supabaseProjectRef}-code-verifier`,
            ];

            for (const altKey of alternativeKeys) {
              codeVerifier = localStorage.getItem(altKey);
              if (codeVerifier) {
                console.log(`[AUTH-CALLBACK] Found code verifier under alternative key: ${altKey}`);
                break;
              }
            }

            // Also check sessionStorage as fallback
            if (!codeVerifier) {
              for (const altKey of alternativeKeys) {
                codeVerifier = sessionStorage.getItem(altKey);
                if (codeVerifier) {
                  console.log(`[AUTH-CALLBACK] Found code verifier in sessionStorage: ${altKey}`);
                  // Move to localStorage for consistency
                  localStorage.setItem(codeVerifierKey, codeVerifier);
                  break;
                }
              }
            }

            // Final wait if still not found
            if (!codeVerifier) {
              console.warn(
                "[AUTH-CALLBACK] Code verifier still missing after checking alternatives, waiting additional time..."
              );
              await new Promise((resolve) => setTimeout(resolve, 1000));
              codeVerifier = localStorage.getItem(codeVerifierKey);
            }
          }

          // CRITICAL: Restore the code to the URL for Supabase's automatic detection
          // Supabase's detectSessionInUrl: true requires the code to be in the URL
          // Since we captured it immediately, restore it if it was stripped
          if (code && !window.location.search.includes("code=")) {
            console.log(
              "[AUTH-CALLBACK] Code was stripped from URL, restoring for Supabase auto-detection..."
            );
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set("code", code);
            // Use replaceState to update URL without reloading - this is critical for Supabase's auto-detection
            window.history.replaceState({}, "", newUrl.toString());
            console.log("[AUTH-CALLBACK] URL restored with code:", newUrl.toString());
          }

          // CRITICAL: Try multiple approaches to get the session
          // 1. Wait for auth state change (Supabase's automatic detection)
          // 2. Try getSession() (might already be set)
          // 3. Try manual exchangeCodeForSession() as fallback

          let data, exchangeError;

          // First, try waiting for auth state change (this catches automatic detection)
          try {
            console.log(
              "[AUTH-CALLBACK] Waiting for Supabase automatic session detection (auth state change)..."
            );
            const autoSession = await Promise.race([
              authStatePromise,
              new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 3000)),
            ]).catch(() => null);

            if (autoSession) {
              console.log("[AUTH-CALLBACK] ✅ Session received via auth state change!");
              data = { session: autoSession };
              exchangeError = null;
            }
          } catch (err) {
            console.log("[AUTH-CALLBACK] Auth state change didn't fire, trying other methods...");
          }

          // If auth state change didn't work, try getSession()
          if (!data?.session) {
            console.log("[AUTH-CALLBACK] Trying getSession()...");
            const { data: autoData, error: autoError } = await supabase.auth.getSession();

            if (autoData?.session && !autoError) {
              console.log("[AUTH-CALLBACK] ✅ Session found via getSession()");
              data = autoData;
              exchangeError = null;
            } else {
              console.log(
                "[AUTH-CALLBACK] getSession() didn't find session, trying manual exchange..."
              );

              // Final fallback: manual exchange
              console.log("[AUTH-CALLBACK] Attempting manual code exchange...");
              const exchangeResult = await supabase.auth.exchangeCodeForSession(code);
              data = exchangeResult.data;
              exchangeError = exchangeResult.error;

              if (exchangeError) {
                console.error("[AUTH-CALLBACK] Manual exchange failed:", exchangeError);
                console.error("[AUTH-CALLBACK] Error message:", exchangeError.message);
              } else if (data?.session) {
                console.log("[AUTH-CALLBACK] ✅ Manual exchange succeeded!");
                console.log("[AUTH-CALLBACK] User:", data.session.user?.email);
              }
            }
          }

          if (exchangeError) {
            console.error("[AUTH-CALLBACK] Session exchange error:", exchangeError);
            console.error("[AUTH-CALLBACK] Error details:", {
              message: exchangeError.message,
              status: exchangeError.status,
              code: exchangeError.code,
            });
            showError(`Session exchange failed: ${exchangeError.message}`);
            setTimeout(() => {
              window.location.href = "/auth/login?error=session_exchange_failed";
            }, 3000);
            return;
          }

          if (!data?.session) {
            console.error("[AUTH-CALLBACK] No session created");
            showError("No session created");
            setTimeout(() => {
              window.location.href = "/auth/login?error=no_session";
            }, 3000);
            return;
          }

          console.log("[AUTH-CALLBACK] Session created successfully:", {
            userId: data.session.user?.id,
            email: data.session.user?.email,
          });

          // Send session tokens to server to set cookies
          console.log("[AUTH-CALLBACK] Sending tokens to server...");
          const response = await fetch("/api/auth/callback", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            credentials: "include", // Ensure cookies are sent and received
            body: JSON.stringify({
              access_token: data.session.access_token,
              refresh_token: data.session.refresh_token,
              expires_in: data.session.expires_in,
              token_type: data.session.token_type || "bearer",
            }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error("[AUTH-CALLBACK] Server callback error:", response.status, errorText);
            showError("Failed to set authentication cookies");
            setTimeout(() => {
              window.location.href = "/auth/login?error=cookie_set_failed";
            }, 3000);
            return;
          }

          console.log("[AUTH-CALLBACK] Authentication successful, redirecting to dashboard...");
          console.log("[AUTH-CALLBACK] Response status:", response.status);
          console.log(
            "[AUTH-CALLBACK] Response headers:",
            Object.fromEntries(response.headers.entries())
          );

          // Small delay to ensure cookies are set before redirect
          // This is especially important for localhost development
          // Increased delay to ensure browser has time to process Set-Cookie headers
          await new Promise((resolve) => setTimeout(resolve, 300));

          // Use replace instead of href to ensure proper navigation with cookies
          // This ensures the browser includes cookies in the redirect
          window.location.replace("/project/dashboard");
        } catch (err) {
          console.error("[AUTH-CALLBACK] Unexpected error:", err);
          showError(`Unexpected error: ${err instanceof Error ? err.message : "Unknown error"}`);
          setTimeout(() => {
            window.location.href = "/auth/login?error=unexpected_error";
          }, 3000);
        }
      }

      function showError(message: string) {
        const errorDiv = document.getElementById("error");
        if (errorDiv) {
          errorDiv.textContent = message;
          errorDiv.style.display = "block";
        }
      }

      // Handle callback when page loads
      handleCallback();
    </script>
  </body>
</html>
